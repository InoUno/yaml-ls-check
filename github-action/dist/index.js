(()=>{var __webpack_modules__={9756:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(__webpack_require__(2037));\nconst utils_1 = __webpack_require__(4857);\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/command.js?")},8117:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = __webpack_require__(9756);\nconst file_command_1 = __webpack_require__(3638);\nconst utils_1 = __webpack_require__(4857);\nconst os = __importStar(__webpack_require__(2037));\nconst path = __importStar(__webpack_require__(1017));\nconst oidc_utils_1 = __webpack_require__(5049);\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));\n    }\n    command_1.issueCommand('set-env', { name }, convertedVal);\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueFileCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    if (options && options.trimWhitespace === false) {\n        return inputs;\n    }\n    return inputs.map(input => input.trim());\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    const filePath = process.env['GITHUB_OUTPUT'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    const filePath = process.env['GITHUB_STATE'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n/**\n * Summary exports\n */\nvar summary_1 = __webpack_require__(77);\nObject.defineProperty(exports, \"summary\", ({ enumerable: true, get: function () { return summary_1.summary; } }));\n/**\n * @deprecated use core.summary\n */\nvar summary_2 = __webpack_require__(77);\nObject.defineProperty(exports, \"markdownSummary\", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));\n/**\n * Path exports\n */\nvar path_utils_1 = __webpack_require__(3382);\nObject.defineProperty(exports, \"toPosixPath\", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));\nObject.defineProperty(exports, \"toWin32Path\", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));\nObject.defineProperty(exports, \"toPlatformPath\", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));\n//# sourceMappingURL=core.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/core.js?")},3638:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.prepareKeyValueMessage = exports.issueFileCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(__webpack_require__(7147));\nconst os = __importStar(__webpack_require__(2037));\nconst uuid_1 = __webpack_require__(9991);\nconst utils_1 = __webpack_require__(4857);\nfunction issueFileCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: \'utf8\'\n    });\n}\nexports.issueFileCommand = issueFileCommand;\nfunction prepareKeyValueMessage(key, value) {\n    const delimiter = `ghadelimiter_${uuid_1.v4()}`;\n    const convertedValue = utils_1.toCommandValue(value);\n    // These should realistically never happen, but just in case someone finds a\n    // way to exploit uuid generation let\'s not allow keys or values that contain\n    // the delimiter.\n    if (key.includes(delimiter)) {\n        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);\n    }\n    if (convertedValue.includes(delimiter)) {\n        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);\n    }\n    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;\n}\nexports.prepareKeyValueMessage = prepareKeyValueMessage;\n//# sourceMappingURL=file-command.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/file-command.js?')},5049:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OidcClient = void 0;\nconst http_client_1 = __webpack_require__(7780);\nconst auth_1 = __webpack_require__(4525);\nconst core_1 = __webpack_require__(8117);\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        }\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        }\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient\n                .getJson(id_token_url)\n                .catch(error => {\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.result.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) {\n                throw new Error('Response json body do not have ID Token field');\n            }\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                core_1.debug(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                core_1.setSecret(id_token);\n                return id_token;\n            }\n            catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n//# sourceMappingURL=oidc-utils.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/oidc-utils.js?")},3382:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;\nconst path = __importStar(__webpack_require__(1017));\n/**\n * toPosixPath converts the given path to the posix form. On Windows, \\\\ will be\n * replaced with /.\n *\n * @param pth. Path to transform.\n * @return string Posix path.\n */\nfunction toPosixPath(pth) {\n    return pth.replace(/[\\\\]/g, \'/\');\n}\nexports.toPosixPath = toPosixPath;\n/**\n * toWin32Path converts the given path to the win32 form. On Linux, / will be\n * replaced with \\\\.\n *\n * @param pth. Path to transform.\n * @return string Win32 path.\n */\nfunction toWin32Path(pth) {\n    return pth.replace(/[/]/g, \'\\\\\');\n}\nexports.toWin32Path = toWin32Path;\n/**\n * toPlatformPath converts the given path to a platform-specific path. It does\n * this by replacing instances of / and \\ with the platform-specific path\n * separator.\n *\n * @param pth The path to platformize.\n * @return string The platform-specific path.\n */\nfunction toPlatformPath(pth) {\n    return pth.replace(/[/\\\\]/g, path.sep);\n}\nexports.toPlatformPath = toPlatformPath;\n//# sourceMappingURL=path-utils.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/path-utils.js?')},77:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;\nconst os_1 = __webpack_require__(2037);\nconst fs_1 = __webpack_require__(7147);\nconst { access, appendFile, writeFile } = fs_1.promises;\nexports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';\nexports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';\nclass Summary {\n    constructor() {\n        this._buffer = '';\n    }\n    /**\n     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist\n     * Also checks r/w permissions.\n     *\n     * @returns step summary file path\n     */\n    filePath() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._filePath) {\n                return this._filePath;\n            }\n            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];\n            if (!pathFromEnv) {\n                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);\n            }\n            try {\n                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);\n            }\n            catch (_a) {\n                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);\n            }\n            this._filePath = pathFromEnv;\n            return this._filePath;\n        });\n    }\n    /**\n     * Wraps content in an HTML tag, adding any HTML attributes\n     *\n     * @param {string} tag HTML tag to wrap\n     * @param {string | null} content content within the tag\n     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add\n     *\n     * @returns {string} content wrapped in HTML element\n     */\n    wrap(tag, content, attrs = {}) {\n        const htmlAttrs = Object.entries(attrs)\n            .map(([key, value]) => ` ${key}=\"${value}\"`)\n            .join('');\n        if (!content) {\n            return `<${tag}${htmlAttrs}>`;\n        }\n        return `<${tag}${htmlAttrs}>${content}</${tag}>`;\n    }\n    /**\n     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.\n     *\n     * @param {SummaryWriteOptions} [options] (optional) options for write operation\n     *\n     * @returns {Promise<Summary>} summary instance\n     */\n    write(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);\n            const filePath = yield this.filePath();\n            const writeFunc = overwrite ? writeFile : appendFile;\n            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });\n            return this.emptyBuffer();\n        });\n    }\n    /**\n     * Clears the summary buffer and wipes the summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.emptyBuffer().write({ overwrite: true });\n        });\n    }\n    /**\n     * Returns the current summary buffer as a string\n     *\n     * @returns {string} string of summary buffer\n     */\n    stringify() {\n        return this._buffer;\n    }\n    /**\n     * If the summary buffer is empty\n     *\n     * @returns {boolen} true if the buffer is empty\n     */\n    isEmptyBuffer() {\n        return this._buffer.length === 0;\n    }\n    /**\n     * Resets the summary buffer without writing to summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    emptyBuffer() {\n        this._buffer = '';\n        return this;\n    }\n    /**\n     * Adds raw text to the summary buffer\n     *\n     * @param {string} text content to add\n     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addRaw(text, addEOL = false) {\n        this._buffer += text;\n        return addEOL ? this.addEOL() : this;\n    }\n    /**\n     * Adds the operating system-specific end-of-line marker to the buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addEOL() {\n        return this.addRaw(os_1.EOL);\n    }\n    /**\n     * Adds an HTML codeblock to the summary buffer\n     *\n     * @param {string} code content to render within fenced code block\n     * @param {string} lang (optional) language to syntax highlight code\n     *\n     * @returns {Summary} summary instance\n     */\n    addCodeBlock(code, lang) {\n        const attrs = Object.assign({}, (lang && { lang }));\n        const element = this.wrap('pre', this.wrap('code', code), attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML list to the summary buffer\n     *\n     * @param {string[]} items list of items to render\n     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addList(items, ordered = false) {\n        const tag = ordered ? 'ol' : 'ul';\n        const listItems = items.map(item => this.wrap('li', item)).join('');\n        const element = this.wrap(tag, listItems);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML table to the summary buffer\n     *\n     * @param {SummaryTableCell[]} rows table rows\n     *\n     * @returns {Summary} summary instance\n     */\n    addTable(rows) {\n        const tableBody = rows\n            .map(row => {\n            const cells = row\n                .map(cell => {\n                if (typeof cell === 'string') {\n                    return this.wrap('td', cell);\n                }\n                const { header, data, colspan, rowspan } = cell;\n                const tag = header ? 'th' : 'td';\n                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));\n                return this.wrap(tag, data, attrs);\n            })\n                .join('');\n            return this.wrap('tr', cells);\n        })\n            .join('');\n        const element = this.wrap('table', tableBody);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds a collapsable HTML details element to the summary buffer\n     *\n     * @param {string} label text for the closed state\n     * @param {string} content collapsable content\n     *\n     * @returns {Summary} summary instance\n     */\n    addDetails(label, content) {\n        const element = this.wrap('details', this.wrap('summary', label) + content);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML image tag to the summary buffer\n     *\n     * @param {string} src path to the image you to embed\n     * @param {string} alt text description of the image\n     * @param {SummaryImageOptions} options (optional) addition image attributes\n     *\n     * @returns {Summary} summary instance\n     */\n    addImage(src, alt, options) {\n        const { width, height } = options || {};\n        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));\n        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML section heading element\n     *\n     * @param {string} text heading text\n     * @param {number | string} [level=1] (optional) the heading level, default: 1\n     *\n     * @returns {Summary} summary instance\n     */\n    addHeading(text, level) {\n        const tag = `h${level}`;\n        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)\n            ? tag\n            : 'h1';\n        const element = this.wrap(allowedTag, text);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML thematic break (<hr>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addSeparator() {\n        const element = this.wrap('hr', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML line break (<br>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addBreak() {\n        const element = this.wrap('br', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML blockquote to the summary buffer\n     *\n     * @param {string} text quote text\n     * @param {string} cite (optional) citation url\n     *\n     * @returns {Summary} summary instance\n     */\n    addQuote(text, cite) {\n        const attrs = Object.assign({}, (cite && { cite }));\n        const element = this.wrap('blockquote', text, attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML anchor tag to the summary buffer\n     *\n     * @param {string} text link text/content\n     * @param {string} href hyperlink\n     *\n     * @returns {Summary} summary instance\n     */\n    addLink(text, href) {\n        const element = this.wrap('a', text, { href });\n        return this.addRaw(element).addEOL();\n    }\n}\nconst _summary = new Summary();\n/**\n * @deprecated use `core.summary`\n */\nexports.markdownSummary = _summary;\nexports.summary = _summary;\n//# sourceMappingURL=summary.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/summary.js?")},4857:(__unused_webpack_module,exports)=>{"use strict";eval("\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nfunction toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) {\n        return {};\n    }\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/@actions+core@1.10.0/node_modules/@actions/core/lib/utils.js?")},4525:function(__unused_webpack_module,exports){"use strict";eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Bearer ${this.token}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n//# sourceMappingURL=auth.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/@actions+http-client@2.1.0/node_modules/@actions/http-client/lib/auth.js?")},7780:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;\nconst http = __importStar(__webpack_require__(3685));\nconst https = __importStar(__webpack_require__(5687));\nconst pm = __importStar(__webpack_require__(9768));\nconst tunnel = __importStar(__webpack_require__(4251));\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes["OK"] = 200] = "OK";\n    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";\n    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";\n    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";\n    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";\n    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";\n    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";\n    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";\n    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";\n    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";\n    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";\n    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";\n    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";\n    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";\n    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";\n    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";\n    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";\n    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";\n    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";\n    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";\n    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";\n    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";\n    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";\n    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";\n    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";\n    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";\n    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers["Accept"] = "accept";\n    Headers["ContentType"] = "content-type";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes["ApplicationJson"] = "application/json";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : \'\';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = [\'OPTIONS\', \'GET\', \'DELETE\', \'HEAD\'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = \'HttpClientError\';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let output = Buffer.alloc(0);\n                this.message.on(\'data\', (chunk) => {\n                    output = Buffer.concat([output, chunk]);\n                });\n                this.message.on(\'end\', () => {\n                    resolve(output.toString());\n                });\n            }));\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    const parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === \'https:\';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(\'OPTIONS\', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    get(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(\'GET\', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    del(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(\'DELETE\', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(\'POST\', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(\'PATCH\', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(\'PUT\', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    head(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(\'HEAD\', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(verb, requestUrl, stream, additionalHeaders);\n        });\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    getJson(requestUrl, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            const res = yield this.get(requestUrl, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    postJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.post(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    putJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.put(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    patchJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.patch(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    request(verb, requestUrl, data, headers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._disposed) {\n                throw new Error(\'Client has already been disposed.\');\n            }\n            const parsedUrl = new URL(requestUrl);\n            let info = this._prepareRequest(verb, parsedUrl, headers);\n            // Only perform retries on reads since writes may not be idempotent.\n            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)\n                ? this._maxRetries + 1\n                : 1;\n            let numTries = 0;\n            let response;\n            do {\n                response = yield this.requestRaw(info, data);\n                // Check if it\'s an authentication challenge\n                if (response &&\n                    response.message &&\n                    response.message.statusCode === HttpCodes.Unauthorized) {\n                    let authenticationHandler;\n                    for (const handler of this.handlers) {\n                        if (handler.canHandleAuthentication(response)) {\n                            authenticationHandler = handler;\n                            break;\n                        }\n                    }\n                    if (authenticationHandler) {\n                        return authenticationHandler.handleAuthentication(this, info, data);\n                    }\n                    else {\n                        // We have received an unauthorized response but have no handlers to handle it.\n                        // Let the response return to the caller.\n                        return response;\n                    }\n                }\n                let redirectsRemaining = this._maxRedirects;\n                while (response.message.statusCode &&\n                    HttpRedirectCodes.includes(response.message.statusCode) &&\n                    this._allowRedirects &&\n                    redirectsRemaining > 0) {\n                    const redirectUrl = response.message.headers[\'location\'];\n                    if (!redirectUrl) {\n                        // if there\'s no location to redirect to, we won\'t\n                        break;\n                    }\n                    const parsedRedirectUrl = new URL(redirectUrl);\n                    if (parsedUrl.protocol === \'https:\' &&\n                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&\n                        !this._allowRedirectDowngrade) {\n                        throw new Error(\'Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.\');\n                    }\n                    // we need to finish reading the response before reassigning response\n                    // which will leak the open socket.\n                    yield response.readBody();\n                    // strip authorization header if redirected to a different hostname\n                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                        for (const header in headers) {\n                            // header names are case insensitive\n                            if (header.toLowerCase() === \'authorization\') {\n                                delete headers[header];\n                            }\n                        }\n                    }\n                    // let\'s make the request with the new redirectUrl\n                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                    response = yield this.requestRaw(info, data);\n                    redirectsRemaining--;\n                }\n                if (!response.message.statusCode ||\n                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {\n                    // If not a retry code, return immediately instead of retrying\n                    return response;\n                }\n                numTries += 1;\n                if (numTries < maxTries) {\n                    yield response.readBody();\n                    yield this._performExponentialBackoff(numTries);\n                }\n            } while (numTries < maxTries);\n            return response;\n        });\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                function callbackForResult(err, res) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else if (!res) {\n                        // If `err` is not passed, then `res` must be passed.\n                        reject(new Error(\'Unknown error\'));\n                    }\n                    else {\n                        resolve(res);\n                    }\n                }\n                this.requestRawWithCallback(info, data, callbackForResult);\n            });\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        if (typeof data === \'string\') {\n            if (!info.options.headers) {\n                info.options.headers = {};\n            }\n            info.options.headers[\'Content-Length\'] = Buffer.byteLength(data, \'utf8\');\n        }\n        let callbackCalled = false;\n        function handleResult(err, res) {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        }\n        const req = info.httpModule.request(info.options, (msg) => {\n            const res = new HttpClientResponse(msg);\n            handleResult(undefined, res);\n        });\n        let socket;\n        req.on(\'socket\', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error(`Request timeout: ${info.options.path}`));\n        });\n        req.on(\'error\', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err);\n        });\n        if (data && typeof data === \'string\') {\n            req.write(data, \'utf8\');\n        }\n        if (data && typeof data !== \'string\') {\n            data.on(\'close\', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        const parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === \'https:\';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || \'\') + (info.parsedUrl.search || \'\');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers[\'user-agent\'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            for (const handler of this.handlers) {\n                handler.prepareRequest(info.options);\n            }\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        const proxyUrl = pm.getProxyUrl(parsedUrl);\n        const useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === \'https:\';\n        let maxSockets = 100;\n        if (this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts\'s flow analysis.\n        if (proxyUrl && proxyUrl.hostname) {\n            const agentOptions = {\n                maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {\n                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                })), { host: proxyUrl.hostname, port: proxyUrl.port })\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === \'https:\';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn\'t assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn\'t setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don\'t want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn\'t expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        return __awaiter(this, void 0, void 0, function* () {\n            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n            return new Promise(resolve => setTimeout(() => resolve(), ms));\n        });\n    }\n    _processResponse(res, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const statusCode = res.message.statusCode || 0;\n                const response = {\n                    statusCode,\n                    result: null,\n                    headers: {}\n                };\n                // not found leads to null obj returned\n                if (statusCode === HttpCodes.NotFound) {\n                    resolve(response);\n                }\n                // get the result from the body\n                function dateTimeDeserializer(key, value) {\n                    if (typeof value === \'string\') {\n                        const a = new Date(value);\n                        if (!isNaN(a.valueOf())) {\n                            return a;\n                        }\n                    }\n                    return value;\n                }\n                let obj;\n                let contents;\n                try {\n                    contents = yield res.readBody();\n                    if (contents && contents.length > 0) {\n                        if (options && options.deserializeDates) {\n                            obj = JSON.parse(contents, dateTimeDeserializer);\n                        }\n                        else {\n                            obj = JSON.parse(contents);\n                        }\n                        response.result = obj;\n                    }\n                    response.headers = res.message.headers;\n                }\n                catch (err) {\n                    // Invalid resource (contents not json);  leaving result obj null\n                }\n                // note that 3xx redirects are handled by the http layer.\n                if (statusCode > 299) {\n                    let msg;\n                    // if exception/error in body, attempt to get better error\n                    if (obj && obj.message) {\n                        msg = obj.message;\n                    }\n                    else if (contents && contents.length > 0) {\n                        // it may be the case that the exception is in the body message as string\n                        msg = contents;\n                    }\n                    else {\n                        msg = `Failed request: (${statusCode})`;\n                    }\n                    const err = new HttpClientError(msg, statusCode);\n                    err.result = response.result;\n                    reject(err);\n                }\n                else {\n                    resolve(response);\n                }\n            }));\n        });\n    }\n}\nexports.HttpClient = HttpClient;\nconst lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/@actions+http-client@2.1.0/node_modules/@actions/http-client/lib/index.js?')},9768:(__unused_webpack_module,exports)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkBypass = exports.getProxyUrl = void 0;\nfunction getProxyUrl(reqUrl) {\n    const usingSsl = reqUrl.protocol === 'https:';\n    if (checkBypass(reqUrl)) {\n        return undefined;\n    }\n    const proxyVar = (() => {\n        if (usingSsl) {\n            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n        }\n        else {\n            return process.env['http_proxy'] || process.env['HTTP_PROXY'];\n        }\n    })();\n    if (proxyVar) {\n        return new URL(proxyVar);\n    }\n    else {\n        return undefined;\n    }\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    const reqHost = reqUrl.hostname;\n    if (isLoopbackAddress(reqHost)) {\n        return true;\n    }\n    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    const upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (const upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperNoProxyItem === '*' ||\n            upperReqHosts.some(x => x === upperNoProxyItem ||\n                x.endsWith(`.${upperNoProxyItem}`) ||\n                (upperNoProxyItem.startsWith('.') &&\n                    x.endsWith(`${upperNoProxyItem}`)))) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\nfunction isLoopbackAddress(host) {\n    const hostLower = host.toLowerCase();\n    return (hostLower === 'localhost' ||\n        hostLower.startsWith('127.') ||\n        hostLower.startsWith('[::1]') ||\n        hostLower.startsWith('[0:0:0:0:0:0:0:1]'));\n}\n//# sourceMappingURL=proxy.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/@actions+http-client@2.1.0/node_modules/@actions/http-client/lib/proxy.js?")},4014:(module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nconst core_1 = __webpack_require__(6044);\nconst draft7_1 = __webpack_require__(8097);\nconst discriminator_1 = __webpack_require__(9886);\nconst draft7MetaSchema = __webpack_require__(5570);\nconst META_SUPPORT_DATA = ["/properties"];\nconst META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";\nclass Ajv extends core_1.default {\n    _addVocabularies() {\n        super._addVocabularies();\n        draft7_1.default.forEach((v) => this.addVocabulary(v));\n        if (this.opts.discriminator)\n            this.addKeyword(discriminator_1.default);\n    }\n    _addDefaultMetaSchema() {\n        super._addDefaultMetaSchema();\n        if (!this.opts.meta)\n            return;\n        const metaSchema = this.opts.$data\n            ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n            : draft7MetaSchema;\n        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);\n        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;\n    }\n    defaultMeta() {\n        return (this.opts.defaultMeta =\n            super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined));\n    }\n}\nmodule.exports = exports = Ajv;\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports["default"] = Ajv;\nvar validate_1 = __webpack_require__(850);\nObject.defineProperty(exports, "KeywordCxt", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));\nvar codegen_1 = __webpack_require__(7994);\nObject.defineProperty(exports, "_", ({ enumerable: true, get: function () { return codegen_1._; } }));\nObject.defineProperty(exports, "str", ({ enumerable: true, get: function () { return codegen_1.str; } }));\nObject.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));\nObject.defineProperty(exports, "nil", ({ enumerable: true, get: function () { return codegen_1.nil; } }));\nObject.defineProperty(exports, "Name", ({ enumerable: true, get: function () { return codegen_1.Name; } }));\nObject.defineProperty(exports, "CodeGen", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));\nvar validation_error_1 = __webpack_require__(3307);\nObject.defineProperty(exports, "ValidationError", ({ enumerable: true, get: function () { return validation_error_1.default; } }));\nvar ref_error_1 = __webpack_require__(4179);\nObject.defineProperty(exports, "MissingRefError", ({ enumerable: true, get: function () { return ref_error_1.default; } }));\n//# sourceMappingURL=ajv.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/ajv.js?')},9730:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;\nclass _CodeOrName {\n}\nexports._CodeOrName = _CodeOrName;\nexports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nclass Name extends _CodeOrName {\n    constructor(s) {\n        super();\n        if (!exports.IDENTIFIER.test(s))\n            throw new Error("CodeGen: name must be a valid identifier");\n        this.str = s;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        return false;\n    }\n    get names() {\n        return { [this.str]: 1 };\n    }\n}\nexports.Name = Name;\nclass _Code extends _CodeOrName {\n    constructor(code) {\n        super();\n        this._items = typeof code === "string" ? [code] : code;\n    }\n    toString() {\n        return this.str;\n    }\n    emptyStr() {\n        if (this._items.length > 1)\n            return false;\n        const item = this._items[0];\n        return item === "" || item === \'""\';\n    }\n    get str() {\n        var _a;\n        return ((_a = this._str) !== null && _a !== void 0 ? _a : (this._str = this._items.reduce((s, c) => `${s}${c}`, "")));\n    }\n    get names() {\n        var _a;\n        return ((_a = this._names) !== null && _a !== void 0 ? _a : (this._names = this._items.reduce((names, c) => {\n            if (c instanceof Name)\n                names[c.str] = (names[c.str] || 0) + 1;\n            return names;\n        }, {})));\n    }\n}\nexports._Code = _Code;\nexports.nil = new _Code("");\nfunction _(strs, ...args) {\n    const code = [strs[0]];\n    let i = 0;\n    while (i < args.length) {\n        addCodeArg(code, args[i]);\n        code.push(strs[++i]);\n    }\n    return new _Code(code);\n}\nexports._ = _;\nconst plus = new _Code("+");\nfunction str(strs, ...args) {\n    const expr = [safeStringify(strs[0])];\n    let i = 0;\n    while (i < args.length) {\n        expr.push(plus);\n        addCodeArg(expr, args[i]);\n        expr.push(plus, safeStringify(strs[++i]));\n    }\n    optimize(expr);\n    return new _Code(expr);\n}\nexports.str = str;\nfunction addCodeArg(code, arg) {\n    if (arg instanceof _Code)\n        code.push(...arg._items);\n    else if (arg instanceof Name)\n        code.push(arg);\n    else\n        code.push(interpolate(arg));\n}\nexports.addCodeArg = addCodeArg;\nfunction optimize(expr) {\n    let i = 1;\n    while (i < expr.length - 1) {\n        if (expr[i] === plus) {\n            const res = mergeExprItems(expr[i - 1], expr[i + 1]);\n            if (res !== undefined) {\n                expr.splice(i - 1, 3, res);\n                continue;\n            }\n            expr[i++] = "+";\n        }\n        i++;\n    }\n}\nfunction mergeExprItems(a, b) {\n    if (b === \'""\')\n        return a;\n    if (a === \'""\')\n        return b;\n    if (typeof a == "string") {\n        if (b instanceof Name || a[a.length - 1] !== \'"\')\n            return;\n        if (typeof b != "string")\n            return `${a.slice(0, -1)}${b}"`;\n        if (b[0] === \'"\')\n            return a.slice(0, -1) + b.slice(1);\n        return;\n    }\n    if (typeof b == "string" && b[0] === \'"\' && !(a instanceof Name))\n        return `"${a}${b.slice(1)}`;\n    return;\n}\nfunction strConcat(c1, c2) {\n    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str `${c1}${c2}`;\n}\nexports.strConcat = strConcat;\n// TODO do not allow arrays here\nfunction interpolate(x) {\n    return typeof x == "number" || typeof x == "boolean" || x === null\n        ? x\n        : safeStringify(Array.isArray(x) ? x.join(",") : x);\n}\nfunction stringify(x) {\n    return new _Code(safeStringify(x));\n}\nexports.stringify = stringify;\nfunction safeStringify(x) {\n    return JSON.stringify(x)\n        .replace(/\\u2028/g, "\\\\u2028")\n        .replace(/\\u2029/g, "\\\\u2029");\n}\nexports.safeStringify = safeStringify;\nfunction getProperty(key) {\n    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _ `[${key}]`;\n}\nexports.getProperty = getProperty;\n//Does best effort to format the name properly\nfunction getEsmExportName(key) {\n    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {\n        return new _Code(`${key}`);\n    }\n    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);\n}\nexports.getEsmExportName = getEsmExportName;\nfunction regexpCode(rx) {\n    return new _Code(rx.toString());\n}\nexports.regexpCode = regexpCode;\n//# sourceMappingURL=code.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/codegen/code.js?')},7994:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\nconst code_1 = __webpack_require__(9730);\nconst scope_1 = __webpack_require__(6156);\nvar code_2 = __webpack_require__(9730);\nObject.defineProperty(exports, "_", ({ enumerable: true, get: function () { return code_2._; } }));\nObject.defineProperty(exports, "str", ({ enumerable: true, get: function () { return code_2.str; } }));\nObject.defineProperty(exports, "strConcat", ({ enumerable: true, get: function () { return code_2.strConcat; } }));\nObject.defineProperty(exports, "nil", ({ enumerable: true, get: function () { return code_2.nil; } }));\nObject.defineProperty(exports, "getProperty", ({ enumerable: true, get: function () { return code_2.getProperty; } }));\nObject.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return code_2.stringify; } }));\nObject.defineProperty(exports, "regexpCode", ({ enumerable: true, get: function () { return code_2.regexpCode; } }));\nObject.defineProperty(exports, "Name", ({ enumerable: true, get: function () { return code_2.Name; } }));\nvar scope_2 = __webpack_require__(6156);\nObject.defineProperty(exports, "Scope", ({ enumerable: true, get: function () { return scope_2.Scope; } }));\nObject.defineProperty(exports, "ValueScope", ({ enumerable: true, get: function () { return scope_2.ValueScope; } }));\nObject.defineProperty(exports, "ValueScopeName", ({ enumerable: true, get: function () { return scope_2.ValueScopeName; } }));\nObject.defineProperty(exports, "varKinds", ({ enumerable: true, get: function () { return scope_2.varKinds; } }));\nexports.operators = {\n    GT: new code_1._Code(">"),\n    GTE: new code_1._Code(">="),\n    LT: new code_1._Code("<"),\n    LTE: new code_1._Code("<="),\n    EQ: new code_1._Code("==="),\n    NEQ: new code_1._Code("!=="),\n    NOT: new code_1._Code("!"),\n    OR: new code_1._Code("||"),\n    AND: new code_1._Code("&&"),\n    ADD: new code_1._Code("+"),\n};\nclass Node {\n    optimizeNodes() {\n        return this;\n    }\n    optimizeNames(_names, _constants) {\n        return this;\n    }\n}\nclass Def extends Node {\n    constructor(varKind, name, rhs) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.rhs = rhs;\n    }\n    render({ es5, _n }) {\n        const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;\n        return `${varKind} ${this.name}${rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (!names[this.name.str])\n            return;\n        if (this.rhs)\n            this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n    }\n}\nclass Assign extends Node {\n    constructor(lhs, rhs, sideEffects) {\n        super();\n        this.lhs = lhs;\n        this.rhs = rhs;\n        this.sideEffects = sideEffects;\n    }\n    render({ _n }) {\n        return `${this.lhs} = ${this.rhs};` + _n;\n    }\n    optimizeNames(names, constants) {\n        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)\n            return;\n        this.rhs = optimizeExpr(this.rhs, names, constants);\n        return this;\n    }\n    get names() {\n        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };\n        return addExprNames(names, this.rhs);\n    }\n}\nclass AssignOp extends Assign {\n    constructor(lhs, op, rhs, sideEffects) {\n        super(lhs, rhs, sideEffects);\n        this.op = op;\n    }\n    render({ _n }) {\n        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n    }\n}\nclass Label extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        return `${this.label}:` + _n;\n    }\n}\nclass Break extends Node {\n    constructor(label) {\n        super();\n        this.label = label;\n        this.names = {};\n    }\n    render({ _n }) {\n        const label = this.label ? ` ${this.label}` : "";\n        return `break${label};` + _n;\n    }\n}\nclass Throw extends Node {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render({ _n }) {\n        return `throw ${this.error};` + _n;\n    }\n    get names() {\n        return this.error.names;\n    }\n}\nclass AnyCode extends Node {\n    constructor(code) {\n        super();\n        this.code = code;\n    }\n    render({ _n }) {\n        return `${this.code};` + _n;\n    }\n    optimizeNodes() {\n        return `${this.code}` ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        this.code = optimizeExpr(this.code, names, constants);\n        return this;\n    }\n    get names() {\n        return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n    }\n}\nclass ParentNode extends Node {\n    constructor(nodes = []) {\n        super();\n        this.nodes = nodes;\n    }\n    render(opts) {\n        return this.nodes.reduce((code, n) => code + n.render(opts), "");\n    }\n    optimizeNodes() {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            const n = nodes[i].optimizeNodes();\n            if (Array.isArray(n))\n                nodes.splice(i, 1, ...n);\n            else if (n)\n                nodes[i] = n;\n            else\n                nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    optimizeNames(names, constants) {\n        const { nodes } = this;\n        let i = nodes.length;\n        while (i--) {\n            // iterating backwards improves 1-pass optimization\n            const n = nodes[i];\n            if (n.optimizeNames(names, constants))\n                continue;\n            subtractNames(names, n.names);\n            nodes.splice(i, 1);\n        }\n        return nodes.length > 0 ? this : undefined;\n    }\n    get names() {\n        return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n    }\n}\nclass BlockNode extends ParentNode {\n    render(opts) {\n        return "{" + opts._n + super.render(opts) + "}" + opts._n;\n    }\n}\nclass Root extends ParentNode {\n}\nclass Else extends BlockNode {\n}\nElse.kind = "else";\nclass If extends BlockNode {\n    constructor(condition, nodes) {\n        super(nodes);\n        this.condition = condition;\n    }\n    render(opts) {\n        let code = `if(${this.condition})` + super.render(opts);\n        if (this.else)\n            code += "else " + this.else.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        super.optimizeNodes();\n        const cond = this.condition;\n        if (cond === true)\n            return this.nodes; // else is ignored here\n        let e = this.else;\n        if (e) {\n            const ns = e.optimizeNodes();\n            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n        }\n        if (e) {\n            if (cond === false)\n                return e instanceof If ? e : e.nodes;\n            if (this.nodes.length)\n                return this;\n            return new If(not(cond), e instanceof If ? [e] : e.nodes);\n        }\n        if (cond === false || !this.nodes.length)\n            return undefined;\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a;\n        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        if (!(super.optimizeNames(names, constants) || this.else))\n            return;\n        this.condition = optimizeExpr(this.condition, names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        addExprNames(names, this.condition);\n        if (this.else)\n            addNames(names, this.else.names);\n        return names;\n    }\n}\nIf.kind = "if";\nclass For extends BlockNode {\n}\nFor.kind = "for";\nclass ForLoop extends For {\n    constructor(iteration) {\n        super();\n        this.iteration = iteration;\n    }\n    render(opts) {\n        return `for(${this.iteration})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iteration = optimizeExpr(this.iteration, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iteration.names);\n    }\n}\nclass ForRange extends For {\n    constructor(varKind, name, from, to) {\n        super();\n        this.varKind = varKind;\n        this.name = name;\n        this.from = from;\n        this.to = to;\n    }\n    render(opts) {\n        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n        const { name, from, to } = this;\n        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n    }\n    get names() {\n        const names = addExprNames(super.names, this.from);\n        return addExprNames(names, this.to);\n    }\n}\nclass ForIter extends For {\n    constructor(loop, varKind, name, iterable) {\n        super();\n        this.loop = loop;\n        this.varKind = varKind;\n        this.name = name;\n        this.iterable = iterable;\n    }\n    render(opts) {\n        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n    }\n    optimizeNames(names, constants) {\n        if (!super.optimizeNames(names, constants))\n            return;\n        this.iterable = optimizeExpr(this.iterable, names, constants);\n        return this;\n    }\n    get names() {\n        return addNames(super.names, this.iterable.names);\n    }\n}\nclass Func extends BlockNode {\n    constructor(name, args, async) {\n        super();\n        this.name = name;\n        this.args = args;\n        this.async = async;\n    }\n    render(opts) {\n        const _async = this.async ? "async " : "";\n        return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n    }\n}\nFunc.kind = "func";\nclass Return extends ParentNode {\n    render(opts) {\n        return "return " + super.render(opts);\n    }\n}\nReturn.kind = "return";\nclass Try extends BlockNode {\n    render(opts) {\n        let code = "try" + super.render(opts);\n        if (this.catch)\n            code += this.catch.render(opts);\n        if (this.finally)\n            code += this.finally.render(opts);\n        return code;\n    }\n    optimizeNodes() {\n        var _a, _b;\n        super.optimizeNodes();\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n        return this;\n    }\n    optimizeNames(names, constants) {\n        var _a, _b;\n        super.optimizeNames(names, constants);\n        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n        return this;\n    }\n    get names() {\n        const names = super.names;\n        if (this.catch)\n            addNames(names, this.catch.names);\n        if (this.finally)\n            addNames(names, this.finally.names);\n        return names;\n    }\n}\nclass Catch extends BlockNode {\n    constructor(error) {\n        super();\n        this.error = error;\n    }\n    render(opts) {\n        return `catch(${this.error})` + super.render(opts);\n    }\n}\nCatch.kind = "catch";\nclass Finally extends BlockNode {\n    render(opts) {\n        return "finally" + super.render(opts);\n    }\n}\nFinally.kind = "finally";\nclass CodeGen {\n    constructor(extScope, opts = {}) {\n        this._values = {};\n        this._blockStarts = [];\n        this._constants = {};\n        this.opts = { ...opts, _n: opts.lines ? "\\n" : "" };\n        this._extScope = extScope;\n        this._scope = new scope_1.Scope({ parent: extScope });\n        this._nodes = [new Root()];\n    }\n    toString() {\n        return this._root.render(this.opts);\n    }\n    // returns unique name in the internal scope\n    name(prefix) {\n        return this._scope.name(prefix);\n    }\n    // reserves unique name in the external scope\n    scopeName(prefix) {\n        return this._extScope.name(prefix);\n    }\n    // reserves unique name in the external scope and assigns value to it\n    scopeValue(prefixOrName, value) {\n        const name = this._extScope.value(prefixOrName, value);\n        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n        vs.add(name);\n        return name;\n    }\n    getScopeValue(prefix, keyOrRef) {\n        return this._extScope.getValue(prefix, keyOrRef);\n    }\n    // return code that assigns values in the external scope to the names that are used internally\n    // (same names that were returned by gen.scopeName or gen.scopeValue)\n    scopeRefs(scopeName) {\n        return this._extScope.scopeRefs(scopeName, this._values);\n    }\n    scopeCode() {\n        return this._extScope.scopeCode(this._values);\n    }\n    _def(varKind, nameOrPrefix, rhs, constant) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (rhs !== undefined && constant)\n            this._constants[name.str] = rhs;\n        this._leafNode(new Def(varKind, name, rhs));\n        return name;\n    }\n    // `const` declaration (`var` in es5 mode)\n    const(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n    }\n    // `let` declaration with optional assignment (`var` in es5 mode)\n    let(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n    }\n    // `var` declaration with optional assignment\n    var(nameOrPrefix, rhs, _constant) {\n        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n    }\n    // assignment code\n    assign(lhs, rhs, sideEffects) {\n        return this._leafNode(new Assign(lhs, rhs, sideEffects));\n    }\n    // `+=` code\n    add(lhs, rhs) {\n        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n    }\n    // appends passed SafeExpr to code or executes Block\n    code(c) {\n        if (typeof c == "function")\n            c();\n        else if (c !== code_1.nil)\n            this._leafNode(new AnyCode(c));\n        return this;\n    }\n    // returns code for object literal for the passed argument list of key-value pairs\n    object(...keyValues) {\n        const code = ["{"];\n        for (const [key, value] of keyValues) {\n            if (code.length > 1)\n                code.push(",");\n            code.push(key);\n            if (key !== value || this.opts.es5) {\n                code.push(":");\n                (0, code_1.addCodeArg)(code, value);\n            }\n        }\n        code.push("}");\n        return new code_1._Code(code);\n    }\n    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n    if(condition, thenBody, elseBody) {\n        this._blockNode(new If(condition));\n        if (thenBody && elseBody) {\n            this.code(thenBody).else().code(elseBody).endIf();\n        }\n        else if (thenBody) {\n            this.code(thenBody).endIf();\n        }\n        else if (elseBody) {\n            throw new Error(\'CodeGen: "else" body without "then" body\');\n        }\n        return this;\n    }\n    // `else if` clause - invalid without `if` or after `else` clauses\n    elseIf(condition) {\n        return this._elseNode(new If(condition));\n    }\n    // `else` clause - only valid after `if` or `else if` clauses\n    else() {\n        return this._elseNode(new Else());\n    }\n    // end `if` statement (needed if gen.if was used only with condition)\n    endIf() {\n        return this._endBlockNode(If, Else);\n    }\n    _for(node, forBody) {\n        this._blockNode(node);\n        if (forBody)\n            this.code(forBody).endFor();\n        return this;\n    }\n    // a generic `for` clause (or statement if `forBody` is passed)\n    for(iteration, forBody) {\n        return this._for(new ForLoop(iteration), forBody);\n    }\n    // `for` statement for a range of values\n    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n    }\n    // `for-of` statement (in es5 mode replace with a normal for loop)\n    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {\n        const name = this._scope.toName(nameOrPrefix);\n        if (this.opts.es5) {\n            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);\n            return this.forRange("_i", 0, (0, code_1._) `${arr}.length`, (i) => {\n                this.var(name, (0, code_1._) `${arr}[${i}]`);\n                forBody(name);\n            });\n        }\n        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));\n    }\n    // `for-in` statement.\n    // With option `ownProperties` replaced with a `for-of` loop for object keys\n    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {\n        if (this.opts.ownProperties) {\n            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj})`, forBody);\n        }\n        const name = this._scope.toName(nameOrPrefix);\n        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));\n    }\n    // end `for` loop\n    endFor() {\n        return this._endBlockNode(For);\n    }\n    // `label` statement\n    label(label) {\n        return this._leafNode(new Label(label));\n    }\n    // `break` statement\n    break(label) {\n        return this._leafNode(new Break(label));\n    }\n    // `return` statement\n    return(value) {\n        const node = new Return();\n        this._blockNode(node);\n        this.code(value);\n        if (node.nodes.length !== 1)\n            throw new Error(\'CodeGen: "return" should have one node\');\n        return this._endBlockNode(Return);\n    }\n    // `try` statement\n    try(tryBody, catchCode, finallyCode) {\n        if (!catchCode && !finallyCode)\n            throw new Error(\'CodeGen: "try" without "catch" and "finally"\');\n        const node = new Try();\n        this._blockNode(node);\n        this.code(tryBody);\n        if (catchCode) {\n            const error = this.name("e");\n            this._currNode = node.catch = new Catch(error);\n            catchCode(error);\n        }\n        if (finallyCode) {\n            this._currNode = node.finally = new Finally();\n            this.code(finallyCode);\n        }\n        return this._endBlockNode(Catch, Finally);\n    }\n    // `throw` statement\n    throw(error) {\n        return this._leafNode(new Throw(error));\n    }\n    // start self-balancing block\n    block(body, nodeCount) {\n        this._blockStarts.push(this._nodes.length);\n        if (body)\n            this.code(body).endBlock(nodeCount);\n        return this;\n    }\n    // end the current self-balancing block\n    endBlock(nodeCount) {\n        const len = this._blockStarts.pop();\n        if (len === undefined)\n            throw new Error("CodeGen: not in self-balancing block");\n        const toClose = this._nodes.length - len;\n        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n            throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n        }\n        this._nodes.length = len;\n        return this;\n    }\n    // `function` heading (or definition if funcBody is passed)\n    func(name, args = code_1.nil, async, funcBody) {\n        this._blockNode(new Func(name, args, async));\n        if (funcBody)\n            this.code(funcBody).endFunc();\n        return this;\n    }\n    // end function definition\n    endFunc() {\n        return this._endBlockNode(Func);\n    }\n    optimize(n = 1) {\n        while (n-- > 0) {\n            this._root.optimizeNodes();\n            this._root.optimizeNames(this._root.names, this._constants);\n        }\n    }\n    _leafNode(node) {\n        this._currNode.nodes.push(node);\n        return this;\n    }\n    _blockNode(node) {\n        this._currNode.nodes.push(node);\n        this._nodes.push(node);\n    }\n    _endBlockNode(N1, N2) {\n        const n = this._currNode;\n        if (n instanceof N1 || (N2 && n instanceof N2)) {\n            this._nodes.pop();\n            return this;\n        }\n        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);\n    }\n    _elseNode(node) {\n        const n = this._currNode;\n        if (!(n instanceof If)) {\n            throw new Error(\'CodeGen: "else" without "if"\');\n        }\n        this._currNode = n.else = node;\n        return this;\n    }\n    get _root() {\n        return this._nodes[0];\n    }\n    get _currNode() {\n        const ns = this._nodes;\n        return ns[ns.length - 1];\n    }\n    set _currNode(node) {\n        const ns = this._nodes;\n        ns[ns.length - 1] = node;\n    }\n}\nexports.CodeGen = CodeGen;\nfunction addNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) + (from[n] || 0);\n    return names;\n}\nfunction addExprNames(names, from) {\n    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\nfunction optimizeExpr(expr, names, constants) {\n    if (expr instanceof code_1.Name)\n        return replaceName(expr);\n    if (!canOptimize(expr))\n        return expr;\n    return new code_1._Code(expr._items.reduce((items, c) => {\n        if (c instanceof code_1.Name)\n            c = replaceName(c);\n        if (c instanceof code_1._Code)\n            items.push(...c._items);\n        else\n            items.push(c);\n        return items;\n    }, []));\n    function replaceName(n) {\n        const c = constants[n.str];\n        if (c === undefined || names[n.str] !== 1)\n            return n;\n        delete names[n.str];\n        return c;\n    }\n    function canOptimize(e) {\n        return (e instanceof code_1._Code &&\n            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));\n    }\n}\nfunction subtractNames(names, from) {\n    for (const n in from)\n        names[n] = (names[n] || 0) - (from[n] || 0);\n}\nfunction not(x) {\n    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)}`;\n}\nexports.not = not;\nconst andCode = mappend(exports.operators.AND);\n// boolean AND (&&) expression with the passed arguments\nfunction and(...args) {\n    return args.reduce(andCode);\n}\nexports.and = and;\nconst orCode = mappend(exports.operators.OR);\n// boolean OR (||) expression with the passed arguments\nfunction or(...args) {\n    return args.reduce(orCode);\n}\nexports.or = or;\nfunction mappend(op) {\n    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)} ${op} ${par(y)}`);\n}\nfunction par(x) {\n    return x instanceof code_1.Name ? x : (0, code_1._) `(${x})`;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/codegen/index.js?')},6156:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\nconst code_1 = __webpack_require__(9730);\nclass ValueError extends Error {\n    constructor(name) {\n        super(`CodeGen: "code" for ${name} not defined`);\n        this.value = name.value;\n    }\n}\nvar UsedValueState;\n(function (UsedValueState) {\n    UsedValueState[UsedValueState["Started"] = 0] = "Started";\n    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";\n})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));\nexports.varKinds = {\n    const: new code_1.Name("const"),\n    let: new code_1.Name("let"),\n    var: new code_1.Name("var"),\n};\nclass Scope {\n    constructor({ prefixes, parent } = {}) {\n        this._names = {};\n        this._prefixes = prefixes;\n        this._parent = parent;\n    }\n    toName(nameOrPrefix) {\n        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n    }\n    name(prefix) {\n        return new code_1.Name(this._newName(prefix));\n    }\n    _newName(prefix) {\n        const ng = this._names[prefix] || this._nameGroup(prefix);\n        return `${prefix}${ng.index++}`;\n    }\n    _nameGroup(prefix) {\n        var _a, _b;\n        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {\n            throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);\n        }\n        return (this._names[prefix] = { prefix, index: 0 });\n    }\n}\nexports.Scope = Scope;\nclass ValueScopeName extends code_1.Name {\n    constructor(prefix, nameStr) {\n        super(nameStr);\n        this.prefix = prefix;\n    }\n    setValue(value, { property, itemIndex }) {\n        this.value = value;\n        this.scopePath = (0, code_1._) `.${new code_1.Name(property)}[${itemIndex}]`;\n    }\n}\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._) `\\n`;\nclass ValueScope extends Scope {\n    constructor(opts) {\n        super(opts);\n        this._values = {};\n        this._scope = opts.scope;\n        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };\n    }\n    get() {\n        return this._scope;\n    }\n    name(prefix) {\n        return new ValueScopeName(prefix, this._newName(prefix));\n    }\n    value(nameOrPrefix, value) {\n        var _a;\n        if (value.ref === undefined)\n            throw new Error("CodeGen: ref must be passed in value");\n        const name = this.toName(nameOrPrefix);\n        const { prefix } = name;\n        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n        let vs = this._values[prefix];\n        if (vs) {\n            const _name = vs.get(valueKey);\n            if (_name)\n                return _name;\n        }\n        else {\n            vs = this._values[prefix] = new Map();\n        }\n        vs.set(valueKey, name);\n        const s = this._scope[prefix] || (this._scope[prefix] = []);\n        const itemIndex = s.length;\n        s[itemIndex] = value.ref;\n        name.setValue(value, { property: prefix, itemIndex });\n        return name;\n    }\n    getValue(prefix, keyOrRef) {\n        const vs = this._values[prefix];\n        if (!vs)\n            return;\n        return vs.get(keyOrRef);\n    }\n    scopeRefs(scopeName, values = this._values) {\n        return this._reduceValues(values, (name) => {\n            if (name.scopePath === undefined)\n                throw new Error(`CodeGen: name "${name}" has no value`);\n            return (0, code_1._) `${scopeName}${name.scopePath}`;\n        });\n    }\n    scopeCode(values = this._values, usedValues, getCode) {\n        return this._reduceValues(values, (name) => {\n            if (name.value === undefined)\n                throw new Error(`CodeGen: name "${name}" has no value`);\n            return name.value.code;\n        }, usedValues, getCode);\n    }\n    _reduceValues(values, valueCode, usedValues = {}, getCode) {\n        let code = code_1.nil;\n        for (const prefix in values) {\n            const vs = values[prefix];\n            if (!vs)\n                continue;\n            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());\n            vs.forEach((name) => {\n                if (nameSet.has(name))\n                    return;\n                nameSet.set(name, UsedValueState.Started);\n                let c = valueCode(name);\n                if (c) {\n                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n                    code = (0, code_1._) `${code}${def} ${name} = ${c};${this.opts._n}`;\n                }\n                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {\n                    code = (0, code_1._) `${code}${c}${this.opts._n}`;\n                }\n                else {\n                    throw new ValueError(name);\n                }\n                nameSet.set(name, UsedValueState.Completed);\n            });\n        }\n        return code;\n    }\n}\nexports.ValueScope = ValueScope;\n//# sourceMappingURL=scope.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/codegen/scope.js?')},8050:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst names_1 = __webpack_require__(9574);\nexports.keywordError = {\n    message: ({ keyword }) => (0, codegen_1.str) `must pass "${keyword}" keyword validation`,\n};\nexports.keyword$DataError = {\n    message: ({ keyword, schemaType }) => schemaType\n        ? (0, codegen_1.str) `"${keyword}" keyword must be ${schemaType} ($data)`\n        : (0, codegen_1.str) `"${keyword}" keyword is invalid ($data)`,\n};\nfunction reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {\n        addError(gen, errObj);\n    }\n    else {\n        returnErrors(it, (0, codegen_1._) `[${errObj}]`);\n    }\n}\nexports.reportError = reportError;\nfunction reportExtraError(cxt, error = exports.keywordError, errorPaths) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    addError(gen, errObj);\n    if (!(compositeRule || allErrors)) {\n        returnErrors(it, names_1.default.vErrors);\n    }\n}\nexports.reportExtraError = reportExtraError;\nfunction resetErrorsCount(gen, errsCount) {\n    gen.assign(names_1.default.errors, errsCount);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n}\nexports.resetErrorsCount = resetErrorsCount;\nfunction extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {\n    /* istanbul ignore if */\n    if (errsCount === undefined)\n        throw new Error("ajv implementation error");\n    const err = gen.name("err");\n    gen.forRange("i", errsCount, names_1.default.errors, (i) => {\n        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors}[${i}]`);\n        gen.if((0, codegen_1._) `${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));\n        gen.assign((0, codegen_1._) `${err}.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n            gen.assign((0, codegen_1._) `${err}.schema`, schemaValue);\n            gen.assign((0, codegen_1._) `${err}.data`, data);\n        }\n    });\n}\nexports.extendErrors = extendErrors;\nfunction addError(gen, errObj) {\n    const err = gen.const("err", errObj);\n    gen.if((0, codegen_1._) `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err}]`), (0, codegen_1._) `${names_1.default.vErrors}.push(${err})`);\n    gen.code((0, codegen_1._) `${names_1.default.errors}++`);\n}\nfunction returnErrors(it, errs) {\n    const { gen, validateName, schemaEnv } = it;\n    if (schemaEnv.$async) {\n        gen.throw((0, codegen_1._) `new ${it.ValidationError}(${errs})`);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, errs);\n        gen.return(false);\n    }\n}\nconst E = {\n    keyword: new codegen_1.Name("keyword"),\n    schemaPath: new codegen_1.Name("schemaPath"),\n    params: new codegen_1.Name("params"),\n    propertyName: new codegen_1.Name("propertyName"),\n    message: new codegen_1.Name("message"),\n    schema: new codegen_1.Name("schema"),\n    parentSchema: new codegen_1.Name("parentSchema"),\n};\nfunction errorObjectCode(cxt, error, errorPaths) {\n    const { createErrors } = cxt.it;\n    if (createErrors === false)\n        return (0, codegen_1._) `{}`;\n    return errorObject(cxt, error, errorPaths);\n}\nfunction errorObject(cxt, error, errorPaths = {}) {\n    const { gen, it } = cxt;\n    const keyValues = [\n        errorInstancePath(it, errorPaths),\n        errorSchemaPath(cxt, errorPaths),\n    ];\n    extraErrorProps(cxt, error, keyValues);\n    return gen.object(...keyValues);\n}\nfunction errorInstancePath({ errorPath }, { instancePath }) {\n    const instPath = instancePath\n        ? (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}`\n        : errorPath;\n    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];\n}\nfunction errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {\n    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath}/${keyword}`;\n    if (schemaPath) {\n        schPath = (0, codegen_1.str) `${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;\n    }\n    return [E.schemaPath, schPath];\n}\nfunction extraErrorProps(cxt, { params, message }, keyValues) {\n    const { keyword, data, schemaValue, it } = cxt;\n    const { opts, propertyName, topSchemaRef, schemaPath } = it;\n    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{}`]);\n    if (opts.messages) {\n        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);\n    }\n    if (opts.verbose) {\n        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n    }\n    if (propertyName)\n        keyValues.push([E.propertyName, propertyName]);\n}\n//# sourceMappingURL=errors.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/errors.js?')},2267:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = __webpack_require__(7994);\nconst validation_error_1 = __webpack_require__(3307);\nconst names_1 = __webpack_require__(9574);\nconst resolve_1 = __webpack_require__(8398);\nconst util_1 = __webpack_require__(8327);\nconst validate_1 = __webpack_require__(850);\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == "object")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue("Error", {\n            ref: validation_error_1.default,\n            code: (0, codegen_1._) `require("ajv/dist/runtime/validation_error").default`,\n        });\n    }\n    const validateName = gen.scopeName("validate");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil],\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true\n            ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),\n        errorPath: (0, codegen_1._) `""`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        (0, validate_1.validateFunctionCode)(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log("\\n\\n\\n *** \\n", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error("Error compiling schema, function code:", sourceCode);\n        // console.log("\\n\\n\\n *** \\n", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == "string")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = this.opts.uriResolver.parse(ref);\n    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);\n    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = (0, resolve_1.normalizeId)(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == "string") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === (0, resolve_1.normalizeId)(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    "properties",\n    "patternProperties",\n    "enum",\n    "dependencies",\n    "definitions",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split("/")) {\n        if (typeof schema === "boolean")\n            return;\n        const partSchema = schema[(0, util_1.unescapeFragment)(part)];\n        if (partSchema === undefined)\n            return;\n        schema = partSchema;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema === "object" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {\n        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/index.js?')},9574:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst names = {\n    // validation function arguments\n    data: new codegen_1.Name("data"),\n    // args passed from referencing schema\n    valCxt: new codegen_1.Name("valCxt"),\n    instancePath: new codegen_1.Name("instancePath"),\n    parentData: new codegen_1.Name("parentData"),\n    parentDataProperty: new codegen_1.Name("parentDataProperty"),\n    rootData: new codegen_1.Name("rootData"),\n    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),\n    // function scoped variables\n    vErrors: new codegen_1.Name("vErrors"),\n    errors: new codegen_1.Name("errors"),\n    this: new codegen_1.Name("this"),\n    // "globals"\n    self: new codegen_1.Name("self"),\n    scope: new codegen_1.Name("scope"),\n    // JTD serialize/parse name for JSON string and position\n    json: new codegen_1.Name("json"),\n    jsonPos: new codegen_1.Name("jsonPos"),\n    jsonLen: new codegen_1.Name("jsonLen"),\n    jsonPart: new codegen_1.Name("jsonPart"),\n};\nexports["default"] = names;\n//# sourceMappingURL=names.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/names.js?')},4179:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst resolve_1 = __webpack_require__(8398);\nclass MissingRefError extends Error {\n    constructor(resolver, baseId, ref, msg) {\n        super(msg || `can\'t resolve reference ${ref} from id ${baseId}`);\n        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);\n        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));\n    }\n}\nexports["default"] = MissingRefError;\n//# sourceMappingURL=ref_error.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/ref_error.js?')},8398:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\nconst util_1 = __webpack_require__(8327);\nconst equal = __webpack_require__(5490);\nconst traverse = __webpack_require__(322);\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n    "type",\n    "format",\n    "pattern",\n    "maxLength",\n    "minLength",\n    "maxProperties",\n    "minProperties",\n    "maxItems",\n    "minItems",\n    "maximum",\n    "minimum",\n    "uniqueItems",\n    "multipleOf",\n    "required",\n    "enum",\n    "const",\n]);\nfunction inlineRef(schema, limit = true) {\n    if (typeof schema == "boolean")\n        return true;\n    if (limit === true)\n        return !hasRef(schema);\n    if (!limit)\n        return false;\n    return countKeys(schema) <= limit;\n}\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\n    "$ref",\n    "$recursiveRef",\n    "$recursiveAnchor",\n    "$dynamicRef",\n    "$dynamicAnchor",\n]);\nfunction hasRef(schema) {\n    for (const key in schema) {\n        if (REF_KEYWORDS.has(key))\n            return true;\n        const sch = schema[key];\n        if (Array.isArray(sch) && sch.some(hasRef))\n            return true;\n        if (typeof sch == "object" && hasRef(sch))\n            return true;\n    }\n    return false;\n}\nfunction countKeys(schema) {\n    let count = 0;\n    for (const key in schema) {\n        if (key === "$ref")\n            return Infinity;\n        count++;\n        if (SIMPLE_INLINED.has(key))\n            continue;\n        if (typeof schema[key] == "object") {\n            (0, util_1.eachItem)(schema[key], (sch) => (count += countKeys(sch)));\n        }\n        if (count === Infinity)\n            return Infinity;\n    }\n    return count;\n}\nfunction getFullPath(resolver, id = "", normalize) {\n    if (normalize !== false)\n        id = normalizeId(id);\n    const p = resolver.parse(id);\n    return _getFullPath(resolver, p);\n}\nexports.getFullPath = getFullPath;\nfunction _getFullPath(resolver, p) {\n    const serialized = resolver.serialize(p);\n    return serialized.split("#")[0] + "#";\n}\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";\n}\nexports.normalizeId = normalizeId;\nfunction resolveUrl(resolver, baseId, id) {\n    id = normalizeId(id);\n    return resolver.resolve(baseId, id);\n}\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\nfunction getSchemaRefs(schema, baseId) {\n    if (typeof schema == "boolean")\n        return {};\n    const { schemaId, uriResolver } = this.opts;\n    const schId = normalizeId(schema[schemaId] || baseId);\n    const baseIds = { "": schId };\n    const pathPrefix = getFullPath(uriResolver, schId, false);\n    const localRefs = {};\n    const schemaRefs = new Set();\n    traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {\n        if (parentJsonPtr === undefined)\n            return;\n        const fullPath = pathPrefix + jsonPtr;\n        let baseId = baseIds[parentJsonPtr];\n        if (typeof sch[schemaId] == "string")\n            baseId = addRef.call(this, sch[schemaId]);\n        addAnchor.call(this, sch.$anchor);\n        addAnchor.call(this, sch.$dynamicAnchor);\n        baseIds[jsonPtr] = baseId;\n        function addRef(ref) {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            const _resolve = this.opts.uriResolver.resolve;\n            ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n            if (schemaRefs.has(ref))\n                throw ambiguos(ref);\n            schemaRefs.add(ref);\n            let schOrRef = this.refs[ref];\n            if (typeof schOrRef == "string")\n                schOrRef = this.refs[schOrRef];\n            if (typeof schOrRef == "object") {\n                checkAmbiguosRef(sch, schOrRef.schema, ref);\n            }\n            else if (ref !== normalizeId(fullPath)) {\n                if (ref[0] === "#") {\n                    checkAmbiguosRef(sch, localRefs[ref], ref);\n                    localRefs[ref] = sch;\n                }\n                else {\n                    this.refs[ref] = fullPath;\n                }\n            }\n            return ref;\n        }\n        function addAnchor(anchor) {\n            if (typeof anchor == "string") {\n                if (!ANCHOR.test(anchor))\n                    throw new Error(`invalid anchor "${anchor}"`);\n                addRef.call(this, `#${anchor}`);\n            }\n        }\n    });\n    return localRefs;\n    function checkAmbiguosRef(sch1, sch2, ref) {\n        if (sch2 !== undefined && !equal(sch1, sch2))\n            throw ambiguos(ref);\n    }\n    function ambiguos(ref) {\n        return new Error(`reference "${ref}" resolves to more than one schema`);\n    }\n}\nexports.getSchemaRefs = getSchemaRefs;\n//# sourceMappingURL=resolve.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/resolve.js?')},5369:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getRules = exports.isJSONType = void 0;\nconst _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];\nconst jsonTypes = new Set(_jsonTypes);\nfunction isJSONType(x) {\n    return typeof x == "string" && jsonTypes.has(x);\n}\nexports.isJSONType = isJSONType;\nfunction getRules() {\n    const groups = {\n        number: { type: "number", rules: [] },\n        string: { type: "string", rules: [] },\n        array: { type: "array", rules: [] },\n        object: { type: "object", rules: [] },\n    };\n    return {\n        types: { ...groups, integer: true, boolean: true, null: true },\n        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],\n        post: { rules: [] },\n        all: {},\n        keywords: {},\n    };\n}\nexports.getRules = getRules;\n//# sourceMappingURL=rules.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/rules.js?')},8327:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;\nconst codegen_1 = __webpack_require__(7994);\nconst code_1 = __webpack_require__(9730);\n// TODO refactor to use Set\nfunction toHash(arr) {\n    const hash = {};\n    for (const item of arr)\n        hash[item] = true;\n    return hash;\n}\nexports.toHash = toHash;\nfunction alwaysValidSchema(it, schema) {\n    if (typeof schema == "boolean")\n        return schema;\n    if (Object.keys(schema).length === 0)\n        return true;\n    checkUnknownRules(it, schema);\n    return !schemaHasRules(schema, it.self.RULES.all);\n}\nexports.alwaysValidSchema = alwaysValidSchema;\nfunction checkUnknownRules(it, schema = it.schema) {\n    const { opts, self } = it;\n    if (!opts.strictSchema)\n        return;\n    if (typeof schema === "boolean")\n        return;\n    const rules = self.RULES.keywords;\n    for (const key in schema) {\n        if (!rules[key])\n            checkStrictMode(it, `unknown keyword: "${key}"`);\n    }\n}\nexports.checkUnknownRules = checkUnknownRules;\nfunction schemaHasRules(schema, rules) {\n    if (typeof schema == "boolean")\n        return !schema;\n    for (const key in schema)\n        if (rules[key])\n            return true;\n    return false;\n}\nexports.schemaHasRules = schemaHasRules;\nfunction schemaHasRulesButRef(schema, RULES) {\n    if (typeof schema == "boolean")\n        return !schema;\n    for (const key in schema)\n        if (key !== "$ref" && RULES.all[key])\n            return true;\n    return false;\n}\nexports.schemaHasRulesButRef = schemaHasRulesButRef;\nfunction schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {\n    if (!$data) {\n        if (typeof schema == "number" || typeof schema == "boolean")\n            return schema;\n        if (typeof schema == "string")\n            return (0, codegen_1._) `${schema}`;\n    }\n    return (0, codegen_1._) `${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;\n}\nexports.schemaRefOrVal = schemaRefOrVal;\nfunction unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n}\nexports.unescapeFragment = unescapeFragment;\nfunction escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n}\nexports.escapeFragment = escapeFragment;\nfunction escapeJsonPointer(str) {\n    if (typeof str == "number")\n        return `${str}`;\n    return str.replace(/~/g, "~0").replace(/\\//g, "~1");\n}\nexports.escapeJsonPointer = escapeJsonPointer;\nfunction unescapeJsonPointer(str) {\n    return str.replace(/~1/g, "/").replace(/~0/g, "~");\n}\nexports.unescapeJsonPointer = unescapeJsonPointer;\nfunction eachItem(xs, f) {\n    if (Array.isArray(xs)) {\n        for (const x of xs)\n            f(x);\n    }\n    else {\n        f(xs);\n    }\n}\nexports.eachItem = eachItem;\nfunction makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, }) {\n    return (gen, from, to, toName) => {\n        const res = to === undefined\n            ? from\n            : to instanceof codegen_1.Name\n                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n                : from instanceof codegen_1.Name\n                    ? (mergeToName(gen, to, from), from)\n                    : mergeValues(from, to);\n        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;\n    };\n}\nexports.mergeEvaluated = {\n    props: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => {\n            gen.if((0, codegen_1._) `${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to} || {}`).code((0, codegen_1._) `Object.assign(${to}, ${from})`));\n        }),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => {\n            if (from === true) {\n                gen.assign(to, true);\n            }\n            else {\n                gen.assign(to, (0, codegen_1._) `${to} || {}`);\n                setEvaluated(gen, to, from);\n            }\n        }),\n        mergeValues: (from, to) => (from === true ? true : { ...from, ...to }),\n        resultToName: evaluatedPropsToName,\n    }),\n    items: makeMergeEvaluated({\n        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),\n        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to} > ${from} ? ${to} : ${from}`)),\n        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n        resultToName: (gen, items) => gen.var("items", items),\n    }),\n};\nfunction evaluatedPropsToName(gen, ps) {\n    if (ps === true)\n        return gen.var("props", true);\n    const props = gen.var("props", (0, codegen_1._) `{}`);\n    if (ps !== undefined)\n        setEvaluated(gen, props, ps);\n    return props;\n}\nexports.evaluatedPropsToName = evaluatedPropsToName;\nfunction setEvaluated(gen, props, ps) {\n    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props}${(0, codegen_1.getProperty)(p)}`, true));\n}\nexports.setEvaluated = setEvaluated;\nconst snippets = {};\nfunction useFunc(gen, f) {\n    return gen.scopeValue("func", {\n        ref: f,\n        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),\n    });\n}\nexports.useFunc = useFunc;\nvar Type;\n(function (Type) {\n    Type[Type["Num"] = 0] = "Num";\n    Type[Type["Str"] = 1] = "Str";\n})(Type = exports.Type || (exports.Type = {}));\nfunction getErrorPath(dataProp, dataPropType, jsPropertySyntax) {\n    // let path\n    if (dataProp instanceof codegen_1.Name) {\n        const isNumber = dataPropType === Type.Num;\n        return jsPropertySyntax\n            ? isNumber\n                ? (0, codegen_1._) `"[" + ${dataProp} + "]"`\n                : (0, codegen_1._) `"[\'" + ${dataProp} + "\']"`\n            : isNumber\n                ? (0, codegen_1._) `"/" + ${dataProp}`\n                : (0, codegen_1._) `"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\\\//g, "~1")`; // TODO maybe use global escapePointer\n    }\n    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);\n}\nexports.getErrorPath = getErrorPath;\nfunction checkStrictMode(it, msg, mode = it.opts.strictSchema) {\n    if (!mode)\n        return;\n    msg = `strict mode: ${msg}`;\n    if (mode === true)\n        throw new Error(msg);\n    it.self.logger.warn(msg);\n}\nexports.checkStrictMode = checkStrictMode;\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/util.js?')},9715:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;\nfunction schemaHasRulesForType({ schema, self }, type) {\n    const group = self.RULES.types[type];\n    return group && group !== true && shouldUseGroup(schema, group);\n}\nexports.schemaHasRulesForType = schemaHasRulesForType;\nfunction shouldUseGroup(schema, group) {\n    return group.rules.some((rule) => shouldUseRule(schema, rule));\n}\nexports.shouldUseGroup = shouldUseGroup;\nfunction shouldUseRule(schema, rule) {\n    var _a;\n    return (schema[rule.keyword] !== undefined ||\n        ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== undefined)));\n}\nexports.shouldUseRule = shouldUseRule;\n//# sourceMappingURL=applicability.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/applicability.js?')},3240:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = __webpack_require__(8050);\nconst codegen_1 = __webpack_require__(7994);\nconst names_1 = __webpack_require__(9574);\nconst boolError = {\n    message: "boolean schema is false",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == "object" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: "false schema",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);\n}\n//# sourceMappingURL=boolSchema.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/boolSchema.js?')},4543:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;\nconst rules_1 = __webpack_require__(5369);\nconst applicability_1 = __webpack_require__(9715);\nconst errors_1 = __webpack_require__(8050);\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nvar DataType;\n(function (DataType) {\n    DataType[DataType["Correct"] = 0] = "Correct";\n    DataType[DataType["Wrong"] = 1] = "Wrong";\n})(DataType = exports.DataType || (exports.DataType = {}));\nfunction getSchemaTypes(schema) {\n    const types = getJSONTypes(schema.type);\n    const hasNull = types.includes("null");\n    if (hasNull) {\n        if (schema.nullable === false)\n            throw new Error("type: null contradicts nullable: false");\n    }\n    else {\n        if (!types.length && schema.nullable !== undefined) {\n            throw new Error(\'"nullable" cannot be used without "type"\');\n        }\n        if (schema.nullable === true)\n            types.push("null");\n    }\n    return types;\n}\nexports.getSchemaTypes = getSchemaTypes;\nfunction getJSONTypes(ts) {\n    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];\n    if (types.every(rules_1.isJSONType))\n        return types;\n    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));\n}\nexports.getJSONTypes = getJSONTypes;\nfunction coerceAndCheckDataType(it, types) {\n    const { gen, data, opts } = it;\n    const coerceTo = coerceToTypes(types, opts.coerceTypes);\n    const checkTypes = types.length > 0 &&\n        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));\n    if (checkTypes) {\n        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);\n        gen.if(wrongType, () => {\n            if (coerceTo.length)\n                coerceData(it, types, coerceTo);\n            else\n                reportTypeError(it);\n        });\n    }\n    return checkTypes;\n}\nexports.coerceAndCheckDataType = coerceAndCheckDataType;\nconst COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);\nfunction coerceToTypes(types, coerceTypes) {\n    return coerceTypes\n        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))\n        : [];\n}\nfunction coerceData(it, types, coerceTo) {\n    const { gen, data, opts } = it;\n    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data}`);\n    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);\n    if (opts.coerceTypes === "array") {\n        gen.if((0, codegen_1._) `${dataType} == \'object\' && Array.isArray(${data}) && ${data}.length == 1`, () => gen\n            .assign(data, (0, codegen_1._) `${data}[0]`)\n            .assign(dataType, (0, codegen_1._) `typeof ${data}`)\n            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));\n    }\n    gen.if((0, codegen_1._) `${coerced} !== undefined`);\n    for (const t of coerceTo) {\n        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {\n            coerceSpecificType(t);\n        }\n    }\n    gen.else();\n    reportTypeError(it);\n    gen.endIf();\n    gen.if((0, codegen_1._) `${coerced} !== undefined`, () => {\n        gen.assign(data, coerced);\n        assignParentData(it, coerced);\n    });\n    function coerceSpecificType(t) {\n        switch (t) {\n            case "string":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == "number" || ${dataType} == "boolean"`)\n                    .assign(coerced, (0, codegen_1._) `"" + ${data}`)\n                    .elseIf((0, codegen_1._) `${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `""`);\n                return;\n            case "number":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} == "boolean" || ${data} === null\n              || (${dataType} == "string" && ${data} && ${data} == +${data})`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case "integer":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === "boolean" || ${data} === null\n              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`)\n                    .assign(coerced, (0, codegen_1._) `+${data}`);\n                return;\n            case "boolean":\n                gen\n                    .elseIf((0, codegen_1._) `${data} === "false" || ${data} === 0 || ${data} === null`)\n                    .assign(coerced, false)\n                    .elseIf((0, codegen_1._) `${data} === "true" || ${data} === 1`)\n                    .assign(coerced, true);\n                return;\n            case "null":\n                gen.elseIf((0, codegen_1._) `${data} === "" || ${data} === 0 || ${data} === false`);\n                gen.assign(coerced, null);\n                return;\n            case "array":\n                gen\n                    .elseIf((0, codegen_1._) `${dataType} === "string" || ${dataType} === "number"\n              || ${dataType} === "boolean" || ${data} === null`)\n                    .assign(coerced, (0, codegen_1._) `[${data}]`);\n        }\n    }\n}\nfunction assignParentData({ gen, parentData, parentDataProperty }, expr) {\n    // TODO use gen.property\n    gen.if((0, codegen_1._) `${parentData} !== undefined`, () => gen.assign((0, codegen_1._) `${parentData}[${parentDataProperty}]`, expr));\n}\nfunction checkDataType(dataType, data, strictNums, correct = DataType.Correct) {\n    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;\n    let cond;\n    switch (dataType) {\n        case "null":\n            return (0, codegen_1._) `${data} ${EQ} null`;\n        case "array":\n            cond = (0, codegen_1._) `Array.isArray(${data})`;\n            break;\n        case "object":\n            cond = (0, codegen_1._) `${data} && typeof ${data} == "object" && !Array.isArray(${data})`;\n            break;\n        case "integer":\n            cond = numCond((0, codegen_1._) `!(${data} % 1) && !isNaN(${data})`);\n            break;\n        case "number":\n            cond = numCond();\n            break;\n        default:\n            return (0, codegen_1._) `typeof ${data} ${EQ} ${dataType}`;\n    }\n    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);\n    function numCond(_cond = codegen_1.nil) {\n        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data})` : codegen_1.nil);\n    }\n}\nexports.checkDataType = checkDataType;\nfunction checkDataTypes(dataTypes, data, strictNums, correct) {\n    if (dataTypes.length === 1) {\n        return checkDataType(dataTypes[0], data, strictNums, correct);\n    }\n    let cond;\n    const types = (0, util_1.toHash)(dataTypes);\n    if (types.array && types.object) {\n        const notObj = (0, codegen_1._) `typeof ${data} != "object"`;\n        cond = types.null ? notObj : (0, codegen_1._) `!${data} || ${notObj}`;\n        delete types.null;\n        delete types.array;\n        delete types.object;\n    }\n    else {\n        cond = codegen_1.nil;\n    }\n    if (types.number)\n        delete types.integer;\n    for (const t in types)\n        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));\n    return cond;\n}\nexports.checkDataTypes = checkDataTypes;\nconst typeError = {\n    message: ({ schema }) => `must be ${schema}`,\n    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema}}` : (0, codegen_1._) `{type: ${schemaValue}}`,\n};\nfunction reportTypeError(it) {\n    const cxt = getTypeErrorContext(it);\n    (0, errors_1.reportError)(cxt, typeError);\n}\nexports.reportTypeError = reportTypeError;\nfunction getTypeErrorContext(it) {\n    const { gen, data, schema } = it;\n    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");\n    return {\n        gen,\n        keyword: "type",\n        data,\n        schema: schema.type,\n        schemaCode,\n        schemaValue: schemaCode,\n        parentSchema: schema,\n        params: {},\n        it,\n    };\n}\n//# sourceMappingURL=dataType.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/dataType.js?')},8587:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.assignDefaults = void 0;\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nfunction assignDefaults(it, ty) {\n    const { properties, items } = it.schema;\n    if (ty === "object" && properties) {\n        for (const key in properties) {\n            assignDefault(it, key, properties[key].default);\n        }\n    }\n    else if (ty === "array" && Array.isArray(items)) {\n        items.forEach((sch, i) => assignDefault(it, i, sch.default));\n    }\n}\nexports.assignDefaults = assignDefaults;\nfunction assignDefault(it, prop, defaultValue) {\n    const { gen, compositeRule, data, opts } = it;\n    if (defaultValue === undefined)\n        return;\n    const childData = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(prop)}`;\n    if (compositeRule) {\n        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);\n        return;\n    }\n    let condition = (0, codegen_1._) `${childData} === undefined`;\n    if (opts.useDefaults === "empty") {\n        condition = (0, codegen_1._) `${condition} || ${childData} === null || ${childData} === ""`;\n    }\n    // `${childData} === undefined` +\n    // (opts.useDefaults === "empty" ? ` || ${childData} === null || ${childData} === ""` : "")\n    gen.if(condition, (0, codegen_1._) `${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);\n}\n//# sourceMappingURL=defaults.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/defaults.js?')},850:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = __webpack_require__(3240);\nconst dataType_1 = __webpack_require__(4543);\nconst applicability_1 = __webpack_require__(9715);\nconst dataType_2 = __webpack_require__(4543);\nconst defaults_1 = __webpack_require__(8587);\nconst keyword_1 = __webpack_require__(8622);\nconst subschema_1 = __webpack_require__(9462);\nconst codegen_1 = __webpack_require__(7994);\nconst names_1 = __webpack_require__(9574);\nconst resolve_1 = __webpack_require__(8398);\nconst util_1 = __webpack_require__(8327);\nconst errors_1 = __webpack_require__(8050);\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, (0, codegen_1._) `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return (0, codegen_1._) `{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);\n        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName}.evaluated`);\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated}.props`, (0, codegen_1._) `undefined`));\n    gen.if((0, codegen_1._) `${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated}.items`, (0, codegen_1._) `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == "object" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    (0, boolSchema_1.boolOrEmptySchema)(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == "boolean")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != "boolean";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const("_errs", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, (0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    (0, util_1.checkUnknownRules)(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = (0, dataType_1.getSchemaTypes)(it.schema);\n    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error("async schema in sync schema");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code((0, codegen_1._) `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == "function") {\n        const schemaPath = (0, codegen_1.str) `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });\n        gen.code((0, codegen_1._) `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if((0, codegen_1._) `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign((0, codegen_1._) `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return((0, codegen_1._) `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign((0, codegen_1._) `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {\n        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!(0, applicability_1.shouldUseGroup)(schema, group))\n            return;\n        if (group.type) {\n            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                (0, dataType_2.reportTypeError)(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it "ok" call?\n        if (!allErrors)\n            gen.if((0, codegen_1._) `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        (0, defaults_1.assignDefaults)(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if ((0, applicability_1.shouldUseRule)(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);\n        }\n    });\n    narrowSchemaTypes(it, types);\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {\n        strictTypesError(it, "use allowUnionTypes to allow union type keyword");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === "integer" && ts.includes("number"));\n}\nfunction narrowSchemaTypes(it, withTypes) {\n    const ts = [];\n    for (const t of it.dataTypes) {\n        if (includesType(withTypes, t))\n            ts.push(t);\n        else if (withTypes.includes("integer") && t === "number")\n            ts.push("integer");\n    }\n    it.dataTypes = ts;\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at "${schemaPath}" (strictTypes)`;\n    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        (0, keyword_1.validateKeywordUsage)(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if ("code" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const("_errs", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult((0, codegen_1.not)(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult((0, codegen_1.not)(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail((0, codegen_1._) `${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error(\'add "trackErrors" to keyword definition\');\n        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error("ajv implementation error");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema }); // TODO value.code for standalone\n                return (0, codegen_1._) `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = (0, subschema_1.getSubschema)(this.it, appl);\n        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);\n        (0, subschema_1.extendSubschemaMode)(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if ("code" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n    else if ("macro" in def) {\n        (0, keyword_1.macroKeywordCode)(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        (0, keyword_1.funcKeywordCode)(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === "")\n        return names_1.default.rootData;\n    if ($data[0] === "/") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === "#") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg("property/index", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg("data", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split("/");\n    for (const segment of segments) {\n        if (segment) {\n            data = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;\n            expr = (0, codegen_1._) `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/index.js?')},8622:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = __webpack_require__(7994);\nconst names_1 = __webpack_require__(9574);\nconst code_1 = __webpack_require__(5178);\nconst errors_1 = __webpack_require__(8050);\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name("valid");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let("valid");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let("ruleErrs", null);\n        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = (0, codegen_1._) `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !(("compile" in def && !$data) || def.schema === false);\n        gen.assign(valid, (0, codegen_1._) `${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if((0, codegen_1._) `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n        (0, errors_1.extendErrors)(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error("async keyword in sync schema");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword "${keyword}" failed to compile`);\n    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === "array"\n            ? Array.isArray(schema)\n            : st === "object"\n                ? schema && typeof schema == "object" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error("ajv implementation error");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === "log")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n//# sourceMappingURL=keyword.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/keyword.js?')},9462:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nfunction getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {\n    if (keyword !== undefined && schema !== undefined) {\n        throw new Error(\'both "keyword" and "schema" passed, only one allowed\');\n    }\n    if (keyword !== undefined) {\n        const sch = it.schema[keyword];\n        return schemaProp === undefined\n            ? {\n                schema: sch,\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n            }\n            : {\n                schema: sch[schemaProp],\n                schemaPath: (0, codegen_1._) `${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n                errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`,\n            };\n    }\n    if (schema !== undefined) {\n        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n            throw new Error(\'"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"\');\n        }\n        return {\n            schema,\n            schemaPath,\n            topSchemaRef,\n            errSchemaPath,\n        };\n    }\n    throw new Error(\'either "keyword" or "schema" must be passed\');\n}\nexports.getSubschema = getSubschema;\nfunction extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {\n    if (data !== undefined && dataProp !== undefined) {\n        throw new Error(\'both "data" and "dataProp" passed, only one allowed\');\n    }\n    const { gen } = it;\n    if (dataProp !== undefined) {\n        const { errorPath, dataPathArr, opts } = it;\n        const nextData = gen.let("data", (0, codegen_1._) `${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n        dataContextProps(nextData);\n        subschema.errorPath = (0, codegen_1.str) `${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n        subschema.parentDataProperty = (0, codegen_1._) `${dataProp}`;\n        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n    }\n    if (data !== undefined) {\n        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?\n        dataContextProps(nextData);\n        if (propertyName !== undefined)\n            subschema.propertyName = propertyName;\n        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n    }\n    if (dataTypes)\n        subschema.dataTypes = dataTypes;\n    function dataContextProps(_nextData) {\n        subschema.data = _nextData;\n        subschema.dataLevel = it.dataLevel + 1;\n        subschema.dataTypes = [];\n        it.definedProperties = new Set();\n        subschema.parentData = it.data;\n        subschema.dataNames = [...it.dataNames, _nextData];\n    }\n}\nexports.extendSubschemaData = extendSubschemaData;\nfunction extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {\n    if (compositeRule !== undefined)\n        subschema.compositeRule = compositeRule;\n    if (createErrors !== undefined)\n        subschema.createErrors = createErrors;\n    if (allErrors !== undefined)\n        subschema.allErrors = allErrors;\n    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n    subschema.jtdMetadata = jtdMetadata; // not inherited\n}\nexports.extendSubschemaMode = extendSubschemaMode;\n//# sourceMappingURL=subschema.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/compile/validate/subschema.js?')},6044:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\nvar validate_1 = __webpack_require__(850);\nObject.defineProperty(exports, "KeywordCxt", ({ enumerable: true, get: function () { return validate_1.KeywordCxt; } }));\nvar codegen_1 = __webpack_require__(7994);\nObject.defineProperty(exports, "_", ({ enumerable: true, get: function () { return codegen_1._; } }));\nObject.defineProperty(exports, "str", ({ enumerable: true, get: function () { return codegen_1.str; } }));\nObject.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return codegen_1.stringify; } }));\nObject.defineProperty(exports, "nil", ({ enumerable: true, get: function () { return codegen_1.nil; } }));\nObject.defineProperty(exports, "Name", ({ enumerable: true, get: function () { return codegen_1.Name; } }));\nObject.defineProperty(exports, "CodeGen", ({ enumerable: true, get: function () { return codegen_1.CodeGen; } }));\nconst validation_error_1 = __webpack_require__(3307);\nconst ref_error_1 = __webpack_require__(4179);\nconst rules_1 = __webpack_require__(5369);\nconst compile_1 = __webpack_require__(2267);\nconst codegen_2 = __webpack_require__(7994);\nconst resolve_1 = __webpack_require__(8398);\nconst dataType_1 = __webpack_require__(4543);\nconst util_1 = __webpack_require__(8327);\nconst $dataRefSchema = __webpack_require__(739);\nconst uri_1 = __webpack_require__(7840);\nconst defaultRegExp = (str, flags) => new RegExp(str, flags);\ndefaultRegExp.code = "new RegExp";\nconst META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];\nconst EXT_SCOPE_NAMES = new Set([\n    "validate",\n    "serialize",\n    "parse",\n    "wrapper",\n    "root",\n    "schema",\n    "keyword",\n    "pattern",\n    "formats",\n    "validate$data",\n    "func",\n    "obj",\n    "Error",\n]);\nconst removedOptions = {\n    errorDataPath: "",\n    format: "`validateFormats: false` can be used instead.",\n    nullable: \'"nullable" keyword is supported by default.\',\n    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",\n    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",\n    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",\n    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",\n    sourceCode: "Use option `code: {source: true}`",\n    strictDefaults: "It is default now, see option `strict`.",\n    strictKeywords: "It is default now, see option `strict`.",\n    uniqueItems: \'"uniqueItems" keyword is always validated.\',\n    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",\n    cache: "Map is used as cache, schema object as key.",\n    serialize: "Map is used as cache, schema object as key.",\n    ajvErrors: "It is default now.",\n};\nconst deprecatedOptions = {\n    ignoreKeywordsWithRef: "",\n    jsPropertySyntax: "",\n    unicode: \'"minLength"/"maxLength" account for unicode characters by default.\',\n};\nconst MAX_EXPRESSION = 200;\n// eslint-disable-next-line complexity\nfunction requiredOptions(o) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n    const s = o.strict;\n    const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;\n    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;\n    const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;\n    const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;\n    return {\n        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,\n        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,\n        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",\n        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",\n        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,\n        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },\n        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,\n        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,\n        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,\n        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,\n        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,\n        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",\n        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,\n        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,\n        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,\n        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,\n        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,\n        uriResolver: uriResolver,\n    };\n}\nclass Ajv {\n    constructor(opts = {}) {\n        this.schemas = {};\n        this.refs = {};\n        this.formats = {};\n        this._compilations = new Set();\n        this._loading = {};\n        this._cache = new Map();\n        opts = this.opts = { ...opts, ...requiredOptions(opts) };\n        const { es5, lines } = this.opts.code;\n        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });\n        this.logger = getLogger(opts.logger);\n        const formatOpt = opts.validateFormats;\n        opts.validateFormats = false;\n        this.RULES = (0, rules_1.getRules)();\n        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");\n        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");\n        this._metaOpts = getMetaSchemaOptions.call(this);\n        if (opts.formats)\n            addInitialFormats.call(this);\n        this._addVocabularies();\n        this._addDefaultMetaSchema();\n        if (opts.keywords)\n            addInitialKeywords.call(this, opts.keywords);\n        if (typeof opts.meta == "object")\n            this.addMetaSchema(opts.meta);\n        addInitialSchemas.call(this);\n        opts.validateFormats = formatOpt;\n    }\n    _addVocabularies() {\n        this.addKeyword("$async");\n    }\n    _addDefaultMetaSchema() {\n        const { $data, meta, schemaId } = this.opts;\n        let _dataRefSchema = $dataRefSchema;\n        if (schemaId === "id") {\n            _dataRefSchema = { ...$dataRefSchema };\n            _dataRefSchema.id = _dataRefSchema.$id;\n            delete _dataRefSchema.$id;\n        }\n        if (meta && $data)\n            this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);\n    }\n    defaultMeta() {\n        const { meta, schemaId } = this.opts;\n        return (this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined);\n    }\n    validate(schemaKeyRef, // key, ref or schema object\n    data // to be validated\n    ) {\n        let v;\n        if (typeof schemaKeyRef == "string") {\n            v = this.getSchema(schemaKeyRef);\n            if (!v)\n                throw new Error(`no schema with key or ref "${schemaKeyRef}"`);\n        }\n        else {\n            v = this.compile(schemaKeyRef);\n        }\n        const valid = v(data);\n        if (!("$async" in v))\n            this.errors = v.errors;\n        return valid;\n    }\n    compile(schema, _meta) {\n        const sch = this._addSchema(schema, _meta);\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    compileAsync(schema, meta) {\n        if (typeof this.opts.loadSchema != "function") {\n            throw new Error("options.loadSchema should be a function");\n        }\n        const { loadSchema } = this.opts;\n        return runCompileAsync.call(this, schema, meta);\n        async function runCompileAsync(_schema, _meta) {\n            await loadMetaSchema.call(this, _schema.$schema);\n            const sch = this._addSchema(_schema, _meta);\n            return sch.validate || _compileAsync.call(this, sch);\n        }\n        async function loadMetaSchema($ref) {\n            if ($ref && !this.getSchema($ref)) {\n                await runCompileAsync.call(this, { $ref }, true);\n            }\n        }\n        async function _compileAsync(sch) {\n            try {\n                return this._compileSchemaEnv(sch);\n            }\n            catch (e) {\n                if (!(e instanceof ref_error_1.default))\n                    throw e;\n                checkLoaded.call(this, e);\n                await loadMissingSchema.call(this, e.missingSchema);\n                return _compileAsync.call(this, sch);\n            }\n        }\n        function checkLoaded({ missingSchema: ref, missingRef }) {\n            if (this.refs[ref]) {\n                throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);\n            }\n        }\n        async function loadMissingSchema(ref) {\n            const _schema = await _loadSchema.call(this, ref);\n            if (!this.refs[ref])\n                await loadMetaSchema.call(this, _schema.$schema);\n            if (!this.refs[ref])\n                this.addSchema(_schema, ref, meta);\n        }\n        async function _loadSchema(ref) {\n            const p = this._loading[ref];\n            if (p)\n                return p;\n            try {\n                return await (this._loading[ref] = loadSchema(ref));\n            }\n            finally {\n                delete this._loading[ref];\n            }\n        }\n    }\n    // Adds schema to the instance\n    addSchema(schema, // If array is passed, `key` will be ignored\n    key, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n    ) {\n        if (Array.isArray(schema)) {\n            for (const sch of schema)\n                this.addSchema(sch, undefined, _meta, _validateSchema);\n            return this;\n        }\n        let id;\n        if (typeof schema === "object") {\n            const { schemaId } = this.opts;\n            id = schema[schemaId];\n            if (id !== undefined && typeof id != "string") {\n                throw new Error(`schema ${schemaId} must be string`);\n            }\n        }\n        key = (0, resolve_1.normalizeId)(key || id);\n        this._checkUnique(key);\n        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);\n        return this;\n    }\n    // Add schema that will be used to validate other schemas\n    // options in META_IGNORE_OPTIONS are alway set to false\n    addMetaSchema(schema, key, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n    ) {\n        this.addSchema(schema, key, true, _validateSchema);\n        return this;\n    }\n    //  Validate schema against its meta-schema\n    validateSchema(schema, throwOrLogError) {\n        if (typeof schema == "boolean")\n            return true;\n        let $schema;\n        $schema = schema.$schema;\n        if ($schema !== undefined && typeof $schema != "string") {\n            throw new Error("$schema must be a string");\n        }\n        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();\n        if (!$schema) {\n            this.logger.warn("meta-schema not available");\n            this.errors = null;\n            return true;\n        }\n        const valid = this.validate($schema, schema);\n        if (!valid && throwOrLogError) {\n            const message = "schema is invalid: " + this.errorsText();\n            if (this.opts.validateSchema === "log")\n                this.logger.error(message);\n            else\n                throw new Error(message);\n        }\n        return valid;\n    }\n    // Get compiled schema by `key` or `ref`.\n    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n    getSchema(keyRef) {\n        let sch;\n        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")\n            keyRef = sch;\n        if (sch === undefined) {\n            const { schemaId } = this.opts;\n            const root = new compile_1.SchemaEnv({ schema: {}, schemaId });\n            sch = compile_1.resolveSchema.call(this, root, keyRef);\n            if (!sch)\n                return;\n            this.refs[keyRef] = sch;\n        }\n        return (sch.validate || this._compileSchemaEnv(sch));\n    }\n    // Remove cached schema(s).\n    // If no parameter is passed all schemas but meta-schemas are removed.\n    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n    removeSchema(schemaKeyRef) {\n        if (schemaKeyRef instanceof RegExp) {\n            this._removeAllSchemas(this.schemas, schemaKeyRef);\n            this._removeAllSchemas(this.refs, schemaKeyRef);\n            return this;\n        }\n        switch (typeof schemaKeyRef) {\n            case "undefined":\n                this._removeAllSchemas(this.schemas);\n                this._removeAllSchemas(this.refs);\n                this._cache.clear();\n                return this;\n            case "string": {\n                const sch = getSchEnv.call(this, schemaKeyRef);\n                if (typeof sch == "object")\n                    this._cache.delete(sch.schema);\n                delete this.schemas[schemaKeyRef];\n                delete this.refs[schemaKeyRef];\n                return this;\n            }\n            case "object": {\n                const cacheKey = schemaKeyRef;\n                this._cache.delete(cacheKey);\n                let id = schemaKeyRef[this.opts.schemaId];\n                if (id) {\n                    id = (0, resolve_1.normalizeId)(id);\n                    delete this.schemas[id];\n                    delete this.refs[id];\n                }\n                return this;\n            }\n            default:\n                throw new Error("ajv.removeSchema: invalid parameter");\n        }\n    }\n    // add "vocabulary" - a collection of keywords\n    addVocabulary(definitions) {\n        for (const def of definitions)\n            this.addKeyword(def);\n        return this;\n    }\n    addKeyword(kwdOrDef, def // deprecated\n    ) {\n        let keyword;\n        if (typeof kwdOrDef == "string") {\n            keyword = kwdOrDef;\n            if (typeof def == "object") {\n                this.logger.warn("these parameters are deprecated, see docs for addKeyword");\n                def.keyword = keyword;\n            }\n        }\n        else if (typeof kwdOrDef == "object" && def === undefined) {\n            def = kwdOrDef;\n            keyword = def.keyword;\n            if (Array.isArray(keyword) && !keyword.length) {\n                throw new Error("addKeywords: keyword must be string or non-empty array");\n            }\n        }\n        else {\n            throw new Error("invalid addKeywords parameters");\n        }\n        checkKeyword.call(this, keyword, def);\n        if (!def) {\n            (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));\n            return this;\n        }\n        keywordMetaschema.call(this, def);\n        const definition = {\n            ...def,\n            type: (0, dataType_1.getJSONTypes)(def.type),\n            schemaType: (0, dataType_1.getJSONTypes)(def.schemaType),\n        };\n        (0, util_1.eachItem)(keyword, definition.type.length === 0\n            ? (k) => addRule.call(this, k, definition)\n            : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));\n        return this;\n    }\n    getKeyword(keyword) {\n        const rule = this.RULES.all[keyword];\n        return typeof rule == "object" ? rule.definition : !!rule;\n    }\n    // Remove keyword\n    removeKeyword(keyword) {\n        // TODO return type should be Ajv\n        const { RULES } = this;\n        delete RULES.keywords[keyword];\n        delete RULES.all[keyword];\n        for (const group of RULES.rules) {\n            const i = group.rules.findIndex((rule) => rule.keyword === keyword);\n            if (i >= 0)\n                group.rules.splice(i, 1);\n        }\n        return this;\n    }\n    // Add format\n    addFormat(name, format) {\n        if (typeof format == "string")\n            format = new RegExp(format);\n        this.formats[name] = format;\n        return this;\n    }\n    errorsText(errors = this.errors, // optional array of validation errors\n    { separator = ", ", dataVar = "data" } = {} // optional options with properties `separator` and `dataVar`\n    ) {\n        if (!errors || errors.length === 0)\n            return "No errors";\n        return errors\n            .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n            .reduce((text, msg) => text + separator + msg);\n    }\n    $dataMetaSchema(metaSchema, keywordsJsonPointers) {\n        const rules = this.RULES.all;\n        metaSchema = JSON.parse(JSON.stringify(metaSchema));\n        for (const jsonPointer of keywordsJsonPointers) {\n            const segments = jsonPointer.split("/").slice(1); // first segment is an empty string\n            let keywords = metaSchema;\n            for (const seg of segments)\n                keywords = keywords[seg];\n            for (const key in rules) {\n                const rule = rules[key];\n                if (typeof rule != "object")\n                    continue;\n                const { $data } = rule.definition;\n                const schema = keywords[key];\n                if ($data && schema)\n                    keywords[key] = schemaOrData(schema);\n            }\n        }\n        return metaSchema;\n    }\n    _removeAllSchemas(schemas, regex) {\n        for (const keyRef in schemas) {\n            const sch = schemas[keyRef];\n            if (!regex || regex.test(keyRef)) {\n                if (typeof sch == "string") {\n                    delete schemas[keyRef];\n                }\n                else if (sch && !sch.meta) {\n                    this._cache.delete(sch.schema);\n                    delete schemas[keyRef];\n                }\n            }\n        }\n    }\n    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {\n        let id;\n        const { schemaId } = this.opts;\n        if (typeof schema == "object") {\n            id = schema[schemaId];\n        }\n        else {\n            if (this.opts.jtd)\n                throw new Error("schema must be object");\n            else if (typeof schema != "boolean")\n                throw new Error("schema must be object or boolean");\n        }\n        let sch = this._cache.get(schema);\n        if (sch !== undefined)\n            return sch;\n        baseId = (0, resolve_1.normalizeId)(id || baseId);\n        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);\n        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });\n        this._cache.set(sch.schema, sch);\n        if (addSchema && !baseId.startsWith("#")) {\n            // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n            if (baseId)\n                this._checkUnique(baseId);\n            this.refs[baseId] = sch;\n        }\n        if (validateSchema)\n            this.validateSchema(schema, true);\n        return sch;\n    }\n    _checkUnique(id) {\n        if (this.schemas[id] || this.refs[id]) {\n            throw new Error(`schema with key or id "${id}" already exists`);\n        }\n    }\n    _compileSchemaEnv(sch) {\n        if (sch.meta)\n            this._compileMetaSchema(sch);\n        else\n            compile_1.compileSchema.call(this, sch);\n        /* istanbul ignore if */\n        if (!sch.validate)\n            throw new Error("ajv implementation error");\n        return sch.validate;\n    }\n    _compileMetaSchema(sch) {\n        const currentOpts = this.opts;\n        this.opts = this._metaOpts;\n        try {\n            compile_1.compileSchema.call(this, sch);\n        }\n        finally {\n            this.opts = currentOpts;\n        }\n    }\n}\nexports["default"] = Ajv;\nAjv.ValidationError = validation_error_1.default;\nAjv.MissingRefError = ref_error_1.default;\nfunction checkOptions(checkOpts, options, msg, log = "error") {\n    for (const key in checkOpts) {\n        const opt = key;\n        if (opt in options)\n            this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);\n    }\n}\nfunction getSchEnv(keyRef) {\n    keyRef = (0, resolve_1.normalizeId)(keyRef); // TODO tests fail without this line\n    return this.schemas[keyRef] || this.refs[keyRef];\n}\nfunction addInitialSchemas() {\n    const optsSchemas = this.opts.schemas;\n    if (!optsSchemas)\n        return;\n    if (Array.isArray(optsSchemas))\n        this.addSchema(optsSchemas);\n    else\n        for (const key in optsSchemas)\n            this.addSchema(optsSchemas[key], key);\n}\nfunction addInitialFormats() {\n    for (const name in this.opts.formats) {\n        const format = this.opts.formats[name];\n        if (format)\n            this.addFormat(name, format);\n    }\n}\nfunction addInitialKeywords(defs) {\n    if (Array.isArray(defs)) {\n        this.addVocabulary(defs);\n        return;\n    }\n    this.logger.warn("keywords option as map is deprecated, pass array");\n    for (const keyword in defs) {\n        const def = defs[keyword];\n        if (!def.keyword)\n            def.keyword = keyword;\n        this.addKeyword(def);\n    }\n}\nfunction getMetaSchemaOptions() {\n    const metaOpts = { ...this.opts };\n    for (const opt of META_IGNORE_OPTIONS)\n        delete metaOpts[opt];\n    return metaOpts;\n}\nconst noLogs = { log() { }, warn() { }, error() { } };\nfunction getLogger(logger) {\n    if (logger === false)\n        return noLogs;\n    if (logger === undefined)\n        return console;\n    if (logger.log && logger.warn && logger.error)\n        return logger;\n    throw new Error("logger must implement log, warn and error methods");\n}\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;\nfunction checkKeyword(keyword, def) {\n    const { RULES } = this;\n    (0, util_1.eachItem)(keyword, (kwd) => {\n        if (RULES.keywords[kwd])\n            throw new Error(`Keyword ${kwd} is already defined`);\n        if (!KEYWORD_NAME.test(kwd))\n            throw new Error(`Keyword ${kwd} has invalid name`);\n    });\n    if (!def)\n        return;\n    if (def.$data && !("code" in def || "validate" in def)) {\n        throw new Error(\'$data keyword must have "code" or "validate" function\');\n    }\n}\nfunction addRule(keyword, definition, dataType) {\n    var _a;\n    const post = definition === null || definition === void 0 ? void 0 : definition.post;\n    if (dataType && post)\n        throw new Error(\'keyword with "post" flag cannot have "type"\');\n    const { RULES } = this;\n    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);\n    if (!ruleGroup) {\n        ruleGroup = { type: dataType, rules: [] };\n        RULES.rules.push(ruleGroup);\n    }\n    RULES.keywords[keyword] = true;\n    if (!definition)\n        return;\n    const rule = {\n        keyword,\n        definition: {\n            ...definition,\n            type: (0, dataType_1.getJSONTypes)(definition.type),\n            schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType),\n        },\n    };\n    if (definition.before)\n        addBeforeRule.call(this, ruleGroup, rule, definition.before);\n    else\n        ruleGroup.rules.push(rule);\n    RULES.all[keyword] = rule;\n    (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));\n}\nfunction addBeforeRule(ruleGroup, rule, before) {\n    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);\n    if (i >= 0) {\n        ruleGroup.rules.splice(i, 0, rule);\n    }\n    else {\n        ruleGroup.rules.push(rule);\n        this.logger.warn(`rule ${before} is not defined`);\n    }\n}\nfunction keywordMetaschema(def) {\n    let { metaSchema } = def;\n    if (metaSchema === undefined)\n        return;\n    if (def.$data && this.opts.$data)\n        metaSchema = schemaOrData(metaSchema);\n    def.validateSchema = this.compile(metaSchema, true);\n}\nconst $dataRef = {\n    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",\n};\nfunction schemaOrData(schema) {\n    return { anyOf: [schema, $dataRef] };\n}\n//# sourceMappingURL=core.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/core.js?')},8652:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n// https://github.com/ajv-validator/ajv/issues/889\nconst equal = __webpack_require__(5490);\nequal.code = \'require("ajv/dist/runtime/equal").default\';\nexports["default"] = equal;\n//# sourceMappingURL=equal.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/runtime/equal.js?')},5501:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nfunction ucs2length(str) {\n    const len = str.length;\n    let length = 0;\n    let pos = 0;\n    let value;\n    while (pos < len) {\n        length++;\n        value = str.charCodeAt(pos++);\n        if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n            // high surrogate, and there is a next character\n            value = str.charCodeAt(pos);\n            if ((value & 0xfc00) === 0xdc00)\n                pos++; // low surrogate\n        }\n    }\n    return length;\n}\nexports["default"] = ucs2length;\nucs2length.code = \'require("ajv/dist/runtime/ucs2length").default\';\n//# sourceMappingURL=ucs2length.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/runtime/ucs2length.js?')},7840:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst uri = __webpack_require__(5648);\nuri.code = \'require("ajv/dist/runtime/uri").default\';\nexports["default"] = uri;\n//# sourceMappingURL=uri.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/runtime/uri.js?')},3307:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nclass ValidationError extends Error {\n    constructor(errors) {\n        super("validation failed");\n        this.errors = errors;\n        this.ajv = this.validation = true;\n    }\n}\nexports["default"] = ValidationError;\n//# sourceMappingURL=validation_error.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/runtime/validation_error.js?')},6960:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.validateAdditionalItems = void 0;\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: "additionalItems",\n    type: "array",\n    schemaType: ["boolean", "object"],\n    before: "uniqueItems",\n    error,\n    code(cxt) {\n        const { parentSchema, it } = cxt;\n        const { items } = parentSchema;\n        if (!Array.isArray(items)) {\n            (0, util_1.checkStrictMode)(it, \'"additionalItems" is ignored when "items" is not an array of schemas\');\n            return;\n        }\n        validateAdditionalItems(cxt, items);\n    },\n};\nfunction validateAdditionalItems(cxt, items) {\n    const { gen, schema, data, keyword, it } = cxt;\n    it.items = true;\n    const len = gen.const("len", (0, codegen_1._) `${data}.length`);\n    if (schema === false) {\n        cxt.setParams({ len: items.length });\n        cxt.pass((0, codegen_1._) `${len} <= ${items.length}`);\n    }\n    else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.var("valid", (0, codegen_1._) `${len} <= ${items.length}`); // TODO var\n        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));\n        cxt.ok(valid);\n    }\n    function validateItems(valid) {\n        gen.forRange("i", items.length, len, (i) => {\n            cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);\n            if (!it.allErrors)\n                gen.if((0, codegen_1.not)(valid), () => gen.break());\n        });\n    }\n}\nexports.validateAdditionalItems = validateAdditionalItems;\nexports["default"] = def;\n//# sourceMappingURL=additionalItems.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js?')},1277:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst code_1 = __webpack_require__(5178);\nconst codegen_1 = __webpack_require__(7994);\nconst names_1 = __webpack_require__(9574);\nconst util_1 = __webpack_require__(8327);\nconst error = {\n    message: "must NOT have additional properties",\n    params: ({ params }) => (0, codegen_1._) `{additionalProperty: ${params.additionalProperty}}`,\n};\nconst def = {\n    keyword: "additionalProperties",\n    type: ["object"],\n    schemaType: ["boolean", "object"],\n    allowUndefined: true,\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, errsCount, it } = cxt;\n        /* istanbul ignore if */\n        if (!errsCount)\n            throw new Error("ajv implementation error");\n        const { allErrors, opts } = it;\n        it.props = true;\n        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n        checkAdditionalProperties();\n        cxt.ok((0, codegen_1._) `${errsCount} === ${names_1.default.errors}`);\n        function checkAdditionalProperties() {\n            gen.forIn("key", data, (key) => {\n                if (!props.length && !patProps.length)\n                    additionalPropertyCode(key);\n                else\n                    gen.if(isAdditional(key), () => additionalPropertyCode(key));\n            });\n        }\n        function isAdditional(key) {\n            let definedProp;\n            if (props.length > 8) {\n                // TODO maybe an option instead of hard-coded 8?\n                const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");\n                definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n            }\n            else if (props.length) {\n                definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._) `${key} === ${p}`));\n            }\n            else {\n                definedProp = codegen_1.nil;\n            }\n            if (patProps.length) {\n                definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._) `${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n            }\n            return (0, codegen_1.not)(definedProp);\n        }\n        function deleteAdditional(key) {\n            gen.code((0, codegen_1._) `delete ${data}[${key}]`);\n        }\n        function additionalPropertyCode(key) {\n            if (opts.removeAdditional === "all" || (opts.removeAdditional && schema === false)) {\n                deleteAdditional(key);\n                return;\n            }\n            if (schema === false) {\n                cxt.setParams({ additionalProperty: key });\n                cxt.error();\n                if (!allErrors)\n                    gen.break();\n                return;\n            }\n            if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n                const valid = gen.name("valid");\n                if (opts.removeAdditional === "failing") {\n                    applyAdditionalSchema(key, valid, false);\n                    gen.if((0, codegen_1.not)(valid), () => {\n                        cxt.reset();\n                        deleteAdditional(key);\n                    });\n                }\n                else {\n                    applyAdditionalSchema(key, valid);\n                    if (!allErrors)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                }\n            }\n        }\n        function applyAdditionalSchema(key, valid, errors) {\n            const subschema = {\n                keyword: "additionalProperties",\n                dataProp: key,\n                dataPropType: util_1.Type.Str,\n            };\n            if (errors === false) {\n                Object.assign(subschema, {\n                    compositeRule: true,\n                    createErrors: false,\n                    allErrors: false,\n                });\n            }\n            cxt.subschema(subschema, valid);\n        }\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=additionalProperties.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js?')},1755:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst util_1 = __webpack_require__(8327);\nconst def = {\n    keyword: "allOf",\n    schemaType: "array",\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error("ajv implementation error");\n        const valid = gen.name("valid");\n        schema.forEach((sch, i) => {\n            if ((0, util_1.alwaysValidSchema)(it, sch))\n                return;\n            const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);\n            cxt.ok(valid);\n            cxt.mergeEvaluated(schCxt);\n        });\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=allOf.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/allOf.js?')},8809:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst code_1 = __webpack_require__(5178);\nconst def = {\n    keyword: "anyOf",\n    schemaType: "array",\n    trackErrors: true,\n    code: code_1.validateUnion,\n    error: { message: "must match a schema in anyOf" },\n};\nexports["default"] = def;\n//# sourceMappingURL=anyOf.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/anyOf.js?')},2196:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst error = {\n    message: ({ params: { min, max } }) => max === undefined\n        ? (0, codegen_1.str) `must contain at least ${min} valid item(s)`\n        : (0, codegen_1.str) `must contain at least ${min} and no more than ${max} valid item(s)`,\n    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._) `{minContains: ${min}}` : (0, codegen_1._) `{minContains: ${min}, maxContains: ${max}}`,\n};\nconst def = {\n    keyword: "contains",\n    type: "array",\n    schemaType: ["object", "boolean"],\n    before: "uniqueItems",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        let min;\n        let max;\n        const { minContains, maxContains } = parentSchema;\n        if (it.opts.next) {\n            min = minContains === undefined ? 1 : minContains;\n            max = maxContains;\n        }\n        else {\n            min = 1;\n        }\n        const len = gen.const("len", (0, codegen_1._) `${data}.length`);\n        cxt.setParams({ min, max });\n        if (max === undefined && min === 0) {\n            (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);\n            return;\n        }\n        if (max !== undefined && min > max) {\n            (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);\n            cxt.fail();\n            return;\n        }\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            let cond = (0, codegen_1._) `${len} >= ${min}`;\n            if (max !== undefined)\n                cond = (0, codegen_1._) `${cond} && ${len} <= ${max}`;\n            cxt.pass(cond);\n            return;\n        }\n        it.items = true;\n        const valid = gen.name("valid");\n        if (max === undefined && min === 1) {\n            validateItems(valid, () => gen.if(valid, () => gen.break()));\n        }\n        else if (min === 0) {\n            gen.let(valid, true);\n            if (max !== undefined)\n                gen.if((0, codegen_1._) `${data}.length > 0`, validateItemsWithCount);\n        }\n        else {\n            gen.let(valid, false);\n            validateItemsWithCount();\n        }\n        cxt.result(valid, () => cxt.reset());\n        function validateItemsWithCount() {\n            const schValid = gen.name("_valid");\n            const count = gen.let("count", 0);\n            validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n        }\n        function validateItems(_valid, block) {\n            gen.forRange("i", 0, len, (i) => {\n                cxt.subschema({\n                    keyword: "contains",\n                    dataProp: i,\n                    dataPropType: util_1.Type.Num,\n                    compositeRule: true,\n                }, _valid);\n                block();\n            });\n        }\n        function checkLimits(count) {\n            gen.code((0, codegen_1._) `${count}++`);\n            if (max === undefined) {\n                gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true).break());\n            }\n            else {\n                gen.if((0, codegen_1._) `${count} > ${max}`, () => gen.assign(valid, false).break());\n                if (min === 1)\n                    gen.assign(valid, true);\n                else\n                    gen.if((0, codegen_1._) `${count} >= ${min}`, () => gen.assign(valid, true));\n            }\n        }\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=contains.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/contains.js?')},9152:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst code_1 = __webpack_require__(5178);\nexports.error = {\n    message: ({ params: { property, depsCount, deps } }) => {\n        const property_ies = depsCount === 1 ? "property" : "properties";\n        return (0, codegen_1.str) `must have ${property_ies} ${deps} when property ${property} is present`;\n    },\n    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._) `{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n};\nconst def = {\n    keyword: "dependencies",\n    type: "object",\n    schemaType: "object",\n    error: exports.error,\n    code(cxt) {\n        const [propDeps, schDeps] = splitDependencies(cxt);\n        validatePropertyDeps(cxt, propDeps);\n        validateSchemaDeps(cxt, schDeps);\n    },\n};\nfunction splitDependencies({ schema }) {\n    const propertyDeps = {};\n    const schemaDeps = {};\n    for (const key in schema) {\n        if (key === "__proto__")\n            continue;\n        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n        deps[key] = schema[key];\n    }\n    return [propertyDeps, schemaDeps];\n}\nfunction validatePropertyDeps(cxt, propertyDeps = cxt.schema) {\n    const { gen, data, it } = cxt;\n    if (Object.keys(propertyDeps).length === 0)\n        return;\n    const missing = gen.let("missing");\n    for (const prop in propertyDeps) {\n        const deps = propertyDeps[prop];\n        if (deps.length === 0)\n            continue;\n        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n        cxt.setParams({\n            property: prop,\n            depsCount: deps.length,\n            deps: deps.join(", "),\n        });\n        if (it.allErrors) {\n            gen.if(hasProperty, () => {\n                for (const depProp of deps) {\n                    (0, code_1.checkReportMissingProp)(cxt, depProp);\n                }\n            });\n        }\n        else {\n            gen.if((0, codegen_1._) `${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n            (0, code_1.reportMissingProp)(cxt, missing);\n            gen.else();\n        }\n    }\n}\nexports.validatePropertyDeps = validatePropertyDeps;\nfunction validateSchemaDeps(cxt, schemaDeps = cxt.schema) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name("valid");\n    for (const prop in schemaDeps) {\n        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))\n            continue;\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);\n            cxt.mergeValidEvaluated(schCxt, valid);\n        }, () => gen.var(valid, true) // TODO var\n        );\n        cxt.ok(valid);\n    }\n}\nexports.validateSchemaDeps = validateSchemaDeps;\nexports["default"] = def;\n//# sourceMappingURL=dependencies.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/dependencies.js?')},9748:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst error = {\n    message: ({ params }) => (0, codegen_1.str) `must match "${params.ifClause}" schema`,\n    params: ({ params }) => (0, codegen_1._) `{failingKeyword: ${params.ifClause}}`,\n};\nconst def = {\n    keyword: "if",\n    schemaType: ["object", "boolean"],\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, parentSchema, it } = cxt;\n        if (parentSchema.then === undefined && parentSchema.else === undefined) {\n            (0, util_1.checkStrictMode)(it, \'"if" without "then" and "else" is ignored\');\n        }\n        const hasThen = hasSchema(it, "then");\n        const hasElse = hasSchema(it, "else");\n        if (!hasThen && !hasElse)\n            return;\n        const valid = gen.let("valid", true);\n        const schValid = gen.name("_valid");\n        validateIf();\n        cxt.reset();\n        if (hasThen && hasElse) {\n            const ifClause = gen.let("ifClause");\n            cxt.setParams({ ifClause });\n            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));\n        }\n        else if (hasThen) {\n            gen.if(schValid, validateClause("then"));\n        }\n        else {\n            gen.if((0, codegen_1.not)(schValid), validateClause("else"));\n        }\n        cxt.pass(valid, () => cxt.error(true));\n        function validateIf() {\n            const schCxt = cxt.subschema({\n                keyword: "if",\n                compositeRule: true,\n                createErrors: false,\n                allErrors: false,\n            }, schValid);\n            cxt.mergeEvaluated(schCxt);\n        }\n        function validateClause(keyword, ifClause) {\n            return () => {\n                const schCxt = cxt.subschema({ keyword }, schValid);\n                gen.assign(valid, schValid);\n                cxt.mergeValidEvaluated(schCxt, valid);\n                if (ifClause)\n                    gen.assign(ifClause, (0, codegen_1._) `${keyword}`);\n                else\n                    cxt.setParams({ ifClause: keyword });\n            };\n        }\n    },\n};\nfunction hasSchema(it, keyword) {\n    const schema = it.schema[keyword];\n    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\nexports["default"] = def;\n//# sourceMappingURL=if.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/if.js?')},8879:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst additionalItems_1 = __webpack_require__(6960);\nconst prefixItems_1 = __webpack_require__(8017);\nconst items_1 = __webpack_require__(25);\nconst items2020_1 = __webpack_require__(2331);\nconst contains_1 = __webpack_require__(2196);\nconst dependencies_1 = __webpack_require__(9152);\nconst propertyNames_1 = __webpack_require__(5105);\nconst additionalProperties_1 = __webpack_require__(1277);\nconst properties_1 = __webpack_require__(3195);\nconst patternProperties_1 = __webpack_require__(4347);\nconst not_1 = __webpack_require__(6435);\nconst anyOf_1 = __webpack_require__(8809);\nconst oneOf_1 = __webpack_require__(9412);\nconst allOf_1 = __webpack_require__(1755);\nconst if_1 = __webpack_require__(9748);\nconst thenElse_1 = __webpack_require__(4649);\nfunction getApplicator(draft2020 = false) {\n    const applicator = [\n        // any\n        not_1.default,\n        anyOf_1.default,\n        oneOf_1.default,\n        allOf_1.default,\n        if_1.default,\n        thenElse_1.default,\n        // object\n        propertyNames_1.default,\n        additionalProperties_1.default,\n        dependencies_1.default,\n        properties_1.default,\n        patternProperties_1.default,\n    ];\n    // array\n    if (draft2020)\n        applicator.push(prefixItems_1.default, items2020_1.default);\n    else\n        applicator.push(additionalItems_1.default, items_1.default);\n    applicator.push(contains_1.default);\n    return applicator;\n}\nexports["default"] = getApplicator;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/index.js?')},25:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.validateTuple = void 0;\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst code_1 = __webpack_require__(5178);\nconst def = {\n    keyword: "items",\n    type: "array",\n    schemaType: ["object", "array", "boolean"],\n    before: "uniqueItems",\n    code(cxt) {\n        const { schema, it } = cxt;\n        if (Array.isArray(schema))\n            return validateTuple(cxt, "additionalItems", schema);\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nfunction validateTuple(cxt, extraItems, schArr = cxt.schema) {\n    const { gen, parentSchema, data, keyword, it } = cxt;\n    checkStrictTuple(parentSchema);\n    if (it.opts.unevaluated && schArr.length && it.items !== true) {\n        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);\n    }\n    const valid = gen.name("valid");\n    const len = gen.const("len", (0, codegen_1._) `${data}.length`);\n    schArr.forEach((sch, i) => {\n        if ((0, util_1.alwaysValidSchema)(it, sch))\n            return;\n        gen.if((0, codegen_1._) `${len} > ${i}`, () => cxt.subschema({\n            keyword,\n            schemaProp: i,\n            dataProp: i,\n        }, valid));\n        cxt.ok(valid);\n    });\n    function checkStrictTuple(sch) {\n        const { opts, errSchemaPath } = it;\n        const l = schArr.length;\n        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);\n        if (opts.strictTuples && !fullTuple) {\n            const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;\n            (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);\n        }\n    }\n}\nexports.validateTuple = validateTuple;\nexports["default"] = def;\n//# sourceMappingURL=items.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/items.js?')},2331:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst code_1 = __webpack_require__(5178);\nconst additionalItems_1 = __webpack_require__(6960);\nconst error = {\n    message: ({ params: { len } }) => (0, codegen_1.str) `must NOT have more than ${len} items`,\n    params: ({ params: { len } }) => (0, codegen_1._) `{limit: ${len}}`,\n};\nconst def = {\n    keyword: "items",\n    type: "array",\n    schemaType: ["object", "boolean"],\n    before: "uniqueItems",\n    error,\n    code(cxt) {\n        const { schema, parentSchema, it } = cxt;\n        const { prefixItems } = parentSchema;\n        it.items = true;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        if (prefixItems)\n            (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);\n        else\n            cxt.ok((0, code_1.validateArray)(cxt));\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=items2020.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/items2020.js?')},6435:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst util_1 = __webpack_require__(8327);\nconst def = {\n    keyword: "not",\n    schemaType: ["object", "boolean"],\n    trackErrors: true,\n    code(cxt) {\n        const { gen, schema, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema)) {\n            cxt.fail();\n            return;\n        }\n        const valid = gen.name("valid");\n        cxt.subschema({\n            keyword: "not",\n            compositeRule: true,\n            createErrors: false,\n            allErrors: false,\n        }, valid);\n        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());\n    },\n    error: { message: "must NOT be valid" },\n};\nexports["default"] = def;\n//# sourceMappingURL=not.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/not.js?')},9412:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst error = {\n    message: "must match exactly one schema in oneOf",\n    params: ({ params }) => (0, codegen_1._) `{passingSchemas: ${params.passing}}`,\n};\nconst def = {\n    keyword: "oneOf",\n    schemaType: "array",\n    trackErrors: true,\n    error,\n    code(cxt) {\n        const { gen, schema, parentSchema, it } = cxt;\n        /* istanbul ignore if */\n        if (!Array.isArray(schema))\n            throw new Error("ajv implementation error");\n        if (it.opts.discriminator && parentSchema.discriminator)\n            return;\n        const schArr = schema;\n        const valid = gen.let("valid", false);\n        const passing = gen.let("passing", null);\n        const schValid = gen.name("_valid");\n        cxt.setParams({ passing });\n        // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n        gen.block(validateOneOf);\n        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n        function validateOneOf() {\n            schArr.forEach((sch, i) => {\n                let schCxt;\n                if ((0, util_1.alwaysValidSchema)(it, sch)) {\n                    gen.var(schValid, true);\n                }\n                else {\n                    schCxt = cxt.subschema({\n                        keyword: "oneOf",\n                        schemaProp: i,\n                        compositeRule: true,\n                    }, schValid);\n                }\n                if (i > 0) {\n                    gen\n                        .if((0, codegen_1._) `${schValid} && ${valid}`)\n                        .assign(valid, false)\n                        .assign(passing, (0, codegen_1._) `[${passing}, ${i}]`)\n                        .else();\n                }\n                gen.if(schValid, () => {\n                    gen.assign(valid, true);\n                    gen.assign(passing, i);\n                    if (schCxt)\n                        cxt.mergeEvaluated(schCxt, codegen_1.Name);\n                });\n            });\n        }\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=oneOf.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/oneOf.js?')},4347:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst code_1 = __webpack_require__(5178);\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst util_2 = __webpack_require__(8327);\nconst def = {\n    keyword: "patternProperties",\n    type: "object",\n    schemaType: "object",\n    code(cxt) {\n        const { gen, schema, data, parentSchema, it } = cxt;\n        const { opts } = it;\n        const patterns = (0, code_1.allSchemaProperties)(schema);\n        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (patterns.length === 0 ||\n            (alwaysValidPatterns.length === patterns.length &&\n                (!it.opts.unevaluated || it.props === true))) {\n            return;\n        }\n        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n        const valid = gen.name("valid");\n        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n            it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n        }\n        const { props } = it;\n        validatePatternProperties();\n        function validatePatternProperties() {\n            for (const pat of patterns) {\n                if (checkProperties)\n                    checkMatchingProperties(pat);\n                if (it.allErrors) {\n                    validateProperties(pat);\n                }\n                else {\n                    gen.var(valid, true); // TODO var\n                    validateProperties(pat);\n                    gen.if(valid);\n                }\n            }\n        }\n        function checkMatchingProperties(pat) {\n            for (const prop in checkProperties) {\n                if (new RegExp(pat).test(prop)) {\n                    (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n                }\n            }\n        }\n        function validateProperties(pat) {\n            gen.forIn("key", data, (key) => {\n                gen.if((0, codegen_1._) `${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n                    const alwaysValid = alwaysValidPatterns.includes(pat);\n                    if (!alwaysValid) {\n                        cxt.subschema({\n                            keyword: "patternProperties",\n                            schemaProp: pat,\n                            dataProp: key,\n                            dataPropType: util_2.Type.Str,\n                        }, valid);\n                    }\n                    if (it.opts.unevaluated && props !== true) {\n                        gen.assign((0, codegen_1._) `${props}[${key}]`, true);\n                    }\n                    else if (!alwaysValid && !it.allErrors) {\n                        // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n                        // or if all properties were evaluated (props === true)\n                        gen.if((0, codegen_1.not)(valid), () => gen.break());\n                    }\n                });\n            });\n        }\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=patternProperties.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js?')},8017:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst items_1 = __webpack_require__(25);\nconst def = {\n    keyword: "prefixItems",\n    type: "array",\n    schemaType: ["array"],\n    before: "uniqueItems",\n    code: (cxt) => (0, items_1.validateTuple)(cxt, "items"),\n};\nexports["default"] = def;\n//# sourceMappingURL=prefixItems.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js?')},3195:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst validate_1 = __webpack_require__(850);\nconst code_1 = __webpack_require__(5178);\nconst util_1 = __webpack_require__(8327);\nconst additionalProperties_1 = __webpack_require__(1277);\nconst def = {\n    keyword: "properties",\n    type: "object",\n    schemaType: "object",\n    code(cxt) {\n        const { gen, schema, parentSchema, data, it } = cxt;\n        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {\n            additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));\n        }\n        const allProps = (0, code_1.allSchemaProperties)(schema);\n        for (const prop of allProps) {\n            it.definedProperties.add(prop);\n        }\n        if (it.opts.unevaluated && allProps.length && it.props !== true) {\n            it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n        }\n        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n        if (properties.length === 0)\n            return;\n        const valid = gen.name("valid");\n        for (const prop of properties) {\n            if (hasDefault(prop)) {\n                applyPropertySchema(prop);\n            }\n            else {\n                gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n                applyPropertySchema(prop);\n                if (!it.allErrors)\n                    gen.else().var(valid, true);\n                gen.endIf();\n            }\n            cxt.it.definedProperties.add(prop);\n            cxt.ok(valid);\n        }\n        function hasDefault(prop) {\n            return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n        }\n        function applyPropertySchema(prop) {\n            cxt.subschema({\n                keyword: "properties",\n                schemaProp: prop,\n                dataProp: prop,\n            }, valid);\n        }\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=properties.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/properties.js?')},5105:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst error = {\n    message: "property name must be valid",\n    params: ({ params }) => (0, codegen_1._) `{propertyName: ${params.propertyName}}`,\n};\nconst def = {\n    keyword: "propertyNames",\n    type: "object",\n    schemaType: ["object", "boolean"],\n    error,\n    code(cxt) {\n        const { gen, schema, data, it } = cxt;\n        if ((0, util_1.alwaysValidSchema)(it, schema))\n            return;\n        const valid = gen.name("valid");\n        gen.forIn("key", data, (key) => {\n            cxt.setParams({ propertyName: key });\n            cxt.subschema({\n                keyword: "propertyNames",\n                data: key,\n                dataTypes: ["string"],\n                propertyName: key,\n                compositeRule: true,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), () => {\n                cxt.error(true);\n                if (!it.allErrors)\n                    gen.break();\n            });\n        });\n        cxt.ok(valid);\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=propertyNames.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js?')},4649:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst util_1 = __webpack_require__(8327);\nconst def = {\n    keyword: ["then", "else"],\n    schemaType: ["object", "boolean"],\n    code({ keyword, parentSchema, it }) {\n        if (parentSchema.if === undefined)\n            (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=thenElse.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/applicator/thenElse.js?')},5178:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst names_1 = __webpack_require__(9574);\nconst util_2 = __webpack_require__(8327);\nfunction checkReportMissingProp(cxt, prop) {\n    const { gen, data, it } = cxt;\n    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop}` }, true);\n        cxt.error();\n    });\n}\nexports.checkReportMissingProp = checkReportMissingProp;\nfunction checkMissingProp({ gen, data, it: { opts } }, properties, missing) {\n    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing} = ${prop}`)));\n}\nexports.checkMissingProp = checkMissingProp;\nfunction reportMissingProp(cxt, missing) {\n    cxt.setParams({ missingProperty: missing }, true);\n    cxt.error();\n}\nexports.reportMissingProp = reportMissingProp;\nfunction hasPropFunc(gen) {\n    return gen.scopeValue("func", {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        ref: Object.prototype.hasOwnProperty,\n        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,\n    });\n}\nexports.hasPropFunc = hasPropFunc;\nfunction isOwnProperty(gen, data, property) {\n    return (0, codegen_1._) `${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\nexports.isOwnProperty = isOwnProperty;\nfunction propertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n    return ownProperties ? (0, codegen_1._) `${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\nexports.propertyInData = propertyInData;\nfunction noPropertyInData(gen, data, property, ownProperties) {\n    const cond = (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\nexports.noPropertyInData = noPropertyInData;\nfunction allSchemaProperties(schemaMap) {\n    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];\n}\nexports.allSchemaProperties = allSchemaProperties;\nfunction schemaProperties(it, schemaMap) {\n    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\nexports.schemaProperties = schemaProperties;\nfunction callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {\n    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n    const valCxt = [\n        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],\n        [names_1.default.parentData, it.parentData],\n        [names_1.default.parentDataProperty, it.parentDataProperty],\n        [names_1.default.rootData, names_1.default.rootData],\n    ];\n    if (it.opts.dynamicRef)\n        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n    const args = (0, codegen_1._) `${dataAndSchema}, ${gen.object(...valCxt)}`;\n    return context !== codegen_1.nil ? (0, codegen_1._) `${func}.call(${context}, ${args})` : (0, codegen_1._) `${func}(${args})`;\n}\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._) `new RegExp`;\nfunction usePattern({ gen, it: { opts } }, pattern) {\n    const u = opts.unicodeRegExp ? "u" : "";\n    const { regExp } = opts.code;\n    const rx = regExp(pattern, u);\n    return gen.scopeValue("pattern", {\n        key: rx.toString(),\n        ref: rx,\n        code: (0, codegen_1._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`,\n    });\n}\nexports.usePattern = usePattern;\nfunction validateArray(cxt) {\n    const { gen, data, keyword, it } = cxt;\n    const valid = gen.name("valid");\n    if (it.allErrors) {\n        const validArr = gen.let("valid", true);\n        validateItems(() => gen.assign(validArr, false));\n        return validArr;\n    }\n    gen.var(valid, true);\n    validateItems(() => gen.break());\n    return valid;\n    function validateItems(notValid) {\n        const len = gen.const("len", (0, codegen_1._) `${data}.length`);\n        gen.forRange("i", 0, len, (i) => {\n            cxt.subschema({\n                keyword,\n                dataProp: i,\n                dataPropType: util_1.Type.Num,\n            }, valid);\n            gen.if((0, codegen_1.not)(valid), notValid);\n        });\n    }\n}\nexports.validateArray = validateArray;\nfunction validateUnion(cxt) {\n    const { gen, schema, keyword, it } = cxt;\n    /* istanbul ignore if */\n    if (!Array.isArray(schema))\n        throw new Error("ajv implementation error");\n    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));\n    if (alwaysValid && !it.opts.unevaluated)\n        return;\n    const valid = gen.let("valid", false);\n    const schValid = gen.name("_valid");\n    gen.block(() => schema.forEach((_sch, i) => {\n        const schCxt = cxt.subschema({\n            keyword,\n            schemaProp: i,\n            compositeRule: true,\n        }, schValid);\n        gen.assign(valid, (0, codegen_1._) `${valid} || ${schValid}`);\n        const merged = cxt.mergeValidEvaluated(schCxt, schValid);\n        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n        // or if all properties and items were evaluated (it.props === true && it.items === true)\n        if (!merged)\n            gen.if((0, codegen_1.not)(valid));\n    }));\n    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\nexports.validateUnion = validateUnion;\n//# sourceMappingURL=code.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/code.js?')},6016:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst def = {\n    keyword: "id",\n    code() {\n        throw new Error(\'NOT SUPPORTED: keyword "id", use "$id" for schema ID\');\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=id.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/core/id.js?')},5925:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst id_1 = __webpack_require__(6016);\nconst ref_1 = __webpack_require__(1052);\nconst core = [\n    "$schema",\n    "$id",\n    "$defs",\n    "$vocabulary",\n    { keyword: "$comment" },\n    "definitions",\n    id_1.default,\n    ref_1.default,\n];\nexports["default"] = core;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/core/index.js?')},1052:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = __webpack_require__(4179);\nconst code_1 = __webpack_require__(5178);\nconst codegen_1 = __webpack_require__(7994);\nconst names_1 = __webpack_require__(9574);\nconst compile_1 = __webpack_require__(2267);\nconst util_1 = __webpack_require__(8327);\nconst def = {\n    keyword: "$ref",\n    schemaType: "string",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue("root", { ref: root });\n            return callRef(cxt, (0, codegen_1._) `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });\n            const valid = gen.name("valid");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue("validate", { ref: sch.validate })\n        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error("async schema referenced by sync schema");\n        const valid = gen.let("valid");\n        gen.try(() => {\n            gen.code((0, codegen_1._) `await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if((0, codegen_1._) `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = (0, codegen_1._) `${source}.errors`;\n        gen.assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var("props", (0, codegen_1._) `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var("items", (0, codegen_1._) `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports["default"] = def;\n//# sourceMappingURL=ref.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/core/ref.js?')},9886:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst types_1 = __webpack_require__(4823);\nconst compile_1 = __webpack_require__(2267);\nconst util_1 = __webpack_require__(8327);\nconst error = {\n    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag\n        ? `tag "${tagName}" must be string`\n        : `value of tag "${tagName}" must be in oneOf`,\n    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._) `{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n};\nconst def = {\n    keyword: "discriminator",\n    type: "object",\n    schemaType: "object",\n    error,\n    code(cxt) {\n        const { gen, data, schema, parentSchema, it } = cxt;\n        const { oneOf } = parentSchema;\n        if (!it.opts.discriminator) {\n            throw new Error("discriminator: requires discriminator option");\n        }\n        const tagName = schema.propertyName;\n        if (typeof tagName != "string")\n            throw new Error("discriminator: requires propertyName");\n        if (schema.mapping)\n            throw new Error("discriminator: mapping is not supported");\n        if (!oneOf)\n            throw new Error("discriminator: requires oneOf keyword");\n        const valid = gen.let("valid", false);\n        const tag = gen.const("tag", (0, codegen_1._) `${data}${(0, codegen_1.getProperty)(tagName)}`);\n        gen.if((0, codegen_1._) `typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));\n        cxt.ok(valid);\n        function validateMapping() {\n            const mapping = getMapping();\n            gen.if(false);\n            for (const tagValue in mapping) {\n                gen.elseIf((0, codegen_1._) `${tag} === ${tagValue}`);\n                gen.assign(valid, applyTagSchema(mapping[tagValue]));\n            }\n            gen.else();\n            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });\n            gen.endIf();\n        }\n        function applyTagSchema(schemaProp) {\n            const _valid = gen.name("valid");\n            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);\n            cxt.mergeEvaluated(schCxt, codegen_1.Name);\n            return _valid;\n        }\n        function getMapping() {\n            var _a;\n            const oneOfMapping = {};\n            const topRequired = hasRequired(parentSchema);\n            let tagRequired = true;\n            for (let i = 0; i < oneOf.length; i++) {\n                let sch = oneOf[i];\n                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {\n                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, sch === null || sch === void 0 ? void 0 : sch.$ref);\n                    if (sch instanceof compile_1.SchemaEnv)\n                        sch = sch.schema;\n                }\n                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];\n                if (typeof propSch != "object") {\n                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);\n                }\n                tagRequired = tagRequired && (topRequired || hasRequired(sch));\n                addMappings(propSch, i);\n            }\n            if (!tagRequired)\n                throw new Error(`discriminator: "${tagName}" must be required`);\n            return oneOfMapping;\n            function hasRequired({ required }) {\n                return Array.isArray(required) && required.includes(tagName);\n            }\n            function addMappings(sch, i) {\n                if (sch.const) {\n                    addMapping(sch.const, i);\n                }\n                else if (sch.enum) {\n                    for (const tagValue of sch.enum) {\n                        addMapping(tagValue, i);\n                    }\n                }\n                else {\n                    throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);\n                }\n            }\n            function addMapping(tagValue, i) {\n                if (typeof tagValue != "string" || tagValue in oneOfMapping) {\n                    throw new Error(`discriminator: "${tagName}" values must be unique strings`);\n                }\n                oneOfMapping[tagValue] = i;\n            }\n        }\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/discriminator/index.js?')},4823:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.DiscrError = void 0;\nvar DiscrError;\n(function (DiscrError) {\n    DiscrError["Tag"] = "tag";\n    DiscrError["Mapping"] = "mapping";\n})(DiscrError = exports.DiscrError || (exports.DiscrError = {}));\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/discriminator/types.js?')},8097:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst core_1 = __webpack_require__(5925);\nconst validation_1 = __webpack_require__(597);\nconst applicator_1 = __webpack_require__(8879);\nconst format_1 = __webpack_require__(1769);\nconst metadata_1 = __webpack_require__(2644);\nconst draft7Vocabularies = [\n    core_1.default,\n    validation_1.default,\n    (0, applicator_1.default)(),\n    format_1.default,\n    metadata_1.metadataVocabulary,\n    metadata_1.contentVocabulary,\n];\nexports["default"] = draft7Vocabularies;\n//# sourceMappingURL=draft7.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/draft7.js?')},3570:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match format "${schemaCode}"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: "format",\n    type: ["number", "string"],\n    schemaType: "string",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue("formats", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const("fDef", (0, codegen_1._) `${fmts}[${schemaCode}]`);\n            const fType = gen.let("fType");\n            const format = gen.let("format");\n            // TODO simplify\n            gen.if((0, codegen_1._) `typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef}.type || "string"`).assign(format, (0, codegen_1._) `${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._) `"string"`).assign(format, fDef));\n            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return (0, codegen_1._) `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? (0, codegen_1._) `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : (0, codegen_1._) `${format}(${data})`;\n                const validData = (0, codegen_1._) `(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;\n                return (0, codegen_1._) `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? (0, codegen_1.regexpCode)(fmtDef)\n                    : opts.code.formats\n                        ? (0, codegen_1._) `${opts.code.formats}${(0, codegen_1.getProperty)(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._) `${fmt}.validate`];\n                }\n                return ["string", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error("async format in sync schema");\n                    return (0, codegen_1._) `await ${fmtRef}(${data})`;\n                }\n                return typeof format == "function" ? (0, codegen_1._) `${fmtRef}(${data})` : (0, codegen_1._) `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=format.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/format/format.js?')},1769:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst format_1 = __webpack_require__(3570);\nconst format = [format_1.default];\nexports["default"] = format;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/format/index.js?')},2644:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.contentVocabulary = exports.metadataVocabulary = void 0;\nexports.metadataVocabulary = [\n    "title",\n    "description",\n    "default",\n    "deprecated",\n    "readOnly",\n    "writeOnly",\n    "examples",\n];\nexports.contentVocabulary = [\n    "contentMediaType",\n    "contentEncoding",\n    "contentSchema",\n];\n//# sourceMappingURL=metadata.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/metadata.js?')},9439:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst equal_1 = __webpack_require__(8652);\nconst error = {\n    message: "must be equal to constant",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValue: ${schemaCode}}`,\n};\nconst def = {\n    keyword: "const",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schemaCode, schema } = cxt;\n        if ($data || (schema && typeof schema == "object")) {\n            cxt.fail$data((0, codegen_1._) `!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);\n        }\n        else {\n            cxt.fail((0, codegen_1._) `${schema} !== ${data}`);\n        }\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=const.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/const.js?')},3479:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst equal_1 = __webpack_require__(8652);\nconst error = {\n    message: "must be equal to one of the allowed values",\n    params: ({ schemaCode }) => (0, codegen_1._) `{allowedValues: ${schemaCode}}`,\n};\nconst def = {\n    keyword: "enum",\n    schemaType: "array",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        if (!$data && schema.length === 0)\n            throw new Error("enum must have non-empty array");\n        const useLoop = schema.length >= it.opts.loopEnum;\n        let eql;\n        const getEql = () => (eql !== null && eql !== void 0 ? eql : (eql = (0, util_1.useFunc)(gen, equal_1.default)));\n        let valid;\n        if (useLoop || $data) {\n            valid = gen.let("valid");\n            cxt.block$data(valid, loopEnum);\n        }\n        else {\n            /* istanbul ignore if */\n            if (!Array.isArray(schema))\n                throw new Error("ajv implementation error");\n            const vSchema = gen.const("vSchema", schemaCode);\n            valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));\n        }\n        cxt.pass(valid);\n        function loopEnum() {\n            gen.assign(valid, false);\n            gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._) `${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));\n        }\n        function equalCode(vSchema, i) {\n            const sch = schema[i];\n            return typeof sch === "object" && sch !== null\n                ? (0, codegen_1._) `${getEql()}(${data}, ${vSchema}[${i}])`\n                : (0, codegen_1._) `${data} === ${sch}`;\n        }\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=enum.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/enum.js?')},597:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst limitNumber_1 = __webpack_require__(6540);\nconst multipleOf_1 = __webpack_require__(8835);\nconst limitLength_1 = __webpack_require__(7347);\nconst pattern_1 = __webpack_require__(1178);\nconst limitProperties_1 = __webpack_require__(6153);\nconst required_1 = __webpack_require__(6204);\nconst limitItems_1 = __webpack_require__(5666);\nconst uniqueItems_1 = __webpack_require__(8340);\nconst const_1 = __webpack_require__(9439);\nconst enum_1 = __webpack_require__(3479);\nconst validation = [\n    // number\n    limitNumber_1.default,\n    multipleOf_1.default,\n    // string\n    limitLength_1.default,\n    pattern_1.default,\n    // object\n    limitProperties_1.default,\n    required_1.default,\n    // array\n    limitItems_1.default,\n    uniqueItems_1.default,\n    // any\n    { keyword: "type", schemaType: ["string", "array"] },\n    { keyword: "nullable", schemaType: "boolean" },\n    const_1.default,\n    enum_1.default,\n];\nexports["default"] = validation;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/index.js?')},5666:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === "maxItems" ? "more" : "fewer";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} items`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: ["maxItems", "minItems"],\n    type: "array",\n    schemaType: "number",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `${data}.length ${op} ${schemaCode}`);\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=limitItems.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/limitItems.js?')},7347:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst ucs2length_1 = __webpack_require__(5501);\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === "maxLength" ? "more" : "fewer";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} characters`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: ["maxLength", "minLength"],\n    type: "string",\n    schemaType: "number",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode, it } = cxt;\n        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        const len = it.opts.unicode === false ? (0, codegen_1._) `${data}.length` : (0, codegen_1._) `${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;\n        cxt.fail$data((0, codegen_1._) `${len} ${op} ${schemaCode}`);\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=limitLength.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/limitLength.js?')},6540:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst ops = codegen_1.operators;\nconst KWDs = {\n    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },\n    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },\n    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },\n    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },\n};\nconst error = {\n    message: ({ keyword, schemaCode }) => (0, codegen_1.str) `must be ${KWDs[keyword].okStr} ${schemaCode}`,\n    params: ({ keyword, schemaCode }) => (0, codegen_1._) `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: Object.keys(KWDs),\n    type: "number",\n    schemaType: "number",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        cxt.fail$data((0, codegen_1._) `${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=limitNumber.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/limitNumber.js?')},6153:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst error = {\n    message({ keyword, schemaCode }) {\n        const comp = keyword === "maxProperties" ? "more" : "fewer";\n        return (0, codegen_1.str) `must NOT have ${comp} than ${schemaCode} properties`;\n    },\n    params: ({ schemaCode }) => (0, codegen_1._) `{limit: ${schemaCode}}`,\n};\nconst def = {\n    keyword: ["maxProperties", "minProperties"],\n    type: "object",\n    schemaType: "number",\n    $data: true,\n    error,\n    code(cxt) {\n        const { keyword, data, schemaCode } = cxt;\n        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;\n        cxt.fail$data((0, codegen_1._) `Object.keys(${data}).length ${op} ${schemaCode}`);\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=limitProperties.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/limitProperties.js?')},8835:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst codegen_1 = __webpack_require__(7994);\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must be multiple of ${schemaCode}`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{multipleOf: ${schemaCode}}`,\n};\nconst def = {\n    keyword: "multipleOf",\n    type: "number",\n    schemaType: "number",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, schemaCode, it } = cxt;\n        // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n        const prec = it.opts.multipleOfPrecision;\n        const res = gen.let("res");\n        const invalid = prec\n            ? (0, codegen_1._) `Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n            : (0, codegen_1._) `${res} !== parseInt(${res})`;\n        cxt.fail$data((0, codegen_1._) `(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=multipleOf.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/multipleOf.js?')},1178:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst code_1 = __webpack_require__(5178);\nconst codegen_1 = __webpack_require__(7994);\nconst error = {\n    message: ({ schemaCode }) => (0, codegen_1.str) `must match pattern "${schemaCode}"`,\n    params: ({ schemaCode }) => (0, codegen_1._) `{pattern: ${schemaCode}}`,\n};\nconst def = {\n    keyword: "pattern",\n    type: "string",\n    schemaType: "string",\n    $data: true,\n    error,\n    code(cxt) {\n        const { data, $data, schema, schemaCode, it } = cxt;\n        // TODO regexp should be wrapped in try/catchs\n        const u = it.opts.unicodeRegExp ? "u" : "";\n        const regExp = $data ? (0, codegen_1._) `(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);\n        cxt.fail$data((0, codegen_1._) `!${regExp}.test(${data})`);\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=pattern.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/pattern.js?')},6204:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst code_1 = __webpack_require__(5178);\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst error = {\n    message: ({ params: { missingProperty } }) => (0, codegen_1.str) `must have required property \'${missingProperty}\'`,\n    params: ({ params: { missingProperty } }) => (0, codegen_1._) `{missingProperty: ${missingProperty}}`,\n};\nconst def = {\n    keyword: "required",\n    type: "object",\n    schemaType: "array",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, schema, schemaCode, data, $data, it } = cxt;\n        const { opts } = it;\n        if (!$data && schema.length === 0)\n            return;\n        const useLoop = schema.length >= opts.loopRequired;\n        if (it.allErrors)\n            allErrorsMode();\n        else\n            exitOnErrorMode();\n        if (opts.strictRequired) {\n            const props = cxt.parentSchema.properties;\n            const { definedProperties } = cxt.it;\n            for (const requiredKey of schema) {\n                if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n                    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n                    const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;\n                    (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n                }\n            }\n        }\n        function allErrorsMode() {\n            if (useLoop || $data) {\n                cxt.block$data(codegen_1.nil, loopAllRequired);\n            }\n            else {\n                for (const prop of schema) {\n                    (0, code_1.checkReportMissingProp)(cxt, prop);\n                }\n            }\n        }\n        function exitOnErrorMode() {\n            const missing = gen.let("missing");\n            if (useLoop || $data) {\n                const valid = gen.let("valid", true);\n                cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n                cxt.ok(valid);\n            }\n            else {\n                gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n                (0, code_1.reportMissingProp)(cxt, missing);\n                gen.else();\n            }\n        }\n        function loopAllRequired() {\n            gen.forOf("prop", schemaCode, (prop) => {\n                cxt.setParams({ missingProperty: prop });\n                gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n            });\n        }\n        function loopUntilMissing(missing, valid) {\n            cxt.setParams({ missingProperty: missing });\n            gen.forOf(missing, schemaCode, () => {\n                gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n                gen.if((0, codegen_1.not)(valid), () => {\n                    cxt.error();\n                    gen.break();\n                });\n            }, codegen_1.nil);\n        }\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=required.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/required.js?')},8340:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst dataType_1 = __webpack_require__(4543);\nconst codegen_1 = __webpack_require__(7994);\nconst util_1 = __webpack_require__(8327);\nconst equal_1 = __webpack_require__(8652);\nconst error = {\n    message: ({ params: { i, j } }) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n    params: ({ params: { i, j } }) => (0, codegen_1._) `{i: ${i}, j: ${j}}`,\n};\nconst def = {\n    keyword: "uniqueItems",\n    type: "array",\n    schemaType: "boolean",\n    $data: true,\n    error,\n    code(cxt) {\n        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;\n        if (!$data && !schema)\n            return;\n        const valid = gen.let("valid");\n        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode} === false`);\n        cxt.ok(valid);\n        function validateUniqueItems() {\n            const i = gen.let("i", (0, codegen_1._) `${data}.length`);\n            const j = gen.let("j");\n            cxt.setParams({ i, j });\n            gen.assign(valid, true);\n            gen.if((0, codegen_1._) `${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n        }\n        function canOptimize() {\n            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");\n        }\n        function loopN(i, j) {\n            const item = gen.name("item");\n            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n            const indices = gen.const("indices", (0, codegen_1._) `{}`);\n            gen.for((0, codegen_1._) `;${i}--;`, () => {\n                gen.let(item, (0, codegen_1._) `${data}[${i}]`);\n                gen.if(wrongType, (0, codegen_1._) `continue`);\n                if (itemTypes.length > 1)\n                    gen.if((0, codegen_1._) `typeof ${item} == "string"`, (0, codegen_1._) `${item} += "_"`);\n                gen\n                    .if((0, codegen_1._) `typeof ${indices}[${item}] == "number"`, () => {\n                    gen.assign(j, (0, codegen_1._) `${indices}[${item}]`);\n                    cxt.error();\n                    gen.assign(valid, false).break();\n                })\n                    .code((0, codegen_1._) `${indices}[${item}] = ${i}`);\n            });\n        }\n        function loopN2(i, j) {\n            const eql = (0, util_1.useFunc)(gen, equal_1.default);\n            const outer = gen.name("outer");\n            gen.label(outer).for((0, codegen_1._) `;${i}--;`, () => gen.for((0, codegen_1._) `${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._) `${eql}(${data}[${i}], ${data}[${j}])`, () => {\n                cxt.error();\n                gen.assign(valid, false).break(outer);\n            })));\n        }\n    },\n};\nexports["default"] = def;\n//# sourceMappingURL=uniqueItems.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js?')},6943:module=>{"use strict";eval("\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    if(a===b) {\n      return [ai, bi];\n    }\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js?")},3054:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var concatMap = __webpack_require__(837);\nvar balanced = __webpack_require__(6943);\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js?")},837:module=>{eval("module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js?")},5490:module=>{"use strict";eval("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js?")},9831:(module,__unused_webpack_exports,__webpack_require__)=>{eval("module.exports = realpath\nrealpath.realpath = realpath\nrealpath.sync = realpathSync\nrealpath.realpathSync = realpathSync\nrealpath.monkeypatch = monkeypatch\nrealpath.unmonkeypatch = unmonkeypatch\n\nvar fs = __webpack_require__(7147)\nvar origRealpath = fs.realpath\nvar origRealpathSync = fs.realpathSync\n\nvar version = process.version\nvar ok = /^v[0-5]\\./.test(version)\nvar old = __webpack_require__(6660)\n\nfunction newError (er) {\n  return er && er.syscall === 'realpath' && (\n    er.code === 'ELOOP' ||\n    er.code === 'ENOMEM' ||\n    er.code === 'ENAMETOOLONG'\n  )\n}\n\nfunction realpath (p, cache, cb) {\n  if (ok) {\n    return origRealpath(p, cache, cb)\n  }\n\n  if (typeof cache === 'function') {\n    cb = cache\n    cache = null\n  }\n  origRealpath(p, cache, function (er, result) {\n    if (newError(er)) {\n      old.realpath(p, cache, cb)\n    } else {\n      cb(er, result)\n    }\n  })\n}\n\nfunction realpathSync (p, cache) {\n  if (ok) {\n    return origRealpathSync(p, cache)\n  }\n\n  try {\n    return origRealpathSync(p, cache)\n  } catch (er) {\n    if (newError(er)) {\n      return old.realpathSync(p, cache)\n    } else {\n      throw er\n    }\n  }\n}\n\nfunction monkeypatch () {\n  fs.realpath = realpath\n  fs.realpathSync = realpathSync\n}\n\nfunction unmonkeypatch () {\n  fs.realpath = origRealpath\n  fs.realpathSync = origRealpathSync\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js?")},6660:(__unused_webpack_module,exports,__webpack_require__)=>{eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar pathModule = __webpack_require__(1017);\nvar isWindows = process.platform === 'win32';\nvar fs = __webpack_require__(7147);\n\n// JavaScript implementation of realpath, ported from node pre-v6\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  var callback;\n  if (DEBUG) {\n    var backtrace = new Error;\n    callback = debugCallback;\n  } else\n    callback = missingCallback;\n\n  return callback;\n\n  function debugCallback(err) {\n    if (err) {\n      backtrace.message = err.message;\n      err = backtrace;\n      missingCallback(err);\n    }\n  }\n\n  function missingCallback(err) {\n    if (err) {\n      if (process.throwDeprecation)\n        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n      else if (!process.noDeprecation) {\n        var msg = 'fs: missing callback ' + (err.stack || err.message);\n        if (process.traceDeprecation)\n          console.trace(msg);\n        else\n          console.error(msg);\n      }\n    }\n  }\n}\n\nfunction maybeCallback(cb) {\n  return typeof cb === 'function' ? cb : rethrow();\n}\n\nvar normalize = pathModule.normalize;\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nexports.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nexports.realpath = function realpath(p, cache, cb) {\n  if (typeof cb !== 'function') {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js?")},2353:(__unused_webpack_module,exports,__webpack_require__)=>{eval("exports.setopts = setopts\nexports.ownProp = ownProp\nexports.makeAbs = makeAbs\nexports.finish = finish\nexports.mark = mark\nexports.isIgnored = isIgnored\nexports.childrenIgnored = childrenIgnored\n\nfunction ownProp (obj, field) {\n  return Object.prototype.hasOwnProperty.call(obj, field)\n}\n\nvar fs = __webpack_require__(7147)\nvar path = __webpack_require__(1017)\nvar minimatch = __webpack_require__(4710)\nvar isAbsolute = __webpack_require__(4659)\nvar Minimatch = minimatch.Minimatch\n\nfunction alphasort (a, b) {\n  return a.localeCompare(b, 'en')\n}\n\nfunction setupIgnores (self, options) {\n  self.ignore = options.ignore || []\n\n  if (!Array.isArray(self.ignore))\n    self.ignore = [self.ignore]\n\n  if (self.ignore.length) {\n    self.ignore = self.ignore.map(ignoreMap)\n  }\n}\n\n// ignore patterns are always in dot:true mode.\nfunction ignoreMap (pattern) {\n  var gmatcher = null\n  if (pattern.slice(-3) === '/**') {\n    var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '')\n    gmatcher = new Minimatch(gpattern, { dot: true })\n  }\n\n  return {\n    matcher: new Minimatch(pattern, { dot: true }),\n    gmatcher: gmatcher\n  }\n}\n\nfunction setopts (self, pattern, options) {\n  if (!options)\n    options = {}\n\n  // base-matching: just use globstar for that.\n  if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n    if (options.noglobstar) {\n      throw new Error(\"base matching requires globstar\")\n    }\n    pattern = \"**/\" + pattern\n  }\n\n  self.silent = !!options.silent\n  self.pattern = pattern\n  self.strict = options.strict !== false\n  self.realpath = !!options.realpath\n  self.realpathCache = options.realpathCache || Object.create(null)\n  self.follow = !!options.follow\n  self.dot = !!options.dot\n  self.mark = !!options.mark\n  self.nodir = !!options.nodir\n  if (self.nodir)\n    self.mark = true\n  self.sync = !!options.sync\n  self.nounique = !!options.nounique\n  self.nonull = !!options.nonull\n  self.nosort = !!options.nosort\n  self.nocase = !!options.nocase\n  self.stat = !!options.stat\n  self.noprocess = !!options.noprocess\n  self.absolute = !!options.absolute\n  self.fs = options.fs || fs\n\n  self.maxLength = options.maxLength || Infinity\n  self.cache = options.cache || Object.create(null)\n  self.statCache = options.statCache || Object.create(null)\n  self.symlinks = options.symlinks || Object.create(null)\n\n  setupIgnores(self, options)\n\n  self.changedCwd = false\n  var cwd = process.cwd()\n  if (!ownProp(options, \"cwd\"))\n    self.cwd = cwd\n  else {\n    self.cwd = path.resolve(options.cwd)\n    self.changedCwd = self.cwd !== cwd\n  }\n\n  self.root = options.root || path.resolve(self.cwd, \"/\")\n  self.root = path.resolve(self.root)\n  if (process.platform === \"win32\")\n    self.root = self.root.replace(/\\\\/g, \"/\")\n\n  // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)\n  if (process.platform === \"win32\")\n    self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\")\n  self.nomount = !!options.nomount\n\n  // disable comments and negation in Minimatch.\n  // Note that they are not supported in Glob itself anyway.\n  options.nonegate = true\n  options.nocomment = true\n  // always treat \\ in patterns as escapes, not path separators\n  options.allowWindowsEscape = false\n\n  self.minimatch = new Minimatch(pattern, options)\n  self.options = self.minimatch.options\n}\n\nfunction finish (self) {\n  var nou = self.nounique\n  var all = nou ? [] : Object.create(null)\n\n  for (var i = 0, l = self.matches.length; i < l; i ++) {\n    var matches = self.matches[i]\n    if (!matches || Object.keys(matches).length === 0) {\n      if (self.nonull) {\n        // do like the shell, and spit out the literal glob\n        var literal = self.minimatch.globSet[i]\n        if (nou)\n          all.push(literal)\n        else\n          all[literal] = true\n      }\n    } else {\n      // had matches\n      var m = Object.keys(matches)\n      if (nou)\n        all.push.apply(all, m)\n      else\n        m.forEach(function (m) {\n          all[m] = true\n        })\n    }\n  }\n\n  if (!nou)\n    all = Object.keys(all)\n\n  if (!self.nosort)\n    all = all.sort(alphasort)\n\n  // at *some* point we statted all of these\n  if (self.mark) {\n    for (var i = 0; i < all.length; i++) {\n      all[i] = self._mark(all[i])\n    }\n    if (self.nodir) {\n      all = all.filter(function (e) {\n        var notDir = !(/\\/$/.test(e))\n        var c = self.cache[e] || self.cache[makeAbs(self, e)]\n        if (notDir && c)\n          notDir = c !== 'DIR' && !Array.isArray(c)\n        return notDir\n      })\n    }\n  }\n\n  if (self.ignore.length)\n    all = all.filter(function(m) {\n      return !isIgnored(self, m)\n    })\n\n  self.found = all\n}\n\nfunction mark (self, p) {\n  var abs = makeAbs(self, p)\n  var c = self.cache[abs]\n  var m = p\n  if (c) {\n    var isDir = c === 'DIR' || Array.isArray(c)\n    var slash = p.slice(-1) === '/'\n\n    if (isDir && !slash)\n      m += '/'\n    else if (!isDir && slash)\n      m = m.slice(0, -1)\n\n    if (m !== p) {\n      var mabs = makeAbs(self, m)\n      self.statCache[mabs] = self.statCache[abs]\n      self.cache[mabs] = self.cache[abs]\n    }\n  }\n\n  return m\n}\n\n// lotta situps...\nfunction makeAbs (self, f) {\n  var abs = f\n  if (f.charAt(0) === '/') {\n    abs = path.join(self.root, f)\n  } else if (isAbsolute(f) || f === '') {\n    abs = f\n  } else if (self.changedCwd) {\n    abs = path.resolve(self.cwd, f)\n  } else {\n    abs = path.resolve(f)\n  }\n\n  if (process.platform === 'win32')\n    abs = abs.replace(/\\\\/g, '/')\n\n  return abs\n}\n\n\n// Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\nfunction isIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\nfunction childrenIgnored (self, path) {\n  if (!self.ignore.length)\n    return false\n\n  return self.ignore.some(function(item) {\n    return !!(item.gmatcher && item.gmatcher.match(path))\n  })\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/glob@7.2.3/node_modules/glob/common.js?")},2360:(module,__unused_webpack_exports,__webpack_require__)=>{eval("// Approach:\n//\n// 1. Get the minimatch set\n// 2. For each pattern in the set, PROCESS(pattern, false)\n// 3. Store matches per-set, then uniq them\n//\n// PROCESS(pattern, inGlobStar)\n// Get the first [n] items from pattern that are all strings\n// Join these together.  This is PREFIX.\n//   If there is no more remaining, then stat(PREFIX) and\n//   add to matches if it succeeds.  END.\n//\n// If inGlobStar and PREFIX is symlink and points to dir\n//   set ENTRIES = []\n// else readdir(PREFIX) as ENTRIES\n//   If fail, END\n//\n// with ENTRIES\n//   If pattern[n] is GLOBSTAR\n//     // handle the case where the globstar match is empty\n//     // by pruning it out, and testing the resulting pattern\n//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n//     // handle other cases.\n//     for ENTRY in ENTRIES (not dotfiles)\n//       // attach globstar + tail onto the entry\n//       // Mark that this entry is a globstar match\n//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n//\n//   else // not globstar\n//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n//       Test ENTRY against pattern[n]\n//       If fails, continue\n//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n//\n// Caveat:\n//   Cache all stats and readdirs results to minimize syscall.  Since all\n//   we ever care about is existence and directory-ness, we can just keep\n//   `true` for files, and [children,...] for directories, or `false` for\n//   things that don't exist.\n\nmodule.exports = glob\n\nvar rp = __webpack_require__(9831)\nvar minimatch = __webpack_require__(4710)\nvar Minimatch = minimatch.Minimatch\nvar inherits = __webpack_require__(2591)\nvar EE = (__webpack_require__(2361).EventEmitter)\nvar path = __webpack_require__(1017)\nvar assert = __webpack_require__(9491)\nvar isAbsolute = __webpack_require__(4659)\nvar globSync = __webpack_require__(7437)\nvar common = __webpack_require__(2353)\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar inflight = __webpack_require__(1592)\nvar util = __webpack_require__(3837)\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nvar once = __webpack_require__(8933)\n\nfunction glob (pattern, options, cb) {\n  if (typeof options === 'function') cb = options, options = {}\n  if (!options) options = {}\n\n  if (options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return globSync(pattern, options)\n  }\n\n  return new Glob(pattern, options, cb)\n}\n\nglob.sync = globSync\nvar GlobSync = glob.GlobSync = globSync.GlobSync\n\n// old api surface\nglob.glob = glob\n\nfunction extend (origin, add) {\n  if (add === null || typeof add !== 'object') {\n    return origin\n  }\n\n  var keys = Object.keys(add)\n  var i = keys.length\n  while (i--) {\n    origin[keys[i]] = add[keys[i]]\n  }\n  return origin\n}\n\nglob.hasMagic = function (pattern, options_) {\n  var options = extend({}, options_)\n  options.noprocess = true\n\n  var g = new Glob(pattern, options)\n  var set = g.minimatch.set\n\n  if (!pattern)\n    return false\n\n  if (set.length > 1)\n    return true\n\n  for (var j = 0; j < set[0].length; j++) {\n    if (typeof set[0][j] !== 'string')\n      return true\n  }\n\n  return false\n}\n\nglob.Glob = Glob\ninherits(Glob, EE)\nfunction Glob (pattern, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = null\n  }\n\n  if (options && options.sync) {\n    if (cb)\n      throw new TypeError('callback provided to sync glob')\n    return new GlobSync(pattern, options)\n  }\n\n  if (!(this instanceof Glob))\n    return new Glob(pattern, options, cb)\n\n  setopts(this, pattern, options)\n  this._didRealPath = false\n\n  // process each pattern in the minimatch set\n  var n = this.minimatch.set.length\n\n  // The matches are stored as {<filename>: true,...} so that\n  // duplicates are automagically pruned.\n  // Later, we do an Object.keys() on these.\n  // Keep them as a list so we can fill in when nonull is set.\n  this.matches = new Array(n)\n\n  if (typeof cb === 'function') {\n    cb = once(cb)\n    this.on('error', cb)\n    this.on('end', function (matches) {\n      cb(null, matches)\n    })\n  }\n\n  var self = this\n  this._processing = 0\n\n  this._emitQueue = []\n  this._processQueue = []\n  this.paused = false\n\n  if (this.noprocess)\n    return this\n\n  if (n === 0)\n    return done()\n\n  var sync = true\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false, done)\n  }\n  sync = false\n\n  function done () {\n    --self._processing\n    if (self._processing <= 0) {\n      if (sync) {\n        process.nextTick(function () {\n          self._finish()\n        })\n      } else {\n        self._finish()\n      }\n    }\n  }\n}\n\nGlob.prototype._finish = function () {\n  assert(this instanceof Glob)\n  if (this.aborted)\n    return\n\n  if (this.realpath && !this._didRealpath)\n    return this._realpath()\n\n  common.finish(this)\n  this.emit('end', this.found)\n}\n\nGlob.prototype._realpath = function () {\n  if (this._didRealpath)\n    return\n\n  this._didRealpath = true\n\n  var n = this.matches.length\n  if (n === 0)\n    return this._finish()\n\n  var self = this\n  for (var i = 0; i < this.matches.length; i++)\n    this._realpathSet(i, next)\n\n  function next () {\n    if (--n === 0)\n      self._finish()\n  }\n}\n\nGlob.prototype._realpathSet = function (index, cb) {\n  var matchset = this.matches[index]\n  if (!matchset)\n    return cb()\n\n  var found = Object.keys(matchset)\n  var self = this\n  var n = found.length\n\n  if (n === 0)\n    return cb()\n\n  var set = this.matches[index] = Object.create(null)\n  found.forEach(function (p, i) {\n    // If there's a problem with the stat, then it means that\n    // one or more of the links in the realpath couldn't be\n    // resolved.  just return the abs value in that case.\n    p = self._makeAbs(p)\n    rp.realpath(p, self.realpathCache, function (er, real) {\n      if (!er)\n        set[real] = true\n      else if (er.syscall === 'stat')\n        set[p] = true\n      else\n        self.emit('error', er) // srsly wtf right here\n\n      if (--n === 0) {\n        self.matches[index] = set\n        cb()\n      }\n    })\n  })\n}\n\nGlob.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlob.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\nGlob.prototype.abort = function () {\n  this.aborted = true\n  this.emit('abort')\n}\n\nGlob.prototype.pause = function () {\n  if (!this.paused) {\n    this.paused = true\n    this.emit('pause')\n  }\n}\n\nGlob.prototype.resume = function () {\n  if (this.paused) {\n    this.emit('resume')\n    this.paused = false\n    if (this._emitQueue.length) {\n      var eq = this._emitQueue.slice(0)\n      this._emitQueue.length = 0\n      for (var i = 0; i < eq.length; i ++) {\n        var e = eq[i]\n        this._emitMatch(e[0], e[1])\n      }\n    }\n    if (this._processQueue.length) {\n      var pq = this._processQueue.slice(0)\n      this._processQueue.length = 0\n      for (var i = 0; i < pq.length; i ++) {\n        var p = pq[i]\n        this._processing--\n        this._process(p[0], p[1], p[2], p[3])\n      }\n    }\n  }\n}\n\nGlob.prototype._process = function (pattern, index, inGlobStar, cb) {\n  assert(this instanceof Glob)\n  assert(typeof cb === 'function')\n\n  if (this.aborted)\n    return\n\n  this._processing++\n  if (this.paused) {\n    this._processQueue.push([pattern, index, inGlobStar, cb])\n    return\n  }\n\n  //console.error('PROCESS %d', this._processing, pattern)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // see if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index, cb)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) ||\n      isAbsolute(pattern.map(function (p) {\n        return typeof p === 'string' ? p : '[*]'\n      }).join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip _processing\n  if (childrenIgnored(this, read))\n    return cb()\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)\n}\n\nGlob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\nGlob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return cb()\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return cb()\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return cb()\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix) {\n      if (prefix !== '/')\n        e = prefix + '/' + e\n      else\n        e = prefix + e\n    }\n    this._process([e].concat(remain), index, inGlobStar, cb)\n  }\n  cb()\n}\n\nGlob.prototype._emitMatch = function (index, e) {\n  if (this.aborted)\n    return\n\n  if (isIgnored(this, e))\n    return\n\n  if (this.paused) {\n    this._emitQueue.push([index, e])\n    return\n  }\n\n  var abs = isAbsolute(e) ? e : this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute)\n    e = abs\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  var st = this.statCache[abs]\n  if (st)\n    this.emit('stat', e, st)\n\n  this.emit('match', e)\n}\n\nGlob.prototype._readdirInGlobStar = function (abs, cb) {\n  if (this.aborted)\n    return\n\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false, cb)\n\n  var lstatkey = 'lstat\\0' + abs\n  var self = this\n  var lstatcb = inflight(lstatkey, lstatcb_)\n\n  if (lstatcb)\n    self.fs.lstat(abs, lstatcb)\n\n  function lstatcb_ (er, lstat) {\n    if (er && er.code === 'ENOENT')\n      return cb()\n\n    var isSym = lstat && lstat.isSymbolicLink()\n    self.symlinks[abs] = isSym\n\n    // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n    if (!isSym && lstat && !lstat.isDirectory()) {\n      self.cache[abs] = 'FILE'\n      cb()\n    } else\n      self._readdir(abs, false, cb)\n  }\n}\n\nGlob.prototype._readdir = function (abs, inGlobStar, cb) {\n  if (this.aborted)\n    return\n\n  cb = inflight('readdir\\0'+abs+'\\0'+inGlobStar, cb)\n  if (!cb)\n    return\n\n  //console.error('RD %j %j', +inGlobStar, abs)\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs, cb)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return cb()\n\n    if (Array.isArray(c))\n      return cb(null, c)\n  }\n\n  var self = this\n  self.fs.readdir(abs, readdirCb(this, abs, cb))\n}\n\nfunction readdirCb (self, abs, cb) {\n  return function (er, entries) {\n    if (er)\n      self._readdirError(abs, er, cb)\n    else\n      self._readdirEntries(abs, entries, cb)\n  }\n}\n\nGlob.prototype._readdirEntries = function (abs, entries, cb) {\n  if (this.aborted)\n    return\n\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n  return cb(null, entries)\n}\n\nGlob.prototype._readdirError = function (f, er, cb) {\n  if (this.aborted)\n    return\n\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        this.emit('error', error)\n        this.abort()\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict) {\n        this.emit('error', er)\n        // If the error is handled, then we abort\n        // if not, we threw out of here\n        this.abort()\n      }\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n\n  return cb()\n}\n\nGlob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n  var self = this\n  this._readdir(abs, inGlobStar, function (er, entries) {\n    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)\n  })\n}\n\n\nGlob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n  //console.error('pgs2', prefix, remain[0], entries)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return cb()\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false, cb)\n\n  var isSym = this.symlinks[abs]\n  var len = entries.length\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return cb()\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true, cb)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true, cb)\n  }\n\n  cb()\n}\n\nGlob.prototype._processSimple = function (prefix, index, cb) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var self = this\n  this._stat(prefix, function (er, exists) {\n    self._processSimple2(prefix, index, er, exists, cb)\n  })\n}\nGlob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n\n  //console.error('ps2', prefix, exists)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return cb()\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n  cb()\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlob.prototype._stat = function (f, cb) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return cb()\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return cb(null, c)\n\n    if (needDir && c === 'FILE')\n      return cb()\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (stat !== undefined) {\n    if (stat === false)\n      return cb(null, stat)\n    else {\n      var type = stat.isDirectory() ? 'DIR' : 'FILE'\n      if (needDir && type === 'FILE')\n        return cb()\n      else\n        return cb(null, type, stat)\n    }\n  }\n\n  var self = this\n  var statcb = inflight('stat\\0' + abs, lstatcb_)\n  if (statcb)\n    self.fs.lstat(abs, statcb)\n\n  function lstatcb_ (er, lstat) {\n    if (lstat && lstat.isSymbolicLink()) {\n      // If it's a symlink, then treat it as the target, unless\n      // the target does not exist, then treat it as a file.\n      return self.fs.stat(abs, function (er, stat) {\n        if (er)\n          self._stat2(f, abs, null, lstat, cb)\n        else\n          self._stat2(f, abs, er, stat, cb)\n      })\n    } else {\n      self._stat2(f, abs, er, lstat, cb)\n    }\n  }\n}\n\nGlob.prototype._stat2 = function (f, abs, er, stat, cb) {\n  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n    this.statCache[abs] = false\n    return cb()\n  }\n\n  var needDir = f.slice(-1) === '/'\n  this.statCache[abs] = stat\n\n  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())\n    return cb(null, false, stat)\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return cb()\n\n  return cb(null, c, stat)\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/glob@7.2.3/node_modules/glob/glob.js?")},7437:(module,__unused_webpack_exports,__webpack_require__)=>{eval("module.exports = globSync\nglobSync.GlobSync = GlobSync\n\nvar rp = __webpack_require__(9831)\nvar minimatch = __webpack_require__(4710)\nvar Minimatch = minimatch.Minimatch\nvar Glob = (__webpack_require__(2360).Glob)\nvar util = __webpack_require__(3837)\nvar path = __webpack_require__(1017)\nvar assert = __webpack_require__(9491)\nvar isAbsolute = __webpack_require__(4659)\nvar common = __webpack_require__(2353)\nvar setopts = common.setopts\nvar ownProp = common.ownProp\nvar childrenIgnored = common.childrenIgnored\nvar isIgnored = common.isIgnored\n\nfunction globSync (pattern, options) {\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  return new GlobSync(pattern, options).found\n}\n\nfunction GlobSync (pattern, options) {\n  if (!pattern)\n    throw new Error('must provide pattern')\n\n  if (typeof options === 'function' || arguments.length === 3)\n    throw new TypeError('callback provided to sync glob\\n'+\n                        'See: https://github.com/isaacs/node-glob/issues/167')\n\n  if (!(this instanceof GlobSync))\n    return new GlobSync(pattern, options)\n\n  setopts(this, pattern, options)\n\n  if (this.noprocess)\n    return this\n\n  var n = this.minimatch.set.length\n  this.matches = new Array(n)\n  for (var i = 0; i < n; i ++) {\n    this._process(this.minimatch.set[i], i, false)\n  }\n  this._finish()\n}\n\nGlobSync.prototype._finish = function () {\n  assert.ok(this instanceof GlobSync)\n  if (this.realpath) {\n    var self = this\n    this.matches.forEach(function (matchset, index) {\n      var set = self.matches[index] = Object.create(null)\n      for (var p in matchset) {\n        try {\n          p = self._makeAbs(p)\n          var real = rp.realpathSync(p, self.realpathCache)\n          set[real] = true\n        } catch (er) {\n          if (er.syscall === 'stat')\n            set[self._makeAbs(p)] = true\n          else\n            throw er\n        }\n      }\n    })\n  }\n  common.finish(this)\n}\n\n\nGlobSync.prototype._process = function (pattern, index, inGlobStar) {\n  assert.ok(this instanceof GlobSync)\n\n  // Get the first [n] parts of pattern that are all strings.\n  var n = 0\n  while (typeof pattern[n] === 'string') {\n    n ++\n  }\n  // now n is the index of the first one that is *not* a string.\n\n  // See if there's anything else\n  var prefix\n  switch (n) {\n    // if not, then this is rather simple\n    case pattern.length:\n      this._processSimple(pattern.join('/'), index)\n      return\n\n    case 0:\n      // pattern *starts* with some non-trivial item.\n      // going to readdir(cwd), but not include the prefix in matches.\n      prefix = null\n      break\n\n    default:\n      // pattern has some string bits in the front.\n      // whatever it starts with, whether that's 'absolute' like /foo/bar,\n      // or 'relative' like '../baz'\n      prefix = pattern.slice(0, n).join('/')\n      break\n  }\n\n  var remain = pattern.slice(n)\n\n  // get the list of entries.\n  var read\n  if (prefix === null)\n    read = '.'\n  else if (isAbsolute(prefix) ||\n      isAbsolute(pattern.map(function (p) {\n        return typeof p === 'string' ? p : '[*]'\n      }).join('/'))) {\n    if (!prefix || !isAbsolute(prefix))\n      prefix = '/' + prefix\n    read = prefix\n  } else\n    read = prefix\n\n  var abs = this._makeAbs(read)\n\n  //if ignored, skip processing\n  if (childrenIgnored(this, read))\n    return\n\n  var isGlobStar = remain[0] === minimatch.GLOBSTAR\n  if (isGlobStar)\n    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)\n  else\n    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)\n}\n\n\nGlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n  var entries = this._readdir(abs, inGlobStar)\n\n  // if the abs isn't a dir, then nothing can match!\n  if (!entries)\n    return\n\n  // It will only match dot entries if it starts with a dot, or if\n  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n  var pn = remain[0]\n  var negate = !!this.minimatch.negate\n  var rawGlob = pn._glob\n  var dotOk = this.dot || rawGlob.charAt(0) === '.'\n\n  var matchedEntries = []\n  for (var i = 0; i < entries.length; i++) {\n    var e = entries[i]\n    if (e.charAt(0) !== '.' || dotOk) {\n      var m\n      if (negate && !prefix) {\n        m = !e.match(pn)\n      } else {\n        m = e.match(pn)\n      }\n      if (m)\n        matchedEntries.push(e)\n    }\n  }\n\n  var len = matchedEntries.length\n  // If there are no matched entries, then nothing matches.\n  if (len === 0)\n    return\n\n  // if this is the last remaining pattern bit, then no need for\n  // an additional stat *unless* the user has specified mark or\n  // stat explicitly.  We know they exist, since readdir returned\n  // them.\n\n  if (remain.length === 1 && !this.mark && !this.stat) {\n    if (!this.matches[index])\n      this.matches[index] = Object.create(null)\n\n    for (var i = 0; i < len; i ++) {\n      var e = matchedEntries[i]\n      if (prefix) {\n        if (prefix.slice(-1) !== '/')\n          e = prefix + '/' + e\n        else\n          e = prefix + e\n      }\n\n      if (e.charAt(0) === '/' && !this.nomount) {\n        e = path.join(this.root, e)\n      }\n      this._emitMatch(index, e)\n    }\n    // This was the last one, and no stats were needed\n    return\n  }\n\n  // now test all matched entries as stand-ins for that part\n  // of the pattern.\n  remain.shift()\n  for (var i = 0; i < len; i ++) {\n    var e = matchedEntries[i]\n    var newPattern\n    if (prefix)\n      newPattern = [prefix, e]\n    else\n      newPattern = [e]\n    this._process(newPattern.concat(remain), index, inGlobStar)\n  }\n}\n\n\nGlobSync.prototype._emitMatch = function (index, e) {\n  if (isIgnored(this, e))\n    return\n\n  var abs = this._makeAbs(e)\n\n  if (this.mark)\n    e = this._mark(e)\n\n  if (this.absolute) {\n    e = abs\n  }\n\n  if (this.matches[index][e])\n    return\n\n  if (this.nodir) {\n    var c = this.cache[abs]\n    if (c === 'DIR' || Array.isArray(c))\n      return\n  }\n\n  this.matches[index][e] = true\n\n  if (this.stat)\n    this._stat(e)\n}\n\n\nGlobSync.prototype._readdirInGlobStar = function (abs) {\n  // follow all symlinked directories forever\n  // just proceed as if this is a non-globstar situation\n  if (this.follow)\n    return this._readdir(abs, false)\n\n  var entries\n  var lstat\n  var stat\n  try {\n    lstat = this.fs.lstatSync(abs)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      // lstat failed, doesn't exist\n      return null\n    }\n  }\n\n  var isSym = lstat && lstat.isSymbolicLink()\n  this.symlinks[abs] = isSym\n\n  // If it's not a symlink or a dir, then it's definitely a regular file.\n  // don't bother doing a readdir in that case.\n  if (!isSym && lstat && !lstat.isDirectory())\n    this.cache[abs] = 'FILE'\n  else\n    entries = this._readdir(abs, false)\n\n  return entries\n}\n\nGlobSync.prototype._readdir = function (abs, inGlobStar) {\n  var entries\n\n  if (inGlobStar && !ownProp(this.symlinks, abs))\n    return this._readdirInGlobStar(abs)\n\n  if (ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n    if (!c || c === 'FILE')\n      return null\n\n    if (Array.isArray(c))\n      return c\n  }\n\n  try {\n    return this._readdirEntries(abs, this.fs.readdirSync(abs))\n  } catch (er) {\n    this._readdirError(abs, er)\n    return null\n  }\n}\n\nGlobSync.prototype._readdirEntries = function (abs, entries) {\n  // if we haven't asked to stat everything, then just\n  // assume that everything in there exists, so we can avoid\n  // having to stat it a second time.\n  if (!this.mark && !this.stat) {\n    for (var i = 0; i < entries.length; i ++) {\n      var e = entries[i]\n      if (abs === '/')\n        e = abs + e\n      else\n        e = abs + '/' + e\n      this.cache[e] = true\n    }\n  }\n\n  this.cache[abs] = entries\n\n  // mark and cache dir-ness\n  return entries\n}\n\nGlobSync.prototype._readdirError = function (f, er) {\n  // handle errors, and cache the information\n  switch (er.code) {\n    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n    case 'ENOTDIR': // totally normal. means it *does* exist.\n      var abs = this._makeAbs(f)\n      this.cache[abs] = 'FILE'\n      if (abs === this.cwdAbs) {\n        var error = new Error(er.code + ' invalid cwd ' + this.cwd)\n        error.path = this.cwd\n        error.code = er.code\n        throw error\n      }\n      break\n\n    case 'ENOENT': // not terribly unusual\n    case 'ELOOP':\n    case 'ENAMETOOLONG':\n    case 'UNKNOWN':\n      this.cache[this._makeAbs(f)] = false\n      break\n\n    default: // some unusual error.  Treat as failure.\n      this.cache[this._makeAbs(f)] = false\n      if (this.strict)\n        throw er\n      if (!this.silent)\n        console.error('glob error', er)\n      break\n  }\n}\n\nGlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n\n  var entries = this._readdir(abs, inGlobStar)\n\n  // no entries means not a dir, so it can never have matches\n  // foo.txt/** doesn't match foo.txt\n  if (!entries)\n    return\n\n  // test without the globstar, and with every child both below\n  // and replacing the globstar.\n  var remainWithoutGlobStar = remain.slice(1)\n  var gspref = prefix ? [ prefix ] : []\n  var noGlobStar = gspref.concat(remainWithoutGlobStar)\n\n  // the noGlobStar pattern exits the inGlobStar state\n  this._process(noGlobStar, index, false)\n\n  var len = entries.length\n  var isSym = this.symlinks[abs]\n\n  // If it's a symlink, and we're in a globstar, then stop\n  if (isSym && inGlobStar)\n    return\n\n  for (var i = 0; i < len; i++) {\n    var e = entries[i]\n    if (e.charAt(0) === '.' && !this.dot)\n      continue\n\n    // these two cases enter the inGlobStar state\n    var instead = gspref.concat(entries[i], remainWithoutGlobStar)\n    this._process(instead, index, true)\n\n    var below = gspref.concat(entries[i], remain)\n    this._process(below, index, true)\n  }\n}\n\nGlobSync.prototype._processSimple = function (prefix, index) {\n  // XXX review this.  Shouldn't it be doing the mounting etc\n  // before doing stat?  kinda weird?\n  var exists = this._stat(prefix)\n\n  if (!this.matches[index])\n    this.matches[index] = Object.create(null)\n\n  // If it doesn't exist, then just mark the lack of results\n  if (!exists)\n    return\n\n  if (prefix && isAbsolute(prefix) && !this.nomount) {\n    var trail = /[\\/\\\\]$/.test(prefix)\n    if (prefix.charAt(0) === '/') {\n      prefix = path.join(this.root, prefix)\n    } else {\n      prefix = path.resolve(this.root, prefix)\n      if (trail)\n        prefix += '/'\n    }\n  }\n\n  if (process.platform === 'win32')\n    prefix = prefix.replace(/\\\\/g, '/')\n\n  // Mark this as a match\n  this._emitMatch(index, prefix)\n}\n\n// Returns either 'DIR', 'FILE', or false\nGlobSync.prototype._stat = function (f) {\n  var abs = this._makeAbs(f)\n  var needDir = f.slice(-1) === '/'\n\n  if (f.length > this.maxLength)\n    return false\n\n  if (!this.stat && ownProp(this.cache, abs)) {\n    var c = this.cache[abs]\n\n    if (Array.isArray(c))\n      c = 'DIR'\n\n    // It exists, but maybe not how we need it\n    if (!needDir || c === 'DIR')\n      return c\n\n    if (needDir && c === 'FILE')\n      return false\n\n    // otherwise we have to stat, because maybe c=true\n    // if we know it exists, but not what it is.\n  }\n\n  var exists\n  var stat = this.statCache[abs]\n  if (!stat) {\n    var lstat\n    try {\n      lstat = this.fs.lstatSync(abs)\n    } catch (er) {\n      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n        this.statCache[abs] = false\n        return false\n      }\n    }\n\n    if (lstat && lstat.isSymbolicLink()) {\n      try {\n        stat = this.fs.statSync(abs)\n      } catch (er) {\n        stat = lstat\n      }\n    } else {\n      stat = lstat\n    }\n  }\n\n  this.statCache[abs] = stat\n\n  var c = true\n  if (stat)\n    c = stat.isDirectory() ? 'DIR' : 'FILE'\n\n  this.cache[abs] = this.cache[abs] || c\n\n  if (needDir && c === 'FILE')\n    return false\n\n  return c\n}\n\nGlobSync.prototype._mark = function (p) {\n  return common.mark(this, p)\n}\n\nGlobSync.prototype._makeAbs = function (f) {\n  return common.makeAbs(this, f)\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/glob@7.2.3/node_modules/glob/sync.js?")},1592:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var wrappy = __webpack_require__(6379)\nvar reqs = Object.create(null)\nvar once = __webpack_require__(8933)\n\nmodule.exports = wrappy(inflight)\n\nfunction inflight (key, cb) {\n  if (reqs[key]) {\n    reqs[key].push(cb)\n    return null\n  } else {\n    reqs[key] = [cb]\n    return makeres(key)\n  }\n}\n\nfunction makeres (key) {\n  return once(function RES () {\n    var cbs = reqs[key]\n    var len = cbs.length\n    var args = slice(arguments)\n\n    // XXX It's somewhat ambiguous whether a new callback added in this\n    // pass should be queued for later execution if something in the\n    // list of callbacks throws, or if it should just be discarded.\n    // However, it's such an edge case that it hardly matters, and either\n    // choice is likely as surprising as the other.\n    // As it happens, we do go ahead and schedule it for later execution.\n    try {\n      for (var i = 0; i < len; i++) {\n        cbs[i].apply(null, args)\n      }\n    } finally {\n      if (cbs.length > len) {\n        // added more in the interim.\n        // de-zalgo, just in case, but don't call again.\n        cbs.splice(0, len)\n        process.nextTick(function () {\n          RES.apply(null, args)\n        })\n      } else {\n        delete reqs[key]\n      }\n    }\n  })\n}\n\nfunction slice (args) {\n  var length = args.length\n  var array = []\n\n  for (var i = 0; i < length; i++) array[i] = args[i]\n  return array\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js?")},2591:(module,__unused_webpack_exports,__webpack_require__)=>{eval("try {\n  var util = __webpack_require__(3837);\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = __webpack_require__(9118);\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js?")},9118:module=>{eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js?")},322:module=>{"use strict";eval("\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js?")},1888:function(module,exports,__webpack_require__){eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.21';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function',\n      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading whitespace. */\n  var reTrimStart = /^\\s+/;\n\n  /** Used to match a single whitespace character. */\n  var reWhitespace = /\\s/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /**\n   * Used to validate the `validate` option in `_.template` variable.\n   *\n   * Forbids characters which could potentially change the meaning of the function argument definition:\n   * - \"(),\" (modification of function parameters)\n   * - \"=\" (default value)\n   * - \"[]{}\" (destructuring of function parameters)\n   * - \"/\" (beginning of a comment)\n   * - whitespace\n   */\n  var reForbiddenIdentifierChars = /[()=,{}\\[\\]\\/\\s]/;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports =  true && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && \"object\" == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.trim`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function baseTrim(string) {\n    return string\n      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n      : string;\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedEndIndex(string) {\n    var index = string.length;\n\n    while (index-- && reWhitespace.test(string.charAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject(srcValue)) {\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      if (iteratees.length) {\n        iteratees = arrayMap(iteratees, function(iteratee) {\n          if (isArray(iteratee)) {\n            return function(value) {\n              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n          }\n          return iteratee;\n        });\n      } else {\n        iteratees = [identity];\n      }\n\n      var index = -1;\n      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n          return object;\n        }\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      var low = 0,\n          high = array == null ? 0 : array.length;\n      if (high === 0) {\n        return 0;\n      }\n\n      value = iteratee(value);\n      var valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision && nativeIsFinite(number)) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Check that cyclic values are equal.\n      var arrStacked = stack.get(array);\n      var othStacked = stack.get(other);\n      if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Check that cyclic values are equal.\n      var objStacked = stack.get(object);\n      var othStacked = stack.get(other);\n      if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n      }\n\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     *\n     * // Combining several predicates using `_.overEvery` or `_.overSome`.\n     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n     * // => objects for ['fred', 'barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 30 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = baseTrim(value);\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('dj vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      // The sourceURL gets injected into the source that's eval-ed, so be careful\n      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in\n      // and escape the comment, thus injecting code that gets evaled.\n      var sourceURL = '//# sourceURL=' +\n        (hasOwnProperty.call(options, 'sourceURL')\n          ? (options.sourceURL + '').replace(/\\s/g, ' ')\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = hasOwnProperty.call(options, 'variable') && options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Throw an error if a forbidden character was found in `variable`, to prevent\n      // potential command injection attacks.\n      else if (reForbiddenIdentifierChars.test(variable)) {\n        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);\n      }\n\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return baseTrim(string);\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.slice(0, trimmedEndIndex(string) + 1);\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     *\n     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])\n     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name + '';\n        if (!hasOwnProperty.call(realNames, key)) {\n          realNames[key] = [];\n        }\n        realNames[key].push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (true) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return _;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else {}\n}.call(this));\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js?")},4710:(module,__unused_webpack_exports,__webpack_require__)=>{eval("module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = (function () { try { return __webpack_require__(1017) } catch (e) {}}()) || {\n  sep: '/'\n}\nminimatch.sep = path.sep\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = __webpack_require__(3054)\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  b = b || {}\n  var t = {}\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n  m.Minimatch.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options)).Minimatch\n  }\n\n  m.filter = function filter (pattern, options) {\n    return orig.filter(pattern, ext(def, options))\n  }\n\n  m.defaults = function defaults (options) {\n    return orig.defaults(ext(def, options))\n  }\n\n  m.makeRe = function makeRe (pattern, options) {\n    return orig.makeRe(pattern, ext(def, options))\n  }\n\n  m.braceExpand = function braceExpand (pattern, options) {\n    return orig.braceExpand(pattern, ext(def, options))\n  }\n\n  m.match = function (list, pattern, options) {\n    return orig.match(list, pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  assertValidPattern(pattern)\n\n  if (!options) options = {}\n\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (!options.allowWindowsEscape && path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n  this.partial = !!options.partial\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --\x3e regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\nvar MAX_PATTERN_LENGTH = 1024 * 64\nvar assertValidPattern = function (pattern) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  assertValidPattern(pattern)\n\n  var options = this.options\n\n  // shortcuts\n  if (pattern === '**') {\n    if (!options.noglobstar)\n      return GLOBSTAR\n    else\n      pattern = '*'\n  }\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      /* istanbul ignore next */\n      case '/': {\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n      }\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        // split where the last [ was, make sure we don't have\n        // an invalid re. if so, re-walk the contents of the\n        // would-be class to re-translate any characters that\n        // were passed through as-is\n        // TODO: It would probably be faster to determine this\n        // without a try/catch and a new RegExp, but it's tricky\n        // to do safely.  For now, this is safe and works.\n        var cs = pattern.substring(classStart + 1, i)\n        try {\n          RegExp('[' + cs + ']')\n        } catch (er) {\n          // not a valid class!\n          var sp = this.parse(cs, SUBPARSE)\n          re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n          hasMagic = hasMagic || sp[1]\n          inClass = false\n          continue\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '[': case '.': case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) /* istanbul ignore next - should be impossible */ {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) /* istanbul ignore next - should be impossible */ {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = function match (f, partial) {\n  if (typeof partial === 'undefined') partial = this.partial\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    /* istanbul ignore if */\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      /* istanbul ignore if */\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      hit = f === p\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else /* istanbul ignore else */ if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    return (fi === fl - 1) && (file[fi] === '')\n  }\n\n  // should be unreachable.\n  /* istanbul ignore next */\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/minimatch@3.1.2/node_modules/minimatch/minimatch.js?")},8933:(module,__unused_webpack_exports,__webpack_require__)=>{eval("var wrappy = __webpack_require__(6379)\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js?")},4659:module=>{"use strict";eval("\n\nfunction posix(path) {\n\treturn path.charAt(0) === '/';\n}\n\nfunction win32(path) {\n\t// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n\tvar splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\tvar result = splitDeviceRe.exec(path);\n\tvar device = result[1] || '';\n\tvar isUnc = Boolean(device && device.charAt(1) !== ':');\n\n\t// UNC paths are always absolute\n\treturn Boolean(result[2] || isUnc);\n}\n\nmodule.exports = process.platform === 'win32' ? win32 : posix;\nmodule.exports.posix = posix;\nmodule.exports.win32 = win32;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/path-is-absolute@1.0.1/node_modules/path-is-absolute/index.js?")},543:function(module,exports){eval('"use strict";\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\n\n// node_modules/core-js/internals/global.js\nvar require_global = __commonJS({\n  "node_modules/core-js/internals/global.js"(exports2, module2) {\n    var check = function(it) {\n      return it && it.Math == Math && it;\n    };\n    module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global == "object" && global) || function() {\n      return this;\n    }() || Function("return this")();\n  }\n});\n\n// node_modules/core-js/internals/fails.js\nvar require_fails = __commonJS({\n  "node_modules/core-js/internals/fails.js"(exports2, module2) {\n    module2.exports = function(exec) {\n      try {\n        return !!exec();\n      } catch (error) {\n        return true;\n      }\n    };\n  }\n});\n\n// node_modules/core-js/internals/descriptors.js\nvar require_descriptors = __commonJS({\n  "node_modules/core-js/internals/descriptors.js"(exports2, module2) {\n    var fails = require_fails();\n    module2.exports = !fails(function() {\n      return Object.defineProperty({}, 1, { get: function() {\n        return 7;\n      } })[1] != 7;\n    });\n  }\n});\n\n// node_modules/core-js/internals/function-bind-native.js\nvar require_function_bind_native = __commonJS({\n  "node_modules/core-js/internals/function-bind-native.js"(exports2, module2) {\n    var fails = require_fails();\n    module2.exports = !fails(function() {\n      var test = function() {\n      }.bind();\n      return typeof test != "function" || test.hasOwnProperty("prototype");\n    });\n  }\n});\n\n// node_modules/core-js/internals/function-call.js\nvar require_function_call = __commonJS({\n  "node_modules/core-js/internals/function-call.js"(exports2, module2) {\n    var NATIVE_BIND = require_function_bind_native();\n    var call = Function.prototype.call;\n    module2.exports = NATIVE_BIND ? call.bind(call) : function() {\n      return call.apply(call, arguments);\n    };\n  }\n});\n\n// node_modules/core-js/internals/object-property-is-enumerable.js\nvar require_object_property_is_enumerable = __commonJS({\n  "node_modules/core-js/internals/object-property-is-enumerable.js"(exports2) {\n    "use strict";\n    var $propertyIsEnumerable = {}.propertyIsEnumerable;\n    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n    exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n      var descriptor = getOwnPropertyDescriptor(this, V);\n      return !!descriptor && descriptor.enumerable;\n    } : $propertyIsEnumerable;\n  }\n});\n\n// node_modules/core-js/internals/create-property-descriptor.js\nvar require_create_property_descriptor = __commonJS({\n  "node_modules/core-js/internals/create-property-descriptor.js"(exports2, module2) {\n    module2.exports = function(bitmap, value) {\n      return {\n        enumerable: !(bitmap & 1),\n        configurable: !(bitmap & 2),\n        writable: !(bitmap & 4),\n        value\n      };\n    };\n  }\n});\n\n// node_modules/core-js/internals/function-uncurry-this.js\nvar require_function_uncurry_this = __commonJS({\n  "node_modules/core-js/internals/function-uncurry-this.js"(exports2, module2) {\n    var NATIVE_BIND = require_function_bind_native();\n    var FunctionPrototype = Function.prototype;\n    var call = FunctionPrototype.call;\n    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);\n    module2.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {\n      return function() {\n        return call.apply(fn, arguments);\n      };\n    };\n  }\n});\n\n// node_modules/core-js/internals/classof-raw.js\nvar require_classof_raw = __commonJS({\n  "node_modules/core-js/internals/classof-raw.js"(exports2, module2) {\n    var uncurryThis = require_function_uncurry_this();\n    var toString = uncurryThis({}.toString);\n    var stringSlice = uncurryThis("".slice);\n    module2.exports = function(it) {\n      return stringSlice(toString(it), 8, -1);\n    };\n  }\n});\n\n// node_modules/core-js/internals/indexed-object.js\nvar require_indexed_object = __commonJS({\n  "node_modules/core-js/internals/indexed-object.js"(exports2, module2) {\n    var uncurryThis = require_function_uncurry_this();\n    var fails = require_fails();\n    var classof = require_classof_raw();\n    var $Object = Object;\n    var split = uncurryThis("".split);\n    module2.exports = fails(function() {\n      return !$Object("z").propertyIsEnumerable(0);\n    }) ? function(it) {\n      return classof(it) == "String" ? split(it, "") : $Object(it);\n    } : $Object;\n  }\n});\n\n// node_modules/core-js/internals/is-null-or-undefined.js\nvar require_is_null_or_undefined = __commonJS({\n  "node_modules/core-js/internals/is-null-or-undefined.js"(exports2, module2) {\n    module2.exports = function(it) {\n      return it === null || it === void 0;\n    };\n  }\n});\n\n// node_modules/core-js/internals/require-object-coercible.js\nvar require_require_object_coercible = __commonJS({\n  "node_modules/core-js/internals/require-object-coercible.js"(exports2, module2) {\n    var isNullOrUndefined = require_is_null_or_undefined();\n    var $TypeError = TypeError;\n    module2.exports = function(it) {\n      if (isNullOrUndefined(it))\n        throw $TypeError("Can\'t call method on " + it);\n      return it;\n    };\n  }\n});\n\n// node_modules/core-js/internals/to-indexed-object.js\nvar require_to_indexed_object = __commonJS({\n  "node_modules/core-js/internals/to-indexed-object.js"(exports2, module2) {\n    var IndexedObject = require_indexed_object();\n    var requireObjectCoercible = require_require_object_coercible();\n    module2.exports = function(it) {\n      return IndexedObject(requireObjectCoercible(it));\n    };\n  }\n});\n\n// node_modules/core-js/internals/document-all.js\nvar require_document_all = __commonJS({\n  "node_modules/core-js/internals/document-all.js"(exports2, module2) {\n    var documentAll = typeof document == "object" && document.all;\n    var IS_HTMLDDA = typeof documentAll == "undefined" && documentAll !== void 0;\n    module2.exports = {\n      all: documentAll,\n      IS_HTMLDDA\n    };\n  }\n});\n\n// node_modules/core-js/internals/is-callable.js\nvar require_is_callable = __commonJS({\n  "node_modules/core-js/internals/is-callable.js"(exports2, module2) {\n    var $documentAll = require_document_all();\n    var documentAll = $documentAll.all;\n    module2.exports = $documentAll.IS_HTMLDDA ? function(argument) {\n      return typeof argument == "function" || argument === documentAll;\n    } : function(argument) {\n      return typeof argument == "function";\n    };\n  }\n});\n\n// node_modules/core-js/internals/is-object.js\nvar require_is_object = __commonJS({\n  "node_modules/core-js/internals/is-object.js"(exports2, module2) {\n    var isCallable = require_is_callable();\n    var $documentAll = require_document_all();\n    var documentAll = $documentAll.all;\n    module2.exports = $documentAll.IS_HTMLDDA ? function(it) {\n      return typeof it == "object" ? it !== null : isCallable(it) || it === documentAll;\n    } : function(it) {\n      return typeof it == "object" ? it !== null : isCallable(it);\n    };\n  }\n});\n\n// node_modules/core-js/internals/get-built-in.js\nvar require_get_built_in = __commonJS({\n  "node_modules/core-js/internals/get-built-in.js"(exports2, module2) {\n    var global2 = require_global();\n    var isCallable = require_is_callable();\n    var aFunction = function(argument) {\n      return isCallable(argument) ? argument : void 0;\n    };\n    module2.exports = function(namespace, method) {\n      return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];\n    };\n  }\n});\n\n// node_modules/core-js/internals/object-is-prototype-of.js\nvar require_object_is_prototype_of = __commonJS({\n  "node_modules/core-js/internals/object-is-prototype-of.js"(exports2, module2) {\n    var uncurryThis = require_function_uncurry_this();\n    module2.exports = uncurryThis({}.isPrototypeOf);\n  }\n});\n\n// node_modules/core-js/internals/engine-user-agent.js\nvar require_engine_user_agent = __commonJS({\n  "node_modules/core-js/internals/engine-user-agent.js"(exports2, module2) {\n    var getBuiltIn = require_get_built_in();\n    module2.exports = getBuiltIn("navigator", "userAgent") || "";\n  }\n});\n\n// node_modules/core-js/internals/engine-v8-version.js\nvar require_engine_v8_version = __commonJS({\n  "node_modules/core-js/internals/engine-v8-version.js"(exports2, module2) {\n    var global2 = require_global();\n    var userAgent = require_engine_user_agent();\n    var process2 = global2.process;\n    var Deno = global2.Deno;\n    var versions = process2 && process2.versions || Deno && Deno.version;\n    var v8 = versions && versions.v8;\n    var match;\n    var version2;\n    if (v8) {\n      match = v8.split(".");\n      version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n    }\n    if (!version2 && userAgent) {\n      match = userAgent.match(/Edge\\/(\\d+)/);\n      if (!match || match[1] >= 74) {\n        match = userAgent.match(/Chrome\\/(\\d+)/);\n        if (match)\n          version2 = +match[1];\n      }\n    }\n    module2.exports = version2;\n  }\n});\n\n// node_modules/core-js/internals/symbol-constructor-detection.js\nvar require_symbol_constructor_detection = __commonJS({\n  "node_modules/core-js/internals/symbol-constructor-detection.js"(exports2, module2) {\n    var V8_VERSION = require_engine_v8_version();\n    var fails = require_fails();\n    module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {\n      var symbol = Symbol();\n      return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n    });\n  }\n});\n\n// node_modules/core-js/internals/use-symbol-as-uid.js\nvar require_use_symbol_as_uid = __commonJS({\n  "node_modules/core-js/internals/use-symbol-as-uid.js"(exports2, module2) {\n    var NATIVE_SYMBOL = require_symbol_constructor_detection();\n    module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";\n  }\n});\n\n// node_modules/core-js/internals/is-symbol.js\nvar require_is_symbol = __commonJS({\n  "node_modules/core-js/internals/is-symbol.js"(exports2, module2) {\n    var getBuiltIn = require_get_built_in();\n    var isCallable = require_is_callable();\n    var isPrototypeOf = require_object_is_prototype_of();\n    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();\n    var $Object = Object;\n    module2.exports = USE_SYMBOL_AS_UID ? function(it) {\n      return typeof it == "symbol";\n    } : function(it) {\n      var $Symbol = getBuiltIn("Symbol");\n      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n    };\n  }\n});\n\n// node_modules/core-js/internals/try-to-string.js\nvar require_try_to_string = __commonJS({\n  "node_modules/core-js/internals/try-to-string.js"(exports2, module2) {\n    var $String = String;\n    module2.exports = function(argument) {\n      try {\n        return $String(argument);\n      } catch (error) {\n        return "Object";\n      }\n    };\n  }\n});\n\n// node_modules/core-js/internals/a-callable.js\nvar require_a_callable = __commonJS({\n  "node_modules/core-js/internals/a-callable.js"(exports2, module2) {\n    var isCallable = require_is_callable();\n    var tryToString = require_try_to_string();\n    var $TypeError = TypeError;\n    module2.exports = function(argument) {\n      if (isCallable(argument))\n        return argument;\n      throw $TypeError(tryToString(argument) + " is not a function");\n    };\n  }\n});\n\n// node_modules/core-js/internals/get-method.js\nvar require_get_method = __commonJS({\n  "node_modules/core-js/internals/get-method.js"(exports2, module2) {\n    var aCallable = require_a_callable();\n    var isNullOrUndefined = require_is_null_or_undefined();\n    module2.exports = function(V, P) {\n      var func = V[P];\n      return isNullOrUndefined(func) ? void 0 : aCallable(func);\n    };\n  }\n});\n\n// node_modules/core-js/internals/ordinary-to-primitive.js\nvar require_ordinary_to_primitive = __commonJS({\n  "node_modules/core-js/internals/ordinary-to-primitive.js"(exports2, module2) {\n    var call = require_function_call();\n    var isCallable = require_is_callable();\n    var isObject = require_is_object();\n    var $TypeError = TypeError;\n    module2.exports = function(input, pref) {\n      var fn, val;\n      if (pref === "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))\n        return val;\n      if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))\n        return val;\n      if (pref !== "string" && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))\n        return val;\n      throw $TypeError("Can\'t convert object to primitive value");\n    };\n  }\n});\n\n// node_modules/core-js/internals/is-pure.js\nvar require_is_pure = __commonJS({\n  "node_modules/core-js/internals/is-pure.js"(exports2, module2) {\n    module2.exports = false;\n  }\n});\n\n// node_modules/core-js/internals/define-global-property.js\nvar require_define_global_property = __commonJS({\n  "node_modules/core-js/internals/define-global-property.js"(exports2, module2) {\n    var global2 = require_global();\n    var defineProperty = Object.defineProperty;\n    module2.exports = function(key, value) {\n      try {\n        defineProperty(global2, key, { value, configurable: true, writable: true });\n      } catch (error) {\n        global2[key] = value;\n      }\n      return value;\n    };\n  }\n});\n\n// node_modules/core-js/internals/shared-store.js\nvar require_shared_store = __commonJS({\n  "node_modules/core-js/internals/shared-store.js"(exports2, module2) {\n    var global2 = require_global();\n    var defineGlobalProperty = require_define_global_property();\n    var SHARED = "__core-js_shared__";\n    var store = global2[SHARED] || defineGlobalProperty(SHARED, {});\n    module2.exports = store;\n  }\n});\n\n// node_modules/core-js/internals/shared.js\nvar require_shared = __commonJS({\n  "node_modules/core-js/internals/shared.js"(exports2, module2) {\n    var IS_PURE = require_is_pure();\n    var store = require_shared_store();\n    (module2.exports = function(key, value) {\n      return store[key] || (store[key] = value !== void 0 ? value : {});\n    })("versions", []).push({\n      version: "3.26.1",\n      mode: IS_PURE ? "pure" : "global",\n      copyright: "\\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",\n      license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE",\n      source: "https://github.com/zloirock/core-js"\n    });\n  }\n});\n\n// node_modules/core-js/internals/to-object.js\nvar require_to_object = __commonJS({\n  "node_modules/core-js/internals/to-object.js"(exports2, module2) {\n    var requireObjectCoercible = require_require_object_coercible();\n    var $Object = Object;\n    module2.exports = function(argument) {\n      return $Object(requireObjectCoercible(argument));\n    };\n  }\n});\n\n// node_modules/core-js/internals/has-own-property.js\nvar require_has_own_property = __commonJS({\n  "node_modules/core-js/internals/has-own-property.js"(exports2, module2) {\n    var uncurryThis = require_function_uncurry_this();\n    var toObject = require_to_object();\n    var hasOwnProperty = uncurryThis({}.hasOwnProperty);\n    module2.exports = Object.hasOwn || function hasOwn(it, key) {\n      return hasOwnProperty(toObject(it), key);\n    };\n  }\n});\n\n// node_modules/core-js/internals/uid.js\nvar require_uid = __commonJS({\n  "node_modules/core-js/internals/uid.js"(exports2, module2) {\n    var uncurryThis = require_function_uncurry_this();\n    var id = 0;\n    var postfix = Math.random();\n    var toString = uncurryThis(1 .toString);\n    module2.exports = function(key) {\n      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);\n    };\n  }\n});\n\n// node_modules/core-js/internals/well-known-symbol.js\nvar require_well_known_symbol = __commonJS({\n  "node_modules/core-js/internals/well-known-symbol.js"(exports2, module2) {\n    var global2 = require_global();\n    var shared = require_shared();\n    var hasOwn = require_has_own_property();\n    var uid = require_uid();\n    var NATIVE_SYMBOL = require_symbol_constructor_detection();\n    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();\n    var WellKnownSymbolsStore = shared("wks");\n    var Symbol2 = global2.Symbol;\n    var symbolFor = Symbol2 && Symbol2["for"];\n    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;\n    module2.exports = function(name) {\n      if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {\n        var description = "Symbol." + name;\n        if (NATIVE_SYMBOL && hasOwn(Symbol2, name)) {\n          WellKnownSymbolsStore[name] = Symbol2[name];\n        } else if (USE_SYMBOL_AS_UID && symbolFor) {\n          WellKnownSymbolsStore[name] = symbolFor(description);\n        } else {\n          WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n        }\n      }\n      return WellKnownSymbolsStore[name];\n    };\n  }\n});\n\n// node_modules/core-js/internals/to-primitive.js\nvar require_to_primitive = __commonJS({\n  "node_modules/core-js/internals/to-primitive.js"(exports2, module2) {\n    var call = require_function_call();\n    var isObject = require_is_object();\n    var isSymbol = require_is_symbol();\n    var getMethod = require_get_method();\n    var ordinaryToPrimitive = require_ordinary_to_primitive();\n    var wellKnownSymbol = require_well_known_symbol();\n    var $TypeError = TypeError;\n    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");\n    module2.exports = function(input, pref) {\n      if (!isObject(input) || isSymbol(input))\n        return input;\n      var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n      var result;\n      if (exoticToPrim) {\n        if (pref === void 0)\n          pref = "default";\n        result = call(exoticToPrim, input, pref);\n        if (!isObject(result) || isSymbol(result))\n          return result;\n        throw $TypeError("Can\'t convert object to primitive value");\n      }\n      if (pref === void 0)\n        pref = "number";\n      return ordinaryToPrimitive(input, pref);\n    };\n  }\n});\n\n// node_modules/core-js/internals/to-property-key.js\nvar require_to_property_key = __commonJS({\n  "node_modules/core-js/internals/to-property-key.js"(exports2, module2) {\n    var toPrimitive = require_to_primitive();\n    var isSymbol = require_is_symbol();\n    module2.exports = function(argument) {\n      var key = toPrimitive(argument, "string");\n      return isSymbol(key) ? key : key + "";\n    };\n  }\n});\n\n// node_modules/core-js/internals/document-create-element.js\nvar require_document_create_element = __commonJS({\n  "node_modules/core-js/internals/document-create-element.js"(exports2, module2) {\n    var global2 = require_global();\n    var isObject = require_is_object();\n    var document2 = global2.document;\n    var EXISTS = isObject(document2) && isObject(document2.createElement);\n    module2.exports = function(it) {\n      return EXISTS ? document2.createElement(it) : {};\n    };\n  }\n});\n\n// node_modules/core-js/internals/ie8-dom-define.js\nvar require_ie8_dom_define = __commonJS({\n  "node_modules/core-js/internals/ie8-dom-define.js"(exports2, module2) {\n    var DESCRIPTORS = require_descriptors();\n    var fails = require_fails();\n    var createElement = require_document_create_element();\n    module2.exports = !DESCRIPTORS && !fails(function() {\n      return Object.defineProperty(createElement("div"), "a", {\n        get: function() {\n          return 7;\n        }\n      }).a != 7;\n    });\n  }\n});\n\n// node_modules/core-js/internals/object-get-own-property-descriptor.js\nvar require_object_get_own_property_descriptor = __commonJS({\n  "node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports2) {\n    var DESCRIPTORS = require_descriptors();\n    var call = require_function_call();\n    var propertyIsEnumerableModule = require_object_property_is_enumerable();\n    var createPropertyDescriptor = require_create_property_descriptor();\n    var toIndexedObject = require_to_indexed_object();\n    var toPropertyKey = require_to_property_key();\n    var hasOwn = require_has_own_property();\n    var IE8_DOM_DEFINE = require_ie8_dom_define();\n    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n      O = toIndexedObject(O);\n      P = toPropertyKey(P);\n      if (IE8_DOM_DEFINE)\n        try {\n          return $getOwnPropertyDescriptor(O, P);\n        } catch (error) {\n        }\n      if (hasOwn(O, P))\n        return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n    };\n  }\n});\n\n// node_modules/core-js/internals/v8-prototype-define-bug.js\nvar require_v8_prototype_define_bug = __commonJS({\n  "node_modules/core-js/internals/v8-prototype-define-bug.js"(exports2, module2) {\n    var DESCRIPTORS = require_descriptors();\n    var fails = require_fails();\n    module2.exports = DESCRIPTORS && fails(function() {\n      return Object.defineProperty(function() {\n      }, "prototype", {\n        value: 42,\n        writable: false\n      }).prototype != 42;\n    });\n  }\n});\n\n// node_modules/core-js/internals/an-object.js\nvar require_an_object = __commonJS({\n  "node_modules/core-js/internals/an-object.js"(exports2, module2) {\n    var isObject = require_is_object();\n    var $String = String;\n    var $TypeError = TypeError;\n    module2.exports = function(argument) {\n      if (isObject(argument))\n        return argument;\n      throw $TypeError($String(argument) + " is not an object");\n    };\n  }\n});\n\n// node_modules/core-js/internals/object-define-property.js\nvar require_object_define_property = __commonJS({\n  "node_modules/core-js/internals/object-define-property.js"(exports2) {\n    var DESCRIPTORS = require_descriptors();\n    var IE8_DOM_DEFINE = require_ie8_dom_define();\n    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();\n    var anObject = require_an_object();\n    var toPropertyKey = require_to_property_key();\n    var $TypeError = TypeError;\n    var $defineProperty = Object.defineProperty;\n    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n    var ENUMERABLE = "enumerable";\n    var CONFIGURABLE = "configurable";\n    var WRITABLE = "writable";\n    exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n      anObject(O);\n      P = toPropertyKey(P);\n      anObject(Attributes);\n      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n        var current = $getOwnPropertyDescriptor(O, P);\n        if (current && current[WRITABLE]) {\n          O[P] = Attributes.value;\n          Attributes = {\n            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n            writable: false\n          };\n        }\n      }\n      return $defineProperty(O, P, Attributes);\n    } : $defineProperty : function defineProperty(O, P, Attributes) {\n      anObject(O);\n      P = toPropertyKey(P);\n      anObject(Attributes);\n      if (IE8_DOM_DEFINE)\n        try {\n          return $defineProperty(O, P, Attributes);\n        } catch (error) {\n        }\n      if ("get" in Attributes || "set" in Attributes)\n        throw $TypeError("Accessors not supported");\n      if ("value" in Attributes)\n        O[P] = Attributes.value;\n      return O;\n    };\n  }\n});\n\n// node_modules/core-js/internals/create-non-enumerable-property.js\nvar require_create_non_enumerable_property = __commonJS({\n  "node_modules/core-js/internals/create-non-enumerable-property.js"(exports2, module2) {\n    var DESCRIPTORS = require_descriptors();\n    var definePropertyModule = require_object_define_property();\n    var createPropertyDescriptor = require_create_property_descriptor();\n    module2.exports = DESCRIPTORS ? function(object, key, value) {\n      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n    } : function(object, key, value) {\n      object[key] = value;\n      return object;\n    };\n  }\n});\n\n// node_modules/core-js/internals/function-name.js\nvar require_function_name = __commonJS({\n  "node_modules/core-js/internals/function-name.js"(exports2, module2) {\n    var DESCRIPTORS = require_descriptors();\n    var hasOwn = require_has_own_property();\n    var FunctionPrototype = Function.prototype;\n    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n    var EXISTS = hasOwn(FunctionPrototype, "name");\n    var PROPER = EXISTS && function something() {\n    }.name === "something";\n    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);\n    module2.exports = {\n      EXISTS,\n      PROPER,\n      CONFIGURABLE\n    };\n  }\n});\n\n// node_modules/core-js/internals/inspect-source.js\nvar require_inspect_source = __commonJS({\n  "node_modules/core-js/internals/inspect-source.js"(exports2, module2) {\n    var uncurryThis = require_function_uncurry_this();\n    var isCallable = require_is_callable();\n    var store = require_shared_store();\n    var functionToString = uncurryThis(Function.toString);\n    if (!isCallable(store.inspectSource)) {\n      store.inspectSource = function(it) {\n        return functionToString(it);\n      };\n    }\n    module2.exports = store.inspectSource;\n  }\n});\n\n// node_modules/core-js/internals/weak-map-basic-detection.js\nvar require_weak_map_basic_detection = __commonJS({\n  "node_modules/core-js/internals/weak-map-basic-detection.js"(exports2, module2) {\n    var global2 = require_global();\n    var isCallable = require_is_callable();\n    var WeakMap2 = global2.WeakMap;\n    module2.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));\n  }\n});\n\n// node_modules/core-js/internals/shared-key.js\nvar require_shared_key = __commonJS({\n  "node_modules/core-js/internals/shared-key.js"(exports2, module2) {\n    var shared = require_shared();\n    var uid = require_uid();\n    var keys = shared("keys");\n    module2.exports = function(key) {\n      return keys[key] || (keys[key] = uid(key));\n    };\n  }\n});\n\n// node_modules/core-js/internals/hidden-keys.js\nvar require_hidden_keys = __commonJS({\n  "node_modules/core-js/internals/hidden-keys.js"(exports2, module2) {\n    module2.exports = {};\n  }\n});\n\n// node_modules/core-js/internals/internal-state.js\nvar require_internal_state = __commonJS({\n  "node_modules/core-js/internals/internal-state.js"(exports2, module2) {\n    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();\n    var global2 = require_global();\n    var isObject = require_is_object();\n    var createNonEnumerableProperty = require_create_non_enumerable_property();\n    var hasOwn = require_has_own_property();\n    var shared = require_shared_store();\n    var sharedKey = require_shared_key();\n    var hiddenKeys = require_hidden_keys();\n    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";\n    var TypeError2 = global2.TypeError;\n    var WeakMap2 = global2.WeakMap;\n    var set;\n    var get;\n    var has;\n    var enforce = function(it) {\n      return has(it) ? get(it) : set(it, {});\n    };\n    var getterFor = function(TYPE) {\n      return function(it) {\n        var state;\n        if (!isObject(it) || (state = get(it)).type !== TYPE) {\n          throw TypeError2("Incompatible receiver, " + TYPE + " required");\n        }\n        return state;\n      };\n    };\n    if (NATIVE_WEAK_MAP || shared.state) {\n      store = shared.state || (shared.state = new WeakMap2());\n      store.get = store.get;\n      store.has = store.has;\n      store.set = store.set;\n      set = function(it, metadata) {\n        if (store.has(it))\n          throw TypeError2(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n        store.set(it, metadata);\n        return metadata;\n      };\n      get = function(it) {\n        return store.get(it) || {};\n      };\n      has = function(it) {\n        return store.has(it);\n      };\n    } else {\n      STATE = sharedKey("state");\n      hiddenKeys[STATE] = true;\n      set = function(it, metadata) {\n        if (hasOwn(it, STATE))\n          throw TypeError2(OBJECT_ALREADY_INITIALIZED);\n        metadata.facade = it;\n        createNonEnumerableProperty(it, STATE, metadata);\n        return metadata;\n      };\n      get = function(it) {\n        return hasOwn(it, STATE) ? it[STATE] : {};\n      };\n      has = function(it) {\n        return hasOwn(it, STATE);\n      };\n    }\n    var store;\n    var STATE;\n    module2.exports = {\n      set,\n      get,\n      has,\n      enforce,\n      getterFor\n    };\n  }\n});\n\n// node_modules/core-js/internals/make-built-in.js\nvar require_make_built_in = __commonJS({\n  "node_modules/core-js/internals/make-built-in.js"(exports2, module2) {\n    var fails = require_fails();\n    var isCallable = require_is_callable();\n    var hasOwn = require_has_own_property();\n    var DESCRIPTORS = require_descriptors();\n    var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;\n    var inspectSource = require_inspect_source();\n    var InternalStateModule = require_internal_state();\n    var enforceInternalState = InternalStateModule.enforce;\n    var getInternalState = InternalStateModule.get;\n    var defineProperty = Object.defineProperty;\n    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {\n      return defineProperty(function() {\n      }, "length", { value: 8 }).length !== 8;\n    });\n    var TEMPLATE = String(String).split("String");\n    var makeBuiltIn = module2.exports = function(value, name, options) {\n      if (String(name).slice(0, 7) === "Symbol(") {\n        name = "[" + String(name).replace(/^Symbol\\(([^)]*)\\)/, "$1") + "]";\n      }\n      if (options && options.getter)\n        name = "get " + name;\n      if (options && options.setter)\n        name = "set " + name;\n      if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {\n        if (DESCRIPTORS)\n          defineProperty(value, "name", { value: name, configurable: true });\n        else\n          value.name = name;\n      }\n      if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {\n        defineProperty(value, "length", { value: options.arity });\n      }\n      try {\n        if (options && hasOwn(options, "constructor") && options.constructor) {\n          if (DESCRIPTORS)\n            defineProperty(value, "prototype", { writable: false });\n        } else if (value.prototype)\n          value.prototype = void 0;\n      } catch (error) {\n      }\n      var state = enforceInternalState(value);\n      if (!hasOwn(state, "source")) {\n        state.source = TEMPLATE.join(typeof name == "string" ? name : "");\n      }\n      return value;\n    };\n    Function.prototype.toString = makeBuiltIn(function toString() {\n      return isCallable(this) && getInternalState(this).source || inspectSource(this);\n    }, "toString");\n  }\n});\n\n// node_modules/core-js/internals/define-built-in.js\nvar require_define_built_in = __commonJS({\n  "node_modules/core-js/internals/define-built-in.js"(exports2, module2) {\n    var isCallable = require_is_callable();\n    var definePropertyModule = require_object_define_property();\n    var makeBuiltIn = require_make_built_in();\n    var defineGlobalProperty = require_define_global_property();\n    module2.exports = function(O, key, value, options) {\n      if (!options)\n        options = {};\n      var simple = options.enumerable;\n      var name = options.name !== void 0 ? options.name : key;\n      if (isCallable(value))\n        makeBuiltIn(value, name, options);\n      if (options.global) {\n        if (simple)\n          O[key] = value;\n        else\n          defineGlobalProperty(key, value);\n      } else {\n        try {\n          if (!options.unsafe)\n            delete O[key];\n          else if (O[key])\n            simple = true;\n        } catch (error) {\n        }\n        if (simple)\n          O[key] = value;\n        else\n          definePropertyModule.f(O, key, {\n            value,\n            enumerable: false,\n            configurable: !options.nonConfigurable,\n            writable: !options.nonWritable\n          });\n      }\n      return O;\n    };\n  }\n});\n\n// node_modules/core-js/internals/math-trunc.js\nvar require_math_trunc = __commonJS({\n  "node_modules/core-js/internals/math-trunc.js"(exports2, module2) {\n    var ceil = Math.ceil;\n    var floor = Math.floor;\n    module2.exports = Math.trunc || function trunc(x) {\n      var n = +x;\n      return (n > 0 ? floor : ceil)(n);\n    };\n  }\n});\n\n// node_modules/core-js/internals/to-integer-or-infinity.js\nvar require_to_integer_or_infinity = __commonJS({\n  "node_modules/core-js/internals/to-integer-or-infinity.js"(exports2, module2) {\n    var trunc = require_math_trunc();\n    module2.exports = function(argument) {\n      var number = +argument;\n      return number !== number || number === 0 ? 0 : trunc(number);\n    };\n  }\n});\n\n// node_modules/core-js/internals/to-absolute-index.js\nvar require_to_absolute_index = __commonJS({\n  "node_modules/core-js/internals/to-absolute-index.js"(exports2, module2) {\n    var toIntegerOrInfinity = require_to_integer_or_infinity();\n    var max = Math.max;\n    var min = Math.min;\n    module2.exports = function(index, length) {\n      var integer = toIntegerOrInfinity(index);\n      return integer < 0 ? max(integer + length, 0) : min(integer, length);\n    };\n  }\n});\n\n// node_modules/core-js/internals/to-length.js\nvar require_to_length = __commonJS({\n  "node_modules/core-js/internals/to-length.js"(exports2, module2) {\n    var toIntegerOrInfinity = require_to_integer_or_infinity();\n    var min = Math.min;\n    module2.exports = function(argument) {\n      return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;\n    };\n  }\n});\n\n// node_modules/core-js/internals/length-of-array-like.js\nvar require_length_of_array_like = __commonJS({\n  "node_modules/core-js/internals/length-of-array-like.js"(exports2, module2) {\n    var toLength = require_to_length();\n    module2.exports = function(obj) {\n      return toLength(obj.length);\n    };\n  }\n});\n\n// node_modules/core-js/internals/array-includes.js\nvar require_array_includes = __commonJS({\n  "node_modules/core-js/internals/array-includes.js"(exports2, module2) {\n    var toIndexedObject = require_to_indexed_object();\n    var toAbsoluteIndex = require_to_absolute_index();\n    var lengthOfArrayLike = require_length_of_array_like();\n    var createMethod = function(IS_INCLUDES) {\n      return function($this, el, fromIndex) {\n        var O = toIndexedObject($this);\n        var length = lengthOfArrayLike(O);\n        var index = toAbsoluteIndex(fromIndex, length);\n        var value;\n        if (IS_INCLUDES && el != el)\n          while (length > index) {\n            value = O[index++];\n            if (value != value)\n              return true;\n          }\n        else\n          for (; length > index; index++) {\n            if ((IS_INCLUDES || index in O) && O[index] === el)\n              return IS_INCLUDES || index || 0;\n          }\n        return !IS_INCLUDES && -1;\n      };\n    };\n    module2.exports = {\n      includes: createMethod(true),\n      indexOf: createMethod(false)\n    };\n  }\n});\n\n// node_modules/core-js/internals/object-keys-internal.js\nvar require_object_keys_internal = __commonJS({\n  "node_modules/core-js/internals/object-keys-internal.js"(exports2, module2) {\n    var uncurryThis = require_function_uncurry_this();\n    var hasOwn = require_has_own_property();\n    var toIndexedObject = require_to_indexed_object();\n    var indexOf = require_array_includes().indexOf;\n    var hiddenKeys = require_hidden_keys();\n    var push = uncurryThis([].push);\n    module2.exports = function(object, names) {\n      var O = toIndexedObject(object);\n      var i = 0;\n      var result = [];\n      var key;\n      for (key in O)\n        !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n      while (names.length > i)\n        if (hasOwn(O, key = names[i++])) {\n          ~indexOf(result, key) || push(result, key);\n        }\n      return result;\n    };\n  }\n});\n\n// node_modules/core-js/internals/enum-bug-keys.js\nvar require_enum_bug_keys = __commonJS({\n  "node_modules/core-js/internals/enum-bug-keys.js"(exports2, module2) {\n    module2.exports = [\n      "constructor",\n      "hasOwnProperty",\n      "isPrototypeOf",\n      "propertyIsEnumerable",\n      "toLocaleString",\n      "toString",\n      "valueOf"\n    ];\n  }\n});\n\n// node_modules/core-js/internals/object-get-own-property-names.js\nvar require_object_get_own_property_names = __commonJS({\n  "node_modules/core-js/internals/object-get-own-property-names.js"(exports2) {\n    var internalObjectKeys = require_object_keys_internal();\n    var enumBugKeys = require_enum_bug_keys();\n    var hiddenKeys = enumBugKeys.concat("length", "prototype");\n    exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n      return internalObjectKeys(O, hiddenKeys);\n    };\n  }\n});\n\n// node_modules/core-js/internals/object-get-own-property-symbols.js\nvar require_object_get_own_property_symbols = __commonJS({\n  "node_modules/core-js/internals/object-get-own-property-symbols.js"(exports2) {\n    exports2.f = Object.getOwnPropertySymbols;\n  }\n});\n\n// node_modules/core-js/internals/own-keys.js\nvar require_own_keys = __commonJS({\n  "node_modules/core-js/internals/own-keys.js"(exports2, module2) {\n    var getBuiltIn = require_get_built_in();\n    var uncurryThis = require_function_uncurry_this();\n    var getOwnPropertyNamesModule = require_object_get_own_property_names();\n    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();\n    var anObject = require_an_object();\n    var concat = uncurryThis([].concat);\n    module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {\n      var keys = getOwnPropertyNamesModule.f(anObject(it));\n      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n      return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n    };\n  }\n});\n\n// node_modules/core-js/internals/copy-constructor-properties.js\nvar require_copy_constructor_properties = __commonJS({\n  "node_modules/core-js/internals/copy-constructor-properties.js"(exports2, module2) {\n    var hasOwn = require_has_own_property();\n    var ownKeys = require_own_keys();\n    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();\n    var definePropertyModule = require_object_define_property();\n    module2.exports = function(target, source, exceptions) {\n      var keys = ownKeys(source);\n      var defineProperty = definePropertyModule.f;\n      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n          defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n        }\n      }\n    };\n  }\n});\n\n// node_modules/core-js/internals/is-forced.js\nvar require_is_forced = __commonJS({\n  "node_modules/core-js/internals/is-forced.js"(exports2, module2) {\n    var fails = require_fails();\n    var isCallable = require_is_callable();\n    var replacement = /#|\\.prototype\\./;\n    var isForced = function(feature, detection) {\n      var value = data[normalize(feature)];\n      return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;\n    };\n    var normalize = isForced.normalize = function(string) {\n      return String(string).replace(replacement, ".").toLowerCase();\n    };\n    var data = isForced.data = {};\n    var NATIVE = isForced.NATIVE = "N";\n    var POLYFILL = isForced.POLYFILL = "P";\n    module2.exports = isForced;\n  }\n});\n\n// node_modules/core-js/internals/export.js\nvar require_export = __commonJS({\n  "node_modules/core-js/internals/export.js"(exports2, module2) {\n    var global2 = require_global();\n    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;\n    var createNonEnumerableProperty = require_create_non_enumerable_property();\n    var defineBuiltIn = require_define_built_in();\n    var defineGlobalProperty = require_define_global_property();\n    var copyConstructorProperties = require_copy_constructor_properties();\n    var isForced = require_is_forced();\n    module2.exports = function(options, source) {\n      var TARGET = options.target;\n      var GLOBAL = options.global;\n      var STATIC = options.stat;\n      var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n      if (GLOBAL) {\n        target = global2;\n      } else if (STATIC) {\n        target = global2[TARGET] || defineGlobalProperty(TARGET, {});\n      } else {\n        target = (global2[TARGET] || {}).prototype;\n      }\n      if (target)\n        for (key in source) {\n          sourceProperty = source[key];\n          if (options.dontCallGetSet) {\n            descriptor = getOwnPropertyDescriptor(target, key);\n            targetProperty = descriptor && descriptor.value;\n          } else\n            targetProperty = target[key];\n          FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);\n          if (!FORCED && targetProperty !== void 0) {\n            if (typeof sourceProperty == typeof targetProperty)\n              continue;\n            copyConstructorProperties(sourceProperty, targetProperty);\n          }\n          if (options.sham || targetProperty && targetProperty.sham) {\n            createNonEnumerableProperty(sourceProperty, "sham", true);\n          }\n          defineBuiltIn(target, key, sourceProperty, options);\n        }\n    };\n  }\n});\n\n// node_modules/core-js/internals/is-array.js\nvar require_is_array = __commonJS({\n  "node_modules/core-js/internals/is-array.js"(exports2, module2) {\n    var classof = require_classof_raw();\n    module2.exports = Array.isArray || function isArray(argument) {\n      return classof(argument) == "Array";\n    };\n  }\n});\n\n// node_modules/core-js/internals/does-not-exceed-safe-integer.js\nvar require_does_not_exceed_safe_integer = __commonJS({\n  "node_modules/core-js/internals/does-not-exceed-safe-integer.js"(exports2, module2) {\n    var $TypeError = TypeError;\n    var MAX_SAFE_INTEGER = 9007199254740991;\n    module2.exports = function(it) {\n      if (it > MAX_SAFE_INTEGER)\n        throw $TypeError("Maximum allowed index exceeded");\n      return it;\n    };\n  }\n});\n\n// node_modules/core-js/internals/function-uncurry-this-clause.js\nvar require_function_uncurry_this_clause = __commonJS({\n  "node_modules/core-js/internals/function-uncurry-this-clause.js"(exports2, module2) {\n    var classofRaw = require_classof_raw();\n    var uncurryThis = require_function_uncurry_this();\n    module2.exports = function(fn) {\n      if (classofRaw(fn) === "Function")\n        return uncurryThis(fn);\n    };\n  }\n});\n\n// node_modules/core-js/internals/function-bind-context.js\nvar require_function_bind_context = __commonJS({\n  "node_modules/core-js/internals/function-bind-context.js"(exports2, module2) {\n    var uncurryThis = require_function_uncurry_this_clause();\n    var aCallable = require_a_callable();\n    var NATIVE_BIND = require_function_bind_native();\n    var bind = uncurryThis(uncurryThis.bind);\n    module2.exports = function(fn, that) {\n      aCallable(fn);\n      return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {\n        return fn.apply(that, arguments);\n      };\n    };\n  }\n});\n\n// node_modules/core-js/internals/flatten-into-array.js\nvar require_flatten_into_array = __commonJS({\n  "node_modules/core-js/internals/flatten-into-array.js"(exports2, module2) {\n    "use strict";\n    var isArray = require_is_array();\n    var lengthOfArrayLike = require_length_of_array_like();\n    var doesNotExceedSafeInteger = require_does_not_exceed_safe_integer();\n    var bind = require_function_bind_context();\n    var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {\n      var targetIndex = start;\n      var sourceIndex = 0;\n      var mapFn = mapper ? bind(mapper, thisArg) : false;\n      var element, elementLen;\n      while (sourceIndex < sourceLen) {\n        if (sourceIndex in source) {\n          element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];\n          if (depth > 0 && isArray(element)) {\n            elementLen = lengthOfArrayLike(element);\n            targetIndex = flattenIntoArray(target, original, element, elementLen, targetIndex, depth - 1) - 1;\n          } else {\n            doesNotExceedSafeInteger(targetIndex + 1);\n            target[targetIndex] = element;\n          }\n          targetIndex++;\n        }\n        sourceIndex++;\n      }\n      return targetIndex;\n    };\n    module2.exports = flattenIntoArray;\n  }\n});\n\n// node_modules/core-js/internals/to-string-tag-support.js\nvar require_to_string_tag_support = __commonJS({\n  "node_modules/core-js/internals/to-string-tag-support.js"(exports2, module2) {\n    var wellKnownSymbol = require_well_known_symbol();\n    var TO_STRING_TAG = wellKnownSymbol("toStringTag");\n    var test = {};\n    test[TO_STRING_TAG] = "z";\n    module2.exports = String(test) === "[object z]";\n  }\n});\n\n// node_modules/core-js/internals/classof.js\nvar require_classof = __commonJS({\n  "node_modules/core-js/internals/classof.js"(exports2, module2) {\n    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();\n    var isCallable = require_is_callable();\n    var classofRaw = require_classof_raw();\n    var wellKnownSymbol = require_well_known_symbol();\n    var TO_STRING_TAG = wellKnownSymbol("toStringTag");\n    var $Object = Object;\n    var CORRECT_ARGUMENTS = classofRaw(function() {\n      return arguments;\n    }()) == "Arguments";\n    var tryGet = function(it, key) {\n      try {\n        return it[key];\n      } catch (error) {\n      }\n    };\n    module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n      var O, tag, result;\n      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;\n    };\n  }\n});\n\n// node_modules/core-js/internals/is-constructor.js\nvar require_is_constructor = __commonJS({\n  "node_modules/core-js/internals/is-constructor.js"(exports2, module2) {\n    var uncurryThis = require_function_uncurry_this();\n    var fails = require_fails();\n    var isCallable = require_is_callable();\n    var classof = require_classof();\n    var getBuiltIn = require_get_built_in();\n    var inspectSource = require_inspect_source();\n    var noop = function() {\n    };\n    var empty = [];\n    var construct = getBuiltIn("Reflect", "construct");\n    var constructorRegExp = /^\\s*(?:class|function)\\b/;\n    var exec = uncurryThis(constructorRegExp.exec);\n    var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n    var isConstructorModern = function isConstructor(argument) {\n      if (!isCallable(argument))\n        return false;\n      try {\n        construct(noop, empty, argument);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    };\n    var isConstructorLegacy = function isConstructor(argument) {\n      if (!isCallable(argument))\n        return false;\n      switch (classof(argument)) {\n        case "AsyncFunction":\n        case "GeneratorFunction":\n        case "AsyncGeneratorFunction":\n          return false;\n      }\n      try {\n        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));\n      } catch (error) {\n        return true;\n      }\n    };\n    isConstructorLegacy.sham = true;\n    module2.exports = !construct || fails(function() {\n      var called;\n      return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {\n        called = true;\n      }) || called;\n    }) ? isConstructorLegacy : isConstructorModern;\n  }\n});\n\n// node_modules/core-js/internals/array-species-constructor.js\nvar require_array_species_constructor = __commonJS({\n  "node_modules/core-js/internals/array-species-constructor.js"(exports2, module2) {\n    var isArray = require_is_array();\n    var isConstructor = require_is_constructor();\n    var isObject = require_is_object();\n    var wellKnownSymbol = require_well_known_symbol();\n    var SPECIES = wellKnownSymbol("species");\n    var $Array = Array;\n    module2.exports = function(originalArray) {\n      var C;\n      if (isArray(originalArray)) {\n        C = originalArray.constructor;\n        if (isConstructor(C) && (C === $Array || isArray(C.prototype)))\n          C = void 0;\n        else if (isObject(C)) {\n          C = C[SPECIES];\n          if (C === null)\n            C = void 0;\n        }\n      }\n      return C === void 0 ? $Array : C;\n    };\n  }\n});\n\n// node_modules/core-js/internals/array-species-create.js\nvar require_array_species_create = __commonJS({\n  "node_modules/core-js/internals/array-species-create.js"(exports2, module2) {\n    var arraySpeciesConstructor = require_array_species_constructor();\n    module2.exports = function(originalArray, length) {\n      return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n    };\n  }\n});\n\n// node_modules/core-js/modules/es.array.flat-map.js\nvar require_es_array_flat_map = __commonJS({\n  "node_modules/core-js/modules/es.array.flat-map.js"() {\n    "use strict";\n    var $ = require_export();\n    var flattenIntoArray = require_flatten_into_array();\n    var aCallable = require_a_callable();\n    var toObject = require_to_object();\n    var lengthOfArrayLike = require_length_of_array_like();\n    var arraySpeciesCreate = require_array_species_create();\n    $({ target: "Array", proto: true }, {\n      flatMap: function flatMap(callbackfn) {\n        var O = toObject(this);\n        var sourceLen = lengthOfArrayLike(O);\n        var A;\n        aCallable(callbackfn);\n        A = arraySpeciesCreate(O, 0);\n        A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);\n        return A;\n      }\n    });\n  }\n});\n\n// node_modules/core-js/internals/iterators.js\nvar require_iterators = __commonJS({\n  "node_modules/core-js/internals/iterators.js"(exports2, module2) {\n    module2.exports = {};\n  }\n});\n\n// node_modules/core-js/internals/is-array-iterator-method.js\nvar require_is_array_iterator_method = __commonJS({\n  "node_modules/core-js/internals/is-array-iterator-method.js"(exports2, module2) {\n    var wellKnownSymbol = require_well_known_symbol();\n    var Iterators = require_iterators();\n    var ITERATOR = wellKnownSymbol("iterator");\n    var ArrayPrototype = Array.prototype;\n    module2.exports = function(it) {\n      return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n    };\n  }\n});\n\n// node_modules/core-js/internals/get-iterator-method.js\nvar require_get_iterator_method = __commonJS({\n  "node_modules/core-js/internals/get-iterator-method.js"(exports2, module2) {\n    var classof = require_classof();\n    var getMethod = require_get_method();\n    var isNullOrUndefined = require_is_null_or_undefined();\n    var Iterators = require_iterators();\n    var wellKnownSymbol = require_well_known_symbol();\n    var ITERATOR = wellKnownSymbol("iterator");\n    module2.exports = function(it) {\n      if (!isNullOrUndefined(it))\n        return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];\n    };\n  }\n});\n\n// node_modules/core-js/internals/get-iterator.js\nvar require_get_iterator = __commonJS({\n  "node_modules/core-js/internals/get-iterator.js"(exports2, module2) {\n    var call = require_function_call();\n    var aCallable = require_a_callable();\n    var anObject = require_an_object();\n    var tryToString = require_try_to_string();\n    var getIteratorMethod = require_get_iterator_method();\n    var $TypeError = TypeError;\n    module2.exports = function(argument, usingIterator) {\n      var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;\n      if (aCallable(iteratorMethod))\n        return anObject(call(iteratorMethod, argument));\n      throw $TypeError(tryToString(argument) + " is not iterable");\n    };\n  }\n});\n\n// node_modules/core-js/internals/iterator-close.js\nvar require_iterator_close = __commonJS({\n  "node_modules/core-js/internals/iterator-close.js"(exports2, module2) {\n    var call = require_function_call();\n    var anObject = require_an_object();\n    var getMethod = require_get_method();\n    module2.exports = function(iterator, kind, value) {\n      var innerResult, innerError;\n      anObject(iterator);\n      try {\n        innerResult = getMethod(iterator, "return");\n        if (!innerResult) {\n          if (kind === "throw")\n            throw value;\n          return value;\n        }\n        innerResult = call(innerResult, iterator);\n      } catch (error) {\n        innerError = true;\n        innerResult = error;\n      }\n      if (kind === "throw")\n        throw value;\n      if (innerError)\n        throw innerResult;\n      anObject(innerResult);\n      return value;\n    };\n  }\n});\n\n// node_modules/core-js/internals/iterate.js\nvar require_iterate = __commonJS({\n  "node_modules/core-js/internals/iterate.js"(exports2, module2) {\n    var bind = require_function_bind_context();\n    var call = require_function_call();\n    var anObject = require_an_object();\n    var tryToString = require_try_to_string();\n    var isArrayIteratorMethod = require_is_array_iterator_method();\n    var lengthOfArrayLike = require_length_of_array_like();\n    var isPrototypeOf = require_object_is_prototype_of();\n    var getIterator = require_get_iterator();\n    var getIteratorMethod = require_get_iterator_method();\n    var iteratorClose = require_iterator_close();\n    var $TypeError = TypeError;\n    var Result = function(stopped, result) {\n      this.stopped = stopped;\n      this.result = result;\n    };\n    var ResultPrototype = Result.prototype;\n    module2.exports = function(iterable, unboundFunction, options) {\n      var that = options && options.that;\n      var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n      var IS_RECORD = !!(options && options.IS_RECORD);\n      var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n      var INTERRUPTED = !!(options && options.INTERRUPTED);\n      var fn = bind(unboundFunction, that);\n      var iterator, iterFn, index, length, result, next, step;\n      var stop = function(condition) {\n        if (iterator)\n          iteratorClose(iterator, "normal", condition);\n        return new Result(true, condition);\n      };\n      var callFn = function(value) {\n        if (AS_ENTRIES) {\n          anObject(value);\n          return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n        }\n        return INTERRUPTED ? fn(value, stop) : fn(value);\n      };\n      if (IS_RECORD) {\n        iterator = iterable.iterator;\n      } else if (IS_ITERATOR) {\n        iterator = iterable;\n      } else {\n        iterFn = getIteratorMethod(iterable);\n        if (!iterFn)\n          throw $TypeError(tryToString(iterable) + " is not iterable");\n        if (isArrayIteratorMethod(iterFn)) {\n          for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {\n            result = callFn(iterable[index]);\n            if (result && isPrototypeOf(ResultPrototype, result))\n              return result;\n          }\n          return new Result(false);\n        }\n        iterator = getIterator(iterable, iterFn);\n      }\n      next = IS_RECORD ? iterable.next : iterator.next;\n      while (!(step = call(next, iterator)).done) {\n        try {\n          result = callFn(step.value);\n        } catch (error) {\n          iteratorClose(iterator, "throw", error);\n        }\n        if (typeof result == "object" && result && isPrototypeOf(ResultPrototype, result))\n          return result;\n      }\n      return new Result(false);\n    };\n  }\n});\n\n// node_modules/core-js/internals/create-property.js\nvar require_create_property = __commonJS({\n  "node_modules/core-js/internals/create-property.js"(exports2, module2) {\n    "use strict";\n    var toPropertyKey = require_to_property_key();\n    var definePropertyModule = require_object_define_property();\n    var createPropertyDescriptor = require_create_property_descriptor();\n    module2.exports = function(object, key, value) {\n      var propertyKey = toPropertyKey(key);\n      if (propertyKey in object)\n        definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n      else\n        object[propertyKey] = value;\n    };\n  }\n});\n\n// node_modules/core-js/modules/es.object.from-entries.js\nvar require_es_object_from_entries = __commonJS({\n  "node_modules/core-js/modules/es.object.from-entries.js"() {\n    var $ = require_export();\n    var iterate = require_iterate();\n    var createProperty = require_create_property();\n    $({ target: "Object", stat: true }, {\n      fromEntries: function fromEntries(iterable) {\n        var obj = {};\n        iterate(iterable, function(k, v) {\n          createProperty(obj, k, v);\n        }, { AS_ENTRIES: true });\n        return obj;\n      }\n    });\n  }\n});\n\n// node_modules/core-js/internals/define-built-in-accessor.js\nvar require_define_built_in_accessor = __commonJS({\n  "node_modules/core-js/internals/define-built-in-accessor.js"(exports2, module2) {\n    var makeBuiltIn = require_make_built_in();\n    var defineProperty = require_object_define_property();\n    module2.exports = function(target, name, descriptor) {\n      if (descriptor.get)\n        makeBuiltIn(descriptor.get, name, { getter: true });\n      if (descriptor.set)\n        makeBuiltIn(descriptor.set, name, { setter: true });\n      return defineProperty.f(target, name, descriptor);\n    };\n  }\n});\n\n// node_modules/core-js/internals/regexp-flags.js\nvar require_regexp_flags = __commonJS({\n  "node_modules/core-js/internals/regexp-flags.js"(exports2, module2) {\n    "use strict";\n    var anObject = require_an_object();\n    module2.exports = function() {\n      var that = anObject(this);\n      var result = "";\n      if (that.hasIndices)\n        result += "d";\n      if (that.global)\n        result += "g";\n      if (that.ignoreCase)\n        result += "i";\n      if (that.multiline)\n        result += "m";\n      if (that.dotAll)\n        result += "s";\n      if (that.unicode)\n        result += "u";\n      if (that.unicodeSets)\n        result += "v";\n      if (that.sticky)\n        result += "y";\n      return result;\n    };\n  }\n});\n\n// node_modules/core-js/modules/es.regexp.flags.js\nvar require_es_regexp_flags = __commonJS({\n  "node_modules/core-js/modules/es.regexp.flags.js"() {\n    var global2 = require_global();\n    var DESCRIPTORS = require_descriptors();\n    var defineBuiltInAccessor = require_define_built_in_accessor();\n    var regExpFlags = require_regexp_flags();\n    var fails = require_fails();\n    var RegExp2 = global2.RegExp;\n    var RegExpPrototype = RegExp2.prototype;\n    var FORCED = DESCRIPTORS && fails(function() {\n      var INDICES_SUPPORT = true;\n      try {\n        RegExp2(".", "d");\n      } catch (error) {\n        INDICES_SUPPORT = false;\n      }\n      var O = {};\n      var calls = "";\n      var expected = INDICES_SUPPORT ? "dgimsy" : "gimsy";\n      var addGetter = function(key2, chr) {\n        Object.defineProperty(O, key2, { get: function() {\n          calls += chr;\n          return true;\n        } });\n      };\n      var pairs = {\n        dotAll: "s",\n        global: "g",\n        ignoreCase: "i",\n        multiline: "m",\n        sticky: "y"\n      };\n      if (INDICES_SUPPORT)\n        pairs.hasIndices = "d";\n      for (var key in pairs)\n        addGetter(key, pairs[key]);\n      var result = Object.getOwnPropertyDescriptor(RegExpPrototype, "flags").get.call(O);\n      return result !== expected || calls !== expected;\n    });\n    if (FORCED)\n      defineBuiltInAccessor(RegExpPrototype, "flags", {\n        configurable: true,\n        get: regExpFlags\n      });\n  }\n});\n\n// node_modules/core-js/modules/es.array.flat.js\nvar require_es_array_flat = __commonJS({\n  "node_modules/core-js/modules/es.array.flat.js"() {\n    "use strict";\n    var $ = require_export();\n    var flattenIntoArray = require_flatten_into_array();\n    var toObject = require_to_object();\n    var lengthOfArrayLike = require_length_of_array_like();\n    var toIntegerOrInfinity = require_to_integer_or_infinity();\n    var arraySpeciesCreate = require_array_species_create();\n    $({ target: "Array", proto: true }, {\n      flat: function flat() {\n        var depthArg = arguments.length ? arguments[0] : void 0;\n        var O = toObject(this);\n        var sourceLen = lengthOfArrayLike(O);\n        var A = arraySpeciesCreate(O, 0);\n        A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === void 0 ? 1 : toIntegerOrInfinity(depthArg));\n        return A;\n      }\n    });\n  }\n});\n\n// dist/_index.js.cjs.js\nvar _excluded = ["cliName", "cliCategory", "cliDescription"];\nvar _excluded2 = ["_"];\nvar _excluded3 = ["overrides"];\nvar _excluded4 = ["languageId"];\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null)\n    return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0)\n        continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key))\n        continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null)\n    return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0)\n      continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nrequire_es_array_flat_map();\nrequire_es_object_from_entries();\nrequire_es_regexp_flags();\nrequire_es_array_flat();\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames2 = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS2 = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = {\n    exports: {}\n  }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames2(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, {\n          get: () => from[key],\n          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", {\n  value: true\n}), mod);\nvar require_base = __commonJS2({\n  "node_modules/diff/lib/diff/base.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2["default"] = Diff;\n    function Diff() {\n    }\n    Diff.prototype = {\n      diff: function diff(oldString, newString) {\n        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        var callback = options.callback;\n        if (typeof options === "function") {\n          callback = options;\n          options = {};\n        }\n        this.options = options;\n        var self2 = this;\n        function done(value) {\n          if (callback) {\n            setTimeout(function() {\n              callback(void 0, value);\n            }, 0);\n            return true;\n          } else {\n            return value;\n          }\n        }\n        oldString = this.castInput(oldString);\n        newString = this.castInput(newString);\n        oldString = this.removeEmpty(this.tokenize(oldString));\n        newString = this.removeEmpty(this.tokenize(newString));\n        var newLen = newString.length, oldLen = oldString.length;\n        var editLength = 1;\n        var maxEditLength = newLen + oldLen;\n        var bestPath = [{\n          newPos: -1,\n          components: []\n        }];\n        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return done([{\n            value: this.join(newString),\n            count: newString.length\n          }]);\n        }\n        function execEditLength() {\n          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n            var basePath = void 0;\n            var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n            if (addPath) {\n              bestPath[diagonalPath - 1] = void 0;\n            }\n            var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n            if (!canAdd && !canRemove) {\n              bestPath[diagonalPath] = void 0;\n              continue;\n            }\n            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n              basePath = clonePath(removePath);\n              self2.pushComponent(basePath.components, void 0, true);\n            } else {\n              basePath = addPath;\n              basePath.newPos++;\n              self2.pushComponent(basePath.components, true, void 0);\n            }\n            _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);\n            if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n              return done(buildValues(self2, basePath.components, newString, oldString, self2.useLongestToken));\n            } else {\n              bestPath[diagonalPath] = basePath;\n            }\n          }\n          editLength++;\n        }\n        if (callback) {\n          (function exec() {\n            setTimeout(function() {\n              if (editLength > maxEditLength) {\n                return callback();\n              }\n              if (!execEditLength()) {\n                exec();\n              }\n            }, 0);\n          })();\n        } else {\n          while (editLength <= maxEditLength) {\n            var ret = execEditLength();\n            if (ret) {\n              return ret;\n            }\n          }\n        }\n      },\n      pushComponent: function pushComponent(components, added, removed) {\n        var last = components[components.length - 1];\n        if (last && last.added === added && last.removed === removed) {\n          components[components.length - 1] = {\n            count: last.count + 1,\n            added,\n            removed\n          };\n        } else {\n          components.push({\n            count: 1,\n            added,\n            removed\n          });\n        }\n      },\n      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n        var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;\n        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n          newPos++;\n          oldPos++;\n          commonCount++;\n        }\n        if (commonCount) {\n          basePath.components.push({\n            count: commonCount\n          });\n        }\n        basePath.newPos = newPos;\n        return oldPos;\n      },\n      equals: function equals(left, right) {\n        if (this.options.comparator) {\n          return this.options.comparator(left, right);\n        } else {\n          return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n        }\n      },\n      removeEmpty: function removeEmpty(array) {\n        var ret = [];\n        for (var i = 0; i < array.length; i++) {\n          if (array[i]) {\n            ret.push(array[i]);\n          }\n        }\n        return ret;\n      },\n      castInput: function castInput(value) {\n        return value;\n      },\n      tokenize: function tokenize(value) {\n        return value.split("");\n      },\n      join: function join(chars) {\n        return chars.join("");\n      }\n    };\n    function buildValues(diff, components, newString, oldString, useLongestToken) {\n      var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;\n      for (; componentPos < componentLen; componentPos++) {\n        var component = components[componentPos];\n        if (!component.removed) {\n          if (!component.added && useLongestToken) {\n            var value = newString.slice(newPos, newPos + component.count);\n            value = value.map(function(value2, i) {\n              var oldValue = oldString[oldPos + i];\n              return oldValue.length > value2.length ? oldValue : value2;\n            });\n            component.value = diff.join(value);\n          } else {\n            component.value = diff.join(newString.slice(newPos, newPos + component.count));\n          }\n          newPos += component.count;\n          if (!component.added) {\n            oldPos += component.count;\n          }\n        } else {\n          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n          oldPos += component.count;\n          if (componentPos && components[componentPos - 1].added) {\n            var tmp = components[componentPos - 1];\n            components[componentPos - 1] = components[componentPos];\n            components[componentPos] = tmp;\n          }\n        }\n      }\n      var lastComponent = components[componentLen - 1];\n      if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {\n        components[componentLen - 2].value += lastComponent.value;\n        components.pop();\n      }\n      return components;\n    }\n    function clonePath(path) {\n      return {\n        newPos: path.newPos,\n        components: path.components.slice(0)\n      };\n    }\n  }\n});\nvar require_array = __commonJS2({\n  "node_modules/diff/lib/diff/array.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.diffArrays = diffArrays;\n    exports2.arrayDiff = void 0;\n    var _base = _interopRequireDefault(require_base());\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        "default": obj\n      };\n    }\n    var arrayDiff = new _base["default"]();\n    exports2.arrayDiff = arrayDiff;\n    arrayDiff.tokenize = function(value) {\n      return value.slice();\n    };\n    arrayDiff.join = arrayDiff.removeEmpty = function(value) {\n      return value;\n    };\n    function diffArrays(oldArr, newArr, callback) {\n      return arrayDiff.diff(oldArr, newArr, callback);\n    }\n  }\n});\nvar escape_string_regexp_exports = {};\n__export(escape_string_regexp_exports, {\n  default: () => escapeStringRegexp\n});\nfunction escapeStringRegexp(string) {\n  if (typeof string !== "string") {\n    throw new TypeError("Expected a string");\n  }\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, "\\\\$&").replace(/-/g, "\\\\x2d");\n}\nvar init_escape_string_regexp = __esm({\n  "node_modules/escape-string-regexp/index.js"() {\n  }\n});\nvar require_get_last = __commonJS2({\n  "src/utils/get-last.js"(exports2, module2) {\n    "use strict";\n    var getLast = (arr) => arr[arr.length - 1];\n    module2.exports = getLast;\n  }\n});\nvar require_debug = __commonJS2({\n  "node_modules/semver/internal/debug.js"(exports2, module2) {\n    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\\bsemver\\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {\n    };\n    module2.exports = debug;\n  }\n});\nvar require_constants = __commonJS2({\n  "node_modules/semver/internal/constants.js"(exports2, module2) {\n    var SEMVER_SPEC_VERSION = "2.0.0";\n    var MAX_LENGTH = 256;\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n    var MAX_SAFE_COMPONENT_LENGTH = 16;\n    module2.exports = {\n      SEMVER_SPEC_VERSION,\n      MAX_LENGTH,\n      MAX_SAFE_INTEGER,\n      MAX_SAFE_COMPONENT_LENGTH\n    };\n  }\n});\nvar require_re = __commonJS2({\n  "node_modules/semver/internal/re.js"(exports2, module2) {\n    var {\n      MAX_SAFE_COMPONENT_LENGTH\n    } = require_constants();\n    var debug = require_debug();\n    exports2 = module2.exports = {};\n    var re = exports2.re = [];\n    var src = exports2.src = [];\n    var t = exports2.t = {};\n    var R = 0;\n    var createToken = (name, value, isGlobal) => {\n      const index = R++;\n      debug(name, index, value);\n      t[name] = index;\n      src[index] = value;\n      re[index] = new RegExp(value, isGlobal ? "g" : void 0);\n    };\n    createToken("NUMERICIDENTIFIER", "0|[1-9]\\\\d*");\n    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");\n    createToken("NONNUMERICIDENTIFIER", "\\\\d*[a-zA-Z-][a-zA-Z0-9-]*");\n    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\\\.(${src[t.NUMERICIDENTIFIER]})\\\\.(${src[t.NUMERICIDENTIFIER]})`);\n    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);\n    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);\n    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);\n    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`);\n    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);\n    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");\n    createToken("BUILD", `(?:\\\\+(${src[t.BUILDIDENTIFIER]}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`);\n    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);\n    createToken("FULL", `^${src[t.FULLPLAIN]}$`);\n    createToken("LOOSEPLAIN", `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);\n    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);\n    createToken("GTLT", "((?:<|>)?=?)");\n    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`);\n    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`);\n    createToken("XRANGEPLAIN", `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\\\.(${src[t.XRANGEIDENTIFIER]})(?:\\\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);\n    createToken("XRANGEPLAINLOOSE", `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);\n    createToken("XRANGE", `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`);\n    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken("COERCE", `${"(^|[^\\\\d])(\\\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\\\d])`);\n    createToken("COERCERTL", src[t.COERCE], true);\n    createToken("LONETILDE", "(?:~>?)");\n    createToken("TILDETRIM", `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true);\n    exports2.tildeTrimReplace = "$1~";\n    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);\n    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken("LONECARET", "(?:\\\\^)");\n    createToken("CARETTRIM", `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true);\n    exports2.caretTrimReplace = "$1^";\n    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);\n    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);\n    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`);\n    createToken("COMPARATOR", `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`);\n    createToken("COMPARATORTRIM", `(\\\\s*)${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);\n    exports2.comparatorTrimReplace = "$1$2$3";\n    createToken("HYPHENRANGE", `^\\\\s*(${src[t.XRANGEPLAIN]})\\\\s+-\\\\s+(${src[t.XRANGEPLAIN]})\\\\s*$`);\n    createToken("HYPHENRANGELOOSE", `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})\\\\s+-\\\\s+(${src[t.XRANGEPLAINLOOSE]})\\\\s*$`);\n    createToken("STAR", "(<|>)?=?\\\\s*\\\\*");\n    createToken("GTE0", "^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$");\n    createToken("GTE0PRE", "^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$");\n  }\n});\nvar require_parse_options = __commonJS2({\n  "node_modules/semver/internal/parse-options.js"(exports2, module2) {\n    var opts = ["includePrerelease", "loose", "rtl"];\n    var parseOptions = (options) => !options ? {} : typeof options !== "object" ? {\n      loose: true\n    } : opts.filter((k) => options[k]).reduce((o, k) => {\n      o[k] = true;\n      return o;\n    }, {});\n    module2.exports = parseOptions;\n  }\n});\nvar require_identifiers = __commonJS2({\n  "node_modules/semver/internal/identifiers.js"(exports2, module2) {\n    var numeric = /^[0-9]+$/;\n    var compareIdentifiers = (a, b) => {\n      const anum = numeric.test(a);\n      const bnum = numeric.test(b);\n      if (anum && bnum) {\n        a = +a;\n        b = +b;\n      }\n      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;\n    };\n    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);\n    module2.exports = {\n      compareIdentifiers,\n      rcompareIdentifiers\n    };\n  }\n});\nvar require_semver = __commonJS2({\n  "node_modules/semver/classes/semver.js"(exports2, module2) {\n    var debug = require_debug();\n    var {\n      MAX_LENGTH,\n      MAX_SAFE_INTEGER\n    } = require_constants();\n    var {\n      re,\n      t\n    } = require_re();\n    var parseOptions = require_parse_options();\n    var {\n      compareIdentifiers\n    } = require_identifiers();\n    var SemVer = class {\n      constructor(version2, options) {\n        options = parseOptions(options);\n        if (version2 instanceof SemVer) {\n          if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {\n            return version2;\n          } else {\n            version2 = version2.version;\n          }\n        } else if (typeof version2 !== "string") {\n          throw new TypeError(`Invalid Version: ${version2}`);\n        }\n        if (version2.length > MAX_LENGTH) {\n          throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);\n        }\n        debug("SemVer", version2, options);\n        this.options = options;\n        this.loose = !!options.loose;\n        this.includePrerelease = !!options.includePrerelease;\n        const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);\n        if (!m) {\n          throw new TypeError(`Invalid Version: ${version2}`);\n        }\n        this.raw = version2;\n        this.major = +m[1];\n        this.minor = +m[2];\n        this.patch = +m[3];\n        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n          throw new TypeError("Invalid major version");\n        }\n        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n          throw new TypeError("Invalid minor version");\n        }\n        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n          throw new TypeError("Invalid patch version");\n        }\n        if (!m[4]) {\n          this.prerelease = [];\n        } else {\n          this.prerelease = m[4].split(".").map((id) => {\n            if (/^[0-9]+$/.test(id)) {\n              const num = +id;\n              if (num >= 0 && num < MAX_SAFE_INTEGER) {\n                return num;\n              }\n            }\n            return id;\n          });\n        }\n        this.build = m[5] ? m[5].split(".") : [];\n        this.format();\n      }\n      format() {\n        this.version = `${this.major}.${this.minor}.${this.patch}`;\n        if (this.prerelease.length) {\n          this.version += `-${this.prerelease.join(".")}`;\n        }\n        return this.version;\n      }\n      toString() {\n        return this.version;\n      }\n      compare(other) {\n        debug("SemVer.compare", this.version, this.options, other);\n        if (!(other instanceof SemVer)) {\n          if (typeof other === "string" && other === this.version) {\n            return 0;\n          }\n          other = new SemVer(other, this.options);\n        }\n        if (other.version === this.version) {\n          return 0;\n        }\n        return this.compareMain(other) || this.comparePre(other);\n      }\n      compareMain(other) {\n        if (!(other instanceof SemVer)) {\n          other = new SemVer(other, this.options);\n        }\n        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);\n      }\n      comparePre(other) {\n        if (!(other instanceof SemVer)) {\n          other = new SemVer(other, this.options);\n        }\n        if (this.prerelease.length && !other.prerelease.length) {\n          return -1;\n        } else if (!this.prerelease.length && other.prerelease.length) {\n          return 1;\n        } else if (!this.prerelease.length && !other.prerelease.length) {\n          return 0;\n        }\n        let i = 0;\n        do {\n          const a = this.prerelease[i];\n          const b = other.prerelease[i];\n          debug("prerelease compare", i, a, b);\n          if (a === void 0 && b === void 0) {\n            return 0;\n          } else if (b === void 0) {\n            return 1;\n          } else if (a === void 0) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      }\n      compareBuild(other) {\n        if (!(other instanceof SemVer)) {\n          other = new SemVer(other, this.options);\n        }\n        let i = 0;\n        do {\n          const a = this.build[i];\n          const b = other.build[i];\n          debug("prerelease compare", i, a, b);\n          if (a === void 0 && b === void 0) {\n            return 0;\n          } else if (b === void 0) {\n            return 1;\n          } else if (a === void 0) {\n            return -1;\n          } else if (a === b) {\n            continue;\n          } else {\n            return compareIdentifiers(a, b);\n          }\n        } while (++i);\n      }\n      inc(release, identifier) {\n        switch (release) {\n          case "premajor":\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor = 0;\n            this.major++;\n            this.inc("pre", identifier);\n            break;\n          case "preminor":\n            this.prerelease.length = 0;\n            this.patch = 0;\n            this.minor++;\n            this.inc("pre", identifier);\n            break;\n          case "prepatch":\n            this.prerelease.length = 0;\n            this.inc("patch", identifier);\n            this.inc("pre", identifier);\n            break;\n          case "prerelease":\n            if (this.prerelease.length === 0) {\n              this.inc("patch", identifier);\n            }\n            this.inc("pre", identifier);\n            break;\n          case "major":\n            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {\n              this.major++;\n            }\n            this.minor = 0;\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n          case "minor":\n            if (this.patch !== 0 || this.prerelease.length === 0) {\n              this.minor++;\n            }\n            this.patch = 0;\n            this.prerelease = [];\n            break;\n          case "patch":\n            if (this.prerelease.length === 0) {\n              this.patch++;\n            }\n            this.prerelease = [];\n            break;\n          case "pre":\n            if (this.prerelease.length === 0) {\n              this.prerelease = [0];\n            } else {\n              let i = this.prerelease.length;\n              while (--i >= 0) {\n                if (typeof this.prerelease[i] === "number") {\n                  this.prerelease[i]++;\n                  i = -2;\n                }\n              }\n              if (i === -1) {\n                this.prerelease.push(0);\n              }\n            }\n            if (identifier) {\n              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n                if (isNaN(this.prerelease[1])) {\n                  this.prerelease = [identifier, 0];\n                }\n              } else {\n                this.prerelease = [identifier, 0];\n              }\n            }\n            break;\n          default:\n            throw new Error(`invalid increment argument: ${release}`);\n        }\n        this.format();\n        this.raw = this.version;\n        return this;\n      }\n    };\n    module2.exports = SemVer;\n  }\n});\nvar require_compare = __commonJS2({\n  "node_modules/semver/functions/compare.js"(exports2, module2) {\n    var SemVer = require_semver();\n    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));\n    module2.exports = compare;\n  }\n});\nvar require_lt = __commonJS2({\n  "node_modules/semver/functions/lt.js"(exports2, module2) {\n    var compare = require_compare();\n    var lt = (a, b, loose) => compare(a, b, loose) < 0;\n    module2.exports = lt;\n  }\n});\nvar require_gte = __commonJS2({\n  "node_modules/semver/functions/gte.js"(exports2, module2) {\n    var compare = require_compare();\n    var gte = (a, b, loose) => compare(a, b, loose) >= 0;\n    module2.exports = gte;\n  }\n});\nvar require_arrayify = __commonJS2({\n  "src/utils/arrayify.js"(exports2, module2) {\n    "use strict";\n    module2.exports = (object, keyName) => Object.entries(object).map(([key, value]) => Object.assign({\n      [keyName]: key\n    }, value));\n  }\n});\nvar require_lib = __commonJS2({\n  "node_modules/outdent/lib/index.js"(exports2, module2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.outdent = void 0;\n    function noop() {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n    }\n    function createWeakMap() {\n      if (typeof WeakMap !== "undefined") {\n        return /* @__PURE__ */ new WeakMap();\n      } else {\n        return fakeSetOrMap();\n      }\n    }\n    function fakeSetOrMap() {\n      return {\n        add: noop,\n        delete: noop,\n        get: noop,\n        set: noop,\n        has: function(k) {\n          return false;\n        }\n      };\n    }\n    var hop = Object.prototype.hasOwnProperty;\n    var has = function(obj, prop) {\n      return hop.call(obj, prop);\n    };\n    function extend(target, source) {\n      for (var prop in source) {\n        if (has(source, prop)) {\n          target[prop] = source[prop];\n        }\n      }\n      return target;\n    }\n    var reLeadingNewline = /^[ \\t]*(?:\\r\\n|\\r|\\n)/;\n    var reTrailingNewline = /(?:\\r\\n|\\r|\\n)[ \\t]*$/;\n    var reStartsWithNewlineOrIsEmpty = /^(?:[\\r\\n]|$)/;\n    var reDetectIndentation = /(?:\\r\\n|\\r|\\n)([ \\t]*)(?:[^ \\t\\r\\n]|$)/;\n    var reOnlyWhitespaceWithAtLeastOneNewline = /^[ \\t]*[\\r\\n][ \\t\\r\\n]*$/;\n    function _outdentArray(strings, firstInterpolatedValueSetsIndentationLevel, options) {\n      var indentationLevel = 0;\n      var match = strings[0].match(reDetectIndentation);\n      if (match) {\n        indentationLevel = match[1].length;\n      }\n      var reSource = "(\\\\r\\\\n|\\\\r|\\\\n).{0," + indentationLevel + "}";\n      var reMatchIndent = new RegExp(reSource, "g");\n      if (firstInterpolatedValueSetsIndentationLevel) {\n        strings = strings.slice(1);\n      }\n      var newline = options.newline, trimLeadingNewline = options.trimLeadingNewline, trimTrailingNewline = options.trimTrailingNewline;\n      var normalizeNewlines = typeof newline === "string";\n      var l = strings.length;\n      var outdentedStrings = strings.map(function(v, i) {\n        v = v.replace(reMatchIndent, "$1");\n        if (i === 0 && trimLeadingNewline) {\n          v = v.replace(reLeadingNewline, "");\n        }\n        if (i === l - 1 && trimTrailingNewline) {\n          v = v.replace(reTrailingNewline, "");\n        }\n        if (normalizeNewlines) {\n          v = v.replace(/\\r\\n|\\n|\\r/g, function(_) {\n            return newline;\n          });\n        }\n        return v;\n      });\n      return outdentedStrings;\n    }\n    function concatStringsAndValues(strings, values) {\n      var ret = "";\n      for (var i = 0, l = strings.length; i < l; i++) {\n        ret += strings[i];\n        if (i < l - 1) {\n          ret += values[i];\n        }\n      }\n      return ret;\n    }\n    function isTemplateStringsArray(v) {\n      return has(v, "raw") && has(v, "length");\n    }\n    function createInstance(options) {\n      var arrayAutoIndentCache = createWeakMap();\n      var arrayFirstInterpSetsIndentCache = createWeakMap();\n      function outdent(stringsOrOptions) {\n        var values = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n          values[_i - 1] = arguments[_i];\n        }\n        if (isTemplateStringsArray(stringsOrOptions)) {\n          var strings = stringsOrOptions;\n          var firstInterpolatedValueSetsIndentationLevel = (values[0] === outdent || values[0] === defaultOutdent) && reOnlyWhitespaceWithAtLeastOneNewline.test(strings[0]) && reStartsWithNewlineOrIsEmpty.test(strings[1]);\n          var cache = firstInterpolatedValueSetsIndentationLevel ? arrayFirstInterpSetsIndentCache : arrayAutoIndentCache;\n          var renderedArray = cache.get(strings);\n          if (!renderedArray) {\n            renderedArray = _outdentArray(strings, firstInterpolatedValueSetsIndentationLevel, options);\n            cache.set(strings, renderedArray);\n          }\n          if (values.length === 0) {\n            return renderedArray[0];\n          }\n          var rendered = concatStringsAndValues(renderedArray, firstInterpolatedValueSetsIndentationLevel ? values.slice(1) : values);\n          return rendered;\n        } else {\n          return createInstance(extend(extend({}, options), stringsOrOptions || {}));\n        }\n      }\n      var fullOutdent = extend(outdent, {\n        string: function(str) {\n          return _outdentArray([str], false, options)[0];\n        }\n      });\n      return fullOutdent;\n    }\n    var defaultOutdent = createInstance({\n      trimLeadingNewline: true,\n      trimTrailingNewline: true\n    });\n    exports2.outdent = defaultOutdent;\n    exports2.default = defaultOutdent;\n    if (typeof module2 !== "undefined") {\n      try {\n        module2.exports = defaultOutdent;\n        Object.defineProperty(defaultOutdent, "__esModule", {\n          value: true\n        });\n        defaultOutdent.default = defaultOutdent;\n        defaultOutdent.outdent = defaultOutdent;\n      } catch (e) {\n      }\n    }\n  }\n});\nvar require_core_options = __commonJS2({\n  "src/main/core-options.js"(exports2, module2) {\n    "use strict";\n    var {\n      outdent\n    } = require_lib();\n    var CATEGORY_CONFIG = "Config";\n    var CATEGORY_EDITOR = "Editor";\n    var CATEGORY_FORMAT = "Format";\n    var CATEGORY_OTHER = "Other";\n    var CATEGORY_OUTPUT = "Output";\n    var CATEGORY_GLOBAL = "Global";\n    var CATEGORY_SPECIAL = "Special";\n    var options = {\n      cursorOffset: {\n        since: "1.4.0",\n        category: CATEGORY_SPECIAL,\n        type: "int",\n        default: -1,\n        range: {\n          start: -1,\n          end: Number.POSITIVE_INFINITY,\n          step: 1\n        },\n        description: outdent`\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    `,\n        cliCategory: CATEGORY_EDITOR\n      },\n      endOfLine: {\n        since: "1.15.0",\n        category: CATEGORY_GLOBAL,\n        type: "choice",\n        default: [{\n          since: "1.15.0",\n          value: "auto"\n        }, {\n          since: "2.0.0",\n          value: "lf"\n        }],\n        description: "Which end of line characters to apply.",\n        choices: [{\n          value: "lf",\n          description: "Line Feed only (\\\\n), common on Linux and macOS as well as inside git repos"\n        }, {\n          value: "crlf",\n          description: "Carriage Return + Line Feed characters (\\\\r\\\\n), common on Windows"\n        }, {\n          value: "cr",\n          description: "Carriage Return character only (\\\\r), used very rarely"\n        }, {\n          value: "auto",\n          description: outdent`\n          Maintain existing\n          (mixed values within one file are normalised by looking at what\'s used after the first line)\n        `\n        }]\n      },\n      filepath: {\n        since: "1.4.0",\n        category: CATEGORY_SPECIAL,\n        type: "path",\n        description: "Specify the input filepath. This will be used to do parser inference.",\n        cliName: "stdin-filepath",\n        cliCategory: CATEGORY_OTHER,\n        cliDescription: "Path to the file to pretend that stdin comes from."\n      },\n      insertPragma: {\n        since: "1.8.0",\n        category: CATEGORY_SPECIAL,\n        type: "boolean",\n        default: false,\n        description: "Insert @format pragma into file\'s first docblock comment.",\n        cliCategory: CATEGORY_OTHER\n      },\n      parser: {\n        since: "0.0.10",\n        category: CATEGORY_GLOBAL,\n        type: "choice",\n        default: [{\n          since: "0.0.10",\n          value: "babylon"\n        }, {\n          since: "1.13.0",\n          value: void 0\n        }],\n        description: "Which parser to use.",\n        exception: (value) => typeof value === "string" || typeof value === "function",\n        choices: [{\n          value: "flow",\n          description: "Flow"\n        }, {\n          value: "babel",\n          since: "1.16.0",\n          description: "JavaScript"\n        }, {\n          value: "babel-flow",\n          since: "1.16.0",\n          description: "Flow"\n        }, {\n          value: "babel-ts",\n          since: "2.0.0",\n          description: "TypeScript"\n        }, {\n          value: "typescript",\n          since: "1.4.0",\n          description: "TypeScript"\n        }, {\n          value: "acorn",\n          since: "2.6.0",\n          description: "JavaScript"\n        }, {\n          value: "espree",\n          since: "2.2.0",\n          description: "JavaScript"\n        }, {\n          value: "meriyah",\n          since: "2.2.0",\n          description: "JavaScript"\n        }, {\n          value: "css",\n          since: "1.7.1",\n          description: "CSS"\n        }, {\n          value: "less",\n          since: "1.7.1",\n          description: "Less"\n        }, {\n          value: "scss",\n          since: "1.7.1",\n          description: "SCSS"\n        }, {\n          value: "json",\n          since: "1.5.0",\n          description: "JSON"\n        }, {\n          value: "json5",\n          since: "1.13.0",\n          description: "JSON5"\n        }, {\n          value: "json-stringify",\n          since: "1.13.0",\n          description: "JSON.stringify"\n        }, {\n          value: "graphql",\n          since: "1.5.0",\n          description: "GraphQL"\n        }, {\n          value: "markdown",\n          since: "1.8.0",\n          description: "Markdown"\n        }, {\n          value: "mdx",\n          since: "1.15.0",\n          description: "MDX"\n        }, {\n          value: "vue",\n          since: "1.10.0",\n          description: "Vue"\n        }, {\n          value: "yaml",\n          since: "1.14.0",\n          description: "YAML"\n        }, {\n          value: "glimmer",\n          since: "2.3.0",\n          description: "Ember / Handlebars"\n        }, {\n          value: "html",\n          since: "1.15.0",\n          description: "HTML"\n        }, {\n          value: "angular",\n          since: "1.15.0",\n          description: "Angular"\n        }, {\n          value: "lwc",\n          since: "1.17.0",\n          description: "Lightning Web Components"\n        }]\n      },\n      plugins: {\n        since: "1.10.0",\n        type: "path",\n        array: true,\n        default: [{\n          value: []\n        }],\n        category: CATEGORY_GLOBAL,\n        description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",\n        exception: (value) => typeof value === "string" || typeof value === "object",\n        cliName: "plugin",\n        cliCategory: CATEGORY_CONFIG\n      },\n      pluginSearchDirs: {\n        since: "1.13.0",\n        type: "path",\n        array: true,\n        default: [{\n          value: []\n        }],\n        category: CATEGORY_GLOBAL,\n        description: outdent`\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    `,\n        exception: (value) => typeof value === "string" || typeof value === "object",\n        cliName: "plugin-search-dir",\n        cliCategory: CATEGORY_CONFIG\n      },\n      printWidth: {\n        since: "0.0.0",\n        category: CATEGORY_GLOBAL,\n        type: "int",\n        default: 80,\n        description: "The line length where Prettier will try wrap.",\n        range: {\n          start: 0,\n          end: Number.POSITIVE_INFINITY,\n          step: 1\n        }\n      },\n      rangeEnd: {\n        since: "1.4.0",\n        category: CATEGORY_SPECIAL,\n        type: "int",\n        default: Number.POSITIVE_INFINITY,\n        range: {\n          start: 0,\n          end: Number.POSITIVE_INFINITY,\n          step: 1\n        },\n        description: outdent`\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    `,\n        cliCategory: CATEGORY_EDITOR\n      },\n      rangeStart: {\n        since: "1.4.0",\n        category: CATEGORY_SPECIAL,\n        type: "int",\n        default: 0,\n        range: {\n          start: 0,\n          end: Number.POSITIVE_INFINITY,\n          step: 1\n        },\n        description: outdent`\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    `,\n        cliCategory: CATEGORY_EDITOR\n      },\n      requirePragma: {\n        since: "1.7.0",\n        category: CATEGORY_SPECIAL,\n        type: "boolean",\n        default: false,\n        description: outdent`\n      Require either \'@prettier\' or \'@format\' to be present in the file\'s first docblock comment\n      in order for it to be formatted.\n    `,\n        cliCategory: CATEGORY_OTHER\n      },\n      tabWidth: {\n        type: "int",\n        category: CATEGORY_GLOBAL,\n        default: 2,\n        description: "Number of spaces per indentation level.",\n        range: {\n          start: 0,\n          end: Number.POSITIVE_INFINITY,\n          step: 1\n        }\n      },\n      useTabs: {\n        since: "1.0.0",\n        category: CATEGORY_GLOBAL,\n        type: "boolean",\n        default: false,\n        description: "Indent with tabs instead of spaces."\n      },\n      embeddedLanguageFormatting: {\n        since: "2.1.0",\n        category: CATEGORY_GLOBAL,\n        type: "choice",\n        default: [{\n          since: "2.1.0",\n          value: "auto"\n        }],\n        description: "Control how Prettier formats quoted code embedded in the file.",\n        choices: [{\n          value: "auto",\n          description: "Format embedded code if Prettier can automatically identify it."\n        }, {\n          value: "off",\n          description: "Never automatically format embedded code."\n        }]\n      }\n    };\n    module2.exports = {\n      CATEGORY_CONFIG,\n      CATEGORY_EDITOR,\n      CATEGORY_FORMAT,\n      CATEGORY_OTHER,\n      CATEGORY_OUTPUT,\n      CATEGORY_GLOBAL,\n      CATEGORY_SPECIAL,\n      options\n    };\n  }\n});\nvar require_support = __commonJS2({\n  "src/main/support.js"(exports2, module2) {\n    "use strict";\n    var semver = {\n      compare: require_compare(),\n      lt: require_lt(),\n      gte: require_gte()\n    };\n    var arrayify = require_arrayify();\n    var currentVersion = require("./package.json").version;\n    var coreOptions = require_core_options().options;\n    function getSupportInfo2({\n      plugins: plugins2 = [],\n      showUnreleased = false,\n      showDeprecated = false,\n      showInternal = false\n    } = {}) {\n      const version2 = currentVersion.split("-", 1)[0];\n      const languages = plugins2.flatMap((plugin) => plugin.languages || []).filter(filterSince);\n      const options = arrayify(Object.assign({}, ...plugins2.map(({\n        options: options2\n      }) => options2), coreOptions), "name").filter((option) => filterSince(option) && filterDeprecated(option)).sort((a, b) => a.name === b.name ? 0 : a.name < b.name ? -1 : 1).map(mapInternal).map((option) => {\n        option = Object.assign({}, option);\n        if (Array.isArray(option.default)) {\n          option.default = option.default.length === 1 ? option.default[0].value : option.default.filter(filterSince).sort((info1, info2) => semver.compare(info2.since, info1.since))[0].value;\n        }\n        if (Array.isArray(option.choices)) {\n          option.choices = option.choices.filter((option2) => filterSince(option2) && filterDeprecated(option2));\n          if (option.name === "parser") {\n            collectParsersFromLanguages(option, languages, plugins2);\n          }\n        }\n        const pluginDefaults = Object.fromEntries(plugins2.filter((plugin) => plugin.defaultOptions && plugin.defaultOptions[option.name] !== void 0).map((plugin) => [plugin.name, plugin.defaultOptions[option.name]]));\n        return Object.assign(Object.assign({}, option), {}, {\n          pluginDefaults\n        });\n      });\n      return {\n        languages,\n        options\n      };\n      function filterSince(object) {\n        return showUnreleased || !("since" in object) || object.since && semver.gte(version2, object.since);\n      }\n      function filterDeprecated(object) {\n        return showDeprecated || !("deprecated" in object) || object.deprecated && semver.lt(version2, object.deprecated);\n      }\n      function mapInternal(object) {\n        if (showInternal) {\n          return object;\n        }\n        const {\n          cliName,\n          cliCategory,\n          cliDescription\n        } = object, newObject = _objectWithoutProperties(object, _excluded);\n        return newObject;\n      }\n    }\n    function collectParsersFromLanguages(option, languages, plugins2) {\n      const existingValues = new Set(option.choices.map((choice) => choice.value));\n      for (const language of languages) {\n        if (language.parsers) {\n          for (const value of language.parsers) {\n            if (!existingValues.has(value)) {\n              existingValues.add(value);\n              const plugin = plugins2.find((plugin2) => plugin2.parsers && plugin2.parsers[value]);\n              let description = language.name;\n              if (plugin && plugin.name) {\n                description += ` (plugin: ${plugin.name})`;\n              }\n              option.choices.push({\n                value,\n                description\n              });\n            }\n          }\n        }\n      }\n    }\n    module2.exports = {\n      getSupportInfo: getSupportInfo2\n    };\n  }\n});\nvar require_is_non_empty_array = __commonJS2({\n  "src/utils/is-non-empty-array.js"(exports2, module2) {\n    "use strict";\n    function isNonEmptyArray(object) {\n      return Array.isArray(object) && object.length > 0;\n    }\n    module2.exports = isNonEmptyArray;\n  }\n});\nfunction ansiRegex({\n  onlyFirst = false\n} = {}) {\n  const pattern = ["[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)", "(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))"].join("|");\n  return new RegExp(pattern, onlyFirst ? void 0 : "g");\n}\nvar init_ansi_regex = __esm({\n  "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {\n  }\n});\nfunction stripAnsi(string) {\n  if (typeof string !== "string") {\n    throw new TypeError(`Expected a \\`string\\`, got \\`${typeof string}\\``);\n  }\n  return string.replace(ansiRegex(), "");\n}\nvar init_strip_ansi = __esm({\n  "node_modules/strip-ansi/index.js"() {\n    init_ansi_regex();\n  }\n});\nfunction isFullwidthCodePoint(codePoint) {\n  if (!Number.isInteger(codePoint)) {\n    return false;\n  }\n  return codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141);\n}\nvar init_is_fullwidth_code_point = __esm({\n  "node_modules/is-fullwidth-code-point/index.js"() {\n  }\n});\nvar require_emoji_regex = __commonJS2({\n  "node_modules/emoji-regex/index.js"(exports2, module2) {\n    "use strict";\n    module2.exports = function() {\n      return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|(?:\\uD83E\\uDDD1\\uD83C\\uDFFF\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C\\uDFFB(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))?|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC)?|(?:\\uD83D\\uDC69(?:\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC69(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83E\\uDDD1(?:\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDE36\\u200D\\uD83C\\uDF2B|\\uD83C\\uDFF3\\uFE0F\\u200D\\u26A7|\\uD83D\\uDC3B\\u200D\\u2744|(?:(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\uD83C\\uDFF4\\u200D\\u2620|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])\\u200D[\\u2640\\u2642]|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u2600-\\u2604\\u260E\\u2611\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26B0\\u26B1\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0\\u26F1\\u26F4\\u26F7\\u26F8\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]|\\uD83D[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3])\\uFE0F|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB|\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83D\\uDC69(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC08\\u200D\\u2B1B|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79)|\\uD83D\\uDC41\\uFE0F|\\uD83C\\uDFF3\\uFE0F|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\u2764\\uFE0F|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF4|(?:[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270C\\u270D]|\\uD83D[\\uDD74\\uDD90])(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC08\\uDC15\\uDC3B\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE2E\\uDE35\\uDE36\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5]|\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD]|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF]|[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD1D\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78\\uDD7A-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCB\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6]|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDD77\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n    };\n  }\n});\nvar string_width_exports = {};\n__export(string_width_exports, {\n  default: () => stringWidth\n});\nfunction stringWidth(string) {\n  if (typeof string !== "string" || string.length === 0) {\n    return 0;\n  }\n  string = stripAnsi(string);\n  if (string.length === 0) {\n    return 0;\n  }\n  string = string.replace((0, import_emoji_regex.default)(), "  ");\n  let width = 0;\n  for (let index = 0; index < string.length; index++) {\n    const codePoint = string.codePointAt(index);\n    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {\n      continue;\n    }\n    if (codePoint >= 768 && codePoint <= 879) {\n      continue;\n    }\n    if (codePoint > 65535) {\n      index++;\n    }\n    width += isFullwidthCodePoint(codePoint) ? 2 : 1;\n  }\n  return width;\n}\nvar import_emoji_regex;\nvar init_string_width = __esm({\n  "node_modules/string-width/index.js"() {\n    init_strip_ansi();\n    init_is_fullwidth_code_point();\n    import_emoji_regex = __toESM(require_emoji_regex());\n  }\n});\nvar require_get_string_width = __commonJS2({\n  "src/utils/get-string-width.js"(exports2, module2) {\n    "use strict";\n    var stringWidth2 = (init_string_width(), __toCommonJS(string_width_exports)).default;\n    var notAsciiRegex = /[^\\x20-\\x7F]/;\n    function getStringWidth(text) {\n      if (!text) {\n        return 0;\n      }\n      if (!notAsciiRegex.test(text)) {\n        return text.length;\n      }\n      return stringWidth2(text);\n    }\n    module2.exports = getStringWidth;\n  }\n});\nvar require_skip = __commonJS2({\n  "src/utils/text/skip.js"(exports2, module2) {\n    "use strict";\n    function skip(chars) {\n      return (text, index, opts) => {\n        const backwards = opts && opts.backwards;\n        if (index === false) {\n          return false;\n        }\n        const {\n          length\n        } = text;\n        let cursor = index;\n        while (cursor >= 0 && cursor < length) {\n          const c = text.charAt(cursor);\n          if (chars instanceof RegExp) {\n            if (!chars.test(c)) {\n              return cursor;\n            }\n          } else if (!chars.includes(c)) {\n            return cursor;\n          }\n          backwards ? cursor-- : cursor++;\n        }\n        if (cursor === -1 || cursor === length) {\n          return cursor;\n        }\n        return false;\n      };\n    }\n    var skipWhitespace = skip(/\\s/);\n    var skipSpaces = skip(" \t");\n    var skipToLineEnd = skip(",; \t");\n    var skipEverythingButNewLine = skip(/[^\\n\\r]/);\n    module2.exports = {\n      skipWhitespace,\n      skipSpaces,\n      skipToLineEnd,\n      skipEverythingButNewLine\n    };\n  }\n});\nvar require_skip_inline_comment = __commonJS2({\n  "src/utils/text/skip-inline-comment.js"(exports2, module2) {\n    "use strict";\n    function skipInlineComment(text, index) {\n      if (index === false) {\n        return false;\n      }\n      if (text.charAt(index) === "/" && text.charAt(index + 1) === "*") {\n        for (let i = index + 2; i < text.length; ++i) {\n          if (text.charAt(i) === "*" && text.charAt(i + 1) === "/") {\n            return i + 2;\n          }\n        }\n      }\n      return index;\n    }\n    module2.exports = skipInlineComment;\n  }\n});\nvar require_skip_trailing_comment = __commonJS2({\n  "src/utils/text/skip-trailing-comment.js"(exports2, module2) {\n    "use strict";\n    var {\n      skipEverythingButNewLine\n    } = require_skip();\n    function skipTrailingComment(text, index) {\n      if (index === false) {\n        return false;\n      }\n      if (text.charAt(index) === "/" && text.charAt(index + 1) === "/") {\n        return skipEverythingButNewLine(text, index);\n      }\n      return index;\n    }\n    module2.exports = skipTrailingComment;\n  }\n});\nvar require_skip_newline = __commonJS2({\n  "src/utils/text/skip-newline.js"(exports2, module2) {\n    "use strict";\n    function skipNewline(text, index, opts) {\n      const backwards = opts && opts.backwards;\n      if (index === false) {\n        return false;\n      }\n      const atIndex = text.charAt(index);\n      if (backwards) {\n        if (text.charAt(index - 1) === "\\r" && atIndex === "\\n") {\n          return index - 2;\n        }\n        if (atIndex === "\\n" || atIndex === "\\r" || atIndex === "\\u2028" || atIndex === "\\u2029") {\n          return index - 1;\n        }\n      } else {\n        if (atIndex === "\\r" && text.charAt(index + 1) === "\\n") {\n          return index + 2;\n        }\n        if (atIndex === "\\n" || atIndex === "\\r" || atIndex === "\\u2028" || atIndex === "\\u2029") {\n          return index + 1;\n        }\n      }\n      return index;\n    }\n    module2.exports = skipNewline;\n  }\n});\nvar require_get_next_non_space_non_comment_character_index_with_start_index = __commonJS2({\n  "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(exports2, module2) {\n    "use strict";\n    var skipInlineComment = require_skip_inline_comment();\n    var skipNewline = require_skip_newline();\n    var skipTrailingComment = require_skip_trailing_comment();\n    var {\n      skipSpaces\n    } = require_skip();\n    function getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, idx) {\n      let oldIdx = null;\n      let nextIdx = idx;\n      while (nextIdx !== oldIdx) {\n        oldIdx = nextIdx;\n        nextIdx = skipSpaces(text, nextIdx);\n        nextIdx = skipInlineComment(text, nextIdx);\n        nextIdx = skipTrailingComment(text, nextIdx);\n        nextIdx = skipNewline(text, nextIdx);\n      }\n      return nextIdx;\n    }\n    module2.exports = getNextNonSpaceNonCommentCharacterIndexWithStartIndex;\n  }\n});\nvar require_util = __commonJS2({\n  "src/common/util.js"(exports2, module2) {\n    "use strict";\n    var {\n      default: escapeStringRegexp2\n    } = (init_escape_string_regexp(), __toCommonJS(escape_string_regexp_exports));\n    var getLast = require_get_last();\n    var {\n      getSupportInfo: getSupportInfo2\n    } = require_support();\n    var isNonEmptyArray = require_is_non_empty_array();\n    var getStringWidth = require_get_string_width();\n    var {\n      skipWhitespace,\n      skipSpaces,\n      skipToLineEnd,\n      skipEverythingButNewLine\n    } = require_skip();\n    var skipInlineComment = require_skip_inline_comment();\n    var skipTrailingComment = require_skip_trailing_comment();\n    var skipNewline = require_skip_newline();\n    var getNextNonSpaceNonCommentCharacterIndexWithStartIndex = require_get_next_non_space_non_comment_character_index_with_start_index();\n    var getPenultimate = (arr) => arr[arr.length - 2];\n    function skip(chars) {\n      return (text, index, opts) => {\n        const backwards = opts && opts.backwards;\n        if (index === false) {\n          return false;\n        }\n        const {\n          length\n        } = text;\n        let cursor = index;\n        while (cursor >= 0 && cursor < length) {\n          const c = text.charAt(cursor);\n          if (chars instanceof RegExp) {\n            if (!chars.test(c)) {\n              return cursor;\n            }\n          } else if (!chars.includes(c)) {\n            return cursor;\n          }\n          backwards ? cursor-- : cursor++;\n        }\n        if (cursor === -1 || cursor === length) {\n          return cursor;\n        }\n        return false;\n      };\n    }\n    function hasNewline(text, index, opts = {}) {\n      const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n      const idx2 = skipNewline(text, idx, opts);\n      return idx !== idx2;\n    }\n    function hasNewlineInRange(text, start, end) {\n      for (let i = start; i < end; ++i) {\n        if (text.charAt(i) === "\\n") {\n          return true;\n        }\n      }\n      return false;\n    }\n    function isPreviousLineEmpty(text, node, locStart) {\n      let idx = locStart(node) - 1;\n      idx = skipSpaces(text, idx, {\n        backwards: true\n      });\n      idx = skipNewline(text, idx, {\n        backwards: true\n      });\n      idx = skipSpaces(text, idx, {\n        backwards: true\n      });\n      const idx2 = skipNewline(text, idx, {\n        backwards: true\n      });\n      return idx !== idx2;\n    }\n    function isNextLineEmptyAfterIndex(text, index) {\n      let oldIdx = null;\n      let idx = index;\n      while (idx !== oldIdx) {\n        oldIdx = idx;\n        idx = skipToLineEnd(text, idx);\n        idx = skipInlineComment(text, idx);\n        idx = skipSpaces(text, idx);\n      }\n      idx = skipTrailingComment(text, idx);\n      idx = skipNewline(text, idx);\n      return idx !== false && hasNewline(text, idx);\n    }\n    function isNextLineEmpty(text, node, locEnd) {\n      return isNextLineEmptyAfterIndex(text, locEnd(node));\n    }\n    function getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {\n      return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, locEnd(node));\n    }\n    function getNextNonSpaceNonCommentCharacter(text, node, locEnd) {\n      return text.charAt(getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd));\n    }\n    function hasSpaces(text, index, opts = {}) {\n      const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);\n      return idx !== index;\n    }\n    function getAlignmentSize(value, tabWidth, startIndex = 0) {\n      let size = 0;\n      for (let i = startIndex; i < value.length; ++i) {\n        if (value[i] === "\t") {\n          size = size + tabWidth - size % tabWidth;\n        } else {\n          size++;\n        }\n      }\n      return size;\n    }\n    function getIndentSize(value, tabWidth) {\n      const lastNewlineIndex = value.lastIndexOf("\\n");\n      if (lastNewlineIndex === -1) {\n        return 0;\n      }\n      return getAlignmentSize(value.slice(lastNewlineIndex + 1).match(/^[\\t ]*/)[0], tabWidth);\n    }\n    function getPreferredQuote(rawContent, preferredQuote) {\n      const double = {\n        quote: \'"\',\n        regex: /"/g,\n        escaped: "&quot;"\n      };\n      const single = {\n        quote: "\'",\n        regex: /\'/g,\n        escaped: "&apos;"\n      };\n      const preferred = preferredQuote === "\'" ? single : double;\n      const alternate = preferred === single ? double : single;\n      let result = preferred;\n      if (rawContent.includes(preferred.quote) || rawContent.includes(alternate.quote)) {\n        const numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;\n        const numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;\n        result = numPreferredQuotes > numAlternateQuotes ? alternate : preferred;\n      }\n      return result;\n    }\n    function printString(raw, options) {\n      const rawContent = raw.slice(1, -1);\n      const enclosingQuote = options.parser === "json" || options.parser === "json5" && options.quoteProps === "preserve" && !options.singleQuote ? \'"\' : options.__isInHtmlAttribute ? "\'" : getPreferredQuote(rawContent, options.singleQuote ? "\'" : \'"\').quote;\n      return makeString(rawContent, enclosingQuote, !(options.parser === "css" || options.parser === "less" || options.parser === "scss" || options.__embeddedInHtml));\n    }\n    function makeString(rawContent, enclosingQuote, unescapeUnnecessaryEscapes) {\n      const otherQuote = enclosingQuote === \'"\' ? "\'" : \'"\';\n      const regex = /\\\\(.)|(["\'])/gs;\n      const newContent = rawContent.replace(regex, (match, escaped, quote) => {\n        if (escaped === otherQuote) {\n          return escaped;\n        }\n        if (quote === enclosingQuote) {\n          return "\\\\" + quote;\n        }\n        if (quote) {\n          return quote;\n        }\n        return unescapeUnnecessaryEscapes && /^[^\\n\\r"\'0-7\\\\bfnrt-vx\\u2028\\u2029]$/.test(escaped) ? escaped : "\\\\" + escaped;\n      });\n      return enclosingQuote + newContent + enclosingQuote;\n    }\n    function printNumber(rawNumber) {\n      return rawNumber.toLowerCase().replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, "$1$2$3").replace(/^([+-]?[\\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\\./, "$10.").replace(/(\\.\\d+?)0+(?=e|$)/, "$1").replace(/\\.(?=e|$)/, "");\n    }\n    function getMaxContinuousCount(str, target) {\n      const results = str.match(new RegExp(`(${escapeStringRegexp2(target)})+`, "g"));\n      if (results === null) {\n        return 0;\n      }\n      return results.reduce((maxCount, result) => Math.max(maxCount, result.length / target.length), 0);\n    }\n    function getMinNotPresentContinuousCount(str, target) {\n      const matches = str.match(new RegExp(`(${escapeStringRegexp2(target)})+`, "g"));\n      if (matches === null) {\n        return 0;\n      }\n      const countPresent = /* @__PURE__ */ new Map();\n      let max = 0;\n      for (const match of matches) {\n        const count = match.length / target.length;\n        countPresent.set(count, true);\n        if (count > max) {\n          max = count;\n        }\n      }\n      for (let i = 1; i < max; i++) {\n        if (!countPresent.get(i)) {\n          return i;\n        }\n      }\n      return max + 1;\n    }\n    function addCommentHelper(node, comment) {\n      const comments = node.comments || (node.comments = []);\n      comments.push(comment);\n      comment.printed = false;\n      comment.nodeDescription = describeNodeForDebugging(node);\n    }\n    function addLeadingComment(node, comment) {\n      comment.leading = true;\n      comment.trailing = false;\n      addCommentHelper(node, comment);\n    }\n    function addDanglingComment(node, comment, marker) {\n      comment.leading = false;\n      comment.trailing = false;\n      if (marker) {\n        comment.marker = marker;\n      }\n      addCommentHelper(node, comment);\n    }\n    function addTrailingComment(node, comment) {\n      comment.leading = false;\n      comment.trailing = true;\n      addCommentHelper(node, comment);\n    }\n    function inferParserByLanguage(language, options) {\n      const {\n        languages\n      } = getSupportInfo2({\n        plugins: options.plugins\n      });\n      const matched = languages.find(({\n        name\n      }) => name.toLowerCase() === language) || languages.find(({\n        aliases\n      }) => Array.isArray(aliases) && aliases.includes(language)) || languages.find(({\n        extensions\n      }) => Array.isArray(extensions) && extensions.includes(`.${language}`));\n      return matched && matched.parsers[0];\n    }\n    function isFrontMatterNode(node) {\n      return node && node.type === "front-matter";\n    }\n    function createGroupIdMapper(description) {\n      const groupIds = /* @__PURE__ */ new WeakMap();\n      return function(node) {\n        if (!groupIds.has(node)) {\n          groupIds.set(node, Symbol(description));\n        }\n        return groupIds.get(node);\n      };\n    }\n    function describeNodeForDebugging(node) {\n      const nodeType = node.type || node.kind || "(unknown type)";\n      let nodeName = String(node.name || node.id && (typeof node.id === "object" ? node.id.name : node.id) || node.key && (typeof node.key === "object" ? node.key.name : node.key) || node.value && (typeof node.value === "object" ? "" : String(node.value)) || node.operator || "");\n      if (nodeName.length > 20) {\n        nodeName = nodeName.slice(0, 19) + "\\u2026";\n      }\n      return nodeType + (nodeName ? " " + nodeName : "");\n    }\n    module2.exports = {\n      inferParserByLanguage,\n      getStringWidth,\n      getMaxContinuousCount,\n      getMinNotPresentContinuousCount,\n      getPenultimate,\n      getLast,\n      getNextNonSpaceNonCommentCharacterIndexWithStartIndex,\n      getNextNonSpaceNonCommentCharacterIndex,\n      getNextNonSpaceNonCommentCharacter,\n      skip,\n      skipWhitespace,\n      skipSpaces,\n      skipToLineEnd,\n      skipEverythingButNewLine,\n      skipInlineComment,\n      skipTrailingComment,\n      skipNewline,\n      isNextLineEmptyAfterIndex,\n      isNextLineEmpty,\n      isPreviousLineEmpty,\n      hasNewline,\n      hasNewlineInRange,\n      hasSpaces,\n      getAlignmentSize,\n      getIndentSize,\n      getPreferredQuote,\n      printString,\n      printNumber,\n      makeString,\n      addLeadingComment,\n      addDanglingComment,\n      addTrailingComment,\n      isFrontMatterNode,\n      isNonEmptyArray,\n      createGroupIdMapper\n    };\n  }\n});\nvar require_end_of_line = __commonJS2({\n  "src/common/end-of-line.js"(exports2, module2) {\n    "use strict";\n    function guessEndOfLine(text) {\n      const index = text.indexOf("\\r");\n      if (index >= 0) {\n        return text.charAt(index + 1) === "\\n" ? "crlf" : "cr";\n      }\n      return "lf";\n    }\n    function convertEndOfLineToChars(value) {\n      switch (value) {\n        case "cr":\n          return "\\r";\n        case "crlf":\n          return "\\r\\n";\n        default:\n          return "\\n";\n      }\n    }\n    function countEndOfLineChars(text, eol) {\n      let regex;\n      switch (eol) {\n        case "\\n":\n          regex = /\\n/g;\n          break;\n        case "\\r":\n          regex = /\\r/g;\n          break;\n        case "\\r\\n":\n          regex = /\\r\\n/g;\n          break;\n        default:\n          throw new Error(`Unexpected "eol" ${JSON.stringify(eol)}.`);\n      }\n      const endOfLines = text.match(regex);\n      return endOfLines ? endOfLines.length : 0;\n    }\n    function normalizeEndOfLine(text) {\n      return text.replace(/\\r\\n?/g, "\\n");\n    }\n    module2.exports = {\n      guessEndOfLine,\n      convertEndOfLineToChars,\n      countEndOfLineChars,\n      normalizeEndOfLine\n    };\n  }\n});\nvar require_errors = __commonJS2({\n  "src/common/errors.js"(exports2, module2) {\n    "use strict";\n    var ConfigError = class extends Error {\n    };\n    var DebugError = class extends Error {\n    };\n    var UndefinedParserError = class extends Error {\n    };\n    var ArgExpansionBailout = class extends Error {\n    };\n    module2.exports = {\n      ConfigError,\n      DebugError,\n      UndefinedParserError,\n      ArgExpansionBailout\n    };\n  }\n});\nvar tslib_es6_exports = {};\n__export(tslib_es6_exports, {\n  __assign: () => __assign,\n  __asyncDelegator: () => __asyncDelegator,\n  __asyncGenerator: () => __asyncGenerator,\n  __asyncValues: () => __asyncValues,\n  __await: () => __await,\n  __awaiter: () => __awaiter,\n  __classPrivateFieldGet: () => __classPrivateFieldGet,\n  __classPrivateFieldSet: () => __classPrivateFieldSet,\n  __createBinding: () => __createBinding,\n  __decorate: () => __decorate,\n  __exportStar: () => __exportStar,\n  __extends: () => __extends,\n  __generator: () => __generator,\n  __importDefault: () => __importDefault,\n  __importStar: () => __importStar,\n  __makeTemplateObject: () => __makeTemplateObject,\n  __metadata: () => __metadata,\n  __param: () => __param,\n  __read: () => __read,\n  __rest: () => __rest,\n  __spread: () => __spread,\n  __spreadArrays: () => __spreadArrays,\n  __values: () => __values\n});\nfunction __extends(d, b) {\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s)\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === "function")\n    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n        t[p[i]] = s[p[i]];\n    }\n  return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __param(paramIndex, decorator) {\n  return function(target, key) {\n    decorator(target, key, paramIndex);\n  };\n}\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")\n    return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator["throw"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function() {\n      if (t[0] & 1)\n        throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  }, f, y, t, g;\n  return g = {\n    next: verb(0),\n    "throw": verb(1),\n    "return": verb(2)\n  }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {\n    return this;\n  }), g;\n  function verb(n) {\n    return function(v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f)\n      throw new TypeError("Generator is already executing.");\n    while (_)\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n          return t;\n        if (y = 0, t)\n          op = [op[0] & 2, t.value];\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n          case 7:\n            op = _.ops.pop();\n            _.trys.pop();\n            continue;\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n              _.ops.push(op);\n              break;\n            }\n            if (t[2])\n              _.ops.pop();\n            _.trys.pop();\n            continue;\n        }\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    if (op[0] & 5)\n      throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\nfunction __createBinding(o, m, k, k2) {\n  if (k2 === void 0)\n    k2 = k;\n  o[k2] = m[k];\n}\nfunction __exportStar(m, exports2) {\n  for (var p in m)\n    if (p !== "default" && !exports2.hasOwnProperty(p))\n      exports2[p] = m[p];\n}\nfunction __values(o) {\n  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m)\n    return m.call(o);\n  if (o && typeof o.length === "number")\n    return {\n      next: function() {\n        if (o && i >= o.length)\n          o = void 0;\n        return {\n          value: o && o[i++],\n          done: !o\n        };\n      }\n    };\n  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\n}\nfunction __read(o, n) {\n  var m = typeof Symbol === "function" && o[Symbol.iterator];\n  if (!m)\n    return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)\n      ar.push(r.value);\n  } catch (error) {\n    e = {\n      error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i["return"]))\n        m.call(i);\n    } finally {\n      if (e)\n        throw e.error;\n    }\n  }\n  return ar;\n}\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n    ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++)\n    s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n      r[k] = a[j];\n  return r;\n}\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError("Symbol.asyncIterator is not defined.");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i;\n  function verb(n) {\n    if (g[n])\n      i[n] = function(v) {\n        return new Promise(function(a, b) {\n          q.push([n, v, a, b]) > 1 || resume(n, v);\n        });\n      };\n  }\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n  function fulfill(value) {\n    resume("next", value);\n  }\n  function reject(value) {\n    resume("throw", value);\n  }\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length)\n      resume(q[0][0], q[0][1]);\n  }\n}\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb("next"), verb("throw", function(e) {\n    throw e;\n  }), verb("return"), i[Symbol.iterator] = function() {\n    return this;\n  }, i;\n  function verb(n, f) {\n    i[n] = o[n] ? function(v) {\n      return (p = !p) ? {\n        value: __await(o[n](v)),\n        done: n === "return"\n      } : f ? f(v) : v;\n    } : f;\n  }\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator)\n    throw new TypeError("Symbol.asyncIterator is not defined.");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function(v) {\n      return new Promise(function(resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function(v2) {\n      resolve({\n        value: v2,\n        done: d\n      });\n    }, reject);\n  }\n}\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) {\n    Object.defineProperty(cooked, "raw", {\n      value: raw\n    });\n  } else {\n    cooked.raw = raw;\n  }\n  return cooked;\n}\nfunction __importStar(mod) {\n  if (mod && mod.__esModule)\n    return mod;\n  var result = {};\n  if (mod != null) {\n    for (var k in mod)\n      if (Object.hasOwnProperty.call(mod, k))\n        result[k] = mod[k];\n  }\n  result.default = mod;\n  return result;\n}\nfunction __importDefault(mod) {\n  return mod && mod.__esModule ? mod : {\n    default: mod\n  };\n}\nfunction __classPrivateFieldGet(receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError("attempted to get private field on non-instance");\n  }\n  return privateMap.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError("attempted to set private field on non-instance");\n  }\n  privateMap.set(receiver, value);\n  return value;\n}\nvar extendStatics;\nvar __assign;\nvar init_tslib_es6 = __esm({\n  "node_modules/tslib/tslib.es6.js"() {\n    extendStatics = function(d, b) {\n      extendStatics = Object.setPrototypeOf || {\n        __proto__: []\n      } instanceof Array && function(d2, b2) {\n        d2.__proto__ = b2;\n      } || function(d2, b2) {\n        for (var p in b2)\n          if (b2.hasOwnProperty(p))\n            d2[p] = b2[p];\n      };\n      return extendStatics(d, b);\n    };\n    __assign = function() {\n      __assign = Object.assign || function __assign2(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s)\n            if (Object.prototype.hasOwnProperty.call(s, p))\n              t[p] = s[p];\n        }\n        return t;\n      };\n      return __assign.apply(this, arguments);\n    };\n  }\n});\nvar require_api = __commonJS2({\n  "node_modules/vnopts/lib/descriptors/api.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.apiDescriptor = {\n      key: (key) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(key) ? key : JSON.stringify(key),\n      value(value) {\n        if (value === null || typeof value !== "object") {\n          return JSON.stringify(value);\n        }\n        if (Array.isArray(value)) {\n          return `[${value.map((subValue) => exports2.apiDescriptor.value(subValue)).join(", ")}]`;\n        }\n        const keys = Object.keys(value);\n        return keys.length === 0 ? "{}" : `{ ${keys.map((key) => `${exports2.apiDescriptor.key(key)}: ${exports2.apiDescriptor.value(value[key])}`).join(", ")} }`;\n      },\n      pair: ({\n        key,\n        value\n      }) => exports2.apiDescriptor.value({\n        [key]: value\n      })\n    };\n  }\n});\nvar require_descriptors2 = __commonJS2({\n  "node_modules/vnopts/lib/descriptors/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    tslib_1.__exportStar(require_api(), exports2);\n  }\n});\nvar require_escape_string_regexp = __commonJS2({\n  "node_modules/vnopts/node_modules/escape-string-regexp/index.js"(exports2, module2) {\n    "use strict";\n    var matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n    module2.exports = function(str) {\n      if (typeof str !== "string") {\n        throw new TypeError("Expected a string");\n      }\n      return str.replace(matchOperatorsRe, "\\\\$&");\n    };\n  }\n});\nvar require_color_name = __commonJS2({\n  "node_modules/color-name/index.js"(exports2, module2) {\n    "use strict";\n    module2.exports = {\n      "aliceblue": [240, 248, 255],\n      "antiquewhite": [250, 235, 215],\n      "aqua": [0, 255, 255],\n      "aquamarine": [127, 255, 212],\n      "azure": [240, 255, 255],\n      "beige": [245, 245, 220],\n      "bisque": [255, 228, 196],\n      "black": [0, 0, 0],\n      "blanchedalmond": [255, 235, 205],\n      "blue": [0, 0, 255],\n      "blueviolet": [138, 43, 226],\n      "brown": [165, 42, 42],\n      "burlywood": [222, 184, 135],\n      "cadetblue": [95, 158, 160],\n      "chartreuse": [127, 255, 0],\n      "chocolate": [210, 105, 30],\n      "coral": [255, 127, 80],\n      "cornflowerblue": [100, 149, 237],\n      "cornsilk": [255, 248, 220],\n      "crimson": [220, 20, 60],\n      "cyan": [0, 255, 255],\n      "darkblue": [0, 0, 139],\n      "darkcyan": [0, 139, 139],\n      "darkgoldenrod": [184, 134, 11],\n      "darkgray": [169, 169, 169],\n      "darkgreen": [0, 100, 0],\n      "darkgrey": [169, 169, 169],\n      "darkkhaki": [189, 183, 107],\n      "darkmagenta": [139, 0, 139],\n      "darkolivegreen": [85, 107, 47],\n      "darkorange": [255, 140, 0],\n      "darkorchid": [153, 50, 204],\n      "darkred": [139, 0, 0],\n      "darksalmon": [233, 150, 122],\n      "darkseagreen": [143, 188, 143],\n      "darkslateblue": [72, 61, 139],\n      "darkslategray": [47, 79, 79],\n      "darkslategrey": [47, 79, 79],\n      "darkturquoise": [0, 206, 209],\n      "darkviolet": [148, 0, 211],\n      "deeppink": [255, 20, 147],\n      "deepskyblue": [0, 191, 255],\n      "dimgray": [105, 105, 105],\n      "dimgrey": [105, 105, 105],\n      "dodgerblue": [30, 144, 255],\n      "firebrick": [178, 34, 34],\n      "floralwhite": [255, 250, 240],\n      "forestgreen": [34, 139, 34],\n      "fuchsia": [255, 0, 255],\n      "gainsboro": [220, 220, 220],\n      "ghostwhite": [248, 248, 255],\n      "gold": [255, 215, 0],\n      "goldenrod": [218, 165, 32],\n      "gray": [128, 128, 128],\n      "green": [0, 128, 0],\n      "greenyellow": [173, 255, 47],\n      "grey": [128, 128, 128],\n      "honeydew": [240, 255, 240],\n      "hotpink": [255, 105, 180],\n      "indianred": [205, 92, 92],\n      "indigo": [75, 0, 130],\n      "ivory": [255, 255, 240],\n      "khaki": [240, 230, 140],\n      "lavender": [230, 230, 250],\n      "lavenderblush": [255, 240, 245],\n      "lawngreen": [124, 252, 0],\n      "lemonchiffon": [255, 250, 205],\n      "lightblue": [173, 216, 230],\n      "lightcoral": [240, 128, 128],\n      "lightcyan": [224, 255, 255],\n      "lightgoldenrodyellow": [250, 250, 210],\n      "lightgray": [211, 211, 211],\n      "lightgreen": [144, 238, 144],\n      "lightgrey": [211, 211, 211],\n      "lightpink": [255, 182, 193],\n      "lightsalmon": [255, 160, 122],\n      "lightseagreen": [32, 178, 170],\n      "lightskyblue": [135, 206, 250],\n      "lightslategray": [119, 136, 153],\n      "lightslategrey": [119, 136, 153],\n      "lightsteelblue": [176, 196, 222],\n      "lightyellow": [255, 255, 224],\n      "lime": [0, 255, 0],\n      "limegreen": [50, 205, 50],\n      "linen": [250, 240, 230],\n      "magenta": [255, 0, 255],\n      "maroon": [128, 0, 0],\n      "mediumaquamarine": [102, 205, 170],\n      "mediumblue": [0, 0, 205],\n      "mediumorchid": [186, 85, 211],\n      "mediumpurple": [147, 112, 219],\n      "mediumseagreen": [60, 179, 113],\n      "mediumslateblue": [123, 104, 238],\n      "mediumspringgreen": [0, 250, 154],\n      "mediumturquoise": [72, 209, 204],\n      "mediumvioletred": [199, 21, 133],\n      "midnightblue": [25, 25, 112],\n      "mintcream": [245, 255, 250],\n      "mistyrose": [255, 228, 225],\n      "moccasin": [255, 228, 181],\n      "navajowhite": [255, 222, 173],\n      "navy": [0, 0, 128],\n      "oldlace": [253, 245, 230],\n      "olive": [128, 128, 0],\n      "olivedrab": [107, 142, 35],\n      "orange": [255, 165, 0],\n      "orangered": [255, 69, 0],\n      "orchid": [218, 112, 214],\n      "palegoldenrod": [238, 232, 170],\n      "palegreen": [152, 251, 152],\n      "paleturquoise": [175, 238, 238],\n      "palevioletred": [219, 112, 147],\n      "papayawhip": [255, 239, 213],\n      "peachpuff": [255, 218, 185],\n      "peru": [205, 133, 63],\n      "pink": [255, 192, 203],\n      "plum": [221, 160, 221],\n      "powderblue": [176, 224, 230],\n      "purple": [128, 0, 128],\n      "rebeccapurple": [102, 51, 153],\n      "red": [255, 0, 0],\n      "rosybrown": [188, 143, 143],\n      "royalblue": [65, 105, 225],\n      "saddlebrown": [139, 69, 19],\n      "salmon": [250, 128, 114],\n      "sandybrown": [244, 164, 96],\n      "seagreen": [46, 139, 87],\n      "seashell": [255, 245, 238],\n      "sienna": [160, 82, 45],\n      "silver": [192, 192, 192],\n      "skyblue": [135, 206, 235],\n      "slateblue": [106, 90, 205],\n      "slategray": [112, 128, 144],\n      "slategrey": [112, 128, 144],\n      "snow": [255, 250, 250],\n      "springgreen": [0, 255, 127],\n      "steelblue": [70, 130, 180],\n      "tan": [210, 180, 140],\n      "teal": [0, 128, 128],\n      "thistle": [216, 191, 216],\n      "tomato": [255, 99, 71],\n      "turquoise": [64, 224, 208],\n      "violet": [238, 130, 238],\n      "wheat": [245, 222, 179],\n      "white": [255, 255, 255],\n      "whitesmoke": [245, 245, 245],\n      "yellow": [255, 255, 0],\n      "yellowgreen": [154, 205, 50]\n    };\n  }\n});\nvar require_conversions = __commonJS2({\n  "node_modules/color-convert/conversions.js"(exports2, module2) {\n    var cssKeywords = require_color_name();\n    var reverseKeywords = {};\n    for (key in cssKeywords) {\n      if (cssKeywords.hasOwnProperty(key)) {\n        reverseKeywords[cssKeywords[key]] = key;\n      }\n    }\n    var key;\n    var convert = module2.exports = {\n      rgb: {\n        channels: 3,\n        labels: "rgb"\n      },\n      hsl: {\n        channels: 3,\n        labels: "hsl"\n      },\n      hsv: {\n        channels: 3,\n        labels: "hsv"\n      },\n      hwb: {\n        channels: 3,\n        labels: "hwb"\n      },\n      cmyk: {\n        channels: 4,\n        labels: "cmyk"\n      },\n      xyz: {\n        channels: 3,\n        labels: "xyz"\n      },\n      lab: {\n        channels: 3,\n        labels: "lab"\n      },\n      lch: {\n        channels: 3,\n        labels: "lch"\n      },\n      hex: {\n        channels: 1,\n        labels: ["hex"]\n      },\n      keyword: {\n        channels: 1,\n        labels: ["keyword"]\n      },\n      ansi16: {\n        channels: 1,\n        labels: ["ansi16"]\n      },\n      ansi256: {\n        channels: 1,\n        labels: ["ansi256"]\n      },\n      hcg: {\n        channels: 3,\n        labels: ["h", "c", "g"]\n      },\n      apple: {\n        channels: 3,\n        labels: ["r16", "g16", "b16"]\n      },\n      gray: {\n        channels: 1,\n        labels: ["gray"]\n      }\n    };\n    for (model in convert) {\n      if (convert.hasOwnProperty(model)) {\n        if (!("channels" in convert[model])) {\n          throw new Error("missing channels property: " + model);\n        }\n        if (!("labels" in convert[model])) {\n          throw new Error("missing channel labels property: " + model);\n        }\n        if (convert[model].labels.length !== convert[model].channels) {\n          throw new Error("channel and label counts mismatch: " + model);\n        }\n        channels = convert[model].channels;\n        labels = convert[model].labels;\n        delete convert[model].channels;\n        delete convert[model].labels;\n        Object.defineProperty(convert[model], "channels", {\n          value: channels\n        });\n        Object.defineProperty(convert[model], "labels", {\n          value: labels\n        });\n      }\n    }\n    var channels;\n    var labels;\n    var model;\n    convert.rgb.hsl = function(rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var min = Math.min(r, g, b);\n      var max = Math.max(r, g, b);\n      var delta = max - min;\n      var h;\n      var s;\n      var l;\n      if (max === min) {\n        h = 0;\n      } else if (r === max) {\n        h = (g - b) / delta;\n      } else if (g === max) {\n        h = 2 + (b - r) / delta;\n      } else if (b === max) {\n        h = 4 + (r - g) / delta;\n      }\n      h = Math.min(h * 60, 360);\n      if (h < 0) {\n        h += 360;\n      }\n      l = (min + max) / 2;\n      if (max === min) {\n        s = 0;\n      } else if (l <= 0.5) {\n        s = delta / (max + min);\n      } else {\n        s = delta / (2 - max - min);\n      }\n      return [h, s * 100, l * 100];\n    };\n    convert.rgb.hsv = function(rgb) {\n      var rdif;\n      var gdif;\n      var bdif;\n      var h;\n      var s;\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var v = Math.max(r, g, b);\n      var diff = v - Math.min(r, g, b);\n      var diffc = function(c) {\n        return (v - c) / 6 / diff + 1 / 2;\n      };\n      if (diff === 0) {\n        h = s = 0;\n      } else {\n        s = diff / v;\n        rdif = diffc(r);\n        gdif = diffc(g);\n        bdif = diffc(b);\n        if (r === v) {\n          h = bdif - gdif;\n        } else if (g === v) {\n          h = 1 / 3 + rdif - bdif;\n        } else if (b === v) {\n          h = 2 / 3 + gdif - rdif;\n        }\n        if (h < 0) {\n          h += 1;\n        } else if (h > 1) {\n          h -= 1;\n        }\n      }\n      return [h * 360, s * 100, v * 100];\n    };\n    convert.rgb.hwb = function(rgb) {\n      var r = rgb[0];\n      var g = rgb[1];\n      var b = rgb[2];\n      var h = convert.rgb.hsl(rgb)[0];\n      var w = 1 / 255 * Math.min(r, Math.min(g, b));\n      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n      return [h, w * 100, b * 100];\n    };\n    convert.rgb.cmyk = function(rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var c;\n      var m;\n      var y;\n      var k;\n      k = Math.min(1 - r, 1 - g, 1 - b);\n      c = (1 - r - k) / (1 - k) || 0;\n      m = (1 - g - k) / (1 - k) || 0;\n      y = (1 - b - k) / (1 - k) || 0;\n      return [c * 100, m * 100, y * 100, k * 100];\n    };\n    function comparativeDistance(x, y) {\n      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);\n    }\n    convert.rgb.keyword = function(rgb) {\n      var reversed = reverseKeywords[rgb];\n      if (reversed) {\n        return reversed;\n      }\n      var currentClosestDistance = Infinity;\n      var currentClosestKeyword;\n      for (var keyword in cssKeywords) {\n        if (cssKeywords.hasOwnProperty(keyword)) {\n          var value = cssKeywords[keyword];\n          var distance = comparativeDistance(rgb, value);\n          if (distance < currentClosestDistance) {\n            currentClosestDistance = distance;\n            currentClosestKeyword = keyword;\n          }\n        }\n      }\n      return currentClosestKeyword;\n    };\n    convert.keyword.rgb = function(keyword) {\n      return cssKeywords[keyword];\n    };\n    convert.rgb.xyz = function(rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;\n      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;\n      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;\n      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n      return [x * 100, y * 100, z * 100];\n    };\n    convert.rgb.lab = function(rgb) {\n      var xyz = convert.rgb.xyz(rgb);\n      var x = xyz[0];\n      var y = xyz[1];\n      var z = xyz[2];\n      var l;\n      var a;\n      var b;\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n      l = 116 * y - 16;\n      a = 500 * (x - y);\n      b = 200 * (y - z);\n      return [l, a, b];\n    };\n    convert.hsl.rgb = function(hsl) {\n      var h = hsl[0] / 360;\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var t1;\n      var t2;\n      var t3;\n      var rgb;\n      var val;\n      if (s === 0) {\n        val = l * 255;\n        return [val, val, val];\n      }\n      if (l < 0.5) {\n        t2 = l * (1 + s);\n      } else {\n        t2 = l + s - l * s;\n      }\n      t1 = 2 * l - t2;\n      rgb = [0, 0, 0];\n      for (var i = 0; i < 3; i++) {\n        t3 = h + 1 / 3 * -(i - 1);\n        if (t3 < 0) {\n          t3++;\n        }\n        if (t3 > 1) {\n          t3--;\n        }\n        if (6 * t3 < 1) {\n          val = t1 + (t2 - t1) * 6 * t3;\n        } else if (2 * t3 < 1) {\n          val = t2;\n        } else if (3 * t3 < 2) {\n          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n        } else {\n          val = t1;\n        }\n        rgb[i] = val * 255;\n      }\n      return rgb;\n    };\n    convert.hsl.hsv = function(hsl) {\n      var h = hsl[0];\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var smin = s;\n      var lmin = Math.max(l, 0.01);\n      var sv;\n      var v;\n      l *= 2;\n      s *= l <= 1 ? l : 2 - l;\n      smin *= lmin <= 1 ? lmin : 2 - lmin;\n      v = (l + s) / 2;\n      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);\n      return [h, sv * 100, v * 100];\n    };\n    convert.hsv.rgb = function(hsv) {\n      var h = hsv[0] / 60;\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var hi = Math.floor(h) % 6;\n      var f = h - Math.floor(h);\n      var p = 255 * v * (1 - s);\n      var q = 255 * v * (1 - s * f);\n      var t = 255 * v * (1 - s * (1 - f));\n      v *= 255;\n      switch (hi) {\n        case 0:\n          return [v, t, p];\n        case 1:\n          return [q, v, p];\n        case 2:\n          return [p, v, t];\n        case 3:\n          return [p, q, v];\n        case 4:\n          return [t, p, v];\n        case 5:\n          return [v, p, q];\n      }\n    };\n    convert.hsv.hsl = function(hsv) {\n      var h = hsv[0];\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var vmin = Math.max(v, 0.01);\n      var lmin;\n      var sl;\n      var l;\n      l = (2 - s) * v;\n      lmin = (2 - s) * vmin;\n      sl = s * vmin;\n      sl /= lmin <= 1 ? lmin : 2 - lmin;\n      sl = sl || 0;\n      l /= 2;\n      return [h, sl * 100, l * 100];\n    };\n    convert.hwb.rgb = function(hwb) {\n      var h = hwb[0] / 360;\n      var wh = hwb[1] / 100;\n      var bl = hwb[2] / 100;\n      var ratio = wh + bl;\n      var i;\n      var v;\n      var f;\n      var n;\n      if (ratio > 1) {\n        wh /= ratio;\n        bl /= ratio;\n      }\n      i = Math.floor(6 * h);\n      v = 1 - bl;\n      f = 6 * h - i;\n      if ((i & 1) !== 0) {\n        f = 1 - f;\n      }\n      n = wh + f * (v - wh);\n      var r;\n      var g;\n      var b;\n      switch (i) {\n        default:\n        case 6:\n        case 0:\n          r = v;\n          g = n;\n          b = wh;\n          break;\n        case 1:\n          r = n;\n          g = v;\n          b = wh;\n          break;\n        case 2:\n          r = wh;\n          g = v;\n          b = n;\n          break;\n        case 3:\n          r = wh;\n          g = n;\n          b = v;\n          break;\n        case 4:\n          r = n;\n          g = wh;\n          b = v;\n          break;\n        case 5:\n          r = v;\n          g = wh;\n          b = n;\n          break;\n      }\n      return [r * 255, g * 255, b * 255];\n    };\n    convert.cmyk.rgb = function(cmyk) {\n      var c = cmyk[0] / 100;\n      var m = cmyk[1] / 100;\n      var y = cmyk[2] / 100;\n      var k = cmyk[3] / 100;\n      var r;\n      var g;\n      var b;\n      r = 1 - Math.min(1, c * (1 - k) + k);\n      g = 1 - Math.min(1, m * (1 - k) + k);\n      b = 1 - Math.min(1, y * (1 - k) + k);\n      return [r * 255, g * 255, b * 255];\n    };\n    convert.xyz.rgb = function(xyz) {\n      var x = xyz[0] / 100;\n      var y = xyz[1] / 100;\n      var z = xyz[2] / 100;\n      var r;\n      var g;\n      var b;\n      r = x * 3.2406 + y * -1.5372 + z * -0.4986;\n      g = x * -0.9689 + y * 1.8758 + z * 0.0415;\n      b = x * 0.0557 + y * -0.204 + z * 1.057;\n      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;\n      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;\n      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;\n      r = Math.min(Math.max(0, r), 1);\n      g = Math.min(Math.max(0, g), 1);\n      b = Math.min(Math.max(0, b), 1);\n      return [r * 255, g * 255, b * 255];\n    };\n    convert.xyz.lab = function(xyz) {\n      var x = xyz[0];\n      var y = xyz[1];\n      var z = xyz[2];\n      var l;\n      var a;\n      var b;\n      x /= 95.047;\n      y /= 100;\n      z /= 108.883;\n      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n      z = z > 8856e-6 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n      l = 116 * y - 16;\n      a = 500 * (x - y);\n      b = 200 * (y - z);\n      return [l, a, b];\n    };\n    convert.lab.xyz = function(lab) {\n      var l = lab[0];\n      var a = lab[1];\n      var b = lab[2];\n      var x;\n      var y;\n      var z;\n      y = (l + 16) / 116;\n      x = a / 500 + y;\n      z = y - b / 200;\n      var y2 = Math.pow(y, 3);\n      var x2 = Math.pow(x, 3);\n      var z2 = Math.pow(z, 3);\n      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;\n      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;\n      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;\n      x *= 95.047;\n      y *= 100;\n      z *= 108.883;\n      return [x, y, z];\n    };\n    convert.lab.lch = function(lab) {\n      var l = lab[0];\n      var a = lab[1];\n      var b = lab[2];\n      var hr;\n      var h;\n      var c;\n      hr = Math.atan2(b, a);\n      h = hr * 360 / 2 / Math.PI;\n      if (h < 0) {\n        h += 360;\n      }\n      c = Math.sqrt(a * a + b * b);\n      return [l, c, h];\n    };\n    convert.lch.lab = function(lch) {\n      var l = lch[0];\n      var c = lch[1];\n      var h = lch[2];\n      var a;\n      var b;\n      var hr;\n      hr = h / 360 * 2 * Math.PI;\n      a = c * Math.cos(hr);\n      b = c * Math.sin(hr);\n      return [l, a, b];\n    };\n    convert.rgb.ansi16 = function(args) {\n      var r = args[0];\n      var g = args[1];\n      var b = args[2];\n      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];\n      value = Math.round(value / 50);\n      if (value === 0) {\n        return 30;\n      }\n      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));\n      if (value === 2) {\n        ansi += 60;\n      }\n      return ansi;\n    };\n    convert.hsv.ansi16 = function(args) {\n      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n    };\n    convert.rgb.ansi256 = function(args) {\n      var r = args[0];\n      var g = args[1];\n      var b = args[2];\n      if (r === g && g === b) {\n        if (r < 8) {\n          return 16;\n        }\n        if (r > 248) {\n          return 231;\n        }\n        return Math.round((r - 8) / 247 * 24) + 232;\n      }\n      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);\n      return ansi;\n    };\n    convert.ansi16.rgb = function(args) {\n      var color = args % 10;\n      if (color === 0 || color === 7) {\n        if (args > 50) {\n          color += 3.5;\n        }\n        color = color / 10.5 * 255;\n        return [color, color, color];\n      }\n      var mult = (~~(args > 50) + 1) * 0.5;\n      var r = (color & 1) * mult * 255;\n      var g = (color >> 1 & 1) * mult * 255;\n      var b = (color >> 2 & 1) * mult * 255;\n      return [r, g, b];\n    };\n    convert.ansi256.rgb = function(args) {\n      if (args >= 232) {\n        var c = (args - 232) * 10 + 8;\n        return [c, c, c];\n      }\n      args -= 16;\n      var rem;\n      var r = Math.floor(args / 36) / 5 * 255;\n      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n      var b = rem % 6 / 5 * 255;\n      return [r, g, b];\n    };\n    convert.rgb.hex = function(args) {\n      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);\n      var string = integer.toString(16).toUpperCase();\n      return "000000".substring(string.length) + string;\n    };\n    convert.hex.rgb = function(args) {\n      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n      if (!match) {\n        return [0, 0, 0];\n      }\n      var colorString = match[0];\n      if (match[0].length === 3) {\n        colorString = colorString.split("").map(function(char) {\n          return char + char;\n        }).join("");\n      }\n      var integer = parseInt(colorString, 16);\n      var r = integer >> 16 & 255;\n      var g = integer >> 8 & 255;\n      var b = integer & 255;\n      return [r, g, b];\n    };\n    convert.rgb.hcg = function(rgb) {\n      var r = rgb[0] / 255;\n      var g = rgb[1] / 255;\n      var b = rgb[2] / 255;\n      var max = Math.max(Math.max(r, g), b);\n      var min = Math.min(Math.min(r, g), b);\n      var chroma = max - min;\n      var grayscale;\n      var hue;\n      if (chroma < 1) {\n        grayscale = min / (1 - chroma);\n      } else {\n        grayscale = 0;\n      }\n      if (chroma <= 0) {\n        hue = 0;\n      } else if (max === r) {\n        hue = (g - b) / chroma % 6;\n      } else if (max === g) {\n        hue = 2 + (b - r) / chroma;\n      } else {\n        hue = 4 + (r - g) / chroma + 4;\n      }\n      hue /= 6;\n      hue %= 1;\n      return [hue * 360, chroma * 100, grayscale * 100];\n    };\n    convert.hsl.hcg = function(hsl) {\n      var s = hsl[1] / 100;\n      var l = hsl[2] / 100;\n      var c = 1;\n      var f = 0;\n      if (l < 0.5) {\n        c = 2 * s * l;\n      } else {\n        c = 2 * s * (1 - l);\n      }\n      if (c < 1) {\n        f = (l - 0.5 * c) / (1 - c);\n      }\n      return [hsl[0], c * 100, f * 100];\n    };\n    convert.hsv.hcg = function(hsv) {\n      var s = hsv[1] / 100;\n      var v = hsv[2] / 100;\n      var c = s * v;\n      var f = 0;\n      if (c < 1) {\n        f = (v - c) / (1 - c);\n      }\n      return [hsv[0], c * 100, f * 100];\n    };\n    convert.hcg.rgb = function(hcg) {\n      var h = hcg[0] / 360;\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      if (c === 0) {\n        return [g * 255, g * 255, g * 255];\n      }\n      var pure = [0, 0, 0];\n      var hi = h % 1 * 6;\n      var v = hi % 1;\n      var w = 1 - v;\n      var mg = 0;\n      switch (Math.floor(hi)) {\n        case 0:\n          pure[0] = 1;\n          pure[1] = v;\n          pure[2] = 0;\n          break;\n        case 1:\n          pure[0] = w;\n          pure[1] = 1;\n          pure[2] = 0;\n          break;\n        case 2:\n          pure[0] = 0;\n          pure[1] = 1;\n          pure[2] = v;\n          break;\n        case 3:\n          pure[0] = 0;\n          pure[1] = w;\n          pure[2] = 1;\n          break;\n        case 4:\n          pure[0] = v;\n          pure[1] = 0;\n          pure[2] = 1;\n          break;\n        default:\n          pure[0] = 1;\n          pure[1] = 0;\n          pure[2] = w;\n      }\n      mg = (1 - c) * g;\n      return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];\n    };\n    convert.hcg.hsv = function(hcg) {\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var v = c + g * (1 - c);\n      var f = 0;\n      if (v > 0) {\n        f = c / v;\n      }\n      return [hcg[0], f * 100, v * 100];\n    };\n    convert.hcg.hsl = function(hcg) {\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var l = g * (1 - c) + 0.5 * c;\n      var s = 0;\n      if (l > 0 && l < 0.5) {\n        s = c / (2 * l);\n      } else if (l >= 0.5 && l < 1) {\n        s = c / (2 * (1 - l));\n      }\n      return [hcg[0], s * 100, l * 100];\n    };\n    convert.hcg.hwb = function(hcg) {\n      var c = hcg[1] / 100;\n      var g = hcg[2] / 100;\n      var v = c + g * (1 - c);\n      return [hcg[0], (v - c) * 100, (1 - v) * 100];\n    };\n    convert.hwb.hcg = function(hwb) {\n      var w = hwb[1] / 100;\n      var b = hwb[2] / 100;\n      var v = 1 - b;\n      var c = v - w;\n      var g = 0;\n      if (c < 1) {\n        g = (v - c) / (1 - c);\n      }\n      return [hwb[0], c * 100, g * 100];\n    };\n    convert.apple.rgb = function(apple) {\n      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];\n    };\n    convert.rgb.apple = function(rgb) {\n      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];\n    };\n    convert.gray.rgb = function(args) {\n      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n    };\n    convert.gray.hsl = convert.gray.hsv = function(args) {\n      return [0, 0, args[0]];\n    };\n    convert.gray.hwb = function(gray) {\n      return [0, 100, gray[0]];\n    };\n    convert.gray.cmyk = function(gray) {\n      return [0, 0, 0, gray[0]];\n    };\n    convert.gray.lab = function(gray) {\n      return [gray[0], 0, 0];\n    };\n    convert.gray.hex = function(gray) {\n      var val = Math.round(gray[0] / 100 * 255) & 255;\n      var integer = (val << 16) + (val << 8) + val;\n      var string = integer.toString(16).toUpperCase();\n      return "000000".substring(string.length) + string;\n    };\n    convert.rgb.gray = function(rgb) {\n      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n      return [val / 255 * 100];\n    };\n  }\n});\nvar require_route = __commonJS2({\n  "node_modules/color-convert/route.js"(exports2, module2) {\n    var conversions = require_conversions();\n    function buildGraph() {\n      var graph = {};\n      var models = Object.keys(conversions);\n      for (var len = models.length, i = 0; i < len; i++) {\n        graph[models[i]] = {\n          distance: -1,\n          parent: null\n        };\n      }\n      return graph;\n    }\n    function deriveBFS(fromModel) {\n      var graph = buildGraph();\n      var queue = [fromModel];\n      graph[fromModel].distance = 0;\n      while (queue.length) {\n        var current = queue.pop();\n        var adjacents = Object.keys(conversions[current]);\n        for (var len = adjacents.length, i = 0; i < len; i++) {\n          var adjacent = adjacents[i];\n          var node = graph[adjacent];\n          if (node.distance === -1) {\n            node.distance = graph[current].distance + 1;\n            node.parent = current;\n            queue.unshift(adjacent);\n          }\n        }\n      }\n      return graph;\n    }\n    function link(from, to) {\n      return function(args) {\n        return to(from(args));\n      };\n    }\n    function wrapConversion(toModel, graph) {\n      var path = [graph[toModel].parent, toModel];\n      var fn = conversions[graph[toModel].parent][toModel];\n      var cur = graph[toModel].parent;\n      while (graph[cur].parent) {\n        path.unshift(graph[cur].parent);\n        fn = link(conversions[graph[cur].parent][cur], fn);\n        cur = graph[cur].parent;\n      }\n      fn.conversion = path;\n      return fn;\n    }\n    module2.exports = function(fromModel) {\n      var graph = deriveBFS(fromModel);\n      var conversion = {};\n      var models = Object.keys(graph);\n      for (var len = models.length, i = 0; i < len; i++) {\n        var toModel = models[i];\n        var node = graph[toModel];\n        if (node.parent === null) {\n          continue;\n        }\n        conversion[toModel] = wrapConversion(toModel, graph);\n      }\n      return conversion;\n    };\n  }\n});\nvar require_color_convert = __commonJS2({\n  "node_modules/color-convert/index.js"(exports2, module2) {\n    var conversions = require_conversions();\n    var route = require_route();\n    var convert = {};\n    var models = Object.keys(conversions);\n    function wrapRaw(fn) {\n      var wrappedFn = function(args) {\n        if (args === void 0 || args === null) {\n          return args;\n        }\n        if (arguments.length > 1) {\n          args = Array.prototype.slice.call(arguments);\n        }\n        return fn(args);\n      };\n      if ("conversion" in fn) {\n        wrappedFn.conversion = fn.conversion;\n      }\n      return wrappedFn;\n    }\n    function wrapRounded(fn) {\n      var wrappedFn = function(args) {\n        if (args === void 0 || args === null) {\n          return args;\n        }\n        if (arguments.length > 1) {\n          args = Array.prototype.slice.call(arguments);\n        }\n        var result = fn(args);\n        if (typeof result === "object") {\n          for (var len = result.length, i = 0; i < len; i++) {\n            result[i] = Math.round(result[i]);\n          }\n        }\n        return result;\n      };\n      if ("conversion" in fn) {\n        wrappedFn.conversion = fn.conversion;\n      }\n      return wrappedFn;\n    }\n    models.forEach(function(fromModel) {\n      convert[fromModel] = {};\n      Object.defineProperty(convert[fromModel], "channels", {\n        value: conversions[fromModel].channels\n      });\n      Object.defineProperty(convert[fromModel], "labels", {\n        value: conversions[fromModel].labels\n      });\n      var routes = route(fromModel);\n      var routeModels = Object.keys(routes);\n      routeModels.forEach(function(toModel) {\n        var fn = routes[toModel];\n        convert[fromModel][toModel] = wrapRounded(fn);\n        convert[fromModel][toModel].raw = wrapRaw(fn);\n      });\n    });\n    module2.exports = convert;\n  }\n});\nvar require_ansi_styles = __commonJS2({\n  "node_modules/ansi-styles/index.js"(exports2, module2) {\n    "use strict";\n    var colorConvert = require_color_convert();\n    var wrapAnsi16 = (fn, offset) => function() {\n      const code = fn.apply(colorConvert, arguments);\n      return `\\x1B[${code + offset}m`;\n    };\n    var wrapAnsi256 = (fn, offset) => function() {\n      const code = fn.apply(colorConvert, arguments);\n      return `\\x1B[${38 + offset};5;${code}m`;\n    };\n    var wrapAnsi16m = (fn, offset) => function() {\n      const rgb = fn.apply(colorConvert, arguments);\n      return `\\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n    };\n    function assembleStyles() {\n      const codes = /* @__PURE__ */ new Map();\n      const styles = {\n        modifier: {\n          reset: [0, 0],\n          bold: [1, 22],\n          dim: [2, 22],\n          italic: [3, 23],\n          underline: [4, 24],\n          inverse: [7, 27],\n          hidden: [8, 28],\n          strikethrough: [9, 29]\n        },\n        color: {\n          black: [30, 39],\n          red: [31, 39],\n          green: [32, 39],\n          yellow: [33, 39],\n          blue: [34, 39],\n          magenta: [35, 39],\n          cyan: [36, 39],\n          white: [37, 39],\n          gray: [90, 39],\n          redBright: [91, 39],\n          greenBright: [92, 39],\n          yellowBright: [93, 39],\n          blueBright: [94, 39],\n          magentaBright: [95, 39],\n          cyanBright: [96, 39],\n          whiteBright: [97, 39]\n        },\n        bgColor: {\n          bgBlack: [40, 49],\n          bgRed: [41, 49],\n          bgGreen: [42, 49],\n          bgYellow: [43, 49],\n          bgBlue: [44, 49],\n          bgMagenta: [45, 49],\n          bgCyan: [46, 49],\n          bgWhite: [47, 49],\n          bgBlackBright: [100, 49],\n          bgRedBright: [101, 49],\n          bgGreenBright: [102, 49],\n          bgYellowBright: [103, 49],\n          bgBlueBright: [104, 49],\n          bgMagentaBright: [105, 49],\n          bgCyanBright: [106, 49],\n          bgWhiteBright: [107, 49]\n        }\n      };\n      styles.color.grey = styles.color.gray;\n      for (const groupName of Object.keys(styles)) {\n        const group = styles[groupName];\n        for (const styleName of Object.keys(group)) {\n          const style = group[styleName];\n          styles[styleName] = {\n            open: `\\x1B[${style[0]}m`,\n            close: `\\x1B[${style[1]}m`\n          };\n          group[styleName] = styles[styleName];\n          codes.set(style[0], style[1]);\n        }\n        Object.defineProperty(styles, groupName, {\n          value: group,\n          enumerable: false\n        });\n        Object.defineProperty(styles, "codes", {\n          value: codes,\n          enumerable: false\n        });\n      }\n      const ansi2ansi = (n) => n;\n      const rgb2rgb = (r, g, b) => [r, g, b];\n      styles.color.close = "\\x1B[39m";\n      styles.bgColor.close = "\\x1B[49m";\n      styles.color.ansi = {\n        ansi: wrapAnsi16(ansi2ansi, 0)\n      };\n      styles.color.ansi256 = {\n        ansi256: wrapAnsi256(ansi2ansi, 0)\n      };\n      styles.color.ansi16m = {\n        rgb: wrapAnsi16m(rgb2rgb, 0)\n      };\n      styles.bgColor.ansi = {\n        ansi: wrapAnsi16(ansi2ansi, 10)\n      };\n      styles.bgColor.ansi256 = {\n        ansi256: wrapAnsi256(ansi2ansi, 10)\n      };\n      styles.bgColor.ansi16m = {\n        rgb: wrapAnsi16m(rgb2rgb, 10)\n      };\n      for (let key of Object.keys(colorConvert)) {\n        if (typeof colorConvert[key] !== "object") {\n          continue;\n        }\n        const suite = colorConvert[key];\n        if (key === "ansi16") {\n          key = "ansi";\n        }\n        if ("ansi16" in suite) {\n          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);\n          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);\n        }\n        if ("ansi256" in suite) {\n          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);\n          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);\n        }\n        if ("rgb" in suite) {\n          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);\n          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);\n        }\n      }\n      return styles;\n    }\n    Object.defineProperty(module2, "exports", {\n      enumerable: true,\n      get: assembleStyles\n    });\n  }\n});\nvar require_has_flag = __commonJS2({\n  "node_modules/vnopts/node_modules/has-flag/index.js"(exports2, module2) {\n    "use strict";\n    module2.exports = (flag, argv) => {\n      argv = argv || process.argv;\n      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";\n      const pos = argv.indexOf(prefix + flag);\n      const terminatorPos = argv.indexOf("--");\n      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n    };\n  }\n});\nvar require_supports_color = __commonJS2({\n  "node_modules/vnopts/node_modules/supports-color/index.js"(exports2, module2) {\n    "use strict";\n    var os = require("os");\n    var hasFlag = require_has_flag();\n    var env = process.env;\n    var forceColor;\n    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {\n      forceColor = false;\n    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {\n      forceColor = true;\n    }\n    if ("FORCE_COLOR" in env) {\n      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n    }\n    function translateLevel(level) {\n      if (level === 0) {\n        return false;\n      }\n      return {\n        level,\n        hasBasic: true,\n        has256: level >= 2,\n        has16m: level >= 3\n      };\n    }\n    function supportsColor(stream) {\n      if (forceColor === false) {\n        return 0;\n      }\n      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {\n        return 3;\n      }\n      if (hasFlag("color=256")) {\n        return 2;\n      }\n      if (stream && !stream.isTTY && forceColor !== true) {\n        return 0;\n      }\n      const min = forceColor ? 1 : 0;\n      if (process.platform === "win32") {\n        const osRelease = os.release().split(".");\n        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {\n          return Number(osRelease[2]) >= 14931 ? 3 : 2;\n        }\n        return 1;\n      }\n      if ("CI" in env) {\n        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {\n          return 1;\n        }\n        return min;\n      }\n      if ("TEAMCITY_VERSION" in env) {\n        return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n      }\n      if (env.COLORTERM === "truecolor") {\n        return 3;\n      }\n      if ("TERM_PROGRAM" in env) {\n        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);\n        switch (env.TERM_PROGRAM) {\n          case "iTerm.app":\n            return version2 >= 3 ? 3 : 2;\n          case "Apple_Terminal":\n            return 2;\n        }\n      }\n      if (/-256(color)?$/i.test(env.TERM)) {\n        return 2;\n      }\n      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n        return 1;\n      }\n      if ("COLORTERM" in env) {\n        return 1;\n      }\n      if (env.TERM === "dumb") {\n        return min;\n      }\n      return min;\n    }\n    function getSupportLevel(stream) {\n      const level = supportsColor(stream);\n      return translateLevel(level);\n    }\n    module2.exports = {\n      supportsColor: getSupportLevel,\n      stdout: getSupportLevel(process.stdout),\n      stderr: getSupportLevel(process.stderr)\n    };\n  }\n});\nvar require_templates = __commonJS2({\n  "node_modules/vnopts/node_modules/chalk/templates.js"(exports2, module2) {\n    "use strict";\n    var TEMPLATE_REGEX = /(?:\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\n    var STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\n    var STRING_REGEX = /^([\'"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\n    var ESCAPE_REGEX = /\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n    var ESCAPES = /* @__PURE__ */ new Map([["n", "\\n"], ["r", "\\r"], ["t", "\t"], ["b", "\\b"], ["f", "\\f"], ["v", "\\v"], ["0", "\\0"], ["\\\\", "\\\\"], ["e", "\\x1B"], ["a", "\\x07"]]);\n    function unescape(c) {\n      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {\n        return String.fromCharCode(parseInt(c.slice(1), 16));\n      }\n      return ESCAPES.get(c) || c;\n    }\n    function parseArguments(name, args) {\n      const results = [];\n      const chunks = args.trim().split(/\\s*,\\s*/g);\n      let matches;\n      for (const chunk of chunks) {\n        if (!isNaN(chunk)) {\n          results.push(Number(chunk));\n        } else if (matches = chunk.match(STRING_REGEX)) {\n          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));\n        } else {\n          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style \'${name}\')`);\n        }\n      }\n      return results;\n    }\n    function parseStyle(style) {\n      STYLE_REGEX.lastIndex = 0;\n      const results = [];\n      let matches;\n      while ((matches = STYLE_REGEX.exec(style)) !== null) {\n        const name = matches[1];\n        if (matches[2]) {\n          const args = parseArguments(name, matches[2]);\n          results.push([name].concat(args));\n        } else {\n          results.push([name]);\n        }\n      }\n      return results;\n    }\n    function buildStyle(chalk, styles) {\n      const enabled = {};\n      for (const layer of styles) {\n        for (const style of layer.styles) {\n          enabled[style[0]] = layer.inverse ? null : style.slice(1);\n        }\n      }\n      let current = chalk;\n      for (const styleName of Object.keys(enabled)) {\n        if (Array.isArray(enabled[styleName])) {\n          if (!(styleName in current)) {\n            throw new Error(`Unknown Chalk style: ${styleName}`);\n          }\n          if (enabled[styleName].length > 0) {\n            current = current[styleName].apply(current, enabled[styleName]);\n          } else {\n            current = current[styleName];\n          }\n        }\n      }\n      return current;\n    }\n    module2.exports = (chalk, tmp) => {\n      const styles = [];\n      const chunks = [];\n      let chunk = [];\n      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {\n        if (escapeChar) {\n          chunk.push(unescape(escapeChar));\n        } else if (style) {\n          const str = chunk.join("");\n          chunk = [];\n          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));\n          styles.push({\n            inverse,\n            styles: parseStyle(style)\n          });\n        } else if (close) {\n          if (styles.length === 0) {\n            throw new Error("Found extraneous } in Chalk template literal");\n          }\n          chunks.push(buildStyle(chalk, styles)(chunk.join("")));\n          chunk = [];\n          styles.pop();\n        } else {\n          chunk.push(chr);\n        }\n      });\n      chunks.push(chunk.join(""));\n      if (styles.length > 0) {\n        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\\`}\\`)`;\n        throw new Error(errMsg);\n      }\n      return chunks.join("");\n    };\n  }\n});\nvar require_chalk = __commonJS2({\n  "node_modules/vnopts/node_modules/chalk/index.js"(exports2, module2) {\n    "use strict";\n    var escapeStringRegexp2 = require_escape_string_regexp();\n    var ansiStyles = require_ansi_styles();\n    var stdoutColor = require_supports_color().stdout;\n    var template = require_templates();\n    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");\n    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];\n    var skipModels = /* @__PURE__ */ new Set(["gray"]);\n    var styles = /* @__PURE__ */ Object.create(null);\n    function applyOptions(obj, options) {\n      options = options || {};\n      const scLevel = stdoutColor ? stdoutColor.level : 0;\n      obj.level = options.level === void 0 ? scLevel : options.level;\n      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;\n    }\n    function Chalk(options) {\n      if (!this || !(this instanceof Chalk) || this.template) {\n        const chalk = {};\n        applyOptions(chalk, options);\n        chalk.template = function() {\n          const args = [].slice.call(arguments);\n          return chalkTag.apply(null, [chalk.template].concat(args));\n        };\n        Object.setPrototypeOf(chalk, Chalk.prototype);\n        Object.setPrototypeOf(chalk.template, chalk);\n        chalk.template.constructor = Chalk;\n        return chalk.template;\n      }\n      applyOptions(this, options);\n    }\n    if (isSimpleWindowsTerm) {\n      ansiStyles.blue.open = "\\x1B[94m";\n    }\n    for (const key of Object.keys(ansiStyles)) {\n      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp2(ansiStyles[key].close), "g");\n      styles[key] = {\n        get() {\n          const codes = ansiStyles[key];\n          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);\n        }\n      };\n    }\n    styles.visible = {\n      get() {\n        return build.call(this, this._styles || [], true, "visible");\n      }\n    };\n    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp2(ansiStyles.color.close), "g");\n    for (const model of Object.keys(ansiStyles.color.ansi)) {\n      if (skipModels.has(model)) {\n        continue;\n      }\n      styles[model] = {\n        get() {\n          const level = this.level;\n          return function() {\n            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);\n            const codes = {\n              open,\n              close: ansiStyles.color.close,\n              closeRe: ansiStyles.color.closeRe\n            };\n            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n          };\n        }\n      };\n    }\n    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp2(ansiStyles.bgColor.close), "g");\n    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {\n      if (skipModels.has(model)) {\n        continue;\n      }\n      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);\n      styles[bgModel] = {\n        get() {\n          const level = this.level;\n          return function() {\n            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);\n            const codes = {\n              open,\n              close: ansiStyles.bgColor.close,\n              closeRe: ansiStyles.bgColor.closeRe\n            };\n            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n          };\n        }\n      };\n    }\n    var proto = Object.defineProperties(() => {\n    }, styles);\n    function build(_styles, _empty, key) {\n      const builder = function() {\n        return applyStyle.apply(builder, arguments);\n      };\n      builder._styles = _styles;\n      builder._empty = _empty;\n      const self2 = this;\n      Object.defineProperty(builder, "level", {\n        enumerable: true,\n        get() {\n          return self2.level;\n        },\n        set(level) {\n          self2.level = level;\n        }\n      });\n      Object.defineProperty(builder, "enabled", {\n        enumerable: true,\n        get() {\n          return self2.enabled;\n        },\n        set(enabled) {\n          self2.enabled = enabled;\n        }\n      });\n      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";\n      builder.__proto__ = proto;\n      return builder;\n    }\n    function applyStyle() {\n      const args = arguments;\n      const argsLen = args.length;\n      let str = String(arguments[0]);\n      if (argsLen === 0) {\n        return "";\n      }\n      if (argsLen > 1) {\n        for (let a = 1; a < argsLen; a++) {\n          str += " " + args[a];\n        }\n      }\n      if (!this.enabled || this.level <= 0 || !str) {\n        return this._empty ? "" : str;\n      }\n      const originalDim = ansiStyles.dim.open;\n      if (isSimpleWindowsTerm && this.hasGrey) {\n        ansiStyles.dim.open = "";\n      }\n      for (const code of this._styles.slice().reverse()) {\n        str = code.open + str.replace(code.closeRe, code.open) + code.close;\n        str = str.replace(/\\r?\\n/g, `${code.close}$&${code.open}`);\n      }\n      ansiStyles.dim.open = originalDim;\n      return str;\n    }\n    function chalkTag(chalk, strings) {\n      if (!Array.isArray(strings)) {\n        return [].slice.call(arguments, 1).join(" ");\n      }\n      const args = [].slice.call(arguments, 2);\n      const parts = [strings.raw[0]];\n      for (let i = 1; i < strings.length; i++) {\n        parts.push(String(args[i - 1]).replace(/[{}\\\\]/g, "\\\\$&"));\n        parts.push(String(strings.raw[i]));\n      }\n      return template(chalk, parts.join(""));\n    }\n    Object.defineProperties(Chalk.prototype, styles);\n    module2.exports = Chalk();\n    module2.exports.supportsColor = stdoutColor;\n    module2.exports.default = module2.exports;\n  }\n});\nvar require_common = __commonJS2({\n  "node_modules/vnopts/lib/handlers/deprecated/common.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var chalk_1 = require_chalk();\n    exports2.commonDeprecatedHandler = (keyOrPair, redirectTo, {\n      descriptor\n    }) => {\n      const messages = [`${chalk_1.default.yellow(typeof keyOrPair === "string" ? descriptor.key(keyOrPair) : descriptor.pair(keyOrPair))} is deprecated`];\n      if (redirectTo) {\n        messages.push(`we now treat it as ${chalk_1.default.blue(typeof redirectTo === "string" ? descriptor.key(redirectTo) : descriptor.pair(redirectTo))}`);\n      }\n      return messages.join("; ") + ".";\n    };\n  }\n});\nvar require_deprecated = __commonJS2({\n  "node_modules/vnopts/lib/handlers/deprecated/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    tslib_1.__exportStar(require_common(), exports2);\n  }\n});\nvar require_common2 = __commonJS2({\n  "node_modules/vnopts/lib/handlers/invalid/common.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var chalk_1 = require_chalk();\n    exports2.commonInvalidHandler = (key, value, utils) => [`Invalid ${chalk_1.default.red(utils.descriptor.key(key))} value.`, `Expected ${chalk_1.default.blue(utils.schemas[key].expected(utils))},`, `but received ${chalk_1.default.red(utils.descriptor.value(value))}.`].join(" ");\n  }\n});\nvar require_invalid = __commonJS2({\n  "node_modules/vnopts/lib/handlers/invalid/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    tslib_1.__exportStar(require_common2(), exports2);\n  }\n});\nvar require_leven = __commonJS2({\n  "node_modules/vnopts/node_modules/leven/index.js"(exports2, module2) {\n    "use strict";\n    var arr = [];\n    var charCodeCache = [];\n    module2.exports = function(a, b) {\n      if (a === b) {\n        return 0;\n      }\n      var swap = a;\n      if (a.length > b.length) {\n        a = b;\n        b = swap;\n      }\n      var aLen = a.length;\n      var bLen = b.length;\n      if (aLen === 0) {\n        return bLen;\n      }\n      if (bLen === 0) {\n        return aLen;\n      }\n      while (aLen > 0 && a.charCodeAt(~-aLen) === b.charCodeAt(~-bLen)) {\n        aLen--;\n        bLen--;\n      }\n      if (aLen === 0) {\n        return bLen;\n      }\n      var start = 0;\n      while (start < aLen && a.charCodeAt(start) === b.charCodeAt(start)) {\n        start++;\n      }\n      aLen -= start;\n      bLen -= start;\n      if (aLen === 0) {\n        return bLen;\n      }\n      var bCharCode;\n      var ret;\n      var tmp;\n      var tmp2;\n      var i = 0;\n      var j = 0;\n      while (i < aLen) {\n        charCodeCache[start + i] = a.charCodeAt(start + i);\n        arr[i] = ++i;\n      }\n      while (j < bLen) {\n        bCharCode = b.charCodeAt(start + j);\n        tmp = j++;\n        ret = j;\n        for (i = 0; i < aLen; i++) {\n          tmp2 = bCharCode === charCodeCache[start + i] ? tmp : tmp + 1;\n          tmp = arr[i];\n          ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2;\n        }\n      }\n      return ret;\n    };\n  }\n});\nvar require_leven2 = __commonJS2({\n  "node_modules/vnopts/lib/handlers/unknown/leven.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var chalk_1 = require_chalk();\n    var leven = require_leven();\n    exports2.levenUnknownHandler = (key, value, {\n      descriptor,\n      logger,\n      schemas\n    }) => {\n      const messages = [`Ignored unknown option ${chalk_1.default.yellow(descriptor.pair({\n        key,\n        value\n      }))}.`];\n      const suggestion = Object.keys(schemas).sort().find((knownKey) => leven(key, knownKey) < 3);\n      if (suggestion) {\n        messages.push(`Did you mean ${chalk_1.default.blue(descriptor.key(suggestion))}?`);\n      }\n      logger.warn(messages.join(" "));\n    };\n  }\n});\nvar require_unknown = __commonJS2({\n  "node_modules/vnopts/lib/handlers/unknown/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    tslib_1.__exportStar(require_leven2(), exports2);\n  }\n});\nvar require_handlers = __commonJS2({\n  "node_modules/vnopts/lib/handlers/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    tslib_1.__exportStar(require_deprecated(), exports2);\n    tslib_1.__exportStar(require_invalid(), exports2);\n    tslib_1.__exportStar(require_unknown(), exports2);\n  }\n});\nvar require_schema = __commonJS2({\n  "node_modules/vnopts/lib/schema.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var HANDLER_KEYS = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];\n    function createSchema(SchemaConstructor, parameters) {\n      const schema = new SchemaConstructor(parameters);\n      const subSchema = Object.create(schema);\n      for (const handlerKey of HANDLER_KEYS) {\n        if (handlerKey in parameters) {\n          subSchema[handlerKey] = normalizeHandler(parameters[handlerKey], schema, Schema.prototype[handlerKey].length);\n        }\n      }\n      return subSchema;\n    }\n    exports2.createSchema = createSchema;\n    var Schema = class {\n      constructor(parameters) {\n        this.name = parameters.name;\n      }\n      static create(parameters) {\n        return createSchema(this, parameters);\n      }\n      default(_utils) {\n        return void 0;\n      }\n      expected(_utils) {\n        return "nothing";\n      }\n      validate(_value, _utils) {\n        return false;\n      }\n      deprecated(_value, _utils) {\n        return false;\n      }\n      forward(_value, _utils) {\n        return void 0;\n      }\n      redirect(_value, _utils) {\n        return void 0;\n      }\n      overlap(currentValue, _newValue, _utils) {\n        return currentValue;\n      }\n      preprocess(value, _utils) {\n        return value;\n      }\n      postprocess(value, _utils) {\n        return value;\n      }\n    };\n    exports2.Schema = Schema;\n    function normalizeHandler(handler, superSchema, handlerArgumentsLength) {\n      return typeof handler === "function" ? (...args) => handler(...args.slice(0, handlerArgumentsLength - 1), superSchema, ...args.slice(handlerArgumentsLength - 1)) : () => handler;\n    }\n  }\n});\nvar require_alias = __commonJS2({\n  "node_modules/vnopts/lib/schemas/alias.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var schema_1 = require_schema();\n    var AliasSchema = class extends schema_1.Schema {\n      constructor(parameters) {\n        super(parameters);\n        this._sourceName = parameters.sourceName;\n      }\n      expected(utils) {\n        return utils.schemas[this._sourceName].expected(utils);\n      }\n      validate(value, utils) {\n        return utils.schemas[this._sourceName].validate(value, utils);\n      }\n      redirect(_value, _utils) {\n        return this._sourceName;\n      }\n    };\n    exports2.AliasSchema = AliasSchema;\n  }\n});\nvar require_any = __commonJS2({\n  "node_modules/vnopts/lib/schemas/any.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var schema_1 = require_schema();\n    var AnySchema = class extends schema_1.Schema {\n      expected() {\n        return "anything";\n      }\n      validate() {\n        return true;\n      }\n    };\n    exports2.AnySchema = AnySchema;\n  }\n});\nvar require_array2 = __commonJS2({\n  "node_modules/vnopts/lib/schemas/array.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    var schema_1 = require_schema();\n    var ArraySchema = class extends schema_1.Schema {\n      constructor(_a) {\n        var {\n          valueSchema,\n          name = valueSchema.name\n        } = _a, handlers = tslib_1.__rest(_a, ["valueSchema", "name"]);\n        super(Object.assign({}, handlers, {\n          name\n        }));\n        this._valueSchema = valueSchema;\n      }\n      expected(utils) {\n        return `an array of ${this._valueSchema.expected(utils)}`;\n      }\n      validate(value, utils) {\n        if (!Array.isArray(value)) {\n          return false;\n        }\n        const invalidValues = [];\n        for (const subValue of value) {\n          const subValidateResult = utils.normalizeValidateResult(this._valueSchema.validate(subValue, utils), subValue);\n          if (subValidateResult !== true) {\n            invalidValues.push(subValidateResult.value);\n          }\n        }\n        return invalidValues.length === 0 ? true : {\n          value: invalidValues\n        };\n      }\n      deprecated(value, utils) {\n        const deprecatedResult = [];\n        for (const subValue of value) {\n          const subDeprecatedResult = utils.normalizeDeprecatedResult(this._valueSchema.deprecated(subValue, utils), subValue);\n          if (subDeprecatedResult !== false) {\n            deprecatedResult.push(...subDeprecatedResult.map(({\n              value: deprecatedValue\n            }) => ({\n              value: [deprecatedValue]\n            })));\n          }\n        }\n        return deprecatedResult;\n      }\n      forward(value, utils) {\n        const forwardResult = [];\n        for (const subValue of value) {\n          const subForwardResult = utils.normalizeForwardResult(this._valueSchema.forward(subValue, utils), subValue);\n          forwardResult.push(...subForwardResult.map(wrapTransferResult));\n        }\n        return forwardResult;\n      }\n      redirect(value, utils) {\n        const remain = [];\n        const redirect = [];\n        for (const subValue of value) {\n          const subRedirectResult = utils.normalizeRedirectResult(this._valueSchema.redirect(subValue, utils), subValue);\n          if ("remain" in subRedirectResult) {\n            remain.push(subRedirectResult.remain);\n          }\n          redirect.push(...subRedirectResult.redirect.map(wrapTransferResult));\n        }\n        return remain.length === 0 ? {\n          redirect\n        } : {\n          redirect,\n          remain\n        };\n      }\n      overlap(currentValue, newValue) {\n        return currentValue.concat(newValue);\n      }\n    };\n    exports2.ArraySchema = ArraySchema;\n    function wrapTransferResult({\n      from,\n      to\n    }) {\n      return {\n        from: [from],\n        to\n      };\n    }\n  }\n});\nvar require_boolean = __commonJS2({\n  "node_modules/vnopts/lib/schemas/boolean.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var schema_1 = require_schema();\n    var BooleanSchema = class extends schema_1.Schema {\n      expected() {\n        return "true or false";\n      }\n      validate(value) {\n        return typeof value === "boolean";\n      }\n    };\n    exports2.BooleanSchema = BooleanSchema;\n  }\n});\nvar require_utils = __commonJS2({\n  "node_modules/vnopts/lib/utils.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    function recordFromArray(array, mainKey) {\n      const record = /* @__PURE__ */ Object.create(null);\n      for (const value of array) {\n        const key = value[mainKey];\n        if (record[key]) {\n          throw new Error(`Duplicate ${mainKey} ${JSON.stringify(key)}`);\n        }\n        record[key] = value;\n      }\n      return record;\n    }\n    exports2.recordFromArray = recordFromArray;\n    function mapFromArray(array, mainKey) {\n      const map = /* @__PURE__ */ new Map();\n      for (const value of array) {\n        const key = value[mainKey];\n        if (map.has(key)) {\n          throw new Error(`Duplicate ${mainKey} ${JSON.stringify(key)}`);\n        }\n        map.set(key, value);\n      }\n      return map;\n    }\n    exports2.mapFromArray = mapFromArray;\n    function createAutoChecklist() {\n      const map = /* @__PURE__ */ Object.create(null);\n      return (id) => {\n        const idString = JSON.stringify(id);\n        if (map[idString]) {\n          return true;\n        }\n        map[idString] = true;\n        return false;\n      };\n    }\n    exports2.createAutoChecklist = createAutoChecklist;\n    function partition(array, predicate) {\n      const trueArray = [];\n      const falseArray = [];\n      for (const value of array) {\n        if (predicate(value)) {\n          trueArray.push(value);\n        } else {\n          falseArray.push(value);\n        }\n      }\n      return [trueArray, falseArray];\n    }\n    exports2.partition = partition;\n    function isInt(value) {\n      return value === Math.floor(value);\n    }\n    exports2.isInt = isInt;\n    function comparePrimitive(a, b) {\n      if (a === b) {\n        return 0;\n      }\n      const typeofA = typeof a;\n      const typeofB = typeof b;\n      const orders = ["undefined", "object", "boolean", "number", "string"];\n      if (typeofA !== typeofB) {\n        return orders.indexOf(typeofA) - orders.indexOf(typeofB);\n      }\n      if (typeofA !== "string") {\n        return Number(a) - Number(b);\n      }\n      return a.localeCompare(b);\n    }\n    exports2.comparePrimitive = comparePrimitive;\n    function normalizeDefaultResult(result) {\n      return result === void 0 ? {} : result;\n    }\n    exports2.normalizeDefaultResult = normalizeDefaultResult;\n    function normalizeValidateResult(result, value) {\n      return result === true ? true : result === false ? {\n        value\n      } : result;\n    }\n    exports2.normalizeValidateResult = normalizeValidateResult;\n    function normalizeDeprecatedResult(result, value, doNotNormalizeTrue = false) {\n      return result === false ? false : result === true ? doNotNormalizeTrue ? true : [{\n        value\n      }] : "value" in result ? [result] : result.length === 0 ? false : result;\n    }\n    exports2.normalizeDeprecatedResult = normalizeDeprecatedResult;\n    function normalizeTransferResult(result, value) {\n      return typeof result === "string" || "key" in result ? {\n        from: value,\n        to: result\n      } : "from" in result ? {\n        from: result.from,\n        to: result.to\n      } : {\n        from: value,\n        to: result.to\n      };\n    }\n    exports2.normalizeTransferResult = normalizeTransferResult;\n    function normalizeForwardResult(result, value) {\n      return result === void 0 ? [] : Array.isArray(result) ? result.map((transferResult) => normalizeTransferResult(transferResult, value)) : [normalizeTransferResult(result, value)];\n    }\n    exports2.normalizeForwardResult = normalizeForwardResult;\n    function normalizeRedirectResult(result, value) {\n      const redirect = normalizeForwardResult(typeof result === "object" && "redirect" in result ? result.redirect : result, value);\n      return redirect.length === 0 ? {\n        remain: value,\n        redirect\n      } : typeof result === "object" && "remain" in result ? {\n        remain: result.remain,\n        redirect\n      } : {\n        redirect\n      };\n    }\n    exports2.normalizeRedirectResult = normalizeRedirectResult;\n  }\n});\nvar require_choice = __commonJS2({\n  "node_modules/vnopts/lib/schemas/choice.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var schema_1 = require_schema();\n    var utils_1 = require_utils();\n    var ChoiceSchema = class extends schema_1.Schema {\n      constructor(parameters) {\n        super(parameters);\n        this._choices = utils_1.mapFromArray(parameters.choices.map((choice) => choice && typeof choice === "object" ? choice : {\n          value: choice\n        }), "value");\n      }\n      expected({\n        descriptor\n      }) {\n        const choiceValues = Array.from(this._choices.keys()).map((value) => this._choices.get(value)).filter((choiceInfo) => !choiceInfo.deprecated).map((choiceInfo) => choiceInfo.value).sort(utils_1.comparePrimitive).map(descriptor.value);\n        const head = choiceValues.slice(0, -2);\n        const tail = choiceValues.slice(-2);\n        return head.concat(tail.join(" or ")).join(", ");\n      }\n      validate(value) {\n        return this._choices.has(value);\n      }\n      deprecated(value) {\n        const choiceInfo = this._choices.get(value);\n        return choiceInfo && choiceInfo.deprecated ? {\n          value\n        } : false;\n      }\n      forward(value) {\n        const choiceInfo = this._choices.get(value);\n        return choiceInfo ? choiceInfo.forward : void 0;\n      }\n      redirect(value) {\n        const choiceInfo = this._choices.get(value);\n        return choiceInfo ? choiceInfo.redirect : void 0;\n      }\n    };\n    exports2.ChoiceSchema = ChoiceSchema;\n  }\n});\nvar require_number = __commonJS2({\n  "node_modules/vnopts/lib/schemas/number.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var schema_1 = require_schema();\n    var NumberSchema = class extends schema_1.Schema {\n      expected() {\n        return "a number";\n      }\n      validate(value, _utils) {\n        return typeof value === "number";\n      }\n    };\n    exports2.NumberSchema = NumberSchema;\n  }\n});\nvar require_integer = __commonJS2({\n  "node_modules/vnopts/lib/schemas/integer.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var utils_1 = require_utils();\n    var number_1 = require_number();\n    var IntegerSchema = class extends number_1.NumberSchema {\n      expected() {\n        return "an integer";\n      }\n      validate(value, utils) {\n        return utils.normalizeValidateResult(super.validate(value, utils), value) === true && utils_1.isInt(value);\n      }\n    };\n    exports2.IntegerSchema = IntegerSchema;\n  }\n});\nvar require_string = __commonJS2({\n  "node_modules/vnopts/lib/schemas/string.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var schema_1 = require_schema();\n    var StringSchema = class extends schema_1.Schema {\n      expected() {\n        return "a string";\n      }\n      validate(value) {\n        return typeof value === "string";\n      }\n    };\n    exports2.StringSchema = StringSchema;\n  }\n});\nvar require_schemas = __commonJS2({\n  "node_modules/vnopts/lib/schemas/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    tslib_1.__exportStar(require_alias(), exports2);\n    tslib_1.__exportStar(require_any(), exports2);\n    tslib_1.__exportStar(require_array2(), exports2);\n    tslib_1.__exportStar(require_boolean(), exports2);\n    tslib_1.__exportStar(require_choice(), exports2);\n    tslib_1.__exportStar(require_integer(), exports2);\n    tslib_1.__exportStar(require_number(), exports2);\n    tslib_1.__exportStar(require_string(), exports2);\n  }\n});\nvar require_defaults = __commonJS2({\n  "node_modules/vnopts/lib/defaults.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var api_1 = require_api();\n    var common_1 = require_common();\n    var invalid_1 = require_invalid();\n    var leven_1 = require_leven2();\n    exports2.defaultDescriptor = api_1.apiDescriptor;\n    exports2.defaultUnknownHandler = leven_1.levenUnknownHandler;\n    exports2.defaultInvalidHandler = invalid_1.commonInvalidHandler;\n    exports2.defaultDeprecatedHandler = common_1.commonDeprecatedHandler;\n  }\n});\nvar require_normalize = __commonJS2({\n  "node_modules/vnopts/lib/normalize.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var defaults_1 = require_defaults();\n    var utils_1 = require_utils();\n    exports2.normalize = (options, schemas, opts) => new Normalizer(schemas, opts).normalize(options);\n    var Normalizer = class {\n      constructor(schemas, opts) {\n        const {\n          logger = console,\n          descriptor = defaults_1.defaultDescriptor,\n          unknown = defaults_1.defaultUnknownHandler,\n          invalid = defaults_1.defaultInvalidHandler,\n          deprecated = defaults_1.defaultDeprecatedHandler\n        } = opts || {};\n        this._utils = {\n          descriptor,\n          logger: logger || {\n            warn: () => {\n            }\n          },\n          schemas: utils_1.recordFromArray(schemas, "name"),\n          normalizeDefaultResult: utils_1.normalizeDefaultResult,\n          normalizeDeprecatedResult: utils_1.normalizeDeprecatedResult,\n          normalizeForwardResult: utils_1.normalizeForwardResult,\n          normalizeRedirectResult: utils_1.normalizeRedirectResult,\n          normalizeValidateResult: utils_1.normalizeValidateResult\n        };\n        this._unknownHandler = unknown;\n        this._invalidHandler = invalid;\n        this._deprecatedHandler = deprecated;\n        this.cleanHistory();\n      }\n      cleanHistory() {\n        this._hasDeprecationWarned = utils_1.createAutoChecklist();\n      }\n      normalize(options) {\n        const normalized = {};\n        const restOptionsArray = [options];\n        const applyNormalization = () => {\n          while (restOptionsArray.length !== 0) {\n            const currentOptions = restOptionsArray.shift();\n            const transferredOptionsArray = this._applyNormalization(currentOptions, normalized);\n            restOptionsArray.push(...transferredOptionsArray);\n          }\n        };\n        applyNormalization();\n        for (const key of Object.keys(this._utils.schemas)) {\n          const schema = this._utils.schemas[key];\n          if (!(key in normalized)) {\n            const defaultResult = utils_1.normalizeDefaultResult(schema.default(this._utils));\n            if ("value" in defaultResult) {\n              restOptionsArray.push({\n                [key]: defaultResult.value\n              });\n            }\n          }\n        }\n        applyNormalization();\n        for (const key of Object.keys(this._utils.schemas)) {\n          const schema = this._utils.schemas[key];\n          if (key in normalized) {\n            normalized[key] = schema.postprocess(normalized[key], this._utils);\n          }\n        }\n        return normalized;\n      }\n      _applyNormalization(options, normalized) {\n        const transferredOptionsArray = [];\n        const [knownOptionNames, unknownOptionNames] = utils_1.partition(Object.keys(options), (key) => key in this._utils.schemas);\n        for (const key of knownOptionNames) {\n          const schema = this._utils.schemas[key];\n          const value = schema.preprocess(options[key], this._utils);\n          const validateResult = utils_1.normalizeValidateResult(schema.validate(value, this._utils), value);\n          if (validateResult !== true) {\n            const {\n              value: invalidValue\n            } = validateResult;\n            const errorMessageOrError = this._invalidHandler(key, invalidValue, this._utils);\n            throw typeof errorMessageOrError === "string" ? new Error(errorMessageOrError) : errorMessageOrError;\n          }\n          const appendTransferredOptions = ({\n            from,\n            to\n          }) => {\n            transferredOptionsArray.push(typeof to === "string" ? {\n              [to]: from\n            } : {\n              [to.key]: to.value\n            });\n          };\n          const warnDeprecated = ({\n            value: currentValue,\n            redirectTo\n          }) => {\n            const deprecatedResult = utils_1.normalizeDeprecatedResult(schema.deprecated(currentValue, this._utils), value, true);\n            if (deprecatedResult === false) {\n              return;\n            }\n            if (deprecatedResult === true) {\n              if (!this._hasDeprecationWarned(key)) {\n                this._utils.logger.warn(this._deprecatedHandler(key, redirectTo, this._utils));\n              }\n            } else {\n              for (const {\n                value: deprecatedValue\n              } of deprecatedResult) {\n                const pair = {\n                  key,\n                  value: deprecatedValue\n                };\n                if (!this._hasDeprecationWarned(pair)) {\n                  const redirectToPair = typeof redirectTo === "string" ? {\n                    key: redirectTo,\n                    value: deprecatedValue\n                  } : redirectTo;\n                  this._utils.logger.warn(this._deprecatedHandler(pair, redirectToPair, this._utils));\n                }\n              }\n            }\n          };\n          const forwardResult = utils_1.normalizeForwardResult(schema.forward(value, this._utils), value);\n          forwardResult.forEach(appendTransferredOptions);\n          const redirectResult = utils_1.normalizeRedirectResult(schema.redirect(value, this._utils), value);\n          redirectResult.redirect.forEach(appendTransferredOptions);\n          if ("remain" in redirectResult) {\n            const remainingValue = redirectResult.remain;\n            normalized[key] = key in normalized ? schema.overlap(normalized[key], remainingValue, this._utils) : remainingValue;\n            warnDeprecated({\n              value: remainingValue\n            });\n          }\n          for (const {\n            from,\n            to\n          } of redirectResult.redirect) {\n            warnDeprecated({\n              value: from,\n              redirectTo: to\n            });\n          }\n        }\n        for (const key of unknownOptionNames) {\n          const value = options[key];\n          const unknownResult = this._unknownHandler(key, value, this._utils);\n          if (unknownResult) {\n            for (const unknownKey of Object.keys(unknownResult)) {\n              const unknownOption = {\n                [unknownKey]: unknownResult[unknownKey]\n              };\n              if (unknownKey in this._utils.schemas) {\n                transferredOptionsArray.push(unknownOption);\n              } else {\n                Object.assign(normalized, unknownOption);\n              }\n            }\n          }\n        }\n        return transferredOptionsArray;\n      }\n    };\n    exports2.Normalizer = Normalizer;\n  }\n});\nvar require_lib2 = __commonJS2({\n  "node_modules/vnopts/lib/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));\n    tslib_1.__exportStar(require_descriptors2(), exports2);\n    tslib_1.__exportStar(require_handlers(), exports2);\n    tslib_1.__exportStar(require_schemas(), exports2);\n    tslib_1.__exportStar(require_normalize(), exports2);\n    tslib_1.__exportStar(require_schema(), exports2);\n  }\n});\nvar require_options_normalizer = __commonJS2({\n  "src/main/options-normalizer.js"(exports2, module2) {\n    "use strict";\n    var vnopts = require_lib2();\n    var getLast = require_get_last();\n    var cliDescriptor = {\n      key: (key) => key.length === 1 ? `-${key}` : `--${key}`,\n      value: (value) => vnopts.apiDescriptor.value(value),\n      pair: ({\n        key,\n        value\n      }) => value === false ? `--no-${key}` : value === true ? cliDescriptor.key(key) : value === "" ? `${cliDescriptor.key(key)} without an argument` : `${cliDescriptor.key(key)}=${value}`\n    };\n    var getFlagSchema = ({\n      colorsModule,\n      levenshteinDistance\n    }) => class FlagSchema extends vnopts.ChoiceSchema {\n      constructor({\n        name,\n        flags\n      }) {\n        super({\n          name,\n          choices: flags\n        });\n        this._flags = [...flags].sort();\n      }\n      preprocess(value, utils) {\n        if (typeof value === "string" && value.length > 0 && !this._flags.includes(value)) {\n          const suggestion = this._flags.find((flag) => levenshteinDistance(flag, value) < 3);\n          if (suggestion) {\n            utils.logger.warn([`Unknown flag ${colorsModule.yellow(utils.descriptor.value(value))},`, `did you mean ${colorsModule.blue(utils.descriptor.value(suggestion))}?`].join(" "));\n            return suggestion;\n          }\n        }\n        return value;\n      }\n      expected() {\n        return "a flag";\n      }\n    };\n    var hasDeprecationWarned;\n    function normalizeOptions(options, optionInfos, {\n      logger = false,\n      isCLI = false,\n      passThrough = false,\n      colorsModule = null,\n      levenshteinDistance = null\n    } = {}) {\n      const unknown = !passThrough ? (key, value, options2) => {\n        const _options2$schemas = options2.schemas, {\n          _\n        } = _options2$schemas, schemas2 = _objectWithoutProperties(_options2$schemas, _excluded2);\n        return vnopts.levenUnknownHandler(key, value, Object.assign(Object.assign({}, options2), {}, {\n          schemas: schemas2\n        }));\n      } : Array.isArray(passThrough) ? (key, value) => !passThrough.includes(key) ? void 0 : {\n        [key]: value\n      } : (key, value) => ({\n        [key]: value\n      });\n      const descriptor = isCLI ? cliDescriptor : vnopts.apiDescriptor;\n      const schemas = optionInfosToSchemas(optionInfos, {\n        isCLI,\n        colorsModule,\n        levenshteinDistance\n      });\n      const normalizer = new vnopts.Normalizer(schemas, {\n        logger,\n        unknown,\n        descriptor\n      });\n      const shouldSuppressDuplicateDeprecationWarnings = logger !== false;\n      if (shouldSuppressDuplicateDeprecationWarnings && hasDeprecationWarned) {\n        normalizer._hasDeprecationWarned = hasDeprecationWarned;\n      }\n      const normalized = normalizer.normalize(options);\n      if (shouldSuppressDuplicateDeprecationWarnings) {\n        hasDeprecationWarned = normalizer._hasDeprecationWarned;\n      }\n      if (isCLI && normalized["plugin-search"] === false) {\n        normalized["plugin-search-dir"] = false;\n      }\n      return normalized;\n    }\n    function optionInfosToSchemas(optionInfos, {\n      isCLI,\n      colorsModule,\n      levenshteinDistance\n    }) {\n      const schemas = [];\n      if (isCLI) {\n        schemas.push(vnopts.AnySchema.create({\n          name: "_"\n        }));\n      }\n      for (const optionInfo of optionInfos) {\n        schemas.push(optionInfoToSchema(optionInfo, {\n          isCLI,\n          optionInfos,\n          colorsModule,\n          levenshteinDistance\n        }));\n        if (optionInfo.alias && isCLI) {\n          schemas.push(vnopts.AliasSchema.create({\n            name: optionInfo.alias,\n            sourceName: optionInfo.name\n          }));\n        }\n      }\n      return schemas;\n    }\n    function optionInfoToSchema(optionInfo, {\n      isCLI,\n      optionInfos,\n      colorsModule,\n      levenshteinDistance\n    }) {\n      const {\n        name\n      } = optionInfo;\n      if (name === "plugin-search-dir" || name === "pluginSearchDirs") {\n        return vnopts.AnySchema.create({\n          name,\n          preprocess(value) {\n            if (value === false) {\n              return value;\n            }\n            value = Array.isArray(value) ? value : [value];\n            return value;\n          },\n          validate(value) {\n            if (value === false) {\n              return true;\n            }\n            return value.every((dir) => typeof dir === "string");\n          },\n          expected() {\n            return "false or paths to plugin search dir";\n          }\n        });\n      }\n      const parameters = {\n        name\n      };\n      let SchemaConstructor;\n      const handlers = {};\n      switch (optionInfo.type) {\n        case "int":\n          SchemaConstructor = vnopts.IntegerSchema;\n          if (isCLI) {\n            parameters.preprocess = Number;\n          }\n          break;\n        case "string":\n          SchemaConstructor = vnopts.StringSchema;\n          break;\n        case "choice":\n          SchemaConstructor = vnopts.ChoiceSchema;\n          parameters.choices = optionInfo.choices.map((choiceInfo) => typeof choiceInfo === "object" && choiceInfo.redirect ? Object.assign(Object.assign({}, choiceInfo), {}, {\n            redirect: {\n              to: {\n                key: optionInfo.name,\n                value: choiceInfo.redirect\n              }\n            }\n          }) : choiceInfo);\n          break;\n        case "boolean":\n          SchemaConstructor = vnopts.BooleanSchema;\n          break;\n        case "flag":\n          SchemaConstructor = getFlagSchema({\n            colorsModule,\n            levenshteinDistance\n          });\n          parameters.flags = optionInfos.flatMap((optionInfo2) => [optionInfo2.alias, optionInfo2.description && optionInfo2.name, optionInfo2.oppositeDescription && `no-${optionInfo2.name}`].filter(Boolean));\n          break;\n        case "path":\n          SchemaConstructor = vnopts.StringSchema;\n          break;\n        default:\n          throw new Error(`Unexpected type ${optionInfo.type}`);\n      }\n      if (optionInfo.exception) {\n        parameters.validate = (value, schema, utils) => optionInfo.exception(value) || schema.validate(value, utils);\n      } else {\n        parameters.validate = (value, schema, utils) => value === void 0 || schema.validate(value, utils);\n      }\n      if (optionInfo.redirect) {\n        handlers.redirect = (value) => !value ? void 0 : {\n          to: {\n            key: optionInfo.redirect.option,\n            value: optionInfo.redirect.value\n          }\n        };\n      }\n      if (optionInfo.deprecated) {\n        handlers.deprecated = true;\n      }\n      if (isCLI && !optionInfo.array) {\n        const originalPreprocess = parameters.preprocess || ((x) => x);\n        parameters.preprocess = (value, schema, utils) => schema.preprocess(originalPreprocess(Array.isArray(value) ? getLast(value) : value), utils);\n      }\n      return optionInfo.array ? vnopts.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, isCLI ? {\n        preprocess: (v) => Array.isArray(v) ? v : [v]\n      } : {}), handlers), {}, {\n        valueSchema: SchemaConstructor.create(parameters)\n      })) : SchemaConstructor.create(Object.assign(Object.assign({}, parameters), handlers));\n    }\n    function normalizeApiOptions(options, optionInfos, opts) {\n      return normalizeOptions(options, optionInfos, opts);\n    }\n    function normalizeCliOptions(options, optionInfos, opts) {\n      if (false) {\n        if (!opts.colorsModule) {\n          throw new Error("\'colorsModule\' option is required.");\n        }\n        if (!opts.levenshteinDistance) {\n          throw new Error("\'levenshteinDistance\' option is required.");\n        }\n      }\n      return normalizeOptions(options, optionInfos, Object.assign({\n        isCLI: true\n      }, opts));\n    }\n    module2.exports = {\n      normalizeApiOptions,\n      normalizeCliOptions\n    };\n  }\n});\nvar require_loc = __commonJS2({\n  "src/language-js/loc.js"(exports2, module2) {\n    "use strict";\n    var isNonEmptyArray = require_is_non_empty_array();\n    function locStart(node) {\n      var _node$declaration$dec, _node$declaration;\n      const start = node.range ? node.range[0] : node.start;\n      const decorators = (_node$declaration$dec = (_node$declaration = node.declaration) === null || _node$declaration === void 0 ? void 0 : _node$declaration.decorators) !== null && _node$declaration$dec !== void 0 ? _node$declaration$dec : node.decorators;\n      if (isNonEmptyArray(decorators)) {\n        return Math.min(locStart(decorators[0]), start);\n      }\n      return start;\n    }\n    function locEnd(node) {\n      return node.range ? node.range[1] : node.end;\n    }\n    function hasSameLocStart(nodeA, nodeB) {\n      const nodeAStart = locStart(nodeA);\n      return Number.isInteger(nodeAStart) && nodeAStart === locStart(nodeB);\n    }\n    function hasSameLocEnd(nodeA, nodeB) {\n      const nodeAEnd = locEnd(nodeA);\n      return Number.isInteger(nodeAEnd) && nodeAEnd === locEnd(nodeB);\n    }\n    function hasSameLoc(nodeA, nodeB) {\n      return hasSameLocStart(nodeA, nodeB) && hasSameLocEnd(nodeA, nodeB);\n    }\n    module2.exports = {\n      locStart,\n      locEnd,\n      hasSameLocStart,\n      hasSameLoc\n    };\n  }\n});\nvar require_load_parser = __commonJS2({\n  "src/main/load-parser.js"(exports2, module2) {\n    "use strict";\n    var path = require("path");\n    var {\n      ConfigError\n    } = require_errors();\n    var {\n      locStart,\n      locEnd\n    } = require_loc();\n    function requireParser(parser) {\n      try {\n        return {\n          parse: require(path.resolve(process.cwd(), parser)),\n          astFormat: "estree",\n          locStart,\n          locEnd\n        };\n      } catch {\n        throw new ConfigError(`Couldn\'t resolve parser "${parser}"`);\n      }\n    }\n    module2.exports = requireParser;\n  }\n});\nvar require_js_tokens = __commonJS2({\n  "node_modules/js-tokens/index.js"(exports2) {\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.default = /(([\'"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\\'"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyus]{1,6}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|(0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?)|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-\\/%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\\](){}])|(\\s+)|(^$|[\\s\\S])/g;\n    exports2.matchToToken = function(match) {\n      var token = {\n        type: "invalid",\n        value: match[0],\n        closed: void 0\n      };\n      if (match[1])\n        token.type = "string", token.closed = !!(match[3] || match[4]);\n      else if (match[5])\n        token.type = "comment";\n      else if (match[6])\n        token.type = "comment", token.closed = !!match[7];\n      else if (match[8])\n        token.type = "regex";\n      else if (match[9])\n        token.type = "number";\n      else if (match[10])\n        token.type = "name";\n      else if (match[11])\n        token.type = "punctuator";\n      else if (match[12])\n        token.type = "whitespace";\n      return token;\n    };\n  }\n});\nvar require_identifier = __commonJS2({\n  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.isIdentifierChar = isIdentifierChar;\n    exports2.isIdentifierName = isIdentifierName;\n    exports2.isIdentifierStart = isIdentifierStart;\n    var nonASCIIidentifierStartChars = "\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC";\n    var nonASCIIidentifierChars = "\\u200C\\u200D\\xB7\\u0300-\\u036F\\u0387\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u0669\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u06F0-\\u06F9\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07C0-\\u07C9\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u0898-\\u089F\\u08CA-\\u08E1\\u08E3-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096F\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u09E6-\\u09EF\\u09FE\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A66-\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0AE6-\\u0AEF\\u0AFA-\\u0AFF\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B66-\\u0B6F\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C04\\u0C3C\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0CE6-\\u0CEF\\u0CF3\\u0D00-\\u0D03\\u0D3B\\u0D3C\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D66-\\u0D6F\\u0D81-\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0E50-\\u0E59\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECE\\u0ED0-\\u0ED9\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1040-\\u1049\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F-\\u109D\\u135D-\\u135F\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u180F-\\u1819\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u194F\\u19D0-\\u19DA\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AB0-\\u1ABD\\u1ABF-\\u1ACE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BB0-\\u1BB9\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1C40-\\u1C49\\u1C50-\\u1C59\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF4\\u1CF7-\\u1CF9\\u1DC0-\\u1DFF\\u203F\\u2040\\u2054\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA620-\\uA629\\uA66F\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA82C\\uA880\\uA881\\uA8B4-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F1\\uA8FF-\\uA909\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9D0-\\uA9D9\\uA9E5\\uA9F0-\\uA9F9\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA50-\\uAA59\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFF10-\\uFF19\\uFF3F";\n    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");\n    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");\n    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];\n    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n    function isInAstralSet(code, set) {\n      let pos = 65536;\n      for (let i = 0, length = set.length; i < length; i += 2) {\n        pos += set[i];\n        if (pos > code)\n          return false;\n        pos += set[i + 1];\n        if (pos >= code)\n          return true;\n      }\n      return false;\n    }\n    function isIdentifierStart(code) {\n      if (code < 65)\n        return code === 36;\n      if (code <= 90)\n        return true;\n      if (code < 97)\n        return code === 95;\n      if (code <= 122)\n        return true;\n      if (code <= 65535) {\n        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));\n      }\n      return isInAstralSet(code, astralIdentifierStartCodes);\n    }\n    function isIdentifierChar(code) {\n      if (code < 48)\n        return code === 36;\n      if (code < 58)\n        return true;\n      if (code < 65)\n        return false;\n      if (code <= 90)\n        return true;\n      if (code < 97)\n        return code === 95;\n      if (code <= 122)\n        return true;\n      if (code <= 65535) {\n        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));\n      }\n      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n    }\n    function isIdentifierName(name) {\n      let isFirst = true;\n      for (let i = 0; i < name.length; i++) {\n        let cp = name.charCodeAt(i);\n        if ((cp & 64512) === 55296 && i + 1 < name.length) {\n          const trail = name.charCodeAt(++i);\n          if ((trail & 64512) === 56320) {\n            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);\n          }\n        }\n        if (isFirst) {\n          isFirst = false;\n          if (!isIdentifierStart(cp)) {\n            return false;\n          }\n        } else if (!isIdentifierChar(cp)) {\n          return false;\n        }\n      }\n      return !isFirst;\n    }\n  }\n});\nvar require_keyword = __commonJS2({\n  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.isKeyword = isKeyword;\n    exports2.isReservedWord = isReservedWord;\n    exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;\n    exports2.isStrictBindReservedWord = isStrictBindReservedWord;\n    exports2.isStrictReservedWord = isStrictReservedWord;\n    var reservedWords = {\n      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],\n      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],\n      strictBind: ["eval", "arguments"]\n    };\n    var keywords = new Set(reservedWords.keyword);\n    var reservedWordsStrictSet = new Set(reservedWords.strict);\n    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\n    function isReservedWord(word, inModule) {\n      return inModule && word === "await" || word === "enum";\n    }\n    function isStrictReservedWord(word, inModule) {\n      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n    }\n    function isStrictBindOnlyReservedWord(word) {\n      return reservedWordsStrictBindSet.has(word);\n    }\n    function isStrictBindReservedWord(word, inModule) {\n      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n    }\n    function isKeyword(word) {\n      return keywords.has(word);\n    }\n  }\n});\nvar require_lib3 = __commonJS2({\n  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    Object.defineProperty(exports2, "isIdentifierChar", {\n      enumerable: true,\n      get: function() {\n        return _identifier.isIdentifierChar;\n      }\n    });\n    Object.defineProperty(exports2, "isIdentifierName", {\n      enumerable: true,\n      get: function() {\n        return _identifier.isIdentifierName;\n      }\n    });\n    Object.defineProperty(exports2, "isIdentifierStart", {\n      enumerable: true,\n      get: function() {\n        return _identifier.isIdentifierStart;\n      }\n    });\n    Object.defineProperty(exports2, "isKeyword", {\n      enumerable: true,\n      get: function() {\n        return _keyword.isKeyword;\n      }\n    });\n    Object.defineProperty(exports2, "isReservedWord", {\n      enumerable: true,\n      get: function() {\n        return _keyword.isReservedWord;\n      }\n    });\n    Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {\n      enumerable: true,\n      get: function() {\n        return _keyword.isStrictBindOnlyReservedWord;\n      }\n    });\n    Object.defineProperty(exports2, "isStrictBindReservedWord", {\n      enumerable: true,\n      get: function() {\n        return _keyword.isStrictBindReservedWord;\n      }\n    });\n    Object.defineProperty(exports2, "isStrictReservedWord", {\n      enumerable: true,\n      get: function() {\n        return _keyword.isStrictReservedWord;\n      }\n    });\n    var _identifier = require_identifier();\n    var _keyword = require_keyword();\n  }\n});\nvar require_escape_string_regexp2 = __commonJS2({\n  "node_modules/@babel/highlight/node_modules/escape-string-regexp/index.js"(exports2, module2) {\n    "use strict";\n    var matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n    module2.exports = function(str) {\n      if (typeof str !== "string") {\n        throw new TypeError("Expected a string");\n      }\n      return str.replace(matchOperatorsRe, "\\\\$&");\n    };\n  }\n});\nvar require_has_flag2 = __commonJS2({\n  "node_modules/@babel/highlight/node_modules/has-flag/index.js"(exports2, module2) {\n    "use strict";\n    module2.exports = (flag, argv) => {\n      argv = argv || process.argv;\n      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";\n      const pos = argv.indexOf(prefix + flag);\n      const terminatorPos = argv.indexOf("--");\n      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n    };\n  }\n});\nvar require_supports_color2 = __commonJS2({\n  "node_modules/@babel/highlight/node_modules/supports-color/index.js"(exports2, module2) {\n    "use strict";\n    var os = require("os");\n    var hasFlag = require_has_flag2();\n    var env = process.env;\n    var forceColor;\n    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {\n      forceColor = false;\n    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {\n      forceColor = true;\n    }\n    if ("FORCE_COLOR" in env) {\n      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n    }\n    function translateLevel(level) {\n      if (level === 0) {\n        return false;\n      }\n      return {\n        level,\n        hasBasic: true,\n        has256: level >= 2,\n        has16m: level >= 3\n      };\n    }\n    function supportsColor(stream) {\n      if (forceColor === false) {\n        return 0;\n      }\n      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {\n        return 3;\n      }\n      if (hasFlag("color=256")) {\n        return 2;\n      }\n      if (stream && !stream.isTTY && forceColor !== true) {\n        return 0;\n      }\n      const min = forceColor ? 1 : 0;\n      if (process.platform === "win32") {\n        const osRelease = os.release().split(".");\n        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {\n          return Number(osRelease[2]) >= 14931 ? 3 : 2;\n        }\n        return 1;\n      }\n      if ("CI" in env) {\n        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {\n          return 1;\n        }\n        return min;\n      }\n      if ("TEAMCITY_VERSION" in env) {\n        return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n      }\n      if (env.COLORTERM === "truecolor") {\n        return 3;\n      }\n      if ("TERM_PROGRAM" in env) {\n        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);\n        switch (env.TERM_PROGRAM) {\n          case "iTerm.app":\n            return version2 >= 3 ? 3 : 2;\n          case "Apple_Terminal":\n            return 2;\n        }\n      }\n      if (/-256(color)?$/i.test(env.TERM)) {\n        return 2;\n      }\n      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n        return 1;\n      }\n      if ("COLORTERM" in env) {\n        return 1;\n      }\n      if (env.TERM === "dumb") {\n        return min;\n      }\n      return min;\n    }\n    function getSupportLevel(stream) {\n      const level = supportsColor(stream);\n      return translateLevel(level);\n    }\n    module2.exports = {\n      supportsColor: getSupportLevel,\n      stdout: getSupportLevel(process.stdout),\n      stderr: getSupportLevel(process.stderr)\n    };\n  }\n});\nvar require_templates2 = __commonJS2({\n  "node_modules/@babel/highlight/node_modules/chalk/templates.js"(exports2, module2) {\n    "use strict";\n    var TEMPLATE_REGEX = /(?:\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\n    var STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\n    var STRING_REGEX = /^([\'"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\n    var ESCAPE_REGEX = /\\\\(u[a-f\\d]{4}|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n    var ESCAPES = /* @__PURE__ */ new Map([["n", "\\n"], ["r", "\\r"], ["t", "\t"], ["b", "\\b"], ["f", "\\f"], ["v", "\\v"], ["0", "\\0"], ["\\\\", "\\\\"], ["e", "\\x1B"], ["a", "\\x07"]]);\n    function unescape(c) {\n      if (c[0] === "u" && c.length === 5 || c[0] === "x" && c.length === 3) {\n        return String.fromCharCode(parseInt(c.slice(1), 16));\n      }\n      return ESCAPES.get(c) || c;\n    }\n    function parseArguments(name, args) {\n      const results = [];\n      const chunks = args.trim().split(/\\s*,\\s*/g);\n      let matches;\n      for (const chunk of chunks) {\n        if (!isNaN(chunk)) {\n          results.push(Number(chunk));\n        } else if (matches = chunk.match(STRING_REGEX)) {\n          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, chr) => escape ? unescape(escape) : chr));\n        } else {\n          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style \'${name}\')`);\n        }\n      }\n      return results;\n    }\n    function parseStyle(style) {\n      STYLE_REGEX.lastIndex = 0;\n      const results = [];\n      let matches;\n      while ((matches = STYLE_REGEX.exec(style)) !== null) {\n        const name = matches[1];\n        if (matches[2]) {\n          const args = parseArguments(name, matches[2]);\n          results.push([name].concat(args));\n        } else {\n          results.push([name]);\n        }\n      }\n      return results;\n    }\n    function buildStyle(chalk, styles) {\n      const enabled = {};\n      for (const layer of styles) {\n        for (const style of layer.styles) {\n          enabled[style[0]] = layer.inverse ? null : style.slice(1);\n        }\n      }\n      let current = chalk;\n      for (const styleName of Object.keys(enabled)) {\n        if (Array.isArray(enabled[styleName])) {\n          if (!(styleName in current)) {\n            throw new Error(`Unknown Chalk style: ${styleName}`);\n          }\n          if (enabled[styleName].length > 0) {\n            current = current[styleName].apply(current, enabled[styleName]);\n          } else {\n            current = current[styleName];\n          }\n        }\n      }\n      return current;\n    }\n    module2.exports = (chalk, tmp) => {\n      const styles = [];\n      const chunks = [];\n      let chunk = [];\n      tmp.replace(TEMPLATE_REGEX, (m, escapeChar, inverse, style, close, chr) => {\n        if (escapeChar) {\n          chunk.push(unescape(escapeChar));\n        } else if (style) {\n          const str = chunk.join("");\n          chunk = [];\n          chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));\n          styles.push({\n            inverse,\n            styles: parseStyle(style)\n          });\n        } else if (close) {\n          if (styles.length === 0) {\n            throw new Error("Found extraneous } in Chalk template literal");\n          }\n          chunks.push(buildStyle(chalk, styles)(chunk.join("")));\n          chunk = [];\n          styles.pop();\n        } else {\n          chunk.push(chr);\n        }\n      });\n      chunks.push(chunk.join(""));\n      if (styles.length > 0) {\n        const errMsg = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\\`}\\`)`;\n        throw new Error(errMsg);\n      }\n      return chunks.join("");\n    };\n  }\n});\nvar require_chalk2 = __commonJS2({\n  "node_modules/@babel/highlight/node_modules/chalk/index.js"(exports2, module2) {\n    "use strict";\n    var escapeStringRegexp2 = require_escape_string_regexp2();\n    var ansiStyles = require_ansi_styles();\n    var stdoutColor = require_supports_color2().stdout;\n    var template = require_templates2();\n    var isSimpleWindowsTerm = process.platform === "win32" && !(process.env.TERM || "").toLowerCase().startsWith("xterm");\n    var levelMapping = ["ansi", "ansi", "ansi256", "ansi16m"];\n    var skipModels = /* @__PURE__ */ new Set(["gray"]);\n    var styles = /* @__PURE__ */ Object.create(null);\n    function applyOptions(obj, options) {\n      options = options || {};\n      const scLevel = stdoutColor ? stdoutColor.level : 0;\n      obj.level = options.level === void 0 ? scLevel : options.level;\n      obj.enabled = "enabled" in options ? options.enabled : obj.level > 0;\n    }\n    function Chalk(options) {\n      if (!this || !(this instanceof Chalk) || this.template) {\n        const chalk = {};\n        applyOptions(chalk, options);\n        chalk.template = function() {\n          const args = [].slice.call(arguments);\n          return chalkTag.apply(null, [chalk.template].concat(args));\n        };\n        Object.setPrototypeOf(chalk, Chalk.prototype);\n        Object.setPrototypeOf(chalk.template, chalk);\n        chalk.template.constructor = Chalk;\n        return chalk.template;\n      }\n      applyOptions(this, options);\n    }\n    if (isSimpleWindowsTerm) {\n      ansiStyles.blue.open = "\\x1B[94m";\n    }\n    for (const key of Object.keys(ansiStyles)) {\n      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp2(ansiStyles[key].close), "g");\n      styles[key] = {\n        get() {\n          const codes = ansiStyles[key];\n          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);\n        }\n      };\n    }\n    styles.visible = {\n      get() {\n        return build.call(this, this._styles || [], true, "visible");\n      }\n    };\n    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp2(ansiStyles.color.close), "g");\n    for (const model of Object.keys(ansiStyles.color.ansi)) {\n      if (skipModels.has(model)) {\n        continue;\n      }\n      styles[model] = {\n        get() {\n          const level = this.level;\n          return function() {\n            const open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);\n            const codes = {\n              open,\n              close: ansiStyles.color.close,\n              closeRe: ansiStyles.color.closeRe\n            };\n            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n          };\n        }\n      };\n    }\n    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp2(ansiStyles.bgColor.close), "g");\n    for (const model of Object.keys(ansiStyles.bgColor.ansi)) {\n      if (skipModels.has(model)) {\n        continue;\n      }\n      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);\n      styles[bgModel] = {\n        get() {\n          const level = this.level;\n          return function() {\n            const open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);\n            const codes = {\n              open,\n              close: ansiStyles.bgColor.close,\n              closeRe: ansiStyles.bgColor.closeRe\n            };\n            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);\n          };\n        }\n      };\n    }\n    var proto = Object.defineProperties(() => {\n    }, styles);\n    function build(_styles, _empty, key) {\n      const builder = function() {\n        return applyStyle.apply(builder, arguments);\n      };\n      builder._styles = _styles;\n      builder._empty = _empty;\n      const self2 = this;\n      Object.defineProperty(builder, "level", {\n        enumerable: true,\n        get() {\n          return self2.level;\n        },\n        set(level) {\n          self2.level = level;\n        }\n      });\n      Object.defineProperty(builder, "enabled", {\n        enumerable: true,\n        get() {\n          return self2.enabled;\n        },\n        set(enabled) {\n          self2.enabled = enabled;\n        }\n      });\n      builder.hasGrey = this.hasGrey || key === "gray" || key === "grey";\n      builder.__proto__ = proto;\n      return builder;\n    }\n    function applyStyle() {\n      const args = arguments;\n      const argsLen = args.length;\n      let str = String(arguments[0]);\n      if (argsLen === 0) {\n        return "";\n      }\n      if (argsLen > 1) {\n        for (let a = 1; a < argsLen; a++) {\n          str += " " + args[a];\n        }\n      }\n      if (!this.enabled || this.level <= 0 || !str) {\n        return this._empty ? "" : str;\n      }\n      const originalDim = ansiStyles.dim.open;\n      if (isSimpleWindowsTerm && this.hasGrey) {\n        ansiStyles.dim.open = "";\n      }\n      for (const code of this._styles.slice().reverse()) {\n        str = code.open + str.replace(code.closeRe, code.open) + code.close;\n        str = str.replace(/\\r?\\n/g, `${code.close}$&${code.open}`);\n      }\n      ansiStyles.dim.open = originalDim;\n      return str;\n    }\n    function chalkTag(chalk, strings) {\n      if (!Array.isArray(strings)) {\n        return [].slice.call(arguments, 1).join(" ");\n      }\n      const args = [].slice.call(arguments, 2);\n      const parts = [strings.raw[0]];\n      for (let i = 1; i < strings.length; i++) {\n        parts.push(String(args[i - 1]).replace(/[{}\\\\]/g, "\\\\$&"));\n        parts.push(String(strings.raw[i]));\n      }\n      return template(chalk, parts.join(""));\n    }\n    Object.defineProperties(Chalk.prototype, styles);\n    module2.exports = Chalk();\n    module2.exports.supportsColor = stdoutColor;\n    module2.exports.default = module2.exports;\n  }\n});\nvar require_lib4 = __commonJS2({\n  "node_modules/@babel/highlight/lib/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.default = highlight;\n    exports2.getChalk = getChalk;\n    exports2.shouldHighlight = shouldHighlight;\n    var _jsTokens = require_js_tokens();\n    var _helperValidatorIdentifier = require_lib3();\n    var _chalk = require_chalk2();\n    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);\n    function getDefs(chalk) {\n      return {\n        keyword: chalk.cyan,\n        capitalized: chalk.yellow,\n        jsxIdentifier: chalk.yellow,\n        punctuator: chalk.yellow,\n        number: chalk.magenta,\n        string: chalk.green,\n        regex: chalk.magenta,\n        comment: chalk.grey,\n        invalid: chalk.white.bgRed.bold\n      };\n    }\n    var NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n    var BRACKET = /^[()[\\]{}]$/;\n    var tokenize;\n    {\n      const JSX_TAG = /^[a-z][\\w-]*$/i;\n      const getTokenType = function(token, offset, text) {\n        if (token.type === "name") {\n          if ((0, _helperValidatorIdentifier.isKeyword)(token.value) || (0, _helperValidatorIdentifier.isStrictReservedWord)(token.value, true) || sometimesKeywords.has(token.value)) {\n            return "keyword";\n          }\n          if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) == "</")) {\n            return "jsxIdentifier";\n          }\n          if (token.value[0] !== token.value[0].toLowerCase()) {\n            return "capitalized";\n          }\n        }\n        if (token.type === "punctuator" && BRACKET.test(token.value)) {\n          return "bracket";\n        }\n        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {\n          return "punctuator";\n        }\n        return token.type;\n      };\n      tokenize = function* (text) {\n        let match;\n        while (match = _jsTokens.default.exec(text)) {\n          const token = _jsTokens.matchToToken(match);\n          yield {\n            type: getTokenType(token, match.index, text),\n            value: token.value\n          };\n        }\n      };\n    }\n    function highlightTokens(defs, text) {\n      let highlighted = "";\n      for (const {\n        type,\n        value\n      } of tokenize(text)) {\n        const colorize = defs[type];\n        if (colorize) {\n          highlighted += value.split(NEWLINE).map((str) => colorize(str)).join("\\n");\n        } else {\n          highlighted += value;\n        }\n      }\n      return highlighted;\n    }\n    function shouldHighlight(options) {\n      return !!_chalk.supportsColor || options.forceColor;\n    }\n    function getChalk(options) {\n      return options.forceColor ? new _chalk.constructor({\n        enabled: true,\n        level: 1\n      }) : _chalk;\n    }\n    function highlight(code, options = {}) {\n      if (code !== "" && shouldHighlight(options)) {\n        const chalk = getChalk(options);\n        const defs = getDefs(chalk);\n        return highlightTokens(defs, code);\n      } else {\n        return code;\n      }\n    }\n  }\n});\nvar require_lib5 = __commonJS2({\n  "node_modules/@babel/code-frame/lib/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.codeFrameColumns = codeFrameColumns;\n    exports2.default = _default;\n    var _highlight = require_lib4();\n    var deprecationWarningShown = false;\n    function getDefs(chalk) {\n      return {\n        gutter: chalk.grey,\n        marker: chalk.red.bold,\n        message: chalk.red.bold\n      };\n    }\n    var NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n    function getMarkerLines(loc, source, opts) {\n      const startLoc = Object.assign({\n        column: 0,\n        line: -1\n      }, loc.start);\n      const endLoc = Object.assign({}, startLoc, loc.end);\n      const {\n        linesAbove = 2,\n        linesBelow = 3\n      } = opts || {};\n      const startLine = startLoc.line;\n      const startColumn = startLoc.column;\n      const endLine = endLoc.line;\n      const endColumn = endLoc.column;\n      let start = Math.max(startLine - (linesAbove + 1), 0);\n      let end = Math.min(source.length, endLine + linesBelow);\n      if (startLine === -1) {\n        start = 0;\n      }\n      if (endLine === -1) {\n        end = source.length;\n      }\n      const lineDiff = endLine - startLine;\n      const markerLines = {};\n      if (lineDiff) {\n        for (let i = 0; i <= lineDiff; i++) {\n          const lineNumber = i + startLine;\n          if (!startColumn) {\n            markerLines[lineNumber] = true;\n          } else if (i === 0) {\n            const sourceLength = source[lineNumber - 1].length;\n            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];\n          } else if (i === lineDiff) {\n            markerLines[lineNumber] = [0, endColumn];\n          } else {\n            const sourceLength = source[lineNumber - i].length;\n            markerLines[lineNumber] = [0, sourceLength];\n          }\n        }\n      } else {\n        if (startColumn === endColumn) {\n          if (startColumn) {\n            markerLines[startLine] = [startColumn, 0];\n          } else {\n            markerLines[startLine] = true;\n          }\n        } else {\n          markerLines[startLine] = [startColumn, endColumn - startColumn];\n        }\n      }\n      return {\n        start,\n        end,\n        markerLines\n      };\n    }\n    function codeFrameColumns(rawLines, loc, opts = {}) {\n      const highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight.shouldHighlight)(opts);\n      const chalk = (0, _highlight.getChalk)(opts);\n      const defs = getDefs(chalk);\n      const maybeHighlight = (chalkFn, string) => {\n        return highlighted ? chalkFn(string) : string;\n      };\n      const lines = rawLines.split(NEWLINE);\n      const {\n        start,\n        end,\n        markerLines\n      } = getMarkerLines(loc, lines, opts);\n      const hasColumns = loc.start && typeof loc.start.column === "number";\n      const numberMaxWidth = String(end).length;\n      const highlightedLines = highlighted ? (0, _highlight.default)(rawLines, opts) : rawLines;\n      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {\n        const number = start + 1 + index;\n        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);\n        const gutter = ` ${paddedNumber} |`;\n        const hasMarker = markerLines[number];\n        const lastMarkerLine = !markerLines[number + 1];\n        if (hasMarker) {\n          let markerLine = "";\n          if (Array.isArray(hasMarker)) {\n            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\\t]/g, " ");\n            const numberOfMarkers = hasMarker[1] || 1;\n            markerLine = ["\\n ", maybeHighlight(defs.gutter, gutter.replace(/\\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");\n            if (lastMarkerLine && opts.message) {\n              markerLine += " " + maybeHighlight(defs.message, opts.message);\n            }\n          }\n          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");\n        } else {\n          return ` ${maybeHighlight(defs.gutter, gutter)}${line.length > 0 ? ` ${line}` : ""}`;\n        }\n      }).join("\\n");\n      if (opts.message && !hasColumns) {\n        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}\n${frame}`;\n      }\n      if (highlighted) {\n        return chalk.reset(frame);\n      } else {\n        return frame;\n      }\n    }\n    function _default(rawLines, lineNumber, colNumber, opts = {}) {\n      if (!deprecationWarningShown) {\n        deprecationWarningShown = true;\n        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";\n        if (process.emitWarning) {\n          process.emitWarning(message, "DeprecationWarning");\n        } else {\n          const deprecationError = new Error(message);\n          deprecationError.name = "DeprecationWarning";\n          console.warn(new Error(message));\n        }\n      }\n      colNumber = Math.max(colNumber, 0);\n      const location = {\n        start: {\n          column: colNumber,\n          line: lineNumber\n        }\n      };\n      return codeFrameColumns(rawLines, location, opts);\n    }\n  }\n});\nvar require_parser = __commonJS2({\n  "src/main/parser.js"(exports2, module2) {\n    "use strict";\n    var {\n      ConfigError\n    } = require_errors();\n    var jsLoc = require_loc();\n    var loadParser = require_load_parser();\n    var {\n      locStart,\n      locEnd\n    } = jsLoc;\n    var ownNames = Object.getOwnPropertyNames;\n    var ownDescriptor = Object.getOwnPropertyDescriptor;\n    function getParsers(options) {\n      const parsers = {};\n      for (const plugin of options.plugins) {\n        if (!plugin.parsers) {\n          continue;\n        }\n        for (const name of ownNames(plugin.parsers)) {\n          Object.defineProperty(parsers, name, ownDescriptor(plugin.parsers, name));\n        }\n      }\n      return parsers;\n    }\n    function resolveParser(opts, parsers = getParsers(opts)) {\n      if (typeof opts.parser === "function") {\n        return {\n          parse: opts.parser,\n          astFormat: "estree",\n          locStart,\n          locEnd\n        };\n      }\n      if (typeof opts.parser === "string") {\n        if (Object.prototype.hasOwnProperty.call(parsers, opts.parser)) {\n          return parsers[opts.parser];\n        }\n        if (false) {\n          throw new ConfigError(`Couldn\'t resolve parser "${opts.parser}". Parsers must be explicitly added to the standalone bundle.`);\n        }\n        return loadParser(opts.parser);\n      }\n    }\n    function parse(text, opts) {\n      const parsers = getParsers(opts);\n      const parsersForCustomParserApi = Object.defineProperties({}, Object.fromEntries(Object.keys(parsers).map((parserName) => [parserName, {\n        enumerable: true,\n        get() {\n          return parsers[parserName].parse;\n        }\n      }])));\n      const parser = resolveParser(opts, parsers);\n      try {\n        if (parser.preprocess) {\n          text = parser.preprocess(text, opts);\n        }\n        return {\n          text,\n          ast: parser.parse(text, parsersForCustomParserApi, opts)\n        };\n      } catch (error) {\n        const {\n          loc\n        } = error;\n        if (loc) {\n          const {\n            codeFrameColumns\n          } = require_lib5();\n          error.codeFrame = codeFrameColumns(text, loc, {\n            highlightCode: true\n          });\n          error.message += "\\n" + error.codeFrame;\n          throw error;\n        }\n        throw error;\n      }\n    }\n    module2.exports = {\n      parse,\n      resolveParser\n    };\n  }\n});\nvar require_readlines = __commonJS2({\n  "node_modules/n-readlines/readlines.js"(exports2, module2) {\n    "use strict";\n    var fs = require("fs");\n    var LineByLine = class {\n      constructor(file, options) {\n        options = options || {};\n        if (!options.readChunk)\n          options.readChunk = 1024;\n        if (!options.newLineCharacter) {\n          options.newLineCharacter = 10;\n        } else {\n          options.newLineCharacter = options.newLineCharacter.charCodeAt(0);\n        }\n        if (typeof file === "number") {\n          this.fd = file;\n        } else {\n          this.fd = fs.openSync(file, "r");\n        }\n        this.options = options;\n        this.newLineCharacter = options.newLineCharacter;\n        this.reset();\n      }\n      _searchInBuffer(buffer, hexNeedle) {\n        let found = -1;\n        for (let i = 0; i <= buffer.length; i++) {\n          let b_byte = buffer[i];\n          if (b_byte === hexNeedle) {\n            found = i;\n            break;\n          }\n        }\n        return found;\n      }\n      reset() {\n        this.eofReached = false;\n        this.linesCache = [];\n        this.fdPosition = 0;\n      }\n      close() {\n        fs.closeSync(this.fd);\n        this.fd = null;\n      }\n      _extractLines(buffer) {\n        let line;\n        const lines = [];\n        let bufferPosition = 0;\n        let lastNewLineBufferPosition = 0;\n        while (true) {\n          let bufferPositionValue = buffer[bufferPosition++];\n          if (bufferPositionValue === this.newLineCharacter) {\n            line = buffer.slice(lastNewLineBufferPosition, bufferPosition);\n            lines.push(line);\n            lastNewLineBufferPosition = bufferPosition;\n          } else if (bufferPositionValue === void 0) {\n            break;\n          }\n        }\n        let leftovers = buffer.slice(lastNewLineBufferPosition, bufferPosition);\n        if (leftovers.length) {\n          lines.push(leftovers);\n        }\n        return lines;\n      }\n      _readChunk(lineLeftovers) {\n        let totalBytesRead = 0;\n        let bytesRead;\n        const buffers = [];\n        do {\n          const readBuffer = new Buffer(this.options.readChunk);\n          bytesRead = fs.readSync(this.fd, readBuffer, 0, this.options.readChunk, this.fdPosition);\n          totalBytesRead = totalBytesRead + bytesRead;\n          this.fdPosition = this.fdPosition + bytesRead;\n          buffers.push(readBuffer);\n        } while (bytesRead && this._searchInBuffer(buffers[buffers.length - 1], this.options.newLineCharacter) === -1);\n        let bufferData = Buffer.concat(buffers);\n        if (bytesRead < this.options.readChunk) {\n          this.eofReached = true;\n          bufferData = bufferData.slice(0, totalBytesRead);\n        }\n        if (totalBytesRead) {\n          this.linesCache = this._extractLines(bufferData);\n          if (lineLeftovers) {\n            this.linesCache[0] = Buffer.concat([lineLeftovers, this.linesCache[0]]);\n          }\n        }\n        return totalBytesRead;\n      }\n      next() {\n        if (!this.fd)\n          return false;\n        let line = false;\n        if (this.eofReached && this.linesCache.length === 0) {\n          return line;\n        }\n        let bytesRead;\n        if (!this.linesCache.length) {\n          bytesRead = this._readChunk();\n        }\n        if (this.linesCache.length) {\n          line = this.linesCache.shift();\n          const lastLineCharacter = line[line.length - 1];\n          if (lastLineCharacter !== this.newLineCharacter) {\n            bytesRead = this._readChunk(line);\n            if (bytesRead) {\n              line = this.linesCache.shift();\n            }\n          }\n        }\n        if (this.eofReached && this.linesCache.length === 0) {\n          this.close();\n        }\n        if (line && line[line.length - 1] === this.newLineCharacter) {\n          line = line.slice(0, line.length - 1);\n        }\n        return line;\n      }\n    };\n    module2.exports = LineByLine;\n  }\n});\nvar require_get_interpreter = __commonJS2({\n  "src/utils/get-interpreter.js"(exports2, module2) {\n    "use strict";\n    var fs = require("fs");\n    var readlines = require_readlines();\n    function getInterpreter(filepath) {\n      if (typeof filepath !== "string") {\n        return "";\n      }\n      let fd;\n      try {\n        fd = fs.openSync(filepath, "r");\n      } catch {\n        return "";\n      }\n      try {\n        const liner = new readlines(fd);\n        const firstLine = liner.next().toString("utf8");\n        const m1 = firstLine.match(/^#!\\/(?:usr\\/)?bin\\/env\\s+(\\S+)/);\n        if (m1) {\n          return m1[1];\n        }\n        const m2 = firstLine.match(/^#!\\/(?:usr\\/(?:local\\/)?)?bin\\/(\\S+)/);\n        if (m2) {\n          return m2[1];\n        }\n        return "";\n      } catch {\n        return "";\n      } finally {\n        try {\n          fs.closeSync(fd);\n        } catch {\n        }\n      }\n    }\n    module2.exports = getInterpreter;\n  }\n});\nvar require_options = __commonJS2({\n  "src/main/options.js"(exports2, module2) {\n    "use strict";\n    var path = require("path");\n    var {\n      UndefinedParserError\n    } = require_errors();\n    var {\n      getSupportInfo: getSupportInfo2\n    } = require_support();\n    var normalizer = require_options_normalizer();\n    var {\n      resolveParser\n    } = require_parser();\n    var hiddenDefaults = {\n      astFormat: "estree",\n      printer: {},\n      originalText: void 0,\n      locStart: null,\n      locEnd: null\n    };\n    function normalize(options, opts = {}) {\n      const rawOptions = Object.assign({}, options);\n      const supportOptions = getSupportInfo2({\n        plugins: options.plugins,\n        showUnreleased: true,\n        showDeprecated: true\n      }).options;\n      const defaults = Object.assign(Object.assign({}, hiddenDefaults), Object.fromEntries(supportOptions.filter((optionInfo) => optionInfo.default !== void 0).map((option) => [option.name, option.default])));\n      if (!rawOptions.parser) {\n        if (!rawOptions.filepath) {\n          const logger = opts.logger || console;\n          logger.warn("No parser and no filepath given, using \'babel\' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred.");\n          rawOptions.parser = "babel";\n        } else {\n          rawOptions.parser = inferParser(rawOptions.filepath, rawOptions.plugins);\n          if (!rawOptions.parser) {\n            throw new UndefinedParserError(`No parser could be inferred for file: ${rawOptions.filepath}`);\n          }\n        }\n      }\n      const parser = resolveParser(normalizer.normalizeApiOptions(rawOptions, [supportOptions.find((x) => x.name === "parser")], {\n        passThrough: true,\n        logger: false\n      }));\n      rawOptions.astFormat = parser.astFormat;\n      rawOptions.locEnd = parser.locEnd;\n      rawOptions.locStart = parser.locStart;\n      const plugin = getPlugin(rawOptions);\n      rawOptions.printer = plugin.printers[rawOptions.astFormat];\n      const pluginDefaults = Object.fromEntries(supportOptions.filter((optionInfo) => optionInfo.pluginDefaults && optionInfo.pluginDefaults[plugin.name] !== void 0).map((optionInfo) => [optionInfo.name, optionInfo.pluginDefaults[plugin.name]]));\n      const mixedDefaults = Object.assign(Object.assign({}, defaults), pluginDefaults);\n      for (const [k, value] of Object.entries(mixedDefaults)) {\n        if (rawOptions[k] === null || rawOptions[k] === void 0) {\n          rawOptions[k] = value;\n        }\n      }\n      if (rawOptions.parser === "json") {\n        rawOptions.trailingComma = "none";\n      }\n      return normalizer.normalizeApiOptions(rawOptions, supportOptions, Object.assign({\n        passThrough: Object.keys(hiddenDefaults)\n      }, opts));\n    }\n    function getPlugin(options) {\n      const {\n        astFormat\n      } = options;\n      if (!astFormat) {\n        throw new Error("getPlugin() requires astFormat to be set");\n      }\n      const printerPlugin = options.plugins.find((plugin) => plugin.printers && plugin.printers[astFormat]);\n      if (!printerPlugin) {\n        throw new Error(`Couldn\'t find plugin for AST format "${astFormat}"`);\n      }\n      return printerPlugin;\n    }\n    function inferParser(filepath, plugins2) {\n      const filename = path.basename(filepath).toLowerCase();\n      const languages = getSupportInfo2({\n        plugins: plugins2\n      }).languages.filter((language2) => language2.since !== null);\n      let language = languages.find((language2) => language2.extensions && language2.extensions.some((extension) => filename.endsWith(extension)) || language2.filenames && language2.filenames.some((name) => name.toLowerCase() === filename));\n      if (!language && !filename.includes(".")) {\n        const getInterpreter = require_get_interpreter();\n        const interpreter = getInterpreter(filepath);\n        language = languages.find((language2) => language2.interpreters && language2.interpreters.includes(interpreter));\n      }\n      return language && language.parsers[0];\n    }\n    module2.exports = {\n      normalize,\n      hiddenDefaults,\n      inferParser\n    };\n  }\n});\nvar require_massage_ast = __commonJS2({\n  "src/main/massage-ast.js"(exports2, module2) {\n    "use strict";\n    function massageAST(ast, options, parent) {\n      if (Array.isArray(ast)) {\n        return ast.map((e) => massageAST(e, options, parent)).filter(Boolean);\n      }\n      if (!ast || typeof ast !== "object") {\n        return ast;\n      }\n      const cleanFunction = options.printer.massageAstNode;\n      let ignoredProperties;\n      if (cleanFunction && cleanFunction.ignoredProperties) {\n        ignoredProperties = cleanFunction.ignoredProperties;\n      } else {\n        ignoredProperties = /* @__PURE__ */ new Set();\n      }\n      const newObj = {};\n      for (const [key, value] of Object.entries(ast)) {\n        if (!ignoredProperties.has(key) && typeof value !== "function") {\n          newObj[key] = massageAST(value, options, ast);\n        }\n      }\n      if (cleanFunction) {\n        const result = cleanFunction(ast, newObj, parent);\n        if (result === null) {\n          return;\n        }\n        if (result) {\n          return result;\n        }\n      }\n      return newObj;\n    }\n    module2.exports = massageAST;\n  }\n});\nvar require_comments = __commonJS2({\n  "src/main/comments.js"(exports2, module2) {\n    "use strict";\n    var assert = require("assert");\n    var {\n      builders: {\n        line,\n        hardline,\n        breakParent,\n        indent,\n        lineSuffix,\n        join,\n        cursor\n      }\n    } = require("./doc.js");\n    var {\n      hasNewline,\n      skipNewline,\n      skipSpaces,\n      isPreviousLineEmpty,\n      addLeadingComment,\n      addDanglingComment,\n      addTrailingComment\n    } = require_util();\n    var childNodesCache = /* @__PURE__ */ new WeakMap();\n    function getSortedChildNodes(node, options, resultArray) {\n      if (!node) {\n        return;\n      }\n      const {\n        printer,\n        locStart,\n        locEnd\n      } = options;\n      if (resultArray) {\n        if (printer.canAttachComment && printer.canAttachComment(node)) {\n          let i;\n          for (i = resultArray.length - 1; i >= 0; --i) {\n            if (locStart(resultArray[i]) <= locStart(node) && locEnd(resultArray[i]) <= locEnd(node)) {\n              break;\n            }\n          }\n          resultArray.splice(i + 1, 0, node);\n          return;\n        }\n      } else if (childNodesCache.has(node)) {\n        return childNodesCache.get(node);\n      }\n      const childNodes = printer.getCommentChildNodes && printer.getCommentChildNodes(node, options) || typeof node === "object" && Object.entries(node).filter(([key]) => key !== "enclosingNode" && key !== "precedingNode" && key !== "followingNode" && key !== "tokens" && key !== "comments" && key !== "parent").map(([, value]) => value);\n      if (!childNodes) {\n        return;\n      }\n      if (!resultArray) {\n        resultArray = [];\n        childNodesCache.set(node, resultArray);\n      }\n      for (const childNode of childNodes) {\n        getSortedChildNodes(childNode, options, resultArray);\n      }\n      return resultArray;\n    }\n    function decorateComment(node, comment, options, enclosingNode) {\n      const {\n        locStart,\n        locEnd\n      } = options;\n      const commentStart = locStart(comment);\n      const commentEnd = locEnd(comment);\n      const childNodes = getSortedChildNodes(node, options);\n      let precedingNode;\n      let followingNode;\n      let left = 0;\n      let right = childNodes.length;\n      while (left < right) {\n        const middle = left + right >> 1;\n        const child = childNodes[middle];\n        const start = locStart(child);\n        const end = locEnd(child);\n        if (start <= commentStart && commentEnd <= end) {\n          return decorateComment(child, comment, options, child);\n        }\n        if (end <= commentStart) {\n          precedingNode = child;\n          left = middle + 1;\n          continue;\n        }\n        if (commentEnd <= start) {\n          followingNode = child;\n          right = middle;\n          continue;\n        }\n        throw new Error("Comment location overlaps with node location");\n      }\n      if (enclosingNode && enclosingNode.type === "TemplateLiteral") {\n        const {\n          quasis\n        } = enclosingNode;\n        const commentIndex = findExpressionIndexForComment(quasis, comment, options);\n        if (precedingNode && findExpressionIndexForComment(quasis, precedingNode, options) !== commentIndex) {\n          precedingNode = null;\n        }\n        if (followingNode && findExpressionIndexForComment(quasis, followingNode, options) !== commentIndex) {\n          followingNode = null;\n        }\n      }\n      return {\n        enclosingNode,\n        precedingNode,\n        followingNode\n      };\n    }\n    var returnFalse = () => false;\n    function attach(comments, ast, text, options) {\n      if (!Array.isArray(comments)) {\n        return;\n      }\n      const tiesToBreak = [];\n      const {\n        locStart,\n        locEnd,\n        printer: {\n          handleComments = {}\n        }\n      } = options;\n      const {\n        avoidAstMutation,\n        ownLine: handleOwnLineComment = returnFalse,\n        endOfLine: handleEndOfLineComment = returnFalse,\n        remaining: handleRemainingComment = returnFalse\n      } = handleComments;\n      const decoratedComments = comments.map((comment, index) => Object.assign(Object.assign({}, decorateComment(ast, comment, options)), {}, {\n        comment,\n        text,\n        options,\n        ast,\n        isLastComment: comments.length - 1 === index\n      }));\n      for (const [index, context] of decoratedComments.entries()) {\n        const {\n          comment,\n          precedingNode,\n          enclosingNode,\n          followingNode,\n          text: text2,\n          options: options2,\n          ast: ast2,\n          isLastComment\n        } = context;\n        if (options2.parser === "json" || options2.parser === "json5" || options2.parser === "__js_expression" || options2.parser === "__vue_expression" || options2.parser === "__vue_ts_expression") {\n          if (locStart(comment) - locStart(ast2) <= 0) {\n            addLeadingComment(ast2, comment);\n            continue;\n          }\n          if (locEnd(comment) - locEnd(ast2) >= 0) {\n            addTrailingComment(ast2, comment);\n            continue;\n          }\n        }\n        let args;\n        if (avoidAstMutation) {\n          args = [context];\n        } else {\n          comment.enclosingNode = enclosingNode;\n          comment.precedingNode = precedingNode;\n          comment.followingNode = followingNode;\n          args = [comment, text2, options2, ast2, isLastComment];\n        }\n        if (isOwnLineComment(text2, options2, decoratedComments, index)) {\n          comment.placement = "ownLine";\n          if (handleOwnLineComment(...args)) {\n          } else if (followingNode) {\n            addLeadingComment(followingNode, comment);\n          } else if (precedingNode) {\n            addTrailingComment(precedingNode, comment);\n          } else if (enclosingNode) {\n            addDanglingComment(enclosingNode, comment);\n          } else {\n            addDanglingComment(ast2, comment);\n          }\n        } else if (isEndOfLineComment(text2, options2, decoratedComments, index)) {\n          comment.placement = "endOfLine";\n          if (handleEndOfLineComment(...args)) {\n          } else if (precedingNode) {\n            addTrailingComment(precedingNode, comment);\n          } else if (followingNode) {\n            addLeadingComment(followingNode, comment);\n          } else if (enclosingNode) {\n            addDanglingComment(enclosingNode, comment);\n          } else {\n            addDanglingComment(ast2, comment);\n          }\n        } else {\n          comment.placement = "remaining";\n          if (handleRemainingComment(...args)) {\n          } else if (precedingNode && followingNode) {\n            const tieCount = tiesToBreak.length;\n            if (tieCount > 0) {\n              const lastTie = tiesToBreak[tieCount - 1];\n              if (lastTie.followingNode !== followingNode) {\n                breakTies(tiesToBreak, text2, options2);\n              }\n            }\n            tiesToBreak.push(context);\n          } else if (precedingNode) {\n            addTrailingComment(precedingNode, comment);\n          } else if (followingNode) {\n            addLeadingComment(followingNode, comment);\n          } else if (enclosingNode) {\n            addDanglingComment(enclosingNode, comment);\n          } else {\n            addDanglingComment(ast2, comment);\n          }\n        }\n      }\n      breakTies(tiesToBreak, text, options);\n      if (!avoidAstMutation) {\n        for (const comment of comments) {\n          delete comment.precedingNode;\n          delete comment.enclosingNode;\n          delete comment.followingNode;\n        }\n      }\n    }\n    var isAllEmptyAndNoLineBreak = (text) => !/[\\S\\n\\u2028\\u2029]/.test(text);\n    function isOwnLineComment(text, options, decoratedComments, commentIndex) {\n      const {\n        comment,\n        precedingNode\n      } = decoratedComments[commentIndex];\n      const {\n        locStart,\n        locEnd\n      } = options;\n      let start = locStart(comment);\n      if (precedingNode) {\n        for (let index = commentIndex - 1; index >= 0; index--) {\n          const {\n            comment: comment2,\n            precedingNode: currentCommentPrecedingNode\n          } = decoratedComments[index];\n          if (currentCommentPrecedingNode !== precedingNode || !isAllEmptyAndNoLineBreak(text.slice(locEnd(comment2), start))) {\n            break;\n          }\n          start = locStart(comment2);\n        }\n      }\n      return hasNewline(text, start, {\n        backwards: true\n      });\n    }\n    function isEndOfLineComment(text, options, decoratedComments, commentIndex) {\n      const {\n        comment,\n        followingNode\n      } = decoratedComments[commentIndex];\n      const {\n        locStart,\n        locEnd\n      } = options;\n      let end = locEnd(comment);\n      if (followingNode) {\n        for (let index = commentIndex + 1; index < decoratedComments.length; index++) {\n          const {\n            comment: comment2,\n            followingNode: currentCommentFollowingNode\n          } = decoratedComments[index];\n          if (currentCommentFollowingNode !== followingNode || !isAllEmptyAndNoLineBreak(text.slice(end, locStart(comment2)))) {\n            break;\n          }\n          end = locEnd(comment2);\n        }\n      }\n      return hasNewline(text, end);\n    }\n    function breakTies(tiesToBreak, text, options) {\n      const tieCount = tiesToBreak.length;\n      if (tieCount === 0) {\n        return;\n      }\n      const {\n        precedingNode,\n        followingNode,\n        enclosingNode\n      } = tiesToBreak[0];\n      const gapRegExp = options.printer.getGapRegex && options.printer.getGapRegex(enclosingNode) || /^[\\s(]*$/;\n      let gapEndPos = options.locStart(followingNode);\n      let indexOfFirstLeadingComment;\n      for (indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n        const {\n          comment,\n          precedingNode: currentCommentPrecedingNode,\n          followingNode: currentCommentFollowingNode\n        } = tiesToBreak[indexOfFirstLeadingComment - 1];\n        assert.strictEqual(currentCommentPrecedingNode, precedingNode);\n        assert.strictEqual(currentCommentFollowingNode, followingNode);\n        const gap = text.slice(options.locEnd(comment), gapEndPos);\n        if (gapRegExp.test(gap)) {\n          gapEndPos = options.locStart(comment);\n        } else {\n          break;\n        }\n      }\n      for (const [i, {\n        comment\n      }] of tiesToBreak.entries()) {\n        if (i < indexOfFirstLeadingComment) {\n          addTrailingComment(precedingNode, comment);\n        } else {\n          addLeadingComment(followingNode, comment);\n        }\n      }\n      for (const node of [precedingNode, followingNode]) {\n        if (node.comments && node.comments.length > 1) {\n          node.comments.sort((a, b) => options.locStart(a) - options.locStart(b));\n        }\n      }\n      tiesToBreak.length = 0;\n    }\n    function printComment(path, options) {\n      const comment = path.getValue();\n      comment.printed = true;\n      return options.printer.printComment(path, options);\n    }\n    function findExpressionIndexForComment(quasis, comment, options) {\n      const startPos = options.locStart(comment) - 1;\n      for (let i = 1; i < quasis.length; ++i) {\n        if (startPos < options.locStart(quasis[i])) {\n          return i - 1;\n        }\n      }\n      return 0;\n    }\n    function printLeadingComment(path, options) {\n      const comment = path.getValue();\n      const parts = [printComment(path, options)];\n      const {\n        printer,\n        originalText,\n        locStart,\n        locEnd\n      } = options;\n      const isBlock = printer.isBlockComment && printer.isBlockComment(comment);\n      if (isBlock) {\n        const lineBreak = hasNewline(originalText, locEnd(comment)) ? hasNewline(originalText, locStart(comment), {\n          backwards: true\n        }) ? hardline : line : " ";\n        parts.push(lineBreak);\n      } else {\n        parts.push(hardline);\n      }\n      const index = skipNewline(originalText, skipSpaces(originalText, locEnd(comment)));\n      if (index !== false && hasNewline(originalText, index)) {\n        parts.push(hardline);\n      }\n      return parts;\n    }\n    function printTrailingComment(path, options) {\n      const comment = path.getValue();\n      const printed = printComment(path, options);\n      const {\n        printer,\n        originalText,\n        locStart\n      } = options;\n      const isBlock = printer.isBlockComment && printer.isBlockComment(comment);\n      if (hasNewline(originalText, locStart(comment), {\n        backwards: true\n      })) {\n        const isLineBeforeEmpty = isPreviousLineEmpty(originalText, comment, locStart);\n        return lineSuffix([hardline, isLineBeforeEmpty ? hardline : "", printed]);\n      }\n      let parts = [" ", printed];\n      if (!isBlock) {\n        parts = [lineSuffix(parts), breakParent];\n      }\n      return parts;\n    }\n    function printDanglingComments(path, options, sameIndent, filter) {\n      const parts = [];\n      const node = path.getValue();\n      if (!node || !node.comments) {\n        return "";\n      }\n      path.each(() => {\n        const comment = path.getValue();\n        if (!comment.leading && !comment.trailing && (!filter || filter(comment))) {\n          parts.push(printComment(path, options));\n        }\n      }, "comments");\n      if (parts.length === 0) {\n        return "";\n      }\n      if (sameIndent) {\n        return join(hardline, parts);\n      }\n      return indent([hardline, join(hardline, parts)]);\n    }\n    function printCommentsSeparately(path, options, ignored) {\n      const value = path.getValue();\n      if (!value) {\n        return {};\n      }\n      let comments = value.comments || [];\n      if (ignored) {\n        comments = comments.filter((comment) => !ignored.has(comment));\n      }\n      const isCursorNode = value === options.cursorNode;\n      if (comments.length === 0) {\n        const maybeCursor = isCursorNode ? cursor : "";\n        return {\n          leading: maybeCursor,\n          trailing: maybeCursor\n        };\n      }\n      const leadingParts = [];\n      const trailingParts = [];\n      path.each(() => {\n        const comment = path.getValue();\n        if (ignored && ignored.has(comment)) {\n          return;\n        }\n        const {\n          leading,\n          trailing\n        } = comment;\n        if (leading) {\n          leadingParts.push(printLeadingComment(path, options));\n        } else if (trailing) {\n          trailingParts.push(printTrailingComment(path, options));\n        }\n      }, "comments");\n      if (isCursorNode) {\n        leadingParts.unshift(cursor);\n        trailingParts.push(cursor);\n      }\n      return {\n        leading: leadingParts,\n        trailing: trailingParts\n      };\n    }\n    function printComments(path, doc2, options, ignored) {\n      const {\n        leading,\n        trailing\n      } = printCommentsSeparately(path, options, ignored);\n      if (!leading && !trailing) {\n        return doc2;\n      }\n      return [leading, doc2, trailing];\n    }\n    function ensureAllCommentsPrinted(astComments) {\n      if (!astComments) {\n        return;\n      }\n      for (const comment of astComments) {\n        if (!comment.printed) {\n          throw new Error(\'Comment "\' + comment.value.trim() + \'" was not printed. Please report this error!\');\n        }\n        delete comment.printed;\n      }\n    }\n    module2.exports = {\n      attach,\n      printComments,\n      printCommentsSeparately,\n      printDanglingComments,\n      getSortedChildNodes,\n      ensureAllCommentsPrinted\n    };\n  }\n});\nvar require_ast_path = __commonJS2({\n  "src/common/ast-path.js"(exports2, module2) {\n    "use strict";\n    var getLast = require_get_last();\n    function getNodeHelper(path, count) {\n      const stackIndex = getNodeStackIndexHelper(path.stack, count);\n      return stackIndex === -1 ? null : path.stack[stackIndex];\n    }\n    function getNodeStackIndexHelper(stack, count) {\n      for (let i = stack.length - 1; i >= 0; i -= 2) {\n        const value = stack[i];\n        if (value && !Array.isArray(value) && --count < 0) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    var AstPath = class {\n      constructor(value) {\n        this.stack = [value];\n      }\n      getName() {\n        const {\n          stack\n        } = this;\n        const {\n          length\n        } = stack;\n        if (length > 1) {\n          return stack[length - 2];\n        }\n        return null;\n      }\n      getValue() {\n        return getLast(this.stack);\n      }\n      getNode(count = 0) {\n        return getNodeHelper(this, count);\n      }\n      getParentNode(count = 0) {\n        return getNodeHelper(this, count + 1);\n      }\n      call(callback, ...names) {\n        const {\n          stack\n        } = this;\n        const {\n          length\n        } = stack;\n        let value = getLast(stack);\n        for (const name of names) {\n          value = value[name];\n          stack.push(name, value);\n        }\n        const result = callback(this);\n        stack.length = length;\n        return result;\n      }\n      callParent(callback, count = 0) {\n        const stackIndex = getNodeStackIndexHelper(this.stack, count + 1);\n        const parentValues = this.stack.splice(stackIndex + 1);\n        const result = callback(this);\n        this.stack.push(...parentValues);\n        return result;\n      }\n      each(callback, ...names) {\n        const {\n          stack\n        } = this;\n        const {\n          length\n        } = stack;\n        let value = getLast(stack);\n        for (const name of names) {\n          value = value[name];\n          stack.push(name, value);\n        }\n        for (let i = 0; i < value.length; ++i) {\n          stack.push(i, value[i]);\n          callback(this, i, value);\n          stack.length -= 2;\n        }\n        stack.length = length;\n      }\n      map(callback, ...names) {\n        const result = [];\n        this.each((path, index, value) => {\n          result[index] = callback(path, index, value);\n        }, ...names);\n        return result;\n      }\n      try(callback) {\n        const {\n          stack\n        } = this;\n        const stackBackup = [...stack];\n        try {\n          return callback();\n        } finally {\n          stack.length = 0;\n          stack.push(...stackBackup);\n        }\n      }\n      match(...predicates) {\n        let stackPointer = this.stack.length - 1;\n        let name = null;\n        let node = this.stack[stackPointer--];\n        for (const predicate of predicates) {\n          if (node === void 0) {\n            return false;\n          }\n          let number = null;\n          if (typeof name === "number") {\n            number = name;\n            name = this.stack[stackPointer--];\n            node = this.stack[stackPointer--];\n          }\n          if (predicate && !predicate(node, name, number)) {\n            return false;\n          }\n          name = this.stack[stackPointer--];\n          node = this.stack[stackPointer--];\n        }\n        return true;\n      }\n      findAncestor(predicate) {\n        let stackPointer = this.stack.length - 1;\n        let name = null;\n        let node = this.stack[stackPointer--];\n        while (node) {\n          let number = null;\n          if (typeof name === "number") {\n            number = name;\n            name = this.stack[stackPointer--];\n            node = this.stack[stackPointer--];\n          }\n          if (name !== null && predicate(node, name, number)) {\n            return node;\n          }\n          name = this.stack[stackPointer--];\n          node = this.stack[stackPointer--];\n        }\n      }\n    };\n    module2.exports = AstPath;\n  }\n});\nvar require_multiparser = __commonJS2({\n  "src/main/multiparser.js"(exports2, module2) {\n    "use strict";\n    var {\n      utils: {\n        stripTrailingHardline\n      }\n    } = require("./doc.js");\n    var {\n      normalize\n    } = require_options();\n    var comments = require_comments();\n    function printSubtree(path, print, options, printAstToDoc) {\n      if (options.printer.embed && options.embeddedLanguageFormatting === "auto") {\n        return options.printer.embed(path, print, (text, partialNextOptions, textToDocOptions) => textToDoc(text, partialNextOptions, options, printAstToDoc, textToDocOptions), options);\n      }\n    }\n    function textToDoc(text, partialNextOptions, parentOptions, printAstToDoc, {\n      stripTrailingHardline: shouldStripTrailingHardline = false\n    } = {}) {\n      const nextOptions = normalize(Object.assign(Object.assign(Object.assign({}, parentOptions), partialNextOptions), {}, {\n        parentParser: parentOptions.parser,\n        originalText: text\n      }), {\n        passThrough: true\n      });\n      const result = require_parser().parse(text, nextOptions);\n      const {\n        ast\n      } = result;\n      text = result.text;\n      const astComments = ast.comments;\n      delete ast.comments;\n      comments.attach(astComments, ast, text, nextOptions);\n      nextOptions[Symbol.for("comments")] = astComments || [];\n      nextOptions[Symbol.for("tokens")] = ast.tokens || [];\n      const doc2 = printAstToDoc(ast, nextOptions);\n      comments.ensureAllCommentsPrinted(astComments);\n      if (shouldStripTrailingHardline) {\n        if (typeof doc2 === "string") {\n          return doc2.replace(/(?:\\r?\\n)*$/, "");\n        }\n        return stripTrailingHardline(doc2);\n      }\n      return doc2;\n    }\n    module2.exports = {\n      printSubtree\n    };\n  }\n});\nvar require_ast_to_doc = __commonJS2({\n  "src/main/ast-to-doc.js"(exports2, module2) {\n    "use strict";\n    var AstPath = require_ast_path();\n    var {\n      builders: {\n        hardline,\n        addAlignmentToDoc\n      },\n      utils: {\n        propagateBreaks\n      }\n    } = require("./doc.js");\n    var {\n      printComments\n    } = require_comments();\n    var multiparser = require_multiparser();\n    function printAstToDoc(ast, options, alignmentSize = 0) {\n      const {\n        printer\n      } = options;\n      if (printer.preprocess) {\n        ast = printer.preprocess(ast, options);\n      }\n      const cache = /* @__PURE__ */ new Map();\n      const path = new AstPath(ast);\n      let doc2 = mainPrint();\n      if (alignmentSize > 0) {\n        doc2 = addAlignmentToDoc([hardline, doc2], alignmentSize, options.tabWidth);\n      }\n      propagateBreaks(doc2);\n      return doc2;\n      function mainPrint(selector, args) {\n        if (selector === void 0 || selector === path) {\n          return mainPrintInternal(args);\n        }\n        if (Array.isArray(selector)) {\n          return path.call(() => mainPrintInternal(args), ...selector);\n        }\n        return path.call(() => mainPrintInternal(args), selector);\n      }\n      function mainPrintInternal(args) {\n        const value = path.getValue();\n        const shouldCache = value && typeof value === "object" && args === void 0;\n        if (shouldCache && cache.has(value)) {\n          return cache.get(value);\n        }\n        const doc3 = callPluginPrintFunction(path, options, mainPrint, args);\n        if (shouldCache) {\n          cache.set(value, doc3);\n        }\n        return doc3;\n      }\n    }\n    function printPrettierIgnoredNode(node, options) {\n      const {\n        originalText,\n        [Symbol.for("comments")]: comments,\n        locStart,\n        locEnd\n      } = options;\n      const start = locStart(node);\n      const end = locEnd(node);\n      const printedComments = /* @__PURE__ */ new Set();\n      for (const comment of comments) {\n        if (locStart(comment) >= start && locEnd(comment) <= end) {\n          comment.printed = true;\n          printedComments.add(comment);\n        }\n      }\n      return {\n        doc: originalText.slice(start, end),\n        printedComments\n      };\n    }\n    function callPluginPrintFunction(path, options, printPath, args) {\n      const node = path.getValue();\n      const {\n        printer\n      } = options;\n      let doc2;\n      let printedComments;\n      if (printer.hasPrettierIgnore && printer.hasPrettierIgnore(path)) {\n        ({\n          doc: doc2,\n          printedComments\n        } = printPrettierIgnoredNode(node, options));\n      } else {\n        if (node) {\n          try {\n            doc2 = multiparser.printSubtree(path, printPath, options, printAstToDoc);\n          } catch (error) {\n            if (process.env.PRETTIER_DEBUG) {\n              throw error;\n            }\n          }\n        }\n        if (!doc2) {\n          doc2 = printer.print(path, options, printPath, args);\n        }\n      }\n      if (!printer.willPrintOwnComments || !printer.willPrintOwnComments(path, options)) {\n        doc2 = printComments(path, doc2, options, printedComments);\n      }\n      return doc2;\n    }\n    module2.exports = printAstToDoc;\n  }\n});\nvar require_range_util = __commonJS2({\n  "src/main/range-util.js"(exports2, module2) {\n    "use strict";\n    var assert = require("assert");\n    var comments = require_comments();\n    var isJsonParser = ({\n      parser\n    }) => parser === "json" || parser === "json5" || parser === "json-stringify";\n    function findCommonAncestor(startNodeAndParents, endNodeAndParents) {\n      const startNodeAndAncestors = [startNodeAndParents.node, ...startNodeAndParents.parentNodes];\n      const endNodeAndAncestors = /* @__PURE__ */ new Set([endNodeAndParents.node, ...endNodeAndParents.parentNodes]);\n      return startNodeAndAncestors.find((node) => jsonSourceElements.has(node.type) && endNodeAndAncestors.has(node));\n    }\n    function dropRootParents(parents) {\n      let lastParentIndex = parents.length - 1;\n      for (; ; ) {\n        const parent = parents[lastParentIndex];\n        if (parent && (parent.type === "Program" || parent.type === "File")) {\n          lastParentIndex--;\n        } else {\n          break;\n        }\n      }\n      return parents.slice(0, lastParentIndex + 1);\n    }\n    function findSiblingAncestors(startNodeAndParents, endNodeAndParents, {\n      locStart,\n      locEnd\n    }) {\n      let resultStartNode = startNodeAndParents.node;\n      let resultEndNode = endNodeAndParents.node;\n      if (resultStartNode === resultEndNode) {\n        return {\n          startNode: resultStartNode,\n          endNode: resultEndNode\n        };\n      }\n      const startNodeStart = locStart(startNodeAndParents.node);\n      for (const endParent of dropRootParents(endNodeAndParents.parentNodes)) {\n        if (locStart(endParent) >= startNodeStart) {\n          resultEndNode = endParent;\n        } else {\n          break;\n        }\n      }\n      const endNodeEnd = locEnd(endNodeAndParents.node);\n      for (const startParent of dropRootParents(startNodeAndParents.parentNodes)) {\n        if (locEnd(startParent) <= endNodeEnd) {\n          resultStartNode = startParent;\n        } else {\n          break;\n        }\n        if (resultStartNode === resultEndNode) {\n          break;\n        }\n      }\n      return {\n        startNode: resultStartNode,\n        endNode: resultEndNode\n      };\n    }\n    function findNodeAtOffset(node, offset, options, predicate, parentNodes = [], type) {\n      const {\n        locStart,\n        locEnd\n      } = options;\n      const start = locStart(node);\n      const end = locEnd(node);\n      if (offset > end || offset < start || type === "rangeEnd" && offset === start || type === "rangeStart" && offset === end) {\n        return;\n      }\n      for (const childNode of comments.getSortedChildNodes(node, options)) {\n        const childResult = findNodeAtOffset(childNode, offset, options, predicate, [node, ...parentNodes], type);\n        if (childResult) {\n          return childResult;\n        }\n      }\n      if (!predicate || predicate(node, parentNodes[0])) {\n        return {\n          node,\n          parentNodes\n        };\n      }\n    }\n    function isJsSourceElement(type, parentType) {\n      return parentType !== "DeclareExportDeclaration" && type !== "TypeParameterDeclaration" && (type === "Directive" || type === "TypeAlias" || type === "TSExportAssignment" || type.startsWith("Declare") || type.startsWith("TSDeclare") || type.endsWith("Statement") || type.endsWith("Declaration"));\n    }\n    var jsonSourceElements = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);\n    var graphqlSourceElements = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);\n    function isSourceElement(opts, node, parentNode) {\n      if (!node) {\n        return false;\n      }\n      switch (opts.parser) {\n        case "flow":\n        case "babel":\n        case "babel-flow":\n        case "babel-ts":\n        case "typescript":\n        case "acorn":\n        case "espree":\n        case "meriyah":\n        case "__babel_estree":\n          return isJsSourceElement(node.type, parentNode && parentNode.type);\n        case "json":\n        case "json5":\n        case "json-stringify":\n          return jsonSourceElements.has(node.type);\n        case "graphql":\n          return graphqlSourceElements.has(node.kind);\n        case "vue":\n          return node.tag !== "root";\n      }\n      return false;\n    }\n    function calculateRange(text, opts, ast) {\n      let {\n        rangeStart: start,\n        rangeEnd: end,\n        locStart,\n        locEnd\n      } = opts;\n      assert.ok(end > start);\n      const firstNonWhitespaceCharacterIndex = text.slice(start, end).search(/\\S/);\n      const isAllWhitespace = firstNonWhitespaceCharacterIndex === -1;\n      if (!isAllWhitespace) {\n        start += firstNonWhitespaceCharacterIndex;\n        for (; end > start; --end) {\n          if (/\\S/.test(text[end - 1])) {\n            break;\n          }\n        }\n      }\n      const startNodeAndParents = findNodeAtOffset(ast, start, opts, (node, parentNode) => isSourceElement(opts, node, parentNode), [], "rangeStart");\n      const endNodeAndParents = isAllWhitespace ? startNodeAndParents : findNodeAtOffset(ast, end, opts, (node) => isSourceElement(opts, node), [], "rangeEnd");\n      if (!startNodeAndParents || !endNodeAndParents) {\n        return {\n          rangeStart: 0,\n          rangeEnd: 0\n        };\n      }\n      let startNode;\n      let endNode;\n      if (isJsonParser(opts)) {\n        const commonAncestor = findCommonAncestor(startNodeAndParents, endNodeAndParents);\n        startNode = commonAncestor;\n        endNode = commonAncestor;\n      } else {\n        ({\n          startNode,\n          endNode\n        } = findSiblingAncestors(startNodeAndParents, endNodeAndParents, opts));\n      }\n      return {\n        rangeStart: Math.min(locStart(startNode), locStart(endNode)),\n        rangeEnd: Math.max(locEnd(startNode), locEnd(endNode))\n      };\n    }\n    module2.exports = {\n      calculateRange,\n      findNodeAtOffset\n    };\n  }\n});\nvar require_core = __commonJS2({\n  "src/main/core.js"(exports2, module2) {\n    "use strict";\n    var {\n      diffArrays\n    } = require_array();\n    var {\n      printer: {\n        printDocToString\n      },\n      debug: {\n        printDocToDebug\n      }\n    } = require("./doc.js");\n    var {\n      getAlignmentSize\n    } = require_util();\n    var {\n      guessEndOfLine,\n      convertEndOfLineToChars,\n      countEndOfLineChars,\n      normalizeEndOfLine\n    } = require_end_of_line();\n    var normalizeOptions = require_options().normalize;\n    var massageAST = require_massage_ast();\n    var comments = require_comments();\n    var parser = require_parser();\n    var printAstToDoc = require_ast_to_doc();\n    var rangeUtil = require_range_util();\n    var BOM = "\\uFEFF";\n    var CURSOR = Symbol("cursor");\n    function attachComments(text, ast, opts) {\n      const astComments = ast.comments;\n      if (astComments) {\n        delete ast.comments;\n        comments.attach(astComments, ast, text, opts);\n      }\n      opts[Symbol.for("comments")] = astComments || [];\n      opts[Symbol.for("tokens")] = ast.tokens || [];\n      opts.originalText = text;\n      return astComments;\n    }\n    function coreFormat(originalText, opts, addAlignmentSize = 0) {\n      if (!originalText || originalText.trim().length === 0) {\n        return {\n          formatted: "",\n          cursorOffset: -1,\n          comments: []\n        };\n      }\n      const {\n        ast,\n        text\n      } = parser.parse(originalText, opts);\n      if (opts.cursorOffset >= 0) {\n        const nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);\n        if (nodeResult && nodeResult.node) {\n          opts.cursorNode = nodeResult.node;\n        }\n      }\n      const astComments = attachComments(text, ast, opts);\n      const doc2 = printAstToDoc(ast, opts, addAlignmentSize);\n      const result = printDocToString(doc2, opts);\n      comments.ensureAllCommentsPrinted(astComments);\n      if (addAlignmentSize > 0) {\n        const trimmed = result.formatted.trim();\n        if (result.cursorNodeStart !== void 0) {\n          result.cursorNodeStart -= result.formatted.indexOf(trimmed);\n        }\n        result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);\n      }\n      if (opts.cursorOffset >= 0) {\n        let oldCursorNodeStart;\n        let oldCursorNodeText;\n        let cursorOffsetRelativeToOldCursorNode;\n        let newCursorNodeStart;\n        let newCursorNodeText;\n        if (opts.cursorNode && result.cursorNodeText) {\n          oldCursorNodeStart = opts.locStart(opts.cursorNode);\n          oldCursorNodeText = text.slice(oldCursorNodeStart, opts.locEnd(opts.cursorNode));\n          cursorOffsetRelativeToOldCursorNode = opts.cursorOffset - oldCursorNodeStart;\n          newCursorNodeStart = result.cursorNodeStart;\n          newCursorNodeText = result.cursorNodeText;\n        } else {\n          oldCursorNodeStart = 0;\n          oldCursorNodeText = text;\n          cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;\n          newCursorNodeStart = 0;\n          newCursorNodeText = result.formatted;\n        }\n        if (oldCursorNodeText === newCursorNodeText) {\n          return {\n            formatted: result.formatted,\n            cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode,\n            comments: astComments\n          };\n        }\n        const oldCursorNodeCharArray = [...oldCursorNodeText];\n        oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorNode, 0, CURSOR);\n        const newCursorNodeCharArray = [...newCursorNodeText];\n        const cursorNodeDiff = diffArrays(oldCursorNodeCharArray, newCursorNodeCharArray);\n        let cursorOffset = newCursorNodeStart;\n        for (const entry of cursorNodeDiff) {\n          if (entry.removed) {\n            if (entry.value.includes(CURSOR)) {\n              break;\n            }\n          } else {\n            cursorOffset += entry.count;\n          }\n        }\n        return {\n          formatted: result.formatted,\n          cursorOffset,\n          comments: astComments\n        };\n      }\n      return {\n        formatted: result.formatted,\n        cursorOffset: -1,\n        comments: astComments\n      };\n    }\n    function formatRange(originalText, opts) {\n      const {\n        ast,\n        text\n      } = parser.parse(originalText, opts);\n      const {\n        rangeStart,\n        rangeEnd\n      } = rangeUtil.calculateRange(text, opts, ast);\n      const rangeString = text.slice(rangeStart, rangeEnd);\n      const rangeStart2 = Math.min(rangeStart, text.lastIndexOf("\\n", rangeStart) + 1);\n      const indentString = text.slice(rangeStart2, rangeStart).match(/^\\s*/)[0];\n      const alignmentSize = getAlignmentSize(indentString, opts.tabWidth);\n      const rangeResult = coreFormat(rangeString, Object.assign(Object.assign({}, opts), {}, {\n        rangeStart: 0,\n        rangeEnd: Number.POSITIVE_INFINITY,\n        cursorOffset: opts.cursorOffset > rangeStart && opts.cursorOffset <= rangeEnd ? opts.cursorOffset - rangeStart : -1,\n        endOfLine: "lf"\n      }), alignmentSize);\n      const rangeTrimmed = rangeResult.formatted.trimEnd();\n      let {\n        cursorOffset\n      } = opts;\n      if (cursorOffset > rangeEnd) {\n        cursorOffset += rangeTrimmed.length - rangeString.length;\n      } else if (rangeResult.cursorOffset >= 0) {\n        cursorOffset = rangeResult.cursorOffset + rangeStart;\n      }\n      let formatted = text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);\n      if (opts.endOfLine !== "lf") {\n        const eol = convertEndOfLineToChars(opts.endOfLine);\n        if (cursorOffset >= 0 && eol === "\\r\\n") {\n          cursorOffset += countEndOfLineChars(formatted.slice(0, cursorOffset), "\\n");\n        }\n        formatted = formatted.replace(/\\n/g, eol);\n      }\n      return {\n        formatted,\n        cursorOffset,\n        comments: rangeResult.comments\n      };\n    }\n    function ensureIndexInText(text, index, defaultValue) {\n      if (typeof index !== "number" || Number.isNaN(index) || index < 0 || index > text.length) {\n        return defaultValue;\n      }\n      return index;\n    }\n    function normalizeIndexes(text, options) {\n      let {\n        cursorOffset,\n        rangeStart,\n        rangeEnd\n      } = options;\n      cursorOffset = ensureIndexInText(text, cursorOffset, -1);\n      rangeStart = ensureIndexInText(text, rangeStart, 0);\n      rangeEnd = ensureIndexInText(text, rangeEnd, text.length);\n      return Object.assign(Object.assign({}, options), {}, {\n        cursorOffset,\n        rangeStart,\n        rangeEnd\n      });\n    }\n    function normalizeInputAndOptions(text, options) {\n      let {\n        cursorOffset,\n        rangeStart,\n        rangeEnd,\n        endOfLine\n      } = normalizeIndexes(text, options);\n      const hasBOM = text.charAt(0) === BOM;\n      if (hasBOM) {\n        text = text.slice(1);\n        cursorOffset--;\n        rangeStart--;\n        rangeEnd--;\n      }\n      if (endOfLine === "auto") {\n        endOfLine = guessEndOfLine(text);\n      }\n      if (text.includes("\\r")) {\n        const countCrlfBefore = (index) => countEndOfLineChars(text.slice(0, Math.max(index, 0)), "\\r\\n");\n        cursorOffset -= countCrlfBefore(cursorOffset);\n        rangeStart -= countCrlfBefore(rangeStart);\n        rangeEnd -= countCrlfBefore(rangeEnd);\n        text = normalizeEndOfLine(text);\n      }\n      return {\n        hasBOM,\n        text,\n        options: normalizeIndexes(text, Object.assign(Object.assign({}, options), {}, {\n          cursorOffset,\n          rangeStart,\n          rangeEnd,\n          endOfLine\n        }))\n      };\n    }\n    function hasPragma(text, options) {\n      const selectedParser = parser.resolveParser(options);\n      return !selectedParser.hasPragma || selectedParser.hasPragma(text);\n    }\n    function formatWithCursor2(originalText, originalOptions) {\n      let {\n        hasBOM,\n        text,\n        options\n      } = normalizeInputAndOptions(originalText, normalizeOptions(originalOptions));\n      if (options.rangeStart >= options.rangeEnd && text !== "" || options.requirePragma && !hasPragma(text, options)) {\n        return {\n          formatted: originalText,\n          cursorOffset: originalOptions.cursorOffset,\n          comments: []\n        };\n      }\n      let result;\n      if (options.rangeStart > 0 || options.rangeEnd < text.length) {\n        result = formatRange(text, options);\n      } else {\n        if (!options.requirePragma && options.insertPragma && options.printer.insertPragma && !hasPragma(text, options)) {\n          text = options.printer.insertPragma(text);\n        }\n        result = coreFormat(text, options);\n      }\n      if (hasBOM) {\n        result.formatted = BOM + result.formatted;\n        if (result.cursorOffset >= 0) {\n          result.cursorOffset++;\n        }\n      }\n      return result;\n    }\n    module2.exports = {\n      formatWithCursor: formatWithCursor2,\n      parse(originalText, originalOptions, massage) {\n        const {\n          text,\n          options\n        } = normalizeInputAndOptions(originalText, normalizeOptions(originalOptions));\n        const parsed = parser.parse(text, options);\n        if (massage) {\n          parsed.ast = massageAST(parsed.ast, options);\n        }\n        return parsed;\n      },\n      formatAST(ast, options) {\n        options = normalizeOptions(options);\n        const doc2 = printAstToDoc(ast, options);\n        return printDocToString(doc2, options);\n      },\n      formatDoc(doc2, options) {\n        return formatWithCursor2(printDocToDebug(doc2), Object.assign(Object.assign({}, options), {}, {\n          parser: "__js_expression"\n        })).formatted;\n      },\n      printToDoc(originalText, options) {\n        options = normalizeOptions(options);\n        const {\n          ast,\n          text\n        } = parser.parse(originalText, options);\n        attachComments(text, ast, options);\n        return printAstToDoc(ast, options);\n      },\n      printDocToString(doc2, options) {\n        return printDocToString(doc2, normalizeOptions(options));\n      }\n    };\n  }\n});\nvar require_utils2 = __commonJS2({\n  "node_modules/braces/lib/utils.js"(exports2) {\n    "use strict";\n    exports2.isInteger = (num) => {\n      if (typeof num === "number") {\n        return Number.isInteger(num);\n      }\n      if (typeof num === "string" && num.trim() !== "") {\n        return Number.isInteger(Number(num));\n      }\n      return false;\n    };\n    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);\n    exports2.exceedsLimit = (min, max, step = 1, limit) => {\n      if (limit === false)\n        return false;\n      if (!exports2.isInteger(min) || !exports2.isInteger(max))\n        return false;\n      return (Number(max) - Number(min)) / Number(step) >= limit;\n    };\n    exports2.escapeNode = (block, n = 0, type) => {\n      let node = block.nodes[n];\n      if (!node)\n        return;\n      if (type && node.type === type || node.type === "open" || node.type === "close") {\n        if (node.escaped !== true) {\n          node.value = "\\\\" + node.value;\n          node.escaped = true;\n        }\n      }\n    };\n    exports2.encloseBrace = (node) => {\n      if (node.type !== "brace")\n        return false;\n      if (node.commas >> 0 + node.ranges >> 0 === 0) {\n        node.invalid = true;\n        return true;\n      }\n      return false;\n    };\n    exports2.isInvalidBrace = (block) => {\n      if (block.type !== "brace")\n        return false;\n      if (block.invalid === true || block.dollar)\n        return true;\n      if (block.commas >> 0 + block.ranges >> 0 === 0) {\n        block.invalid = true;\n        return true;\n      }\n      if (block.open !== true || block.close !== true) {\n        block.invalid = true;\n        return true;\n      }\n      return false;\n    };\n    exports2.isOpenOrClose = (node) => {\n      if (node.type === "open" || node.type === "close") {\n        return true;\n      }\n      return node.open === true || node.close === true;\n    };\n    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {\n      if (node.type === "text")\n        acc.push(node.value);\n      if (node.type === "range")\n        node.type = "text";\n      return acc;\n    }, []);\n    exports2.flatten = (...args) => {\n      const result = [];\n      const flat = (arr) => {\n        for (let i = 0; i < arr.length; i++) {\n          let ele = arr[i];\n          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);\n        }\n        return result;\n      };\n      flat(args);\n      return result;\n    };\n  }\n});\nvar require_stringify = __commonJS2({\n  "node_modules/braces/lib/stringify.js"(exports2, module2) {\n    "use strict";\n    var utils = require_utils2();\n    module2.exports = (ast, options = {}) => {\n      let stringify = (node, parent = {}) => {\n        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n        let invalidNode = node.invalid === true && options.escapeInvalid === true;\n        let output = "";\n        if (node.value) {\n          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n            return "\\\\" + node.value;\n          }\n          return node.value;\n        }\n        if (node.value) {\n          return node.value;\n        }\n        if (node.nodes) {\n          for (let child of node.nodes) {\n            output += stringify(child);\n          }\n        }\n        return output;\n      };\n      return stringify(ast);\n    };\n  }\n});\nvar require_is_number = __commonJS2({\n  "node_modules/is-number/index.js"(exports2, module2) {\n    "use strict";\n    module2.exports = function(num) {\n      if (typeof num === "number") {\n        return num - num === 0;\n      }\n      if (typeof num === "string" && num.trim() !== "") {\n        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n      }\n      return false;\n    };\n  }\n});\nvar require_to_regex_range = __commonJS2({\n  "node_modules/to-regex-range/index.js"(exports2, module2) {\n    "use strict";\n    var isNumber = require_is_number();\n    var toRegexRange = (min, max, options) => {\n      if (isNumber(min) === false) {\n        throw new TypeError("toRegexRange: expected the first argument to be a number");\n      }\n      if (max === void 0 || min === max) {\n        return String(min);\n      }\n      if (isNumber(max) === false) {\n        throw new TypeError("toRegexRange: expected the second argument to be a number.");\n      }\n      let opts = Object.assign({\n        relaxZeros: true\n      }, options);\n      if (typeof opts.strictZeros === "boolean") {\n        opts.relaxZeros = opts.strictZeros === false;\n      }\n      let relax = String(opts.relaxZeros);\n      let shorthand = String(opts.shorthand);\n      let capture = String(opts.capture);\n      let wrap = String(opts.wrap);\n      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;\n      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n        return toRegexRange.cache[cacheKey].result;\n      }\n      let a = Math.min(min, max);\n      let b = Math.max(min, max);\n      if (Math.abs(a - b) === 1) {\n        let result = min + "|" + max;\n        if (opts.capture) {\n          return `(${result})`;\n        }\n        if (opts.wrap === false) {\n          return result;\n        }\n        return `(?:${result})`;\n      }\n      let isPadded = hasPadding(min) || hasPadding(max);\n      let state = {\n        min,\n        max,\n        a,\n        b\n      };\n      let positives = [];\n      let negatives = [];\n      if (isPadded) {\n        state.isPadded = isPadded;\n        state.maxLen = String(state.max).length;\n      }\n      if (a < 0) {\n        let newMin = b < 0 ? Math.abs(b) : 1;\n        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n        a = state.a = 0;\n      }\n      if (b >= 0) {\n        positives = splitToPatterns(a, b, state, opts);\n      }\n      state.negatives = negatives;\n      state.positives = positives;\n      state.result = collatePatterns(negatives, positives, opts);\n      if (opts.capture === true) {\n        state.result = `(${state.result})`;\n      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n        state.result = `(?:${state.result})`;\n      }\n      toRegexRange.cache[cacheKey] = state;\n      return state.result;\n    };\n    function collatePatterns(neg, pos, options) {\n      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];\n      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];\n      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];\n      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n      return subpatterns.join("|");\n    }\n    function splitToRanges(min, max) {\n      let nines = 1;\n      let zeros = 1;\n      let stop = countNines(min, nines);\n      let stops = /* @__PURE__ */ new Set([max]);\n      while (min <= stop && stop <= max) {\n        stops.add(stop);\n        nines += 1;\n        stop = countNines(min, nines);\n      }\n      stop = countZeros(max + 1, zeros) - 1;\n      while (min < stop && stop <= max) {\n        stops.add(stop);\n        zeros += 1;\n        stop = countZeros(max + 1, zeros) - 1;\n      }\n      stops = [...stops];\n      stops.sort(compare);\n      return stops;\n    }\n    function rangeToPattern(start, stop, options) {\n      if (start === stop) {\n        return {\n          pattern: start,\n          count: [],\n          digits: 0\n        };\n      }\n      let zipped = zip(start, stop);\n      let digits = zipped.length;\n      let pattern = "";\n      let count = 0;\n      for (let i = 0; i < digits; i++) {\n        let [startDigit, stopDigit] = zipped[i];\n        if (startDigit === stopDigit) {\n          pattern += startDigit;\n        } else if (startDigit !== "0" || stopDigit !== "9") {\n          pattern += toCharacterClass(startDigit, stopDigit, options);\n        } else {\n          count++;\n        }\n      }\n      if (count) {\n        pattern += options.shorthand === true ? "\\\\d" : "[0-9]";\n      }\n      return {\n        pattern,\n        count: [count],\n        digits\n      };\n    }\n    function splitToPatterns(min, max, tok, options) {\n      let ranges = splitToRanges(min, max);\n      let tokens = [];\n      let start = min;\n      let prev;\n      for (let i = 0; i < ranges.length; i++) {\n        let max2 = ranges[i];\n        let obj = rangeToPattern(String(start), String(max2), options);\n        let zeros = "";\n        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n          if (prev.count.length > 1) {\n            prev.count.pop();\n          }\n          prev.count.push(obj.count[0]);\n          prev.string = prev.pattern + toQuantifier(prev.count);\n          start = max2 + 1;\n          continue;\n        }\n        if (tok.isPadded) {\n          zeros = padZeros(max2, tok, options);\n        }\n        obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n        tokens.push(obj);\n        start = max2 + 1;\n        prev = obj;\n      }\n      return tokens;\n    }\n    function filterPatterns(arr, comparison, prefix, intersection, options) {\n      let result = [];\n      for (let ele of arr) {\n        let {\n          string\n        } = ele;\n        if (!intersection && !contains(comparison, "string", string)) {\n          result.push(prefix + string);\n        }\n        if (intersection && contains(comparison, "string", string)) {\n          result.push(prefix + string);\n        }\n      }\n      return result;\n    }\n    function zip(a, b) {\n      let arr = [];\n      for (let i = 0; i < a.length; i++)\n        arr.push([a[i], b[i]]);\n      return arr;\n    }\n    function compare(a, b) {\n      return a > b ? 1 : b > a ? -1 : 0;\n    }\n    function contains(arr, key, val) {\n      return arr.some((ele) => ele[key] === val);\n    }\n    function countNines(min, len) {\n      return Number(String(min).slice(0, -len) + "9".repeat(len));\n    }\n    function countZeros(integer, zeros) {\n      return integer - integer % Math.pow(10, zeros);\n    }\n    function toQuantifier(digits) {\n      let [start = 0, stop = ""] = digits;\n      if (stop || start > 1) {\n        return `{${start + (stop ? "," + stop : "")}}`;\n      }\n      return "";\n    }\n    function toCharacterClass(a, b, options) {\n      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;\n    }\n    function hasPadding(str) {\n      return /^-?(0+)\\d/.test(str);\n    }\n    function padZeros(value, tok, options) {\n      if (!tok.isPadded) {\n        return value;\n      }\n      let diff = Math.abs(tok.maxLen - String(value).length);\n      let relax = options.relaxZeros !== false;\n      switch (diff) {\n        case 0:\n          return "";\n        case 1:\n          return relax ? "0?" : "0";\n        case 2:\n          return relax ? "0{0,2}" : "00";\n        default: {\n          return relax ? `0{0,${diff}}` : `0{${diff}}`;\n        }\n      }\n    }\n    toRegexRange.cache = {};\n    toRegexRange.clearCache = () => toRegexRange.cache = {};\n    module2.exports = toRegexRange;\n  }\n});\nvar require_fill_range = __commonJS2({\n  "node_modules/fill-range/index.js"(exports2, module2) {\n    "use strict";\n    var util = require("util");\n    var toRegexRange = require_to_regex_range();\n    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);\n    var transform = (toNumber) => {\n      return (value) => toNumber === true ? Number(value) : String(value);\n    };\n    var isValidValue = (value) => {\n      return typeof value === "number" || typeof value === "string" && value !== "";\n    };\n    var isNumber = (num) => Number.isInteger(+num);\n    var zeros = (input) => {\n      let value = `${input}`;\n      let index = -1;\n      if (value[0] === "-")\n        value = value.slice(1);\n      if (value === "0")\n        return false;\n      while (value[++index] === "0")\n        ;\n      return index > 0;\n    };\n    var stringify = (start, end, options) => {\n      if (typeof start === "string" || typeof end === "string") {\n        return true;\n      }\n      return options.stringify === true;\n    };\n    var pad = (input, maxLength, toNumber) => {\n      if (maxLength > 0) {\n        let dash = input[0] === "-" ? "-" : "";\n        if (dash)\n          input = input.slice(1);\n        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");\n      }\n      if (toNumber === false) {\n        return String(input);\n      }\n      return input;\n    };\n    var toMaxLen = (input, maxLength) => {\n      let negative = input[0] === "-" ? "-" : "";\n      if (negative) {\n        input = input.slice(1);\n        maxLength--;\n      }\n      while (input.length < maxLength)\n        input = "0" + input;\n      return negative ? "-" + input : input;\n    };\n    var toSequence = (parts, options) => {\n      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n      let prefix = options.capture ? "" : "?:";\n      let positives = "";\n      let negatives = "";\n      let result;\n      if (parts.positives.length) {\n        positives = parts.positives.join("|");\n      }\n      if (parts.negatives.length) {\n        negatives = `-(${prefix}${parts.negatives.join("|")})`;\n      }\n      if (positives && negatives) {\n        result = `${positives}|${negatives}`;\n      } else {\n        result = positives || negatives;\n      }\n      if (options.wrap) {\n        return `(${prefix}${result})`;\n      }\n      return result;\n    };\n    var toRange = (a, b, isNumbers, options) => {\n      if (isNumbers) {\n        return toRegexRange(a, b, Object.assign({\n          wrap: false\n        }, options));\n      }\n      let start = String.fromCharCode(a);\n      if (a === b)\n        return start;\n      let stop = String.fromCharCode(b);\n      return `[${start}-${stop}]`;\n    };\n    var toRegex = (start, end, options) => {\n      if (Array.isArray(start)) {\n        let wrap = options.wrap === true;\n        let prefix = options.capture ? "" : "?:";\n        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");\n      }\n      return toRegexRange(start, end, options);\n    };\n    var rangeError = (...args) => {\n      return new RangeError("Invalid range arguments: " + util.inspect(...args));\n    };\n    var invalidRange = (start, end, options) => {\n      if (options.strictRanges === true)\n        throw rangeError([start, end]);\n      return [];\n    };\n    var invalidStep = (step, options) => {\n      if (options.strictRanges === true) {\n        throw new TypeError(`Expected step "${step}" to be a number`);\n      }\n      return [];\n    };\n    var fillNumbers = (start, end, step = 1, options = {}) => {\n      let a = Number(start);\n      let b = Number(end);\n      if (!Number.isInteger(a) || !Number.isInteger(b)) {\n        if (options.strictRanges === true)\n          throw rangeError([start, end]);\n        return [];\n      }\n      if (a === 0)\n        a = 0;\n      if (b === 0)\n        b = 0;\n      let descending = a > b;\n      let startString = String(start);\n      let endString = String(end);\n      let stepString = String(step);\n      step = Math.max(Math.abs(step), 1);\n      let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n      let toNumber = padded === false && stringify(start, end, options) === false;\n      let format = options.transform || transform(toNumber);\n      if (options.toRegex && step === 1) {\n        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n      }\n      let parts = {\n        negatives: [],\n        positives: []\n      };\n      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));\n      let range = [];\n      let index = 0;\n      while (descending ? a >= b : a <= b) {\n        if (options.toRegex === true && step > 1) {\n          push(a);\n        } else {\n          range.push(pad(format(a, index), maxLen, toNumber));\n        }\n        a = descending ? a - step : a + step;\n        index++;\n      }\n      if (options.toRegex === true) {\n        return step > 1 ? toSequence(parts, options) : toRegex(range, null, Object.assign({\n          wrap: false\n        }, options));\n      }\n      return range;\n    };\n    var fillLetters = (start, end, step = 1, options = {}) => {\n      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {\n        return invalidRange(start, end, options);\n      }\n      let format = options.transform || ((val) => String.fromCharCode(val));\n      let a = `${start}`.charCodeAt(0);\n      let b = `${end}`.charCodeAt(0);\n      let descending = a > b;\n      let min = Math.min(a, b);\n      let max = Math.max(a, b);\n      if (options.toRegex && step === 1) {\n        return toRange(min, max, false, options);\n      }\n      let range = [];\n      let index = 0;\n      while (descending ? a >= b : a <= b) {\n        range.push(format(a, index));\n        a = descending ? a - step : a + step;\n        index++;\n      }\n      if (options.toRegex === true) {\n        return toRegex(range, null, {\n          wrap: false,\n          options\n        });\n      }\n      return range;\n    };\n    var fill = (start, end, step, options = {}) => {\n      if (end == null && isValidValue(start)) {\n        return [start];\n      }\n      if (!isValidValue(start) || !isValidValue(end)) {\n        return invalidRange(start, end, options);\n      }\n      if (typeof step === "function") {\n        return fill(start, end, 1, {\n          transform: step\n        });\n      }\n      if (isObject(step)) {\n        return fill(start, end, 0, step);\n      }\n      let opts = Object.assign({}, options);\n      if (opts.capture === true)\n        opts.wrap = true;\n      step = step || opts.step || 1;\n      if (!isNumber(step)) {\n        if (step != null && !isObject(step))\n          return invalidStep(step, opts);\n        return fill(start, end, 1, step);\n      }\n      if (isNumber(start) && isNumber(end)) {\n        return fillNumbers(start, end, step, opts);\n      }\n      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n    };\n    module2.exports = fill;\n  }\n});\nvar require_compile = __commonJS2({\n  "node_modules/braces/lib/compile.js"(exports2, module2) {\n    "use strict";\n    var fill = require_fill_range();\n    var utils = require_utils2();\n    var compile = (ast, options = {}) => {\n      let walk = (node, parent = {}) => {\n        let invalidBlock = utils.isInvalidBrace(parent);\n        let invalidNode = node.invalid === true && options.escapeInvalid === true;\n        let invalid = invalidBlock === true || invalidNode === true;\n        let prefix = options.escapeInvalid === true ? "\\\\" : "";\n        let output = "";\n        if (node.isOpen === true) {\n          return prefix + node.value;\n        }\n        if (node.isClose === true) {\n          return prefix + node.value;\n        }\n        if (node.type === "open") {\n          return invalid ? prefix + node.value : "(";\n        }\n        if (node.type === "close") {\n          return invalid ? prefix + node.value : ")";\n        }\n        if (node.type === "comma") {\n          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";\n        }\n        if (node.value) {\n          return node.value;\n        }\n        if (node.nodes && node.ranges > 0) {\n          let args = utils.reduce(node.nodes);\n          let range = fill(...args, Object.assign(Object.assign({}, options), {}, {\n            wrap: false,\n            toRegex: true\n          }));\n          if (range.length !== 0) {\n            return args.length > 1 && range.length > 1 ? `(${range})` : range;\n          }\n        }\n        if (node.nodes) {\n          for (let child of node.nodes) {\n            output += walk(child, node);\n          }\n        }\n        return output;\n      };\n      return walk(ast);\n    };\n    module2.exports = compile;\n  }\n});\nvar require_expand = __commonJS2({\n  "node_modules/braces/lib/expand.js"(exports2, module2) {\n    "use strict";\n    var fill = require_fill_range();\n    var stringify = require_stringify();\n    var utils = require_utils2();\n    var append = (queue = "", stash = "", enclose = false) => {\n      let result = [];\n      queue = [].concat(queue);\n      stash = [].concat(stash);\n      if (!stash.length)\n        return queue;\n      if (!queue.length) {\n        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;\n      }\n      for (let item of queue) {\n        if (Array.isArray(item)) {\n          for (let value of item) {\n            result.push(append(value, stash, enclose));\n          }\n        } else {\n          for (let ele of stash) {\n            if (enclose === true && typeof ele === "string")\n              ele = `{${ele}}`;\n            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n          }\n        }\n      }\n      return utils.flatten(result);\n    };\n    var expand = (ast, options = {}) => {\n      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;\n      let walk = (node, parent = {}) => {\n        node.queue = [];\n        let p = parent;\n        let q = parent.queue;\n        while (p.type !== "brace" && p.type !== "root" && p.parent) {\n          p = p.parent;\n          q = p.queue;\n        }\n        if (node.invalid || node.dollar) {\n          q.push(append(q.pop(), stringify(node, options)));\n          return;\n        }\n        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {\n          q.push(append(q.pop(), ["{}"]));\n          return;\n        }\n        if (node.nodes && node.ranges > 0) {\n          let args = utils.reduce(node.nodes);\n          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");\n          }\n          let range = fill(...args, options);\n          if (range.length === 0) {\n            range = stringify(node, options);\n          }\n          q.push(append(q.pop(), range));\n          node.nodes = [];\n          return;\n        }\n        let enclose = utils.encloseBrace(node);\n        let queue = node.queue;\n        let block = node;\n        while (block.type !== "brace" && block.type !== "root" && block.parent) {\n          block = block.parent;\n          queue = block.queue;\n        }\n        for (let i = 0; i < node.nodes.length; i++) {\n          let child = node.nodes[i];\n          if (child.type === "comma" && node.type === "brace") {\n            if (i === 1)\n              queue.push("");\n            queue.push("");\n            continue;\n          }\n          if (child.type === "close") {\n            q.push(append(q.pop(), queue, enclose));\n            continue;\n          }\n          if (child.value && child.type !== "open") {\n            queue.push(append(queue.pop(), child.value));\n            continue;\n          }\n          if (child.nodes) {\n            walk(child, node);\n          }\n        }\n        return queue;\n      };\n      return utils.flatten(walk(ast));\n    };\n    module2.exports = expand;\n  }\n});\nvar require_constants2 = __commonJS2({\n  "node_modules/braces/lib/constants.js"(exports2, module2) {\n    "use strict";\n    module2.exports = {\n      MAX_LENGTH: 1024 * 64,\n      CHAR_0: "0",\n      CHAR_9: "9",\n      CHAR_UPPERCASE_A: "A",\n      CHAR_LOWERCASE_A: "a",\n      CHAR_UPPERCASE_Z: "Z",\n      CHAR_LOWERCASE_Z: "z",\n      CHAR_LEFT_PARENTHESES: "(",\n      CHAR_RIGHT_PARENTHESES: ")",\n      CHAR_ASTERISK: "*",\n      CHAR_AMPERSAND: "&",\n      CHAR_AT: "@",\n      CHAR_BACKSLASH: "\\\\",\n      CHAR_BACKTICK: "`",\n      CHAR_CARRIAGE_RETURN: "\\r",\n      CHAR_CIRCUMFLEX_ACCENT: "^",\n      CHAR_COLON: ":",\n      CHAR_COMMA: ",",\n      CHAR_DOLLAR: "$",\n      CHAR_DOT: ".",\n      CHAR_DOUBLE_QUOTE: \'"\',\n      CHAR_EQUAL: "=",\n      CHAR_EXCLAMATION_MARK: "!",\n      CHAR_FORM_FEED: "\\f",\n      CHAR_FORWARD_SLASH: "/",\n      CHAR_HASH: "#",\n      CHAR_HYPHEN_MINUS: "-",\n      CHAR_LEFT_ANGLE_BRACKET: "<",\n      CHAR_LEFT_CURLY_BRACE: "{",\n      CHAR_LEFT_SQUARE_BRACKET: "[",\n      CHAR_LINE_FEED: "\\n",\n      CHAR_NO_BREAK_SPACE: "\\xA0",\n      CHAR_PERCENT: "%",\n      CHAR_PLUS: "+",\n      CHAR_QUESTION_MARK: "?",\n      CHAR_RIGHT_ANGLE_BRACKET: ">",\n      CHAR_RIGHT_CURLY_BRACE: "}",\n      CHAR_RIGHT_SQUARE_BRACKET: "]",\n      CHAR_SEMICOLON: ";",\n      CHAR_SINGLE_QUOTE: "\'",\n      CHAR_SPACE: " ",\n      CHAR_TAB: "\t",\n      CHAR_UNDERSCORE: "_",\n      CHAR_VERTICAL_LINE: "|",\n      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\\uFEFF"\n    };\n  }\n});\nvar require_parse = __commonJS2({\n  "node_modules/braces/lib/parse.js"(exports2, module2) {\n    "use strict";\n    var stringify = require_stringify();\n    var {\n      MAX_LENGTH,\n      CHAR_BACKSLASH,\n      CHAR_BACKTICK,\n      CHAR_COMMA,\n      CHAR_DOT,\n      CHAR_LEFT_PARENTHESES,\n      CHAR_RIGHT_PARENTHESES,\n      CHAR_LEFT_CURLY_BRACE,\n      CHAR_RIGHT_CURLY_BRACE,\n      CHAR_LEFT_SQUARE_BRACKET,\n      CHAR_RIGHT_SQUARE_BRACKET,\n      CHAR_DOUBLE_QUOTE,\n      CHAR_SINGLE_QUOTE,\n      CHAR_NO_BREAK_SPACE,\n      CHAR_ZERO_WIDTH_NOBREAK_SPACE\n    } = require_constants2();\n    var parse = (input, options = {}) => {\n      if (typeof input !== "string") {\n        throw new TypeError("Expected a string");\n      }\n      let opts = options || {};\n      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n      if (input.length > max) {\n        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n      }\n      let ast = {\n        type: "root",\n        input,\n        nodes: []\n      };\n      let stack = [ast];\n      let block = ast;\n      let prev = ast;\n      let brackets = 0;\n      let length = input.length;\n      let index = 0;\n      let depth = 0;\n      let value;\n      let memo = {};\n      const advance = () => input[index++];\n      const push = (node) => {\n        if (node.type === "text" && prev.type === "dot") {\n          prev.type = "text";\n        }\n        if (prev && prev.type === "text" && node.type === "text") {\n          prev.value += node.value;\n          return;\n        }\n        block.nodes.push(node);\n        node.parent = block;\n        node.prev = prev;\n        prev = node;\n        return node;\n      };\n      push({\n        type: "bos"\n      });\n      while (index < length) {\n        block = stack[stack.length - 1];\n        value = advance();\n        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n          continue;\n        }\n        if (value === CHAR_BACKSLASH) {\n          push({\n            type: "text",\n            value: (options.keepEscaping ? value : "") + advance()\n          });\n          continue;\n        }\n        if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n          push({\n            type: "text",\n            value: "\\\\" + value\n          });\n          continue;\n        }\n        if (value === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          let closed = true;\n          let next;\n          while (index < length && (next = advance())) {\n            value += next;\n            if (next === CHAR_LEFT_SQUARE_BRACKET) {\n              brackets++;\n              continue;\n            }\n            if (next === CHAR_BACKSLASH) {\n              value += advance();\n              continue;\n            }\n            if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n              brackets--;\n              if (brackets === 0) {\n                break;\n              }\n            }\n          }\n          push({\n            type: "text",\n            value\n          });\n          continue;\n        }\n        if (value === CHAR_LEFT_PARENTHESES) {\n          block = push({\n            type: "paren",\n            nodes: []\n          });\n          stack.push(block);\n          push({\n            type: "text",\n            value\n          });\n          continue;\n        }\n        if (value === CHAR_RIGHT_PARENTHESES) {\n          if (block.type !== "paren") {\n            push({\n              type: "text",\n              value\n            });\n            continue;\n          }\n          block = stack.pop();\n          push({\n            type: "text",\n            value\n          });\n          block = stack[stack.length - 1];\n          continue;\n        }\n        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n          let open = value;\n          let next;\n          if (options.keepQuotes !== true) {\n            value = "";\n          }\n          while (index < length && (next = advance())) {\n            if (next === CHAR_BACKSLASH) {\n              value += next + advance();\n              continue;\n            }\n            if (next === open) {\n              if (options.keepQuotes === true)\n                value += next;\n              break;\n            }\n            value += next;\n          }\n          push({\n            type: "text",\n            value\n          });\n          continue;\n        }\n        if (value === CHAR_LEFT_CURLY_BRACE) {\n          depth++;\n          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;\n          let brace = {\n            type: "brace",\n            open: true,\n            close: false,\n            dollar,\n            depth,\n            commas: 0,\n            ranges: 0,\n            nodes: []\n          };\n          block = push(brace);\n          stack.push(block);\n          push({\n            type: "open",\n            value\n          });\n          continue;\n        }\n        if (value === CHAR_RIGHT_CURLY_BRACE) {\n          if (block.type !== "brace") {\n            push({\n              type: "text",\n              value\n            });\n            continue;\n          }\n          let type = "close";\n          block = stack.pop();\n          block.close = true;\n          push({\n            type,\n            value\n          });\n          depth--;\n          block = stack[stack.length - 1];\n          continue;\n        }\n        if (value === CHAR_COMMA && depth > 0) {\n          if (block.ranges > 0) {\n            block.ranges = 0;\n            let open = block.nodes.shift();\n            block.nodes = [open, {\n              type: "text",\n              value: stringify(block)\n            }];\n          }\n          push({\n            type: "comma",\n            value\n          });\n          block.commas++;\n          continue;\n        }\n        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n          let siblings = block.nodes;\n          if (depth === 0 || siblings.length === 0) {\n            push({\n              type: "text",\n              value\n            });\n            continue;\n          }\n          if (prev.type === "dot") {\n            block.range = [];\n            prev.value += value;\n            prev.type = "range";\n            if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n              block.invalid = true;\n              block.ranges = 0;\n              prev.type = "text";\n              continue;\n            }\n            block.ranges++;\n            block.args = [];\n            continue;\n          }\n          if (prev.type === "range") {\n            siblings.pop();\n            let before = siblings[siblings.length - 1];\n            before.value += prev.value + value;\n            prev = before;\n            block.ranges--;\n            continue;\n          }\n          push({\n            type: "dot",\n            value\n          });\n          continue;\n        }\n        push({\n          type: "text",\n          value\n        });\n      }\n      do {\n        block = stack.pop();\n        if (block.type !== "root") {\n          block.nodes.forEach((node) => {\n            if (!node.nodes) {\n              if (node.type === "open")\n                node.isOpen = true;\n              if (node.type === "close")\n                node.isClose = true;\n              if (!node.nodes)\n                node.type = "text";\n              node.invalid = true;\n            }\n          });\n          let parent = stack[stack.length - 1];\n          let index2 = parent.nodes.indexOf(block);\n          parent.nodes.splice(index2, 1, ...block.nodes);\n        }\n      } while (stack.length > 0);\n      push({\n        type: "eos"\n      });\n      return ast;\n    };\n    module2.exports = parse;\n  }\n});\nvar require_braces = __commonJS2({\n  "node_modules/braces/index.js"(exports2, module2) {\n    "use strict";\n    var stringify = require_stringify();\n    var compile = require_compile();\n    var expand = require_expand();\n    var parse = require_parse();\n    var braces = (input, options = {}) => {\n      let output = [];\n      if (Array.isArray(input)) {\n        for (let pattern of input) {\n          let result = braces.create(pattern, options);\n          if (Array.isArray(result)) {\n            output.push(...result);\n          } else {\n            output.push(result);\n          }\n        }\n      } else {\n        output = [].concat(braces.create(input, options));\n      }\n      if (options && options.expand === true && options.nodupes === true) {\n        output = [...new Set(output)];\n      }\n      return output;\n    };\n    braces.parse = (input, options = {}) => parse(input, options);\n    braces.stringify = (input, options = {}) => {\n      if (typeof input === "string") {\n        return stringify(braces.parse(input, options), options);\n      }\n      return stringify(input, options);\n    };\n    braces.compile = (input, options = {}) => {\n      if (typeof input === "string") {\n        input = braces.parse(input, options);\n      }\n      return compile(input, options);\n    };\n    braces.expand = (input, options = {}) => {\n      if (typeof input === "string") {\n        input = braces.parse(input, options);\n      }\n      let result = expand(input, options);\n      if (options.noempty === true) {\n        result = result.filter(Boolean);\n      }\n      if (options.nodupes === true) {\n        result = [...new Set(result)];\n      }\n      return result;\n    };\n    braces.create = (input, options = {}) => {\n      if (input === "" || input.length < 3) {\n        return [input];\n      }\n      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);\n    };\n    module2.exports = braces;\n  }\n});\nvar require_constants3 = __commonJS2({\n  "node_modules/picomatch/lib/constants.js"(exports2, module2) {\n    "use strict";\n    var path = require("path");\n    var WIN_SLASH = "\\\\\\\\/";\n    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n    var DOT_LITERAL = "\\\\.";\n    var PLUS_LITERAL = "\\\\+";\n    var QMARK_LITERAL = "\\\\?";\n    var SLASH_LITERAL = "\\\\/";\n    var ONE_CHAR = "(?=.)";\n    var QMARK = "[^/]";\n    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\n    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\n    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\n    var NO_DOT = `(?!${DOT_LITERAL})`;\n    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\n    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\n    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\n    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\n    var STAR = `${QMARK}*?`;\n    var POSIX_CHARS = {\n      DOT_LITERAL,\n      PLUS_LITERAL,\n      QMARK_LITERAL,\n      SLASH_LITERAL,\n      ONE_CHAR,\n      QMARK,\n      END_ANCHOR,\n      DOTS_SLASH,\n      NO_DOT,\n      NO_DOTS,\n      NO_DOT_SLASH,\n      NO_DOTS_SLASH,\n      QMARK_NO_DOT,\n      STAR,\n      START_ANCHOR\n    };\n    var WINDOWS_CHARS = Object.assign(Object.assign({}, POSIX_CHARS), {}, {\n      SLASH_LITERAL: `[${WIN_SLASH}]`,\n      QMARK: WIN_NO_SLASH,\n      STAR: `${WIN_NO_SLASH}*?`,\n      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n      NO_DOT: `(?!${DOT_LITERAL})`,\n      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n    });\n    var POSIX_REGEX_SOURCE = {\n      alnum: "a-zA-Z0-9",\n      alpha: "a-zA-Z",\n      ascii: "\\\\x00-\\\\x7F",\n      blank: " \\\\t",\n      cntrl: "\\\\x00-\\\\x1F\\\\x7F",\n      digit: "0-9",\n      graph: "\\\\x21-\\\\x7E",\n      lower: "a-z",\n      print: "\\\\x20-\\\\x7E ",\n      punct: "\\\\-!\\"#$%&\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~",\n      space: " \\\\t\\\\r\\\\n\\\\v\\\\f",\n      upper: "A-Z",\n      word: "A-Za-z0-9_",\n      xdigit: "A-Fa-f0-9"\n    };\n    module2.exports = {\n      MAX_LENGTH: 1024 * 64,\n      POSIX_REGEX_SOURCE,\n      REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n      REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n      REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n      REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n      REPLACEMENTS: {\n        "***": "*",\n        "**/**": "**",\n        "**/**/**": "**"\n      },\n      CHAR_0: 48,\n      CHAR_9: 57,\n      CHAR_UPPERCASE_A: 65,\n      CHAR_LOWERCASE_A: 97,\n      CHAR_UPPERCASE_Z: 90,\n      CHAR_LOWERCASE_Z: 122,\n      CHAR_LEFT_PARENTHESES: 40,\n      CHAR_RIGHT_PARENTHESES: 41,\n      CHAR_ASTERISK: 42,\n      CHAR_AMPERSAND: 38,\n      CHAR_AT: 64,\n      CHAR_BACKWARD_SLASH: 92,\n      CHAR_CARRIAGE_RETURN: 13,\n      CHAR_CIRCUMFLEX_ACCENT: 94,\n      CHAR_COLON: 58,\n      CHAR_COMMA: 44,\n      CHAR_DOT: 46,\n      CHAR_DOUBLE_QUOTE: 34,\n      CHAR_EQUAL: 61,\n      CHAR_EXCLAMATION_MARK: 33,\n      CHAR_FORM_FEED: 12,\n      CHAR_FORWARD_SLASH: 47,\n      CHAR_GRAVE_ACCENT: 96,\n      CHAR_HASH: 35,\n      CHAR_HYPHEN_MINUS: 45,\n      CHAR_LEFT_ANGLE_BRACKET: 60,\n      CHAR_LEFT_CURLY_BRACE: 123,\n      CHAR_LEFT_SQUARE_BRACKET: 91,\n      CHAR_LINE_FEED: 10,\n      CHAR_NO_BREAK_SPACE: 160,\n      CHAR_PERCENT: 37,\n      CHAR_PLUS: 43,\n      CHAR_QUESTION_MARK: 63,\n      CHAR_RIGHT_ANGLE_BRACKET: 62,\n      CHAR_RIGHT_CURLY_BRACE: 125,\n      CHAR_RIGHT_SQUARE_BRACKET: 93,\n      CHAR_SEMICOLON: 59,\n      CHAR_SINGLE_QUOTE: 39,\n      CHAR_SPACE: 32,\n      CHAR_TAB: 9,\n      CHAR_UNDERSCORE: 95,\n      CHAR_VERTICAL_LINE: 124,\n      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n      SEP: path.sep,\n      extglobChars(chars) {\n        return {\n          "!": {\n            type: "negate",\n            open: "(?:(?!(?:",\n            close: `))${chars.STAR})`\n          },\n          "?": {\n            type: "qmark",\n            open: "(?:",\n            close: ")?"\n          },\n          "+": {\n            type: "plus",\n            open: "(?:",\n            close: ")+"\n          },\n          "*": {\n            type: "star",\n            open: "(?:",\n            close: ")*"\n          },\n          "@": {\n            type: "at",\n            open: "(?:",\n            close: ")"\n          }\n        };\n      },\n      globChars(win32) {\n        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n      }\n    };\n  }\n});\nvar require_utils3 = __commonJS2({\n  "node_modules/picomatch/lib/utils.js"(exports2) {\n    "use strict";\n    var path = require("path");\n    var win32 = process.platform === "win32";\n    var {\n      REGEX_BACKSLASH,\n      REGEX_REMOVE_BACKSLASH,\n      REGEX_SPECIAL_CHARS,\n      REGEX_SPECIAL_CHARS_GLOBAL\n    } = require_constants3();\n    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);\n    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);\n    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);\n    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\\\$1");\n    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");\n    exports2.removeBackslashes = (str) => {\n      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {\n        return match === "\\\\" ? "" : match;\n      });\n    };\n    exports2.supportsLookbehinds = () => {\n      const segs = process.version.slice(1).split(".").map(Number);\n      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {\n        return true;\n      }\n      return false;\n    };\n    exports2.isWindows = (options) => {\n      if (options && typeof options.windows === "boolean") {\n        return options.windows;\n      }\n      return win32 === true || path.sep === "\\\\";\n    };\n    exports2.escapeLast = (input, char, lastIdx) => {\n      const idx = input.lastIndexOf(char, lastIdx);\n      if (idx === -1)\n        return input;\n      if (input[idx - 1] === "\\\\")\n        return exports2.escapeLast(input, char, idx - 1);\n      return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n    };\n    exports2.removePrefix = (input, state = {}) => {\n      let output = input;\n      if (output.startsWith("./")) {\n        output = output.slice(2);\n        state.prefix = "./";\n      }\n      return output;\n    };\n    exports2.wrapOutput = (input, state = {}, options = {}) => {\n      const prepend = options.contains ? "" : "^";\n      const append = options.contains ? "" : "$";\n      let output = `${prepend}(?:${input})${append}`;\n      if (state.negated === true) {\n        output = `(?:^(?!${output}).*$)`;\n      }\n      return output;\n    };\n  }\n});\nvar require_scan = __commonJS2({\n  "node_modules/picomatch/lib/scan.js"(exports2, module2) {\n    "use strict";\n    var utils = require_utils3();\n    var {\n      CHAR_ASTERISK,\n      CHAR_AT,\n      CHAR_BACKWARD_SLASH,\n      CHAR_COMMA,\n      CHAR_DOT,\n      CHAR_EXCLAMATION_MARK,\n      CHAR_FORWARD_SLASH,\n      CHAR_LEFT_CURLY_BRACE,\n      CHAR_LEFT_PARENTHESES,\n      CHAR_LEFT_SQUARE_BRACKET,\n      CHAR_PLUS,\n      CHAR_QUESTION_MARK,\n      CHAR_RIGHT_CURLY_BRACE,\n      CHAR_RIGHT_PARENTHESES,\n      CHAR_RIGHT_SQUARE_BRACKET\n    } = require_constants3();\n    var isPathSeparator = (code) => {\n      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n    };\n    var depth = (token) => {\n      if (token.isPrefix !== true) {\n        token.depth = token.isGlobstar ? Infinity : 1;\n      }\n    };\n    var scan = (input, options) => {\n      const opts = options || {};\n      const length = input.length - 1;\n      const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n      const slashes = [];\n      const tokens = [];\n      const parts = [];\n      let str = input;\n      let index = -1;\n      let start = 0;\n      let lastIndex = 0;\n      let isBrace = false;\n      let isBracket = false;\n      let isGlob = false;\n      let isExtglob = false;\n      let isGlobstar = false;\n      let braceEscaped = false;\n      let backslashes = false;\n      let negated = false;\n      let negatedExtglob = false;\n      let finished = false;\n      let braces = 0;\n      let prev;\n      let code;\n      let token = {\n        value: "",\n        depth: 0,\n        isGlob: false\n      };\n      const eos = () => index >= length;\n      const peek = () => str.charCodeAt(index + 1);\n      const advance = () => {\n        prev = code;\n        return str.charCodeAt(++index);\n      };\n      while (index < length) {\n        code = advance();\n        let next;\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          code = advance();\n          if (code === CHAR_LEFT_CURLY_BRACE) {\n            braceEscaped = true;\n          }\n          continue;\n        }\n        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              advance();\n              continue;\n            }\n            if (code === CHAR_LEFT_CURLY_BRACE) {\n              braces++;\n              continue;\n            }\n            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n              isBrace = token.isBrace = true;\n              isGlob = token.isGlob = true;\n              finished = true;\n              if (scanToEnd === true) {\n                continue;\n              }\n              break;\n            }\n            if (braceEscaped !== true && code === CHAR_COMMA) {\n              isBrace = token.isBrace = true;\n              isGlob = token.isGlob = true;\n              finished = true;\n              if (scanToEnd === true) {\n                continue;\n              }\n              break;\n            }\n            if (code === CHAR_RIGHT_CURLY_BRACE) {\n              braces--;\n              if (braces === 0) {\n                braceEscaped = false;\n                isBrace = token.isBrace = true;\n                finished = true;\n                break;\n              }\n            }\n          }\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n        if (code === CHAR_FORWARD_SLASH) {\n          slashes.push(index);\n          tokens.push(token);\n          token = {\n            value: "",\n            depth: 0,\n            isGlob: false\n          };\n          if (finished === true)\n            continue;\n          if (prev === CHAR_DOT && index === start + 1) {\n            start += 2;\n            continue;\n          }\n          lastIndex = index + 1;\n          continue;\n        }\n        if (opts.noext !== true) {\n          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;\n          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n            isGlob = token.isGlob = true;\n            isExtglob = token.isExtglob = true;\n            finished = true;\n            if (code === CHAR_EXCLAMATION_MARK && index === start) {\n              negatedExtglob = true;\n            }\n            if (scanToEnd === true) {\n              while (eos() !== true && (code = advance())) {\n                if (code === CHAR_BACKWARD_SLASH) {\n                  backslashes = token.backslashes = true;\n                  code = advance();\n                  continue;\n                }\n                if (code === CHAR_RIGHT_PARENTHESES) {\n                  isGlob = token.isGlob = true;\n                  finished = true;\n                  break;\n                }\n              }\n              continue;\n            }\n            break;\n          }\n        }\n        if (code === CHAR_ASTERISK) {\n          if (prev === CHAR_ASTERISK)\n            isGlobstar = token.isGlobstar = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n        if (code === CHAR_QUESTION_MARK) {\n          isGlob = token.isGlob = true;\n          finished = true;\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n        if (code === CHAR_LEFT_SQUARE_BRACKET) {\n          while (eos() !== true && (next = advance())) {\n            if (next === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              advance();\n              continue;\n            }\n            if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n              isBracket = token.isBracket = true;\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n          negated = token.negated = true;\n          start++;\n          continue;\n        }\n        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n          isGlob = token.isGlob = true;\n          if (scanToEnd === true) {\n            while (eos() !== true && (code = advance())) {\n              if (code === CHAR_LEFT_PARENTHESES) {\n                backslashes = token.backslashes = true;\n                code = advance();\n                continue;\n              }\n              if (code === CHAR_RIGHT_PARENTHESES) {\n                finished = true;\n                break;\n              }\n            }\n            continue;\n          }\n          break;\n        }\n        if (isGlob === true) {\n          finished = true;\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n      }\n      if (opts.noext === true) {\n        isExtglob = false;\n        isGlob = false;\n      }\n      let base = str;\n      let prefix = "";\n      let glob = "";\n      if (start > 0) {\n        prefix = str.slice(0, start);\n        str = str.slice(start);\n        lastIndex -= start;\n      }\n      if (base && isGlob === true && lastIndex > 0) {\n        base = str.slice(0, lastIndex);\n        glob = str.slice(lastIndex);\n      } else if (isGlob === true) {\n        base = "";\n        glob = str;\n      } else {\n        base = str;\n      }\n      if (base && base !== "" && base !== "/" && base !== str) {\n        if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n          base = base.slice(0, -1);\n        }\n      }\n      if (opts.unescape === true) {\n        if (glob)\n          glob = utils.removeBackslashes(glob);\n        if (base && backslashes === true) {\n          base = utils.removeBackslashes(base);\n        }\n      }\n      const state = {\n        prefix,\n        input,\n        start,\n        base,\n        glob,\n        isBrace,\n        isBracket,\n        isGlob,\n        isExtglob,\n        isGlobstar,\n        negated,\n        negatedExtglob\n      };\n      if (opts.tokens === true) {\n        state.maxDepth = 0;\n        if (!isPathSeparator(code)) {\n          tokens.push(token);\n        }\n        state.tokens = tokens;\n      }\n      if (opts.parts === true || opts.tokens === true) {\n        let prevIndex;\n        for (let idx = 0; idx < slashes.length; idx++) {\n          const n = prevIndex ? prevIndex + 1 : start;\n          const i = slashes[idx];\n          const value = input.slice(n, i);\n          if (opts.tokens) {\n            if (idx === 0 && start !== 0) {\n              tokens[idx].isPrefix = true;\n              tokens[idx].value = prefix;\n            } else {\n              tokens[idx].value = value;\n            }\n            depth(tokens[idx]);\n            state.maxDepth += tokens[idx].depth;\n          }\n          if (idx !== 0 || value !== "") {\n            parts.push(value);\n          }\n          prevIndex = i;\n        }\n        if (prevIndex && prevIndex + 1 < input.length) {\n          const value = input.slice(prevIndex + 1);\n          parts.push(value);\n          if (opts.tokens) {\n            tokens[tokens.length - 1].value = value;\n            depth(tokens[tokens.length - 1]);\n            state.maxDepth += tokens[tokens.length - 1].depth;\n          }\n        }\n        state.slashes = slashes;\n        state.parts = parts;\n      }\n      return state;\n    };\n    module2.exports = scan;\n  }\n});\nvar require_parse2 = __commonJS2({\n  "node_modules/picomatch/lib/parse.js"(exports2, module2) {\n    "use strict";\n    var constants = require_constants3();\n    var utils = require_utils3();\n    var {\n      MAX_LENGTH,\n      POSIX_REGEX_SOURCE,\n      REGEX_NON_SPECIAL_CHARS,\n      REGEX_SPECIAL_CHARS_BACKREF,\n      REPLACEMENTS\n    } = constants;\n    var expandRange = (args, options) => {\n      if (typeof options.expandRange === "function") {\n        return options.expandRange(...args, options);\n      }\n      args.sort();\n      const value = `[${args.join("-")}]`;\n      try {\n        new RegExp(value);\n      } catch (ex) {\n        return args.map((v) => utils.escapeRegex(v)).join("..");\n      }\n      return value;\n    };\n    var syntaxError = (type, char) => {\n      return `Missing ${type}: "${char}" - use "\\\\\\\\${char}" to match literal characters`;\n    };\n    var parse = (input, options) => {\n      if (typeof input !== "string") {\n        throw new TypeError("Expected a string");\n      }\n      input = REPLACEMENTS[input] || input;\n      const opts = Object.assign({}, options);\n      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n      let len = input.length;\n      if (len > max) {\n        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n      }\n      const bos = {\n        type: "bos",\n        value: "",\n        output: opts.prepend || ""\n      };\n      const tokens = [bos];\n      const capture = opts.capture ? "" : "?:";\n      const win32 = utils.isWindows(options);\n      const PLATFORM_CHARS = constants.globChars(win32);\n      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n      const {\n        DOT_LITERAL,\n        PLUS_LITERAL,\n        SLASH_LITERAL,\n        ONE_CHAR,\n        DOTS_SLASH,\n        NO_DOT,\n        NO_DOT_SLASH,\n        NO_DOTS_SLASH,\n        QMARK,\n        QMARK_NO_DOT,\n        STAR,\n        START_ANCHOR\n      } = PLATFORM_CHARS;\n      const globstar = (opts2) => {\n        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n      };\n      const nodot = opts.dot ? "" : NO_DOT;\n      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n      let star = opts.bash === true ? globstar(opts) : STAR;\n      if (opts.capture) {\n        star = `(${star})`;\n      }\n      if (typeof opts.noext === "boolean") {\n        opts.noextglob = opts.noext;\n      }\n      const state = {\n        input,\n        index: -1,\n        start: 0,\n        dot: opts.dot === true,\n        consumed: "",\n        output: "",\n        prefix: "",\n        backtrack: false,\n        negated: false,\n        brackets: 0,\n        braces: 0,\n        parens: 0,\n        quotes: 0,\n        globstar: false,\n        tokens\n      };\n      input = utils.removePrefix(input, state);\n      len = input.length;\n      const extglobs = [];\n      const braces = [];\n      const stack = [];\n      let prev = bos;\n      let value;\n      const eos = () => state.index === len - 1;\n      const peek = state.peek = (n = 1) => input[state.index + n];\n      const advance = state.advance = () => input[++state.index] || "";\n      const remaining = () => input.slice(state.index + 1);\n      const consume = (value2 = "", num = 0) => {\n        state.consumed += value2;\n        state.index += num;\n      };\n      const append = (token) => {\n        state.output += token.output != null ? token.output : token.value;\n        consume(token.value);\n      };\n      const negate = () => {\n        let count = 1;\n        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {\n          advance();\n          state.start++;\n          count++;\n        }\n        if (count % 2 === 0) {\n          return false;\n        }\n        state.negated = true;\n        state.start++;\n        return true;\n      };\n      const increment = (type) => {\n        state[type]++;\n        stack.push(type);\n      };\n      const decrement = (type) => {\n        state[type]--;\n        stack.pop();\n      };\n      const push = (tok) => {\n        if (prev.type === "globstar") {\n          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");\n          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");\n          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {\n            state.output = state.output.slice(0, -prev.output.length);\n            prev.type = "star";\n            prev.value = "*";\n            prev.output = star;\n            state.output += prev.output;\n          }\n        }\n        if (extglobs.length && tok.type !== "paren") {\n          extglobs[extglobs.length - 1].inner += tok.value;\n        }\n        if (tok.value || tok.output)\n          append(tok);\n        if (prev && prev.type === "text" && tok.type === "text") {\n          prev.value += tok.value;\n          prev.output = (prev.output || "") + tok.value;\n          return;\n        }\n        tok.prev = prev;\n        tokens.push(tok);\n        prev = tok;\n      };\n      const extglobOpen = (type, value2) => {\n        const token = Object.assign(Object.assign({}, EXTGLOB_CHARS[value2]), {}, {\n          conditions: 1,\n          inner: ""\n        });\n        token.prev = prev;\n        token.parens = state.parens;\n        token.output = state.output;\n        const output = (opts.capture ? "(" : "") + token.open;\n        increment("parens");\n        push({\n          type,\n          value: value2,\n          output: state.output ? "" : ONE_CHAR\n        });\n        push({\n          type: "paren",\n          extglob: true,\n          value: advance(),\n          output\n        });\n        extglobs.push(token);\n      };\n      const extglobClose = (token) => {\n        let output = token.close + (opts.capture ? ")" : "");\n        let rest;\n        if (token.type === "negate") {\n          let extglobStar = star;\n          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {\n            extglobStar = globstar(opts);\n          }\n          if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n            output = token.close = `)$))${extglobStar}`;\n          }\n          if (token.inner.includes("*") && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {\n            const expression = parse(rest, Object.assign(Object.assign({}, options), {}, {\n              fastpaths: false\n            })).output;\n            output = token.close = `)${expression})${extglobStar})`;\n          }\n          if (token.prev.type === "bos") {\n            state.negatedExtglob = true;\n          }\n        }\n        push({\n          type: "paren",\n          extglob: true,\n          value,\n          output\n        });\n        decrement("parens");\n      };\n      if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}"])/.test(input)) {\n        let backslashes = false;\n        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n          if (first === "\\\\") {\n            backslashes = true;\n            return m;\n          }\n          if (first === "?") {\n            if (esc) {\n              return esc + first + (rest ? QMARK.repeat(rest.length) : "");\n            }\n            if (index === 0) {\n              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");\n            }\n            return QMARK.repeat(chars.length);\n          }\n          if (first === ".") {\n            return DOT_LITERAL.repeat(chars.length);\n          }\n          if (first === "*") {\n            if (esc) {\n              return esc + first + (rest ? star : "");\n            }\n            return star;\n          }\n          return esc ? m : `\\\\${m}`;\n        });\n        if (backslashes === true) {\n          if (opts.unescape === true) {\n            output = output.replace(/\\\\/g, "");\n          } else {\n            output = output.replace(/\\\\+/g, (m) => {\n              return m.length % 2 === 0 ? "\\\\\\\\" : m ? "\\\\" : "";\n            });\n          }\n        }\n        if (output === input && opts.contains === true) {\n          state.output = input;\n          return state;\n        }\n        state.output = utils.wrapOutput(output, state, options);\n        return state;\n      }\n      while (!eos()) {\n        value = advance();\n        if (value === "\\0") {\n          continue;\n        }\n        if (value === "\\\\") {\n          const next = peek();\n          if (next === "/" && opts.bash !== true) {\n            continue;\n          }\n          if (next === "." || next === ";") {\n            continue;\n          }\n          if (!next) {\n            value += "\\\\";\n            push({\n              type: "text",\n              value\n            });\n            continue;\n          }\n          const match = /^\\\\+/.exec(remaining());\n          let slashes = 0;\n          if (match && match[0].length > 2) {\n            slashes = match[0].length;\n            state.index += slashes;\n            if (slashes % 2 !== 0) {\n              value += "\\\\";\n            }\n          }\n          if (opts.unescape === true) {\n            value = advance();\n          } else {\n            value += advance();\n          }\n          if (state.brackets === 0) {\n            push({\n              type: "text",\n              value\n            });\n            continue;\n          }\n        }\n        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {\n          if (opts.posix !== false && value === ":") {\n            const inner = prev.value.slice(1);\n            if (inner.includes("[")) {\n              prev.posix = true;\n              if (inner.includes(":")) {\n                const idx = prev.value.lastIndexOf("[");\n                const pre = prev.value.slice(0, idx);\n                const rest2 = prev.value.slice(idx + 2);\n                const posix = POSIX_REGEX_SOURCE[rest2];\n                if (posix) {\n                  prev.value = pre + posix;\n                  state.backtrack = true;\n                  advance();\n                  if (!bos.output && tokens.indexOf(prev) === 1) {\n                    bos.output = ONE_CHAR;\n                  }\n                  continue;\n                }\n              }\n            }\n          }\n          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {\n            value = `\\\\${value}`;\n          }\n          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {\n            value = `\\\\${value}`;\n          }\n          if (opts.posix === true && value === "!" && prev.value === "[") {\n            value = "^";\n          }\n          prev.value += value;\n          append({\n            value\n          });\n          continue;\n        }\n        if (state.quotes === 1 && value !== \'"\') {\n          value = utils.escapeRegex(value);\n          prev.value += value;\n          append({\n            value\n          });\n          continue;\n        }\n        if (value === \'"\') {\n          state.quotes = state.quotes === 1 ? 0 : 1;\n          if (opts.keepQuotes === true) {\n            push({\n              type: "text",\n              value\n            });\n          }\n          continue;\n        }\n        if (value === "(") {\n          increment("parens");\n          push({\n            type: "paren",\n            value\n          });\n          continue;\n        }\n        if (value === ")") {\n          if (state.parens === 0 && opts.strictBrackets === true) {\n            throw new SyntaxError(syntaxError("opening", "("));\n          }\n          const extglob = extglobs[extglobs.length - 1];\n          if (extglob && state.parens === extglob.parens + 1) {\n            extglobClose(extglobs.pop());\n            continue;\n          }\n          push({\n            type: "paren",\n            value,\n            output: state.parens ? ")" : "\\\\)"\n          });\n          decrement("parens");\n          continue;\n        }\n        if (value === "[") {\n          if (opts.nobracket === true || !remaining().includes("]")) {\n            if (opts.nobracket !== true && opts.strictBrackets === true) {\n              throw new SyntaxError(syntaxError("closing", "]"));\n            }\n            value = `\\\\${value}`;\n          } else {\n            increment("brackets");\n          }\n          push({\n            type: "bracket",\n            value\n          });\n          continue;\n        }\n        if (value === "]") {\n          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {\n            push({\n              type: "text",\n              value,\n              output: `\\\\${value}`\n            });\n            continue;\n          }\n          if (state.brackets === 0) {\n            if (opts.strictBrackets === true) {\n              throw new SyntaxError(syntaxError("opening", "["));\n            }\n            push({\n              type: "text",\n              value,\n              output: `\\\\${value}`\n            });\n            continue;\n          }\n          decrement("brackets");\n          const prevValue = prev.value.slice(1);\n          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {\n            value = `/${value}`;\n          }\n          prev.value += value;\n          append({\n            value\n          });\n          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n            continue;\n          }\n          const escaped = utils.escapeRegex(prev.value);\n          state.output = state.output.slice(0, -prev.value.length);\n          if (opts.literalBrackets === true) {\n            state.output += escaped;\n            prev.value = escaped;\n            continue;\n          }\n          prev.value = `(${capture}${escaped}|${prev.value})`;\n          state.output += prev.value;\n          continue;\n        }\n        if (value === "{" && opts.nobrace !== true) {\n          increment("braces");\n          const open = {\n            type: "brace",\n            value,\n            output: "(",\n            outputIndex: state.output.length,\n            tokensIndex: state.tokens.length\n          };\n          braces.push(open);\n          push(open);\n          continue;\n        }\n        if (value === "}") {\n          const brace = braces[braces.length - 1];\n          if (opts.nobrace === true || !brace) {\n            push({\n              type: "text",\n              value,\n              output: value\n            });\n            continue;\n          }\n          let output = ")";\n          if (brace.dots === true) {\n            const arr = tokens.slice();\n            const range = [];\n            for (let i = arr.length - 1; i >= 0; i--) {\n              tokens.pop();\n              if (arr[i].type === "brace") {\n                break;\n              }\n              if (arr[i].type !== "dots") {\n                range.unshift(arr[i].value);\n              }\n            }\n            output = expandRange(range, opts);\n            state.backtrack = true;\n          }\n          if (brace.comma !== true && brace.dots !== true) {\n            const out = state.output.slice(0, brace.outputIndex);\n            const toks = state.tokens.slice(brace.tokensIndex);\n            brace.value = brace.output = "\\\\{";\n            value = output = "\\\\}";\n            state.output = out;\n            for (const t of toks) {\n              state.output += t.output || t.value;\n            }\n          }\n          push({\n            type: "brace",\n            value,\n            output\n          });\n          decrement("braces");\n          braces.pop();\n          continue;\n        }\n        if (value === "|") {\n          if (extglobs.length > 0) {\n            extglobs[extglobs.length - 1].conditions++;\n          }\n          push({\n            type: "text",\n            value\n          });\n          continue;\n        }\n        if (value === ",") {\n          let output = value;\n          const brace = braces[braces.length - 1];\n          if (brace && stack[stack.length - 1] === "braces") {\n            brace.comma = true;\n            output = "|";\n          }\n          push({\n            type: "comma",\n            value,\n            output\n          });\n          continue;\n        }\n        if (value === "/") {\n          if (prev.type === "dot" && state.index === state.start + 1) {\n            state.start = state.index + 1;\n            state.consumed = "";\n            state.output = "";\n            tokens.pop();\n            prev = bos;\n            continue;\n          }\n          push({\n            type: "slash",\n            value,\n            output: SLASH_LITERAL\n          });\n          continue;\n        }\n        if (value === ".") {\n          if (state.braces > 0 && prev.type === "dot") {\n            if (prev.value === ".")\n              prev.output = DOT_LITERAL;\n            const brace = braces[braces.length - 1];\n            prev.type = "dots";\n            prev.output += value;\n            prev.value += value;\n            brace.dots = true;\n            continue;\n          }\n          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {\n            push({\n              type: "text",\n              value,\n              output: DOT_LITERAL\n            });\n            continue;\n          }\n          push({\n            type: "dot",\n            value,\n            output: DOT_LITERAL\n          });\n          continue;\n        }\n        if (value === "?") {\n          const isGroup = prev && prev.value === "(";\n          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {\n            extglobOpen("qmark", value);\n            continue;\n          }\n          if (prev && prev.type === "paren") {\n            const next = peek();\n            let output = value;\n            if (next === "<" && !utils.supportsLookbehinds()) {\n              throw new Error("Node.js v10 or higher is required for regex lookbehinds");\n            }\n            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\\w+>)/.test(remaining())) {\n              output = `\\\\${value}`;\n            }\n            push({\n              type: "text",\n              value,\n              output\n            });\n            continue;\n          }\n          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {\n            push({\n              type: "qmark",\n              value,\n              output: QMARK_NO_DOT\n            });\n            continue;\n          }\n          push({\n            type: "qmark",\n            value,\n            output: QMARK\n          });\n          continue;\n        }\n        if (value === "!") {\n          if (opts.noextglob !== true && peek() === "(") {\n            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {\n              extglobOpen("negate", value);\n              continue;\n            }\n          }\n          if (opts.nonegate !== true && state.index === 0) {\n            negate();\n            continue;\n          }\n        }\n        if (value === "+") {\n          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {\n            extglobOpen("plus", value);\n            continue;\n          }\n          if (prev && prev.value === "(" || opts.regex === false) {\n            push({\n              type: "plus",\n              value,\n              output: PLUS_LITERAL\n            });\n            continue;\n          }\n          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {\n            push({\n              type: "plus",\n              value\n            });\n            continue;\n          }\n          push({\n            type: "plus",\n            value: PLUS_LITERAL\n          });\n          continue;\n        }\n        if (value === "@") {\n          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {\n            push({\n              type: "at",\n              extglob: true,\n              value,\n              output: ""\n            });\n            continue;\n          }\n          push({\n            type: "text",\n            value\n          });\n          continue;\n        }\n        if (value !== "*") {\n          if (value === "$" || value === "^") {\n            value = `\\\\${value}`;\n          }\n          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n          if (match) {\n            value += match[0];\n            state.index += match[0].length;\n          }\n          push({\n            type: "text",\n            value\n          });\n          continue;\n        }\n        if (prev && (prev.type === "globstar" || prev.star === true)) {\n          prev.type = "star";\n          prev.star = true;\n          prev.value += value;\n          prev.output = star;\n          state.backtrack = true;\n          state.globstar = true;\n          consume(value);\n          continue;\n        }\n        let rest = remaining();\n        if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n          extglobOpen("star", value);\n          continue;\n        }\n        if (prev.type === "star") {\n          if (opts.noglobstar === true) {\n            consume(value);\n            continue;\n          }\n          const prior = prev.prev;\n          const before = prior.prev;\n          const isStart = prior.type === "slash" || prior.type === "bos";\n          const afterStar = before && (before.type === "star" || before.type === "globstar");\n          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {\n            push({\n              type: "star",\n              value,\n              output: ""\n            });\n            continue;\n          }\n          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");\n          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");\n          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {\n            push({\n              type: "star",\n              value,\n              output: ""\n            });\n            continue;\n          }\n          while (rest.slice(0, 3) === "/**") {\n            const after = input[state.index + 4];\n            if (after && after !== "/") {\n              break;\n            }\n            rest = rest.slice(3);\n            consume("/**", 3);\n          }\n          if (prior.type === "bos" && eos()) {\n            prev.type = "globstar";\n            prev.value += value;\n            prev.output = globstar(opts);\n            state.output = prev.output;\n            state.globstar = true;\n            consume(value);\n            continue;\n          }\n          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {\n            state.output = state.output.slice(0, -(prior.output + prev.output).length);\n            prior.output = `(?:${prior.output}`;\n            prev.type = "globstar";\n            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");\n            prev.value += value;\n            state.globstar = true;\n            state.output += prior.output + prev.output;\n            consume(value);\n            continue;\n          }\n          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {\n            const end = rest[1] !== void 0 ? "|$" : "";\n            state.output = state.output.slice(0, -(prior.output + prev.output).length);\n            prior.output = `(?:${prior.output}`;\n            prev.type = "globstar";\n            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n            prev.value += value;\n            state.output += prior.output + prev.output;\n            state.globstar = true;\n            consume(value + advance());\n            push({\n              type: "slash",\n              value: "/",\n              output: ""\n            });\n            continue;\n          }\n          if (prior.type === "bos" && rest[0] === "/") {\n            prev.type = "globstar";\n            prev.value += value;\n            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n            state.output = prev.output;\n            state.globstar = true;\n            consume(value + advance());\n            push({\n              type: "slash",\n              value: "/",\n              output: ""\n            });\n            continue;\n          }\n          state.output = state.output.slice(0, -prev.output.length);\n          prev.type = "globstar";\n          prev.output = globstar(opts);\n          prev.value += value;\n          state.output += prev.output;\n          state.globstar = true;\n          consume(value);\n          continue;\n        }\n        const token = {\n          type: "star",\n          value,\n          output: star\n        };\n        if (opts.bash === true) {\n          token.output = ".*?";\n          if (prev.type === "bos" || prev.type === "slash") {\n            token.output = nodot + token.output;\n          }\n          push(token);\n          continue;\n        }\n        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {\n          token.output = value;\n          push(token);\n          continue;\n        }\n        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {\n          if (prev.type === "dot") {\n            state.output += NO_DOT_SLASH;\n            prev.output += NO_DOT_SLASH;\n          } else if (opts.dot === true) {\n            state.output += NO_DOTS_SLASH;\n            prev.output += NO_DOTS_SLASH;\n          } else {\n            state.output += nodot;\n            prev.output += nodot;\n          }\n          if (peek() !== "*") {\n            state.output += ONE_CHAR;\n            prev.output += ONE_CHAR;\n          }\n        }\n        push(token);\n      }\n      while (state.brackets > 0) {\n        if (opts.strictBrackets === true)\n          throw new SyntaxError(syntaxError("closing", "]"));\n        state.output = utils.escapeLast(state.output, "[");\n        decrement("brackets");\n      }\n      while (state.parens > 0) {\n        if (opts.strictBrackets === true)\n          throw new SyntaxError(syntaxError("closing", ")"));\n        state.output = utils.escapeLast(state.output, "(");\n        decrement("parens");\n      }\n      while (state.braces > 0) {\n        if (opts.strictBrackets === true)\n          throw new SyntaxError(syntaxError("closing", "}"));\n        state.output = utils.escapeLast(state.output, "{");\n        decrement("braces");\n      }\n      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {\n        push({\n          type: "maybe_slash",\n          value: "",\n          output: `${SLASH_LITERAL}?`\n        });\n      }\n      if (state.backtrack === true) {\n        state.output = "";\n        for (const token of state.tokens) {\n          state.output += token.output != null ? token.output : token.value;\n          if (token.suffix) {\n            state.output += token.suffix;\n          }\n        }\n      }\n      return state;\n    };\n    parse.fastpaths = (input, options) => {\n      const opts = Object.assign({}, options);\n      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n      const len = input.length;\n      if (len > max) {\n        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n      }\n      input = REPLACEMENTS[input] || input;\n      const win32 = utils.isWindows(options);\n      const {\n        DOT_LITERAL,\n        SLASH_LITERAL,\n        ONE_CHAR,\n        DOTS_SLASH,\n        NO_DOT,\n        NO_DOTS,\n        NO_DOTS_SLASH,\n        STAR,\n        START_ANCHOR\n      } = constants.globChars(win32);\n      const nodot = opts.dot ? NO_DOTS : NO_DOT;\n      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n      const capture = opts.capture ? "" : "?:";\n      const state = {\n        negated: false,\n        prefix: ""\n      };\n      let star = opts.bash === true ? ".*?" : STAR;\n      if (opts.capture) {\n        star = `(${star})`;\n      }\n      const globstar = (opts2) => {\n        if (opts2.noglobstar === true)\n          return star;\n        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n      };\n      const create = (str) => {\n        switch (str) {\n          case "*":\n            return `${nodot}${ONE_CHAR}${star}`;\n          case ".*":\n            return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n          case "*.*":\n            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n          case "*/*":\n            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n          case "**":\n            return nodot + globstar(opts);\n          case "**/*":\n            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n          case "**/*.*":\n            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n          case "**/.*":\n            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n          default: {\n            const match = /^(.*?)\\.(\\w+)$/.exec(str);\n            if (!match)\n              return;\n            const source2 = create(match[1]);\n            if (!source2)\n              return;\n            return source2 + DOT_LITERAL + match[2];\n          }\n        }\n      };\n      const output = utils.removePrefix(input, state);\n      let source = create(output);\n      if (source && opts.strictSlashes !== true) {\n        source += `${SLASH_LITERAL}?`;\n      }\n      return source;\n    };\n    module2.exports = parse;\n  }\n});\nvar require_picomatch = __commonJS2({\n  "node_modules/picomatch/lib/picomatch.js"(exports2, module2) {\n    "use strict";\n    var path = require("path");\n    var scan = require_scan();\n    var parse = require_parse2();\n    var utils = require_utils3();\n    var constants = require_constants3();\n    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);\n    var picomatch = (glob, options, returnState = false) => {\n      if (Array.isArray(glob)) {\n        const fns = glob.map((input) => picomatch(input, options, returnState));\n        const arrayMatcher = (str) => {\n          for (const isMatch of fns) {\n            const state2 = isMatch(str);\n            if (state2)\n              return state2;\n          }\n          return false;\n        };\n        return arrayMatcher;\n      }\n      const isState = isObject(glob) && glob.tokens && glob.input;\n      if (glob === "" || typeof glob !== "string" && !isState) {\n        throw new TypeError("Expected pattern to be a non-empty string");\n      }\n      const opts = options || {};\n      const posix = utils.isWindows(options);\n      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);\n      const state = regex.state;\n      delete regex.state;\n      let isIgnored = () => false;\n      if (opts.ignore) {\n        const ignoreOpts = Object.assign(Object.assign({}, options), {}, {\n          ignore: null,\n          onMatch: null,\n          onResult: null\n        });\n        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n      }\n      const matcher = (input, returnObject = false) => {\n        const {\n          isMatch,\n          match,\n          output\n        } = picomatch.test(input, regex, options, {\n          glob,\n          posix\n        });\n        const result = {\n          glob,\n          state,\n          regex,\n          posix,\n          input,\n          output,\n          match,\n          isMatch\n        };\n        if (typeof opts.onResult === "function") {\n          opts.onResult(result);\n        }\n        if (isMatch === false) {\n          result.isMatch = false;\n          return returnObject ? result : false;\n        }\n        if (isIgnored(input)) {\n          if (typeof opts.onIgnore === "function") {\n            opts.onIgnore(result);\n          }\n          result.isMatch = false;\n          return returnObject ? result : false;\n        }\n        if (typeof opts.onMatch === "function") {\n          opts.onMatch(result);\n        }\n        return returnObject ? result : true;\n      };\n      if (returnState) {\n        matcher.state = state;\n      }\n      return matcher;\n    };\n    picomatch.test = (input, regex, options, {\n      glob,\n      posix\n    } = {}) => {\n      if (typeof input !== "string") {\n        throw new TypeError("Expected input to be a string");\n      }\n      if (input === "") {\n        return {\n          isMatch: false,\n          output: ""\n        };\n      }\n      const opts = options || {};\n      const format = opts.format || (posix ? utils.toPosixSlashes : null);\n      let match = input === glob;\n      let output = match && format ? format(input) : input;\n      if (match === false) {\n        output = format ? format(input) : input;\n        match = output === glob;\n      }\n      if (match === false || opts.capture === true) {\n        if (opts.matchBase === true || opts.basename === true) {\n          match = picomatch.matchBase(input, regex, options, posix);\n        } else {\n          match = regex.exec(output);\n        }\n      }\n      return {\n        isMatch: Boolean(match),\n        match,\n        output\n      };\n    };\n    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n      return regex.test(path.basename(input));\n    };\n    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n    picomatch.parse = (pattern, options) => {\n      if (Array.isArray(pattern))\n        return pattern.map((p) => picomatch.parse(p, options));\n      return parse(pattern, Object.assign(Object.assign({}, options), {}, {\n        fastpaths: false\n      }));\n    };\n    picomatch.scan = (input, options) => scan(input, options);\n    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {\n      if (returnOutput === true) {\n        return state.output;\n      }\n      const opts = options || {};\n      const prepend = opts.contains ? "" : "^";\n      const append = opts.contains ? "" : "$";\n      let source = `${prepend}(?:${state.output})${append}`;\n      if (state && state.negated === true) {\n        source = `^(?!${source}).*$`;\n      }\n      const regex = picomatch.toRegex(source, options);\n      if (returnState === true) {\n        regex.state = state;\n      }\n      return regex;\n    };\n    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {\n      if (!input || typeof input !== "string") {\n        throw new TypeError("Expected a non-empty string");\n      }\n      let parsed = {\n        negated: false,\n        fastpaths: true\n      };\n      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {\n        parsed.output = parse.fastpaths(input, options);\n      }\n      if (!parsed.output) {\n        parsed = parse(input, options);\n      }\n      return picomatch.compileRe(parsed, options, returnOutput, returnState);\n    };\n    picomatch.toRegex = (source, options) => {\n      try {\n        const opts = options || {};\n        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));\n      } catch (err) {\n        if (options && options.debug === true)\n          throw err;\n        return /$^/;\n      }\n    };\n    picomatch.constants = constants;\n    module2.exports = picomatch;\n  }\n});\nvar require_picomatch2 = __commonJS2({\n  "node_modules/picomatch/index.js"(exports2, module2) {\n    "use strict";\n    module2.exports = require_picomatch();\n  }\n});\nvar require_micromatch = __commonJS2({\n  "node_modules/micromatch/index.js"(exports2, module2) {\n    "use strict";\n    var util = require("util");\n    var braces = require_braces();\n    var picomatch = require_picomatch2();\n    var utils = require_utils3();\n    var isEmptyString = (val) => val === "" || val === "./";\n    var micromatch = (list, patterns, options) => {\n      patterns = [].concat(patterns);\n      list = [].concat(list);\n      let omit = /* @__PURE__ */ new Set();\n      let keep = /* @__PURE__ */ new Set();\n      let items = /* @__PURE__ */ new Set();\n      let negatives = 0;\n      let onResult = (state) => {\n        items.add(state.output);\n        if (options && options.onResult) {\n          options.onResult(state);\n        }\n      };\n      for (let i = 0; i < patterns.length; i++) {\n        let isMatch = picomatch(String(patterns[i]), Object.assign(Object.assign({}, options), {}, {\n          onResult\n        }), true);\n        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n        if (negated)\n          negatives++;\n        for (let item of list) {\n          let matched = isMatch(item, true);\n          let match = negated ? !matched.isMatch : matched.isMatch;\n          if (!match)\n            continue;\n          if (negated) {\n            omit.add(matched.output);\n          } else {\n            omit.delete(matched.output);\n            keep.add(matched.output);\n          }\n        }\n      }\n      let result = negatives === patterns.length ? [...items] : [...keep];\n      let matches = result.filter((item) => !omit.has(item));\n      if (options && matches.length === 0) {\n        if (options.failglob === true) {\n          throw new Error(`No matches found for "${patterns.join(", ")}"`);\n        }\n        if (options.nonull === true || options.nullglob === true) {\n          return options.unescape ? patterns.map((p) => p.replace(/\\\\/g, "")) : patterns;\n        }\n      }\n      return matches;\n    };\n    micromatch.match = micromatch;\n    micromatch.matcher = (pattern, options) => picomatch(pattern, options);\n    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n    micromatch.any = micromatch.isMatch;\n    micromatch.not = (list, patterns, options = {}) => {\n      patterns = [].concat(patterns).map(String);\n      let result = /* @__PURE__ */ new Set();\n      let items = [];\n      let onResult = (state) => {\n        if (options.onResult)\n          options.onResult(state);\n        items.push(state.output);\n      };\n      let matches = new Set(micromatch(list, patterns, Object.assign(Object.assign({}, options), {}, {\n        onResult\n      })));\n      for (let item of items) {\n        if (!matches.has(item)) {\n          result.add(item);\n        }\n      }\n      return [...result];\n    };\n    micromatch.contains = (str, pattern, options) => {\n      if (typeof str !== "string") {\n        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);\n      }\n      if (Array.isArray(pattern)) {\n        return pattern.some((p) => micromatch.contains(str, p, options));\n      }\n      if (typeof pattern === "string") {\n        if (isEmptyString(str) || isEmptyString(pattern)) {\n          return false;\n        }\n        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {\n          return true;\n        }\n      }\n      return micromatch.isMatch(str, pattern, Object.assign(Object.assign({}, options), {}, {\n        contains: true\n      }));\n    };\n    micromatch.matchKeys = (obj, patterns, options) => {\n      if (!utils.isObject(obj)) {\n        throw new TypeError("Expected the first argument to be an object");\n      }\n      let keys = micromatch(Object.keys(obj), patterns, options);\n      let res = {};\n      for (let key of keys)\n        res[key] = obj[key];\n      return res;\n    };\n    micromatch.some = (list, patterns, options) => {\n      let items = [].concat(list);\n      for (let pattern of [].concat(patterns)) {\n        let isMatch = picomatch(String(pattern), options);\n        if (items.some((item) => isMatch(item))) {\n          return true;\n        }\n      }\n      return false;\n    };\n    micromatch.every = (list, patterns, options) => {\n      let items = [].concat(list);\n      for (let pattern of [].concat(patterns)) {\n        let isMatch = picomatch(String(pattern), options);\n        if (!items.every((item) => isMatch(item))) {\n          return false;\n        }\n      }\n      return true;\n    };\n    micromatch.all = (str, patterns, options) => {\n      if (typeof str !== "string") {\n        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);\n      }\n      return [].concat(patterns).every((p) => picomatch(p, options)(str));\n    };\n    micromatch.capture = (glob, input, options) => {\n      let posix = utils.isWindows(options);\n      let regex = picomatch.makeRe(String(glob), Object.assign(Object.assign({}, options), {}, {\n        capture: true\n      }));\n      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n      if (match) {\n        return match.slice(1).map((v) => v === void 0 ? "" : v);\n      }\n    };\n    micromatch.makeRe = (...args) => picomatch.makeRe(...args);\n    micromatch.scan = (...args) => picomatch.scan(...args);\n    micromatch.parse = (patterns, options) => {\n      let res = [];\n      for (let pattern of [].concat(patterns || [])) {\n        for (let str of braces(String(pattern), options)) {\n          res.push(picomatch.parse(str, options));\n        }\n      }\n      return res;\n    };\n    micromatch.braces = (pattern, options) => {\n      if (typeof pattern !== "string")\n        throw new TypeError("Expected a string");\n      if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n        return [pattern];\n      }\n      return braces(pattern, options);\n    };\n    micromatch.braceExpand = (pattern, options) => {\n      if (typeof pattern !== "string")\n        throw new TypeError("Expected a string");\n      return micromatch.braces(pattern, Object.assign(Object.assign({}, options), {}, {\n        expand: true\n      }));\n    };\n    module2.exports = micromatch;\n  }\n});\nvar require_parser2 = __commonJS2({\n  "node_modules/@iarna/toml/lib/parser.js"(exports2, module2) {\n    "use strict";\n    var ParserEND = 1114112;\n    var ParserError = class extends Error {\n      constructor(msg, filename, linenumber) {\n        super("[ParserError] " + msg, filename, linenumber);\n        this.name = "ParserError";\n        this.code = "ParserError";\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(this, ParserError);\n      }\n    };\n    var State = class {\n      constructor(parser) {\n        this.parser = parser;\n        this.buf = "";\n        this.returned = null;\n        this.result = null;\n        this.resultTable = null;\n        this.resultArr = null;\n      }\n    };\n    var Parser = class {\n      constructor() {\n        this.pos = 0;\n        this.col = 0;\n        this.line = 0;\n        this.obj = {};\n        this.ctx = this.obj;\n        this.stack = [];\n        this._buf = "";\n        this.char = null;\n        this.ii = 0;\n        this.state = new State(this.parseStart);\n      }\n      parse(str) {\n        if (str.length === 0 || str.length == null)\n          return;\n        this._buf = String(str);\n        this.ii = -1;\n        this.char = -1;\n        let getNext;\n        while (getNext === false || this.nextChar()) {\n          getNext = this.runOne();\n        }\n        this._buf = null;\n      }\n      nextChar() {\n        if (this.char === 10) {\n          ++this.line;\n          this.col = -1;\n        }\n        ++this.ii;\n        this.char = this._buf.codePointAt(this.ii);\n        ++this.pos;\n        ++this.col;\n        return this.haveBuffer();\n      }\n      haveBuffer() {\n        return this.ii < this._buf.length;\n      }\n      runOne() {\n        return this.state.parser.call(this, this.state.returned);\n      }\n      finish() {\n        this.char = ParserEND;\n        let last;\n        do {\n          last = this.state.parser;\n          this.runOne();\n        } while (this.state.parser !== last);\n        this.ctx = null;\n        this.state = null;\n        this._buf = null;\n        return this.obj;\n      }\n      next(fn) {\n        if (typeof fn !== "function")\n          throw new ParserError("Tried to set state to non-existent state: " + JSON.stringify(fn));\n        this.state.parser = fn;\n      }\n      goto(fn) {\n        this.next(fn);\n        return this.runOne();\n      }\n      call(fn, returnWith) {\n        if (returnWith)\n          this.next(returnWith);\n        this.stack.push(this.state);\n        this.state = new State(fn);\n      }\n      callNow(fn, returnWith) {\n        this.call(fn, returnWith);\n        return this.runOne();\n      }\n      return(value) {\n        if (this.stack.length === 0)\n          throw this.error(new ParserError("Stack underflow"));\n        if (value === void 0)\n          value = this.state.buf;\n        this.state = this.stack.pop();\n        this.state.returned = value;\n      }\n      returnNow(value) {\n        this.return(value);\n        return this.runOne();\n      }\n      consume() {\n        if (this.char === ParserEND)\n          throw this.error(new ParserError("Unexpected end-of-buffer"));\n        this.state.buf += this._buf[this.ii];\n      }\n      error(err) {\n        err.line = this.line;\n        err.col = this.col;\n        err.pos = this.pos;\n        return err;\n      }\n      parseStart() {\n        throw new ParserError("Must declare a parseStart method");\n      }\n    };\n    Parser.END = ParserEND;\n    Parser.Error = ParserError;\n    module2.exports = Parser;\n  }\n});\nvar require_create_datetime = __commonJS2({\n  "node_modules/@iarna/toml/lib/create-datetime.js"(exports2, module2) {\n    "use strict";\n    module2.exports = (value) => {\n      const date = new Date(value);\n      if (isNaN(date)) {\n        throw new TypeError("Invalid Datetime");\n      } else {\n        return date;\n      }\n    };\n  }\n});\nvar require_format_num = __commonJS2({\n  "node_modules/@iarna/toml/lib/format-num.js"(exports2, module2) {\n    "use strict";\n    module2.exports = (d, num) => {\n      num = String(num);\n      while (num.length < d)\n        num = "0" + num;\n      return num;\n    };\n  }\n});\nvar require_create_datetime_float = __commonJS2({\n  "node_modules/@iarna/toml/lib/create-datetime-float.js"(exports2, module2) {\n    "use strict";\n    var f = require_format_num();\n    var FloatingDateTime = class extends Date {\n      constructor(value) {\n        super(value + "Z");\n        this.isFloating = true;\n      }\n      toISOString() {\n        const date = `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;\n        const time = `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;\n        return `${date}T${time}`;\n      }\n    };\n    module2.exports = (value) => {\n      const date = new FloatingDateTime(value);\n      if (isNaN(date)) {\n        throw new TypeError("Invalid Datetime");\n      } else {\n        return date;\n      }\n    };\n  }\n});\nvar require_create_date = __commonJS2({\n  "node_modules/@iarna/toml/lib/create-date.js"(exports2, module2) {\n    "use strict";\n    var f = require_format_num();\n    var DateTime = global.Date;\n    var Date2 = class extends DateTime {\n      constructor(value) {\n        super(value);\n        this.isDate = true;\n      }\n      toISOString() {\n        return `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;\n      }\n    };\n    module2.exports = (value) => {\n      const date = new Date2(value);\n      if (isNaN(date)) {\n        throw new TypeError("Invalid Datetime");\n      } else {\n        return date;\n      }\n    };\n  }\n});\nvar require_create_time = __commonJS2({\n  "node_modules/@iarna/toml/lib/create-time.js"(exports2, module2) {\n    "use strict";\n    var f = require_format_num();\n    var Time = class extends Date {\n      constructor(value) {\n        super(`0000-01-01T${value}Z`);\n        this.isTime = true;\n      }\n      toISOString() {\n        return `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;\n      }\n    };\n    module2.exports = (value) => {\n      const date = new Time(value);\n      if (isNaN(date)) {\n        throw new TypeError("Invalid Datetime");\n      } else {\n        return date;\n      }\n    };\n  }\n});\nvar require_toml_parser = __commonJS2({\n  "node_modules/@iarna/toml/lib/toml-parser.js"(exports2, module2) {\n    "use strict";\n    module2.exports = makeParserClass(require_parser2());\n    module2.exports.makeParserClass = makeParserClass;\n    var TomlError = class extends Error {\n      constructor(msg) {\n        super(msg);\n        this.name = "TomlError";\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(this, TomlError);\n        this.fromTOML = true;\n        this.wrapped = null;\n      }\n    };\n    TomlError.wrap = (err) => {\n      const terr = new TomlError(err.message);\n      terr.code = err.code;\n      terr.wrapped = err;\n      return terr;\n    };\n    module2.exports.TomlError = TomlError;\n    var createDateTime = require_create_datetime();\n    var createDateTimeFloat = require_create_datetime_float();\n    var createDate = require_create_date();\n    var createTime = require_create_time();\n    var CTRL_I = 9;\n    var CTRL_J = 10;\n    var CTRL_M = 13;\n    var CTRL_CHAR_BOUNDARY = 31;\n    var CHAR_SP = 32;\n    var CHAR_QUOT = 34;\n    var CHAR_NUM = 35;\n    var CHAR_APOS = 39;\n    var CHAR_PLUS = 43;\n    var CHAR_COMMA = 44;\n    var CHAR_HYPHEN = 45;\n    var CHAR_PERIOD = 46;\n    var CHAR_0 = 48;\n    var CHAR_1 = 49;\n    var CHAR_7 = 55;\n    var CHAR_9 = 57;\n    var CHAR_COLON = 58;\n    var CHAR_EQUALS = 61;\n    var CHAR_A = 65;\n    var CHAR_E = 69;\n    var CHAR_F = 70;\n    var CHAR_T = 84;\n    var CHAR_U = 85;\n    var CHAR_Z = 90;\n    var CHAR_LOWBAR = 95;\n    var CHAR_a = 97;\n    var CHAR_b = 98;\n    var CHAR_e = 101;\n    var CHAR_f = 102;\n    var CHAR_i = 105;\n    var CHAR_l = 108;\n    var CHAR_n = 110;\n    var CHAR_o = 111;\n    var CHAR_r = 114;\n    var CHAR_s = 115;\n    var CHAR_t = 116;\n    var CHAR_u = 117;\n    var CHAR_x = 120;\n    var CHAR_z = 122;\n    var CHAR_LCUB = 123;\n    var CHAR_RCUB = 125;\n    var CHAR_LSQB = 91;\n    var CHAR_BSOL = 92;\n    var CHAR_RSQB = 93;\n    var CHAR_DEL = 127;\n    var SURROGATE_FIRST = 55296;\n    var SURROGATE_LAST = 57343;\n    var escapes = {\n      [CHAR_b]: "\\b",\n      [CHAR_t]: "\t",\n      [CHAR_n]: "\\n",\n      [CHAR_f]: "\\f",\n      [CHAR_r]: "\\r",\n      [CHAR_QUOT]: \'"\',\n      [CHAR_BSOL]: "\\\\"\n    };\n    function isDigit(cp) {\n      return cp >= CHAR_0 && cp <= CHAR_9;\n    }\n    function isHexit(cp) {\n      return cp >= CHAR_A && cp <= CHAR_F || cp >= CHAR_a && cp <= CHAR_f || cp >= CHAR_0 && cp <= CHAR_9;\n    }\n    function isBit(cp) {\n      return cp === CHAR_1 || cp === CHAR_0;\n    }\n    function isOctit(cp) {\n      return cp >= CHAR_0 && cp <= CHAR_7;\n    }\n    function isAlphaNumQuoteHyphen(cp) {\n      return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_APOS || cp === CHAR_QUOT || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;\n    }\n    function isAlphaNumHyphen(cp) {\n      return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;\n    }\n    var _type = Symbol("type");\n    var _declared = Symbol("declared");\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var defineProperty = Object.defineProperty;\n    var descriptor = {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: void 0\n    };\n    function hasKey(obj, key) {\n      if (hasOwnProperty.call(obj, key))\n        return true;\n      if (key === "__proto__")\n        defineProperty(obj, "__proto__", descriptor);\n      return false;\n    }\n    var INLINE_TABLE = Symbol("inline-table");\n    function InlineTable() {\n      return Object.defineProperties({}, {\n        [_type]: {\n          value: INLINE_TABLE\n        }\n      });\n    }\n    function isInlineTable(obj) {\n      if (obj === null || typeof obj !== "object")\n        return false;\n      return obj[_type] === INLINE_TABLE;\n    }\n    var TABLE = Symbol("table");\n    function Table() {\n      return Object.defineProperties({}, {\n        [_type]: {\n          value: TABLE\n        },\n        [_declared]: {\n          value: false,\n          writable: true\n        }\n      });\n    }\n    function isTable(obj) {\n      if (obj === null || typeof obj !== "object")\n        return false;\n      return obj[_type] === TABLE;\n    }\n    var _contentType = Symbol("content-type");\n    var INLINE_LIST = Symbol("inline-list");\n    function InlineList(type) {\n      return Object.defineProperties([], {\n        [_type]: {\n          value: INLINE_LIST\n        },\n        [_contentType]: {\n          value: type\n        }\n      });\n    }\n    function isInlineList(obj) {\n      if (obj === null || typeof obj !== "object")\n        return false;\n      return obj[_type] === INLINE_LIST;\n    }\n    var LIST = Symbol("list");\n    function List() {\n      return Object.defineProperties([], {\n        [_type]: {\n          value: LIST\n        }\n      });\n    }\n    function isList(obj) {\n      if (obj === null || typeof obj !== "object")\n        return false;\n      return obj[_type] === LIST;\n    }\n    var _custom;\n    try {\n      const utilInspect = require("util").inspect;\n      _custom = utilInspect.custom;\n    } catch (_) {\n    }\n    var _inspect = _custom || "inspect";\n    var BoxedBigInt = class {\n      constructor(value) {\n        try {\n          this.value = global.BigInt.asIntN(64, value);\n        } catch (_) {\n          this.value = null;\n        }\n        Object.defineProperty(this, _type, {\n          value: INTEGER\n        });\n      }\n      isNaN() {\n        return this.value === null;\n      }\n      toString() {\n        return String(this.value);\n      }\n      [_inspect]() {\n        return `[BigInt: ${this.toString()}]}`;\n      }\n      valueOf() {\n        return this.value;\n      }\n    };\n    var INTEGER = Symbol("integer");\n    function Integer(value) {\n      let num = Number(value);\n      if (Object.is(num, -0))\n        num = 0;\n      if (global.BigInt && !Number.isSafeInteger(num)) {\n        return new BoxedBigInt(value);\n      } else {\n        return Object.defineProperties(new Number(num), {\n          isNaN: {\n            value: function() {\n              return isNaN(this);\n            }\n          },\n          [_type]: {\n            value: INTEGER\n          },\n          [_inspect]: {\n            value: () => `[Integer: ${value}]`\n          }\n        });\n      }\n    }\n    function isInteger(obj) {\n      if (obj === null || typeof obj !== "object")\n        return false;\n      return obj[_type] === INTEGER;\n    }\n    var FLOAT = Symbol("float");\n    function Float(value) {\n      return Object.defineProperties(new Number(value), {\n        [_type]: {\n          value: FLOAT\n        },\n        [_inspect]: {\n          value: () => `[Float: ${value}]`\n        }\n      });\n    }\n    function isFloat(obj) {\n      if (obj === null || typeof obj !== "object")\n        return false;\n      return obj[_type] === FLOAT;\n    }\n    function tomlType(value) {\n      const type = typeof value;\n      if (type === "object") {\n        if (value === null)\n          return "null";\n        if (value instanceof Date)\n          return "datetime";\n        if (_type in value) {\n          switch (value[_type]) {\n            case INLINE_TABLE:\n              return "inline-table";\n            case INLINE_LIST:\n              return "inline-list";\n            case TABLE:\n              return "table";\n            case LIST:\n              return "list";\n            case FLOAT:\n              return "float";\n            case INTEGER:\n              return "integer";\n          }\n        }\n      }\n      return type;\n    }\n    function makeParserClass(Parser) {\n      class TOMLParser extends Parser {\n        constructor() {\n          super();\n          this.ctx = this.obj = Table();\n        }\n        atEndOfWord() {\n          return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();\n        }\n        atEndOfLine() {\n          return this.char === Parser.END || this.char === CTRL_J || this.char === CTRL_M;\n        }\n        parseStart() {\n          if (this.char === Parser.END) {\n            return null;\n          } else if (this.char === CHAR_LSQB) {\n            return this.call(this.parseTableOrList);\n          } else if (this.char === CHAR_NUM) {\n            return this.call(this.parseComment);\n          } else if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {\n            return null;\n          } else if (isAlphaNumQuoteHyphen(this.char)) {\n            return this.callNow(this.parseAssignStatement);\n          } else {\n            throw this.error(new TomlError(`Unknown character "${this.char}"`));\n          }\n        }\n        parseWhitespaceToEOL() {\n          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {\n            return null;\n          } else if (this.char === CHAR_NUM) {\n            return this.goto(this.parseComment);\n          } else if (this.char === Parser.END || this.char === CTRL_J) {\n            return this.return();\n          } else {\n            throw this.error(new TomlError("Unexpected character, expected only whitespace or comments till end of line"));\n          }\n        }\n        parseAssignStatement() {\n          return this.callNow(this.parseAssign, this.recordAssignStatement);\n        }\n        recordAssignStatement(kv) {\n          let target = this.ctx;\n          let finalKey = kv.key.pop();\n          for (let kw of kv.key) {\n            if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {\n              throw this.error(new TomlError("Can\'t redefine existing key"));\n            }\n            target = target[kw] = target[kw] || Table();\n          }\n          if (hasKey(target, finalKey)) {\n            throw this.error(new TomlError("Can\'t redefine existing key"));\n          }\n          if (isInteger(kv.value) || isFloat(kv.value)) {\n            target[finalKey] = kv.value.valueOf();\n          } else {\n            target[finalKey] = kv.value;\n          }\n          return this.goto(this.parseWhitespaceToEOL);\n        }\n        parseAssign() {\n          return this.callNow(this.parseKeyword, this.recordAssignKeyword);\n        }\n        recordAssignKeyword(key) {\n          if (this.state.resultTable) {\n            this.state.resultTable.push(key);\n          } else {\n            this.state.resultTable = [key];\n          }\n          return this.goto(this.parseAssignKeywordPreDot);\n        }\n        parseAssignKeywordPreDot() {\n          if (this.char === CHAR_PERIOD) {\n            return this.next(this.parseAssignKeywordPostDot);\n          } else if (this.char !== CHAR_SP && this.char !== CTRL_I) {\n            return this.goto(this.parseAssignEqual);\n          }\n        }\n        parseAssignKeywordPostDot() {\n          if (this.char !== CHAR_SP && this.char !== CTRL_I) {\n            return this.callNow(this.parseKeyword, this.recordAssignKeyword);\n          }\n        }\n        parseAssignEqual() {\n          if (this.char === CHAR_EQUALS) {\n            return this.next(this.parseAssignPreValue);\n          } else {\n            throw this.error(new TomlError(\'Invalid character, expected "="\'));\n          }\n        }\n        parseAssignPreValue() {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else {\n            return this.callNow(this.parseValue, this.recordAssignValue);\n          }\n        }\n        recordAssignValue(value) {\n          return this.returnNow({\n            key: this.state.resultTable,\n            value\n          });\n        }\n        parseComment() {\n          do {\n            if (this.char === Parser.END || this.char === CTRL_J) {\n              return this.return();\n            }\n          } while (this.nextChar());\n        }\n        parseTableOrList() {\n          if (this.char === CHAR_LSQB) {\n            this.next(this.parseList);\n          } else {\n            return this.goto(this.parseTable);\n          }\n        }\n        parseTable() {\n          this.ctx = this.obj;\n          return this.goto(this.parseTableNext);\n        }\n        parseTableNext() {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else {\n            return this.callNow(this.parseKeyword, this.parseTableMore);\n          }\n        }\n        parseTableMore(keyword) {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else if (this.char === CHAR_RSQB) {\n            if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared])) {\n              throw this.error(new TomlError("Can\'t redefine existing key"));\n            } else {\n              this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table();\n              this.ctx[_declared] = true;\n            }\n            return this.next(this.parseWhitespaceToEOL);\n          } else if (this.char === CHAR_PERIOD) {\n            if (!hasKey(this.ctx, keyword)) {\n              this.ctx = this.ctx[keyword] = Table();\n            } else if (isTable(this.ctx[keyword])) {\n              this.ctx = this.ctx[keyword];\n            } else if (isList(this.ctx[keyword])) {\n              this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];\n            } else {\n              throw this.error(new TomlError("Can\'t redefine existing key"));\n            }\n            return this.next(this.parseTableNext);\n          } else {\n            throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));\n          }\n        }\n        parseList() {\n          this.ctx = this.obj;\n          return this.goto(this.parseListNext);\n        }\n        parseListNext() {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else {\n            return this.callNow(this.parseKeyword, this.parseListMore);\n          }\n        }\n        parseListMore(keyword) {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else if (this.char === CHAR_RSQB) {\n            if (!hasKey(this.ctx, keyword)) {\n              this.ctx[keyword] = List();\n            }\n            if (isInlineList(this.ctx[keyword])) {\n              throw this.error(new TomlError("Can\'t extend an inline array"));\n            } else if (isList(this.ctx[keyword])) {\n              const next = Table();\n              this.ctx[keyword].push(next);\n              this.ctx = next;\n            } else {\n              throw this.error(new TomlError("Can\'t redefine an existing key"));\n            }\n            return this.next(this.parseListEnd);\n          } else if (this.char === CHAR_PERIOD) {\n            if (!hasKey(this.ctx, keyword)) {\n              this.ctx = this.ctx[keyword] = Table();\n            } else if (isInlineList(this.ctx[keyword])) {\n              throw this.error(new TomlError("Can\'t extend an inline array"));\n            } else if (isInlineTable(this.ctx[keyword])) {\n              throw this.error(new TomlError("Can\'t extend an inline table"));\n            } else if (isList(this.ctx[keyword])) {\n              this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];\n            } else if (isTable(this.ctx[keyword])) {\n              this.ctx = this.ctx[keyword];\n            } else {\n              throw this.error(new TomlError("Can\'t redefine an existing key"));\n            }\n            return this.next(this.parseListNext);\n          } else {\n            throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));\n          }\n        }\n        parseListEnd(keyword) {\n          if (this.char === CHAR_RSQB) {\n            return this.next(this.parseWhitespaceToEOL);\n          } else {\n            throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));\n          }\n        }\n        parseValue() {\n          if (this.char === Parser.END) {\n            throw this.error(new TomlError("Key without value"));\n          } else if (this.char === CHAR_QUOT) {\n            return this.next(this.parseDoubleString);\n          }\n          if (this.char === CHAR_APOS) {\n            return this.next(this.parseSingleString);\n          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {\n            return this.goto(this.parseNumberSign);\n          } else if (this.char === CHAR_i) {\n            return this.next(this.parseInf);\n          } else if (this.char === CHAR_n) {\n            return this.next(this.parseNan);\n          } else if (isDigit(this.char)) {\n            return this.goto(this.parseNumberOrDateTime);\n          } else if (this.char === CHAR_t || this.char === CHAR_f) {\n            return this.goto(this.parseBoolean);\n          } else if (this.char === CHAR_LSQB) {\n            return this.call(this.parseInlineList, this.recordValue);\n          } else if (this.char === CHAR_LCUB) {\n            return this.call(this.parseInlineTable, this.recordValue);\n          } else {\n            throw this.error(new TomlError("Unexpected character, expecting string, number, datetime, boolean, inline array or inline table"));\n          }\n        }\n        recordValue(value) {\n          return this.returnNow(value);\n        }\n        parseInf() {\n          if (this.char === CHAR_n) {\n            return this.next(this.parseInf2);\n          } else {\n            throw this.error(new TomlError(\'Unexpected character, expected "inf", "+inf" or "-inf"\'));\n          }\n        }\n        parseInf2() {\n          if (this.char === CHAR_f) {\n            if (this.state.buf === "-") {\n              return this.return(-Infinity);\n            } else {\n              return this.return(Infinity);\n            }\n          } else {\n            throw this.error(new TomlError(\'Unexpected character, expected "inf", "+inf" or "-inf"\'));\n          }\n        }\n        parseNan() {\n          if (this.char === CHAR_a) {\n            return this.next(this.parseNan2);\n          } else {\n            throw this.error(new TomlError(\'Unexpected character, expected "nan"\'));\n          }\n        }\n        parseNan2() {\n          if (this.char === CHAR_n) {\n            return this.return(NaN);\n          } else {\n            throw this.error(new TomlError(\'Unexpected character, expected "nan"\'));\n          }\n        }\n        parseKeyword() {\n          if (this.char === CHAR_QUOT) {\n            return this.next(this.parseBasicString);\n          } else if (this.char === CHAR_APOS) {\n            return this.next(this.parseLiteralString);\n          } else {\n            return this.goto(this.parseBareKey);\n          }\n        }\n        parseBareKey() {\n          do {\n            if (this.char === Parser.END) {\n              throw this.error(new TomlError("Key ended without value"));\n            } else if (isAlphaNumHyphen(this.char)) {\n              this.consume();\n            } else if (this.state.buf.length === 0) {\n              throw this.error(new TomlError("Empty bare keys are not allowed"));\n            } else {\n              return this.returnNow();\n            }\n          } while (this.nextChar());\n        }\n        parseSingleString() {\n          if (this.char === CHAR_APOS) {\n            return this.next(this.parseLiteralMultiStringMaybe);\n          } else {\n            return this.goto(this.parseLiteralString);\n          }\n        }\n        parseLiteralString() {\n          do {\n            if (this.char === CHAR_APOS) {\n              return this.return();\n            } else if (this.atEndOfLine()) {\n              throw this.error(new TomlError("Unterminated string"));\n            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {\n              throw this.errorControlCharInString();\n            } else {\n              this.consume();\n            }\n          } while (this.nextChar());\n        }\n        parseLiteralMultiStringMaybe() {\n          if (this.char === CHAR_APOS) {\n            return this.next(this.parseLiteralMultiString);\n          } else {\n            return this.returnNow();\n          }\n        }\n        parseLiteralMultiString() {\n          if (this.char === CTRL_M) {\n            return null;\n          } else if (this.char === CTRL_J) {\n            return this.next(this.parseLiteralMultiStringContent);\n          } else {\n            return this.goto(this.parseLiteralMultiStringContent);\n          }\n        }\n        parseLiteralMultiStringContent() {\n          do {\n            if (this.char === CHAR_APOS) {\n              return this.next(this.parseLiteralMultiEnd);\n            } else if (this.char === Parser.END) {\n              throw this.error(new TomlError("Unterminated multi-line string"));\n            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {\n              throw this.errorControlCharInString();\n            } else {\n              this.consume();\n            }\n          } while (this.nextChar());\n        }\n        parseLiteralMultiEnd() {\n          if (this.char === CHAR_APOS) {\n            return this.next(this.parseLiteralMultiEnd2);\n          } else {\n            this.state.buf += "\'";\n            return this.goto(this.parseLiteralMultiStringContent);\n          }\n        }\n        parseLiteralMultiEnd2() {\n          if (this.char === CHAR_APOS) {\n            return this.return();\n          } else {\n            this.state.buf += "\'\'";\n            return this.goto(this.parseLiteralMultiStringContent);\n          }\n        }\n        parseDoubleString() {\n          if (this.char === CHAR_QUOT) {\n            return this.next(this.parseMultiStringMaybe);\n          } else {\n            return this.goto(this.parseBasicString);\n          }\n        }\n        parseBasicString() {\n          do {\n            if (this.char === CHAR_BSOL) {\n              return this.call(this.parseEscape, this.recordEscapeReplacement);\n            } else if (this.char === CHAR_QUOT) {\n              return this.return();\n            } else if (this.atEndOfLine()) {\n              throw this.error(new TomlError("Unterminated string"));\n            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {\n              throw this.errorControlCharInString();\n            } else {\n              this.consume();\n            }\n          } while (this.nextChar());\n        }\n        recordEscapeReplacement(replacement) {\n          this.state.buf += replacement;\n          return this.goto(this.parseBasicString);\n        }\n        parseMultiStringMaybe() {\n          if (this.char === CHAR_QUOT) {\n            return this.next(this.parseMultiString);\n          } else {\n            return this.returnNow();\n          }\n        }\n        parseMultiString() {\n          if (this.char === CTRL_M) {\n            return null;\n          } else if (this.char === CTRL_J) {\n            return this.next(this.parseMultiStringContent);\n          } else {\n            return this.goto(this.parseMultiStringContent);\n          }\n        }\n        parseMultiStringContent() {\n          do {\n            if (this.char === CHAR_BSOL) {\n              return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);\n            } else if (this.char === CHAR_QUOT) {\n              return this.next(this.parseMultiEnd);\n            } else if (this.char === Parser.END) {\n              throw this.error(new TomlError("Unterminated multi-line string"));\n            } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {\n              throw this.errorControlCharInString();\n            } else {\n              this.consume();\n            }\n          } while (this.nextChar());\n        }\n        errorControlCharInString() {\n          let displayCode = "\\\\u00";\n          if (this.char < 16) {\n            displayCode += "0";\n          }\n          displayCode += this.char.toString(16);\n          return this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));\n        }\n        recordMultiEscapeReplacement(replacement) {\n          this.state.buf += replacement;\n          return this.goto(this.parseMultiStringContent);\n        }\n        parseMultiEnd() {\n          if (this.char === CHAR_QUOT) {\n            return this.next(this.parseMultiEnd2);\n          } else {\n            this.state.buf += \'"\';\n            return this.goto(this.parseMultiStringContent);\n          }\n        }\n        parseMultiEnd2() {\n          if (this.char === CHAR_QUOT) {\n            return this.return();\n          } else {\n            this.state.buf += \'""\';\n            return this.goto(this.parseMultiStringContent);\n          }\n        }\n        parseMultiEscape() {\n          if (this.char === CTRL_M || this.char === CTRL_J) {\n            return this.next(this.parseMultiTrim);\n          } else if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return this.next(this.parsePreMultiTrim);\n          } else {\n            return this.goto(this.parseEscape);\n          }\n        }\n        parsePreMultiTrim() {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else if (this.char === CTRL_M || this.char === CTRL_J) {\n            return this.next(this.parseMultiTrim);\n          } else {\n            throw this.error(new TomlError("Can\'t escape whitespace"));\n          }\n        }\n        parseMultiTrim() {\n          if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {\n            return null;\n          } else {\n            return this.returnNow();\n          }\n        }\n        parseEscape() {\n          if (this.char in escapes) {\n            return this.return(escapes[this.char]);\n          } else if (this.char === CHAR_u) {\n            return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);\n          } else if (this.char === CHAR_U) {\n            return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);\n          } else {\n            throw this.error(new TomlError("Unknown escape character: " + this.char));\n          }\n        }\n        parseUnicodeReturn(char) {\n          try {\n            const codePoint = parseInt(char, 16);\n            if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST) {\n              throw this.error(new TomlError("Invalid unicode, character in range 0xD800 - 0xDFFF is reserved"));\n            }\n            return this.returnNow(String.fromCodePoint(codePoint));\n          } catch (err) {\n            throw this.error(TomlError.wrap(err));\n          }\n        }\n        parseSmallUnicode() {\n          if (!isHexit(this.char)) {\n            throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));\n          } else {\n            this.consume();\n            if (this.state.buf.length >= 4)\n              return this.return();\n          }\n        }\n        parseLargeUnicode() {\n          if (!isHexit(this.char)) {\n            throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));\n          } else {\n            this.consume();\n            if (this.state.buf.length >= 8)\n              return this.return();\n          }\n        }\n        parseNumberSign() {\n          this.consume();\n          return this.next(this.parseMaybeSignedInfOrNan);\n        }\n        parseMaybeSignedInfOrNan() {\n          if (this.char === CHAR_i) {\n            return this.next(this.parseInf);\n          } else if (this.char === CHAR_n) {\n            return this.next(this.parseNan);\n          } else {\n            return this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);\n          }\n        }\n        parseNumberIntegerStart() {\n          if (this.char === CHAR_0) {\n            this.consume();\n            return this.next(this.parseNumberIntegerExponentOrDecimal);\n          } else {\n            return this.goto(this.parseNumberInteger);\n          }\n        }\n        parseNumberIntegerExponentOrDecimal() {\n          if (this.char === CHAR_PERIOD) {\n            this.consume();\n            return this.call(this.parseNoUnder, this.parseNumberFloat);\n          } else if (this.char === CHAR_E || this.char === CHAR_e) {\n            this.consume();\n            return this.next(this.parseNumberExponentSign);\n          } else {\n            return this.returnNow(Integer(this.state.buf));\n          }\n        }\n        parseNumberInteger() {\n          if (isDigit(this.char)) {\n            this.consume();\n          } else if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnder);\n          } else if (this.char === CHAR_E || this.char === CHAR_e) {\n            this.consume();\n            return this.next(this.parseNumberExponentSign);\n          } else if (this.char === CHAR_PERIOD) {\n            this.consume();\n            return this.call(this.parseNoUnder, this.parseNumberFloat);\n          } else {\n            const result = Integer(this.state.buf);\n            if (result.isNaN()) {\n              throw this.error(new TomlError("Invalid number"));\n            } else {\n              return this.returnNow(result);\n            }\n          }\n        }\n        parseNoUnder() {\n          if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e) {\n            throw this.error(new TomlError("Unexpected character, expected digit"));\n          } else if (this.atEndOfWord()) {\n            throw this.error(new TomlError("Incomplete number"));\n          }\n          return this.returnNow();\n        }\n        parseNoUnderHexOctBinLiteral() {\n          if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD) {\n            throw this.error(new TomlError("Unexpected character, expected digit"));\n          } else if (this.atEndOfWord()) {\n            throw this.error(new TomlError("Incomplete number"));\n          }\n          return this.returnNow();\n        }\n        parseNumberFloat() {\n          if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnder, this.parseNumberFloat);\n          } else if (isDigit(this.char)) {\n            this.consume();\n          } else if (this.char === CHAR_E || this.char === CHAR_e) {\n            this.consume();\n            return this.next(this.parseNumberExponentSign);\n          } else {\n            return this.returnNow(Float(this.state.buf));\n          }\n        }\n        parseNumberExponentSign() {\n          if (isDigit(this.char)) {\n            return this.goto(this.parseNumberExponent);\n          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {\n            this.consume();\n            this.call(this.parseNoUnder, this.parseNumberExponent);\n          } else {\n            throw this.error(new TomlError("Unexpected character, expected -, + or digit"));\n          }\n        }\n        parseNumberExponent() {\n          if (isDigit(this.char)) {\n            this.consume();\n          } else if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnder);\n          } else {\n            return this.returnNow(Float(this.state.buf));\n          }\n        }\n        parseNumberOrDateTime() {\n          if (this.char === CHAR_0) {\n            this.consume();\n            return this.next(this.parseNumberBaseOrDateTime);\n          } else {\n            return this.goto(this.parseNumberOrDateTimeOnly);\n          }\n        }\n        parseNumberOrDateTimeOnly() {\n          if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnder, this.parseNumberInteger);\n          } else if (isDigit(this.char)) {\n            this.consume();\n            if (this.state.buf.length > 4)\n              this.next(this.parseNumberInteger);\n          } else if (this.char === CHAR_E || this.char === CHAR_e) {\n            this.consume();\n            return this.next(this.parseNumberExponentSign);\n          } else if (this.char === CHAR_PERIOD) {\n            this.consume();\n            return this.call(this.parseNoUnder, this.parseNumberFloat);\n          } else if (this.char === CHAR_HYPHEN) {\n            return this.goto(this.parseDateTime);\n          } else if (this.char === CHAR_COLON) {\n            return this.goto(this.parseOnlyTimeHour);\n          } else {\n            return this.returnNow(Integer(this.state.buf));\n          }\n        }\n        parseDateTimeOnly() {\n          if (this.state.buf.length < 4) {\n            if (isDigit(this.char)) {\n              return this.consume();\n            } else if (this.char === CHAR_COLON) {\n              return this.goto(this.parseOnlyTimeHour);\n            } else {\n              throw this.error(new TomlError("Expected digit while parsing year part of a date"));\n            }\n          } else {\n            if (this.char === CHAR_HYPHEN) {\n              return this.goto(this.parseDateTime);\n            } else {\n              throw this.error(new TomlError("Expected hyphen (-) while parsing year part of date"));\n            }\n          }\n        }\n        parseNumberBaseOrDateTime() {\n          if (this.char === CHAR_b) {\n            this.consume();\n            return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerBin);\n          } else if (this.char === CHAR_o) {\n            this.consume();\n            return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerOct);\n          } else if (this.char === CHAR_x) {\n            this.consume();\n            return this.call(this.parseNoUnderHexOctBinLiteral, this.parseIntegerHex);\n          } else if (this.char === CHAR_PERIOD) {\n            return this.goto(this.parseNumberInteger);\n          } else if (isDigit(this.char)) {\n            return this.goto(this.parseDateTimeOnly);\n          } else {\n            return this.returnNow(Integer(this.state.buf));\n          }\n        }\n        parseIntegerHex() {\n          if (isHexit(this.char)) {\n            this.consume();\n          } else if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnderHexOctBinLiteral);\n          } else {\n            const result = Integer(this.state.buf);\n            if (result.isNaN()) {\n              throw this.error(new TomlError("Invalid number"));\n            } else {\n              return this.returnNow(result);\n            }\n          }\n        }\n        parseIntegerOct() {\n          if (isOctit(this.char)) {\n            this.consume();\n          } else if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnderHexOctBinLiteral);\n          } else {\n            const result = Integer(this.state.buf);\n            if (result.isNaN()) {\n              throw this.error(new TomlError("Invalid number"));\n            } else {\n              return this.returnNow(result);\n            }\n          }\n        }\n        parseIntegerBin() {\n          if (isBit(this.char)) {\n            this.consume();\n          } else if (this.char === CHAR_LOWBAR) {\n            return this.call(this.parseNoUnderHexOctBinLiteral);\n          } else {\n            const result = Integer(this.state.buf);\n            if (result.isNaN()) {\n              throw this.error(new TomlError("Invalid number"));\n            } else {\n              return this.returnNow(result);\n            }\n          }\n        }\n        parseDateTime() {\n          if (this.state.buf.length < 4) {\n            throw this.error(new TomlError("Years less than 1000 must be zero padded to four characters"));\n          }\n          this.state.result = this.state.buf;\n          this.state.buf = "";\n          return this.next(this.parseDateMonth);\n        }\n        parseDateMonth() {\n          if (this.char === CHAR_HYPHEN) {\n            if (this.state.buf.length < 2) {\n              throw this.error(new TomlError("Months less than 10 must be zero padded to two characters"));\n            }\n            this.state.result += "-" + this.state.buf;\n            this.state.buf = "";\n            return this.next(this.parseDateDay);\n          } else if (isDigit(this.char)) {\n            this.consume();\n          } else {\n            throw this.error(new TomlError("Incomplete datetime"));\n          }\n        }\n        parseDateDay() {\n          if (this.char === CHAR_T || this.char === CHAR_SP) {\n            if (this.state.buf.length < 2) {\n              throw this.error(new TomlError("Days less than 10 must be zero padded to two characters"));\n            }\n            this.state.result += "-" + this.state.buf;\n            this.state.buf = "";\n            return this.next(this.parseStartTimeHour);\n          } else if (this.atEndOfWord()) {\n            return this.returnNow(createDate(this.state.result + "-" + this.state.buf));\n          } else if (isDigit(this.char)) {\n            this.consume();\n          } else {\n            throw this.error(new TomlError("Incomplete datetime"));\n          }\n        }\n        parseStartTimeHour() {\n          if (this.atEndOfWord()) {\n            return this.returnNow(createDate(this.state.result));\n          } else {\n            return this.goto(this.parseTimeHour);\n          }\n        }\n        parseTimeHour() {\n          if (this.char === CHAR_COLON) {\n            if (this.state.buf.length < 2) {\n              throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));\n            }\n            this.state.result += "T" + this.state.buf;\n            this.state.buf = "";\n            return this.next(this.parseTimeMin);\n          } else if (isDigit(this.char)) {\n            this.consume();\n          } else {\n            throw this.error(new TomlError("Incomplete datetime"));\n          }\n        }\n        parseTimeMin() {\n          if (this.state.buf.length < 2 && isDigit(this.char)) {\n            this.consume();\n          } else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {\n            this.state.result += ":" + this.state.buf;\n            this.state.buf = "";\n            return this.next(this.parseTimeSec);\n          } else {\n            throw this.error(new TomlError("Incomplete datetime"));\n          }\n        }\n        parseTimeSec() {\n          if (isDigit(this.char)) {\n            this.consume();\n            if (this.state.buf.length === 2) {\n              this.state.result += ":" + this.state.buf;\n              this.state.buf = "";\n              return this.next(this.parseTimeZoneOrFraction);\n            }\n          } else {\n            throw this.error(new TomlError("Incomplete datetime"));\n          }\n        }\n        parseOnlyTimeHour() {\n          if (this.char === CHAR_COLON) {\n            if (this.state.buf.length < 2) {\n              throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));\n            }\n            this.state.result = this.state.buf;\n            this.state.buf = "";\n            return this.next(this.parseOnlyTimeMin);\n          } else {\n            throw this.error(new TomlError("Incomplete time"));\n          }\n        }\n        parseOnlyTimeMin() {\n          if (this.state.buf.length < 2 && isDigit(this.char)) {\n            this.consume();\n          } else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {\n            this.state.result += ":" + this.state.buf;\n            this.state.buf = "";\n            return this.next(this.parseOnlyTimeSec);\n          } else {\n            throw this.error(new TomlError("Incomplete time"));\n          }\n        }\n        parseOnlyTimeSec() {\n          if (isDigit(this.char)) {\n            this.consume();\n            if (this.state.buf.length === 2) {\n              return this.next(this.parseOnlyTimeFractionMaybe);\n            }\n          } else {\n            throw this.error(new TomlError("Incomplete time"));\n          }\n        }\n        parseOnlyTimeFractionMaybe() {\n          this.state.result += ":" + this.state.buf;\n          if (this.char === CHAR_PERIOD) {\n            this.state.buf = "";\n            this.next(this.parseOnlyTimeFraction);\n          } else {\n            return this.return(createTime(this.state.result));\n          }\n        }\n        parseOnlyTimeFraction() {\n          if (isDigit(this.char)) {\n            this.consume();\n          } else if (this.atEndOfWord()) {\n            if (this.state.buf.length === 0)\n              throw this.error(new TomlError("Expected digit in milliseconds"));\n            return this.returnNow(createTime(this.state.result + "." + this.state.buf));\n          } else {\n            throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));\n          }\n        }\n        parseTimeZoneOrFraction() {\n          if (this.char === CHAR_PERIOD) {\n            this.consume();\n            this.next(this.parseDateTimeFraction);\n          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {\n            this.consume();\n            this.next(this.parseTimeZoneHour);\n          } else if (this.char === CHAR_Z) {\n            this.consume();\n            return this.return(createDateTime(this.state.result + this.state.buf));\n          } else if (this.atEndOfWord()) {\n            return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));\n          } else {\n            throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));\n          }\n        }\n        parseDateTimeFraction() {\n          if (isDigit(this.char)) {\n            this.consume();\n          } else if (this.state.buf.length === 1) {\n            throw this.error(new TomlError("Expected digit in milliseconds"));\n          } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {\n            this.consume();\n            this.next(this.parseTimeZoneHour);\n          } else if (this.char === CHAR_Z) {\n            this.consume();\n            return this.return(createDateTime(this.state.result + this.state.buf));\n          } else if (this.atEndOfWord()) {\n            return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));\n          } else {\n            throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));\n          }\n        }\n        parseTimeZoneHour() {\n          if (isDigit(this.char)) {\n            this.consume();\n            if (/\\d\\d$/.test(this.state.buf))\n              return this.next(this.parseTimeZoneSep);\n          } else {\n            throw this.error(new TomlError("Unexpected character in datetime, expected digit"));\n          }\n        }\n        parseTimeZoneSep() {\n          if (this.char === CHAR_COLON) {\n            this.consume();\n            this.next(this.parseTimeZoneMin);\n          } else {\n            throw this.error(new TomlError("Unexpected character in datetime, expected colon"));\n          }\n        }\n        parseTimeZoneMin() {\n          if (isDigit(this.char)) {\n            this.consume();\n            if (/\\d\\d$/.test(this.state.buf))\n              return this.return(createDateTime(this.state.result + this.state.buf));\n          } else {\n            throw this.error(new TomlError("Unexpected character in datetime, expected digit"));\n          }\n        }\n        parseBoolean() {\n          if (this.char === CHAR_t) {\n            this.consume();\n            return this.next(this.parseTrue_r);\n          } else if (this.char === CHAR_f) {\n            this.consume();\n            return this.next(this.parseFalse_a);\n          }\n        }\n        parseTrue_r() {\n          if (this.char === CHAR_r) {\n            this.consume();\n            return this.next(this.parseTrue_u);\n          } else {\n            throw this.error(new TomlError("Invalid boolean, expected true or false"));\n          }\n        }\n        parseTrue_u() {\n          if (this.char === CHAR_u) {\n            this.consume();\n            return this.next(this.parseTrue_e);\n          } else {\n            throw this.error(new TomlError("Invalid boolean, expected true or false"));\n          }\n        }\n        parseTrue_e() {\n          if (this.char === CHAR_e) {\n            return this.return(true);\n          } else {\n            throw this.error(new TomlError("Invalid boolean, expected true or false"));\n          }\n        }\n        parseFalse_a() {\n          if (this.char === CHAR_a) {\n            this.consume();\n            return this.next(this.parseFalse_l);\n          } else {\n            throw this.error(new TomlError("Invalid boolean, expected true or false"));\n          }\n        }\n        parseFalse_l() {\n          if (this.char === CHAR_l) {\n            this.consume();\n            return this.next(this.parseFalse_s);\n          } else {\n            throw this.error(new TomlError("Invalid boolean, expected true or false"));\n          }\n        }\n        parseFalse_s() {\n          if (this.char === CHAR_s) {\n            this.consume();\n            return this.next(this.parseFalse_e);\n          } else {\n            throw this.error(new TomlError("Invalid boolean, expected true or false"));\n          }\n        }\n        parseFalse_e() {\n          if (this.char === CHAR_e) {\n            return this.return(false);\n          } else {\n            throw this.error(new TomlError("Invalid boolean, expected true or false"));\n          }\n        }\n        parseInlineList() {\n          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {\n            return null;\n          } else if (this.char === Parser.END) {\n            throw this.error(new TomlError("Unterminated inline array"));\n          } else if (this.char === CHAR_NUM) {\n            return this.call(this.parseComment);\n          } else if (this.char === CHAR_RSQB) {\n            return this.return(this.state.resultArr || InlineList());\n          } else {\n            return this.callNow(this.parseValue, this.recordInlineListValue);\n          }\n        }\n        recordInlineListValue(value) {\n          if (this.state.resultArr) {\n            const listType = this.state.resultArr[_contentType];\n            const valueType = tomlType(value);\n            if (listType !== valueType) {\n              throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));\n            }\n          } else {\n            this.state.resultArr = InlineList(tomlType(value));\n          }\n          if (isFloat(value) || isInteger(value)) {\n            this.state.resultArr.push(value.valueOf());\n          } else {\n            this.state.resultArr.push(value);\n          }\n          return this.goto(this.parseInlineListNext);\n        }\n        parseInlineListNext() {\n          if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {\n            return null;\n          } else if (this.char === CHAR_NUM) {\n            return this.call(this.parseComment);\n          } else if (this.char === CHAR_COMMA) {\n            return this.next(this.parseInlineList);\n          } else if (this.char === CHAR_RSQB) {\n            return this.goto(this.parseInlineList);\n          } else {\n            throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));\n          }\n        }\n        parseInlineTable() {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {\n            throw this.error(new TomlError("Unterminated inline array"));\n          } else if (this.char === CHAR_RCUB) {\n            return this.return(this.state.resultTable || InlineTable());\n          } else {\n            if (!this.state.resultTable)\n              this.state.resultTable = InlineTable();\n            return this.callNow(this.parseAssign, this.recordInlineTableValue);\n          }\n        }\n        recordInlineTableValue(kv) {\n          let target = this.state.resultTable;\n          let finalKey = kv.key.pop();\n          for (let kw of kv.key) {\n            if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {\n              throw this.error(new TomlError("Can\'t redefine existing key"));\n            }\n            target = target[kw] = target[kw] || Table();\n          }\n          if (hasKey(target, finalKey)) {\n            throw this.error(new TomlError("Can\'t redefine existing key"));\n          }\n          if (isInteger(kv.value) || isFloat(kv.value)) {\n            target[finalKey] = kv.value.valueOf();\n          } else {\n            target[finalKey] = kv.value;\n          }\n          return this.goto(this.parseInlineTableNext);\n        }\n        parseInlineTableNext() {\n          if (this.char === CHAR_SP || this.char === CTRL_I) {\n            return null;\n          } else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {\n            throw this.error(new TomlError("Unterminated inline array"));\n          } else if (this.char === CHAR_COMMA) {\n            return this.next(this.parseInlineTable);\n          } else if (this.char === CHAR_RCUB) {\n            return this.goto(this.parseInlineTable);\n          } else {\n            throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));\n          }\n        }\n      }\n      return TOMLParser;\n    }\n  }\n});\nvar require_parse_pretty_error = __commonJS2({\n  "node_modules/@iarna/toml/parse-pretty-error.js"(exports2, module2) {\n    "use strict";\n    module2.exports = prettyError;\n    function prettyError(err, buf) {\n      if (err.pos == null || err.line == null)\n        return err;\n      let msg = err.message;\n      msg += ` at row ${err.line + 1}, col ${err.col + 1}, pos ${err.pos}:\n`;\n      if (buf && buf.split) {\n        const lines = buf.split(/\\n/);\n        const lineNumWidth = String(Math.min(lines.length, err.line + 3)).length;\n        let linePadding = " ";\n        while (linePadding.length < lineNumWidth)\n          linePadding += " ";\n        for (let ii = Math.max(0, err.line - 1); ii < Math.min(lines.length, err.line + 2); ++ii) {\n          let lineNum = String(ii + 1);\n          if (lineNum.length < lineNumWidth)\n            lineNum = " " + lineNum;\n          if (err.line === ii) {\n            msg += lineNum + "> " + lines[ii] + "\\n";\n            msg += linePadding + "  ";\n            for (let hh = 0; hh < err.col; ++hh) {\n              msg += " ";\n            }\n            msg += "^\\n";\n          } else {\n            msg += lineNum + ": " + lines[ii] + "\\n";\n          }\n        }\n      }\n      err.message = msg + "\\n";\n      return err;\n    }\n  }\n});\nvar require_parse_string = __commonJS2({\n  "node_modules/@iarna/toml/parse-string.js"(exports2, module2) {\n    "use strict";\n    module2.exports = parseString;\n    var TOMLParser = require_toml_parser();\n    var prettyError = require_parse_pretty_error();\n    function parseString(str) {\n      if (global.Buffer && global.Buffer.isBuffer(str)) {\n        str = str.toString("utf8");\n      }\n      const parser = new TOMLParser();\n      try {\n        parser.parse(str);\n        return parser.finish();\n      } catch (err) {\n        throw prettyError(err, str);\n      }\n    }\n  }\n});\nvar require_load_toml = __commonJS2({\n  "src/utils/load-toml.js"(exports2, module2) {\n    "use strict";\n    var parse = require_parse_string();\n    module2.exports = function(filePath, content) {\n      try {\n        return parse(content);\n      } catch (error) {\n        error.message = `TOML Error in ${filePath}:\n${error.message}`;\n        throw error;\n      }\n    };\n  }\n});\nvar require_unicode = __commonJS2({\n  "node_modules/json5/lib/unicode.js"(exports2, module2) {\n    module2.exports.Space_Separator = /[\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/;\n    module2.exports.ID_Start = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE83\\uDE86-\\uDE89\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]/;\n    module2.exports.ID_Continue = /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF9\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312E\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE83\\uDE86-\\uDE99\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0\\uDFE1]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00-\\uDD1E\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/;\n  }\n});\nvar require_util2 = __commonJS2({\n  "node_modules/json5/lib/util.js"(exports2, module2) {\n    var unicode = require_unicode();\n    module2.exports = {\n      isSpaceSeparator(c) {\n        return typeof c === "string" && unicode.Space_Separator.test(c);\n      },\n      isIdStartChar(c) {\n        return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "$" || c === "_" || unicode.ID_Start.test(c));\n      },\n      isIdContinueChar(c) {\n        return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "$" || c === "_" || c === "\\u200C" || c === "\\u200D" || unicode.ID_Continue.test(c));\n      },\n      isDigit(c) {\n        return typeof c === "string" && /[0-9]/.test(c);\n      },\n      isHexDigit(c) {\n        return typeof c === "string" && /[0-9A-Fa-f]/.test(c);\n      }\n    };\n  }\n});\nvar require_parse3 = __commonJS2({\n  "node_modules/json5/lib/parse.js"(exports2, module2) {\n    var util = require_util2();\n    var source;\n    var parseState;\n    var stack;\n    var pos;\n    var line;\n    var column;\n    var token;\n    var key;\n    var root;\n    module2.exports = function parse(text, reviver) {\n      source = String(text);\n      parseState = "start";\n      stack = [];\n      pos = 0;\n      line = 1;\n      column = 0;\n      token = void 0;\n      key = void 0;\n      root = void 0;\n      do {\n        token = lex();\n        parseStates[parseState]();\n      } while (token.type !== "eof");\n      if (typeof reviver === "function") {\n        return internalize({\n          "": root\n        }, "", reviver);\n      }\n      return root;\n    };\n    function internalize(holder, name, reviver) {\n      const value = holder[name];\n      if (value != null && typeof value === "object") {\n        if (Array.isArray(value)) {\n          for (let i = 0; i < value.length; i++) {\n            const key2 = String(i);\n            const replacement = internalize(value, key2, reviver);\n            if (replacement === void 0) {\n              delete value[key2];\n            } else {\n              Object.defineProperty(value, key2, {\n                value: replacement,\n                writable: true,\n                enumerable: true,\n                configurable: true\n              });\n            }\n          }\n        } else {\n          for (const key2 in value) {\n            const replacement = internalize(value, key2, reviver);\n            if (replacement === void 0) {\n              delete value[key2];\n            } else {\n              Object.defineProperty(value, key2, {\n                value: replacement,\n                writable: true,\n                enumerable: true,\n                configurable: true\n              });\n            }\n          }\n        }\n      }\n      return reviver.call(holder, name, value);\n    }\n    var lexState;\n    var buffer;\n    var doubleQuote;\n    var sign;\n    var c;\n    function lex() {\n      lexState = "default";\n      buffer = "";\n      doubleQuote = false;\n      sign = 1;\n      for (; ; ) {\n        c = peek();\n        const token2 = lexStates[lexState]();\n        if (token2) {\n          return token2;\n        }\n      }\n    }\n    function peek() {\n      if (source[pos]) {\n        return String.fromCodePoint(source.codePointAt(pos));\n      }\n    }\n    function read() {\n      const c2 = peek();\n      if (c2 === "\\n") {\n        line++;\n        column = 0;\n      } else if (c2) {\n        column += c2.length;\n      } else {\n        column++;\n      }\n      if (c2) {\n        pos += c2.length;\n      }\n      return c2;\n    }\n    var lexStates = {\n      default() {\n        switch (c) {\n          case "\t":\n          case "\\v":\n          case "\\f":\n          case " ":\n          case "\\xA0":\n          case "\\uFEFF":\n          case "\\n":\n          case "\\r":\n          case "\\u2028":\n          case "\\u2029":\n            read();\n            return;\n          case "/":\n            read();\n            lexState = "comment";\n            return;\n          case void 0:\n            read();\n            return newToken("eof");\n        }\n        if (util.isSpaceSeparator(c)) {\n          read();\n          return;\n        }\n        return lexStates[parseState]();\n      },\n      comment() {\n        switch (c) {\n          case "*":\n            read();\n            lexState = "multiLineComment";\n            return;\n          case "/":\n            read();\n            lexState = "singleLineComment";\n            return;\n        }\n        throw invalidChar(read());\n      },\n      multiLineComment() {\n        switch (c) {\n          case "*":\n            read();\n            lexState = "multiLineCommentAsterisk";\n            return;\n          case void 0:\n            throw invalidChar(read());\n        }\n        read();\n      },\n      multiLineCommentAsterisk() {\n        switch (c) {\n          case "*":\n            read();\n            return;\n          case "/":\n            read();\n            lexState = "default";\n            return;\n          case void 0:\n            throw invalidChar(read());\n        }\n        read();\n        lexState = "multiLineComment";\n      },\n      singleLineComment() {\n        switch (c) {\n          case "\\n":\n          case "\\r":\n          case "\\u2028":\n          case "\\u2029":\n            read();\n            lexState = "default";\n            return;\n          case void 0:\n            read();\n            return newToken("eof");\n        }\n        read();\n      },\n      value() {\n        switch (c) {\n          case "{":\n          case "[":\n            return newToken("punctuator", read());\n          case "n":\n            read();\n            literal("ull");\n            return newToken("null", null);\n          case "t":\n            read();\n            literal("rue");\n            return newToken("boolean", true);\n          case "f":\n            read();\n            literal("alse");\n            return newToken("boolean", false);\n          case "-":\n          case "+":\n            if (read() === "-") {\n              sign = -1;\n            }\n            lexState = "sign";\n            return;\n          case ".":\n            buffer = read();\n            lexState = "decimalPointLeading";\n            return;\n          case "0":\n            buffer = read();\n            lexState = "zero";\n            return;\n          case "1":\n          case "2":\n          case "3":\n          case "4":\n          case "5":\n          case "6":\n          case "7":\n          case "8":\n          case "9":\n            buffer = read();\n            lexState = "decimalInteger";\n            return;\n          case "I":\n            read();\n            literal("nfinity");\n            return newToken("numeric", Infinity);\n          case "N":\n            read();\n            literal("aN");\n            return newToken("numeric", NaN);\n          case \'"\':\n          case "\'":\n            doubleQuote = read() === \'"\';\n            buffer = "";\n            lexState = "string";\n            return;\n        }\n        throw invalidChar(read());\n      },\n      identifierNameStartEscape() {\n        if (c !== "u") {\n          throw invalidChar(read());\n        }\n        read();\n        const u = unicodeEscape();\n        switch (u) {\n          case "$":\n          case "_":\n            break;\n          default:\n            if (!util.isIdStartChar(u)) {\n              throw invalidIdentifier();\n            }\n            break;\n        }\n        buffer += u;\n        lexState = "identifierName";\n      },\n      identifierName() {\n        switch (c) {\n          case "$":\n          case "_":\n          case "\\u200C":\n          case "\\u200D":\n            buffer += read();\n            return;\n          case "\\\\":\n            read();\n            lexState = "identifierNameEscape";\n            return;\n        }\n        if (util.isIdContinueChar(c)) {\n          buffer += read();\n          return;\n        }\n        return newToken("identifier", buffer);\n      },\n      identifierNameEscape() {\n        if (c !== "u") {\n          throw invalidChar(read());\n        }\n        read();\n        const u = unicodeEscape();\n        switch (u) {\n          case "$":\n          case "_":\n          case "\\u200C":\n          case "\\u200D":\n            break;\n          default:\n            if (!util.isIdContinueChar(u)) {\n              throw invalidIdentifier();\n            }\n            break;\n        }\n        buffer += u;\n        lexState = "identifierName";\n      },\n      sign() {\n        switch (c) {\n          case ".":\n            buffer = read();\n            lexState = "decimalPointLeading";\n            return;\n          case "0":\n            buffer = read();\n            lexState = "zero";\n            return;\n          case "1":\n          case "2":\n          case "3":\n          case "4":\n          case "5":\n          case "6":\n          case "7":\n          case "8":\n          case "9":\n            buffer = read();\n            lexState = "decimalInteger";\n            return;\n          case "I":\n            read();\n            literal("nfinity");\n            return newToken("numeric", sign * Infinity);\n          case "N":\n            read();\n            literal("aN");\n            return newToken("numeric", NaN);\n        }\n        throw invalidChar(read());\n      },\n      zero() {\n        switch (c) {\n          case ".":\n            buffer += read();\n            lexState = "decimalPoint";\n            return;\n          case "e":\n          case "E":\n            buffer += read();\n            lexState = "decimalExponent";\n            return;\n          case "x":\n          case "X":\n            buffer += read();\n            lexState = "hexadecimal";\n            return;\n        }\n        return newToken("numeric", sign * 0);\n      },\n      decimalInteger() {\n        switch (c) {\n          case ".":\n            buffer += read();\n            lexState = "decimalPoint";\n            return;\n          case "e":\n          case "E":\n            buffer += read();\n            lexState = "decimalExponent";\n            return;\n        }\n        if (util.isDigit(c)) {\n          buffer += read();\n          return;\n        }\n        return newToken("numeric", sign * Number(buffer));\n      },\n      decimalPointLeading() {\n        if (util.isDigit(c)) {\n          buffer += read();\n          lexState = "decimalFraction";\n          return;\n        }\n        throw invalidChar(read());\n      },\n      decimalPoint() {\n        switch (c) {\n          case "e":\n          case "E":\n            buffer += read();\n            lexState = "decimalExponent";\n            return;\n        }\n        if (util.isDigit(c)) {\n          buffer += read();\n          lexState = "decimalFraction";\n          return;\n        }\n        return newToken("numeric", sign * Number(buffer));\n      },\n      decimalFraction() {\n        switch (c) {\n          case "e":\n          case "E":\n            buffer += read();\n            lexState = "decimalExponent";\n            return;\n        }\n        if (util.isDigit(c)) {\n          buffer += read();\n          return;\n        }\n        return newToken("numeric", sign * Number(buffer));\n      },\n      decimalExponent() {\n        switch (c) {\n          case "+":\n          case "-":\n            buffer += read();\n            lexState = "decimalExponentSign";\n            return;\n        }\n        if (util.isDigit(c)) {\n          buffer += read();\n          lexState = "decimalExponentInteger";\n          return;\n        }\n        throw invalidChar(read());\n      },\n      decimalExponentSign() {\n        if (util.isDigit(c)) {\n          buffer += read();\n          lexState = "decimalExponentInteger";\n          return;\n        }\n        throw invalidChar(read());\n      },\n      decimalExponentInteger() {\n        if (util.isDigit(c)) {\n          buffer += read();\n          return;\n        }\n        return newToken("numeric", sign * Number(buffer));\n      },\n      hexadecimal() {\n        if (util.isHexDigit(c)) {\n          buffer += read();\n          lexState = "hexadecimalInteger";\n          return;\n        }\n        throw invalidChar(read());\n      },\n      hexadecimalInteger() {\n        if (util.isHexDigit(c)) {\n          buffer += read();\n          return;\n        }\n        return newToken("numeric", sign * Number(buffer));\n      },\n      string() {\n        switch (c) {\n          case "\\\\":\n            read();\n            buffer += escape();\n            return;\n          case \'"\':\n            if (doubleQuote) {\n              read();\n              return newToken("string", buffer);\n            }\n            buffer += read();\n            return;\n          case "\'":\n            if (!doubleQuote) {\n              read();\n              return newToken("string", buffer);\n            }\n            buffer += read();\n            return;\n          case "\\n":\n          case "\\r":\n            throw invalidChar(read());\n          case "\\u2028":\n          case "\\u2029":\n            separatorChar(c);\n            break;\n          case void 0:\n            throw invalidChar(read());\n        }\n        buffer += read();\n      },\n      start() {\n        switch (c) {\n          case "{":\n          case "[":\n            return newToken("punctuator", read());\n        }\n        lexState = "value";\n      },\n      beforePropertyName() {\n        switch (c) {\n          case "$":\n          case "_":\n            buffer = read();\n            lexState = "identifierName";\n            return;\n          case "\\\\":\n            read();\n            lexState = "identifierNameStartEscape";\n            return;\n          case "}":\n            return newToken("punctuator", read());\n          case \'"\':\n          case "\'":\n            doubleQuote = read() === \'"\';\n            lexState = "string";\n            return;\n        }\n        if (util.isIdStartChar(c)) {\n          buffer += read();\n          lexState = "identifierName";\n          return;\n        }\n        throw invalidChar(read());\n      },\n      afterPropertyName() {\n        if (c === ":") {\n          return newToken("punctuator", read());\n        }\n        throw invalidChar(read());\n      },\n      beforePropertyValue() {\n        lexState = "value";\n      },\n      afterPropertyValue() {\n        switch (c) {\n          case ",":\n          case "}":\n            return newToken("punctuator", read());\n        }\n        throw invalidChar(read());\n      },\n      beforeArrayValue() {\n        if (c === "]") {\n          return newToken("punctuator", read());\n        }\n        lexState = "value";\n      },\n      afterArrayValue() {\n        switch (c) {\n          case ",":\n          case "]":\n            return newToken("punctuator", read());\n        }\n        throw invalidChar(read());\n      },\n      end() {\n        throw invalidChar(read());\n      }\n    };\n    function newToken(type, value) {\n      return {\n        type,\n        value,\n        line,\n        column\n      };\n    }\n    function literal(s) {\n      for (const c2 of s) {\n        const p = peek();\n        if (p !== c2) {\n          throw invalidChar(read());\n        }\n        read();\n      }\n    }\n    function escape() {\n      const c2 = peek();\n      switch (c2) {\n        case "b":\n          read();\n          return "\\b";\n        case "f":\n          read();\n          return "\\f";\n        case "n":\n          read();\n          return "\\n";\n        case "r":\n          read();\n          return "\\r";\n        case "t":\n          read();\n          return "\t";\n        case "v":\n          read();\n          return "\\v";\n        case "0":\n          read();\n          if (util.isDigit(peek())) {\n            throw invalidChar(read());\n          }\n          return "\\0";\n        case "x":\n          read();\n          return hexEscape();\n        case "u":\n          read();\n          return unicodeEscape();\n        case "\\n":\n        case "\\u2028":\n        case "\\u2029":\n          read();\n          return "";\n        case "\\r":\n          read();\n          if (peek() === "\\n") {\n            read();\n          }\n          return "";\n        case "1":\n        case "2":\n        case "3":\n        case "4":\n        case "5":\n        case "6":\n        case "7":\n        case "8":\n        case "9":\n          throw invalidChar(read());\n        case void 0:\n          throw invalidChar(read());\n      }\n      return read();\n    }\n    function hexEscape() {\n      let buffer2 = "";\n      let c2 = peek();\n      if (!util.isHexDigit(c2)) {\n        throw invalidChar(read());\n      }\n      buffer2 += read();\n      c2 = peek();\n      if (!util.isHexDigit(c2)) {\n        throw invalidChar(read());\n      }\n      buffer2 += read();\n      return String.fromCodePoint(parseInt(buffer2, 16));\n    }\n    function unicodeEscape() {\n      let buffer2 = "";\n      let count = 4;\n      while (count-- > 0) {\n        const c2 = peek();\n        if (!util.isHexDigit(c2)) {\n          throw invalidChar(read());\n        }\n        buffer2 += read();\n      }\n      return String.fromCodePoint(parseInt(buffer2, 16));\n    }\n    var parseStates = {\n      start() {\n        if (token.type === "eof") {\n          throw invalidEOF();\n        }\n        push();\n      },\n      beforePropertyName() {\n        switch (token.type) {\n          case "identifier":\n          case "string":\n            key = token.value;\n            parseState = "afterPropertyName";\n            return;\n          case "punctuator":\n            pop();\n            return;\n          case "eof":\n            throw invalidEOF();\n        }\n      },\n      afterPropertyName() {\n        if (token.type === "eof") {\n          throw invalidEOF();\n        }\n        parseState = "beforePropertyValue";\n      },\n      beforePropertyValue() {\n        if (token.type === "eof") {\n          throw invalidEOF();\n        }\n        push();\n      },\n      beforeArrayValue() {\n        if (token.type === "eof") {\n          throw invalidEOF();\n        }\n        if (token.type === "punctuator" && token.value === "]") {\n          pop();\n          return;\n        }\n        push();\n      },\n      afterPropertyValue() {\n        if (token.type === "eof") {\n          throw invalidEOF();\n        }\n        switch (token.value) {\n          case ",":\n            parseState = "beforePropertyName";\n            return;\n          case "}":\n            pop();\n        }\n      },\n      afterArrayValue() {\n        if (token.type === "eof") {\n          throw invalidEOF();\n        }\n        switch (token.value) {\n          case ",":\n            parseState = "beforeArrayValue";\n            return;\n          case "]":\n            pop();\n        }\n      },\n      end() {\n      }\n    };\n    function push() {\n      let value;\n      switch (token.type) {\n        case "punctuator":\n          switch (token.value) {\n            case "{":\n              value = {};\n              break;\n            case "[":\n              value = [];\n              break;\n          }\n          break;\n        case "null":\n        case "boolean":\n        case "numeric":\n        case "string":\n          value = token.value;\n          break;\n      }\n      if (root === void 0) {\n        root = value;\n      } else {\n        const parent = stack[stack.length - 1];\n        if (Array.isArray(parent)) {\n          parent.push(value);\n        } else {\n          Object.defineProperty(parent, key, {\n            value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        }\n      }\n      if (value !== null && typeof value === "object") {\n        stack.push(value);\n        if (Array.isArray(value)) {\n          parseState = "beforeArrayValue";\n        } else {\n          parseState = "beforePropertyName";\n        }\n      } else {\n        const current = stack[stack.length - 1];\n        if (current == null) {\n          parseState = "end";\n        } else if (Array.isArray(current)) {\n          parseState = "afterArrayValue";\n        } else {\n          parseState = "afterPropertyValue";\n        }\n      }\n    }\n    function pop() {\n      stack.pop();\n      const current = stack[stack.length - 1];\n      if (current == null) {\n        parseState = "end";\n      } else if (Array.isArray(current)) {\n        parseState = "afterArrayValue";\n      } else {\n        parseState = "afterPropertyValue";\n      }\n    }\n    function invalidChar(c2) {\n      if (c2 === void 0) {\n        return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);\n      }\n      return syntaxError(`JSON5: invalid character \'${formatChar(c2)}\' at ${line}:${column}`);\n    }\n    function invalidEOF() {\n      return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);\n    }\n    function invalidIdentifier() {\n      column -= 5;\n      return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);\n    }\n    function separatorChar(c2) {\n      console.warn(`JSON5: \'${formatChar(c2)}\' in strings is not valid ECMAScript; consider escaping`);\n    }\n    function formatChar(c2) {\n      const replacements = {\n        "\'": "\\\\\'",\n        \'"\': \'\\\\"\',\n        "\\\\": "\\\\\\\\",\n        "\\b": "\\\\b",\n        "\\f": "\\\\f",\n        "\\n": "\\\\n",\n        "\\r": "\\\\r",\n        "\t": "\\\\t",\n        "\\v": "\\\\v",\n        "\\0": "\\\\0",\n        "\\u2028": "\\\\u2028",\n        "\\u2029": "\\\\u2029"\n      };\n      if (replacements[c2]) {\n        return replacements[c2];\n      }\n      if (c2 < " ") {\n        const hexString = c2.charCodeAt(0).toString(16);\n        return "\\\\x" + ("00" + hexString).substring(hexString.length);\n      }\n      return c2;\n    }\n    function syntaxError(message) {\n      const err = new SyntaxError(message);\n      err.lineNumber = line;\n      err.columnNumber = column;\n      return err;\n    }\n  }\n});\nvar require_stringify2 = __commonJS2({\n  "node_modules/json5/lib/stringify.js"(exports2, module2) {\n    var util = require_util2();\n    module2.exports = function stringify(value, replacer, space) {\n      const stack = [];\n      let indent = "";\n      let propertyList;\n      let replacerFunc;\n      let gap = "";\n      let quote;\n      if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {\n        space = replacer.space;\n        quote = replacer.quote;\n        replacer = replacer.replacer;\n      }\n      if (typeof replacer === "function") {\n        replacerFunc = replacer;\n      } else if (Array.isArray(replacer)) {\n        propertyList = [];\n        for (const v of replacer) {\n          let item;\n          if (typeof v === "string") {\n            item = v;\n          } else if (typeof v === "number" || v instanceof String || v instanceof Number) {\n            item = String(v);\n          }\n          if (item !== void 0 && propertyList.indexOf(item) < 0) {\n            propertyList.push(item);\n          }\n        }\n      }\n      if (space instanceof Number) {\n        space = Number(space);\n      } else if (space instanceof String) {\n        space = String(space);\n      }\n      if (typeof space === "number") {\n        if (space > 0) {\n          space = Math.min(10, Math.floor(space));\n          gap = "          ".substr(0, space);\n        }\n      } else if (typeof space === "string") {\n        gap = space.substr(0, 10);\n      }\n      return serializeProperty("", {\n        "": value\n      });\n      function serializeProperty(key, holder) {\n        let value2 = holder[key];\n        if (value2 != null) {\n          if (typeof value2.toJSON5 === "function") {\n            value2 = value2.toJSON5(key);\n          } else if (typeof value2.toJSON === "function") {\n            value2 = value2.toJSON(key);\n          }\n        }\n        if (replacerFunc) {\n          value2 = replacerFunc.call(holder, key, value2);\n        }\n        if (value2 instanceof Number) {\n          value2 = Number(value2);\n        } else if (value2 instanceof String) {\n          value2 = String(value2);\n        } else if (value2 instanceof Boolean) {\n          value2 = value2.valueOf();\n        }\n        switch (value2) {\n          case null:\n            return "null";\n          case true:\n            return "true";\n          case false:\n            return "false";\n        }\n        if (typeof value2 === "string") {\n          return quoteString(value2, false);\n        }\n        if (typeof value2 === "number") {\n          return String(value2);\n        }\n        if (typeof value2 === "object") {\n          return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);\n        }\n        return void 0;\n      }\n      function quoteString(value2) {\n        const quotes = {\n          "\'": 0.1,\n          \'"\': 0.2\n        };\n        const replacements = {\n          "\'": "\\\\\'",\n          \'"\': \'\\\\"\',\n          "\\\\": "\\\\\\\\",\n          "\\b": "\\\\b",\n          "\\f": "\\\\f",\n          "\\n": "\\\\n",\n          "\\r": "\\\\r",\n          "\t": "\\\\t",\n          "\\v": "\\\\v",\n          "\\0": "\\\\0",\n          "\\u2028": "\\\\u2028",\n          "\\u2029": "\\\\u2029"\n        };\n        let product = "";\n        for (let i = 0; i < value2.length; i++) {\n          const c = value2[i];\n          switch (c) {\n            case "\'":\n            case \'"\':\n              quotes[c]++;\n              product += c;\n              continue;\n            case "\\0":\n              if (util.isDigit(value2[i + 1])) {\n                product += "\\\\x00";\n                continue;\n              }\n          }\n          if (replacements[c]) {\n            product += replacements[c];\n            continue;\n          }\n          if (c < " ") {\n            let hexString = c.charCodeAt(0).toString(16);\n            product += "\\\\x" + ("00" + hexString).substring(hexString.length);\n            continue;\n          }\n          product += c;\n        }\n        const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);\n        product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);\n        return quoteChar + product + quoteChar;\n      }\n      function serializeObject(value2) {\n        if (stack.indexOf(value2) >= 0) {\n          throw TypeError("Converting circular structure to JSON5");\n        }\n        stack.push(value2);\n        let stepback = indent;\n        indent = indent + gap;\n        let keys = propertyList || Object.keys(value2);\n        let partial = [];\n        for (const key of keys) {\n          const propertyString = serializeProperty(key, value2);\n          if (propertyString !== void 0) {\n            let member = serializeKey(key) + ":";\n            if (gap !== "") {\n              member += " ";\n            }\n            member += propertyString;\n            partial.push(member);\n          }\n        }\n        let final;\n        if (partial.length === 0) {\n          final = "{}";\n        } else {\n          let properties;\n          if (gap === "") {\n            properties = partial.join(",");\n            final = "{" + properties + "}";\n          } else {\n            let separator = ",\\n" + indent;\n            properties = partial.join(separator);\n            final = "{\\n" + indent + properties + ",\\n" + stepback + "}";\n          }\n        }\n        stack.pop();\n        indent = stepback;\n        return final;\n      }\n      function serializeKey(key) {\n        if (key.length === 0) {\n          return quoteString(key, true);\n        }\n        const firstChar = String.fromCodePoint(key.codePointAt(0));\n        if (!util.isIdStartChar(firstChar)) {\n          return quoteString(key, true);\n        }\n        for (let i = firstChar.length; i < key.length; i++) {\n          if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {\n            return quoteString(key, true);\n          }\n        }\n        return key;\n      }\n      function serializeArray(value2) {\n        if (stack.indexOf(value2) >= 0) {\n          throw TypeError("Converting circular structure to JSON5");\n        }\n        stack.push(value2);\n        let stepback = indent;\n        indent = indent + gap;\n        let partial = [];\n        for (let i = 0; i < value2.length; i++) {\n          const propertyString = serializeProperty(String(i), value2);\n          partial.push(propertyString !== void 0 ? propertyString : "null");\n        }\n        let final;\n        if (partial.length === 0) {\n          final = "[]";\n        } else {\n          if (gap === "") {\n            let properties = partial.join(",");\n            final = "[" + properties + "]";\n          } else {\n            let separator = ",\\n" + indent;\n            let properties = partial.join(separator);\n            final = "[\\n" + indent + properties + ",\\n" + stepback + "]";\n          }\n        }\n        stack.pop();\n        indent = stepback;\n        return final;\n      }\n    };\n  }\n});\nvar require_lib6 = __commonJS2({\n  "node_modules/json5/lib/index.js"(exports2, module2) {\n    var parse = require_parse3();\n    var stringify = require_stringify2();\n    var JSON5 = {\n      parse,\n      stringify\n    };\n    module2.exports = JSON5;\n  }\n});\nvar require_load_json5 = __commonJS2({\n  "src/utils/load-json5.js"(exports2, module2) {\n    "use strict";\n    var {\n      parse\n    } = require_lib6();\n    module2.exports = function(filePath, content) {\n      try {\n        return parse(content);\n      } catch (error) {\n        error.message = `JSON5 Error in ${filePath}:\n${error.message}`;\n        throw error;\n      }\n    };\n  }\n});\nvar require_partition = __commonJS2({\n  "src/utils/partition.js"(exports2, module2) {\n    "use strict";\n    function partition(array, predicate) {\n      const result = [[], []];\n      for (const value of array) {\n        result[predicate(value) ? 0 : 1].push(value);\n      }\n      return result;\n    }\n    module2.exports = partition;\n  }\n});\nvar require_homedir = __commonJS2({\n  "node_modules/resolve/lib/homedir.js"(exports2, module2) {\n    "use strict";\n    var os = require("os");\n    module2.exports = os.homedir || function homedir() {\n      var home = process.env.HOME;\n      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;\n      if (process.platform === "win32") {\n        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;\n      }\n      if (process.platform === "darwin") {\n        return home || (user ? "/Users/" + user : null);\n      }\n      if (process.platform === "linux") {\n        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);\n      }\n      return home || null;\n    };\n  }\n});\nvar require_caller = __commonJS2({\n  "node_modules/resolve/lib/caller.js"(exports2, module2) {\n    module2.exports = function() {\n      var origPrepareStackTrace = Error.prepareStackTrace;\n      Error.prepareStackTrace = function(_, stack2) {\n        return stack2;\n      };\n      var stack = new Error().stack;\n      Error.prepareStackTrace = origPrepareStackTrace;\n      return stack[2].getFileName();\n    };\n  }\n});\nvar require_path_parse = __commonJS2({\n  "node_modules/path-parse/index.js"(exports2, module2) {\n    "use strict";\n    var isWindows = process.platform === "win32";\n    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?[\\\\\\/]?)(?:[^\\\\\\/]*[\\\\\\/])*)((\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))[\\\\\\/]*$/;\n    var win32 = {};\n    function win32SplitPath(filename) {\n      return splitWindowsRe.exec(filename).slice(1);\n    }\n    win32.parse = function(pathString) {\n      if (typeof pathString !== "string") {\n        throw new TypeError("Parameter \'pathString\' must be a string, not " + typeof pathString);\n      }\n      var allParts = win32SplitPath(pathString);\n      if (!allParts || allParts.length !== 5) {\n        throw new TypeError("Invalid path \'" + pathString + "\'");\n      }\n      return {\n        root: allParts[1],\n        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),\n        base: allParts[2],\n        ext: allParts[4],\n        name: allParts[3]\n      };\n    };\n    var splitPathRe = /^((\\/?)(?:[^\\/]*\\/)*)((\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))[\\/]*$/;\n    var posix = {};\n    function posixSplitPath(filename) {\n      return splitPathRe.exec(filename).slice(1);\n    }\n    posix.parse = function(pathString) {\n      if (typeof pathString !== "string") {\n        throw new TypeError("Parameter \'pathString\' must be a string, not " + typeof pathString);\n      }\n      var allParts = posixSplitPath(pathString);\n      if (!allParts || allParts.length !== 5) {\n        throw new TypeError("Invalid path \'" + pathString + "\'");\n      }\n      return {\n        root: allParts[1],\n        dir: allParts[0].slice(0, -1),\n        base: allParts[2],\n        ext: allParts[4],\n        name: allParts[3]\n      };\n    };\n    if (isWindows)\n      module2.exports = win32.parse;\n    else\n      module2.exports = posix.parse;\n    module2.exports.posix = posix.parse;\n    module2.exports.win32 = win32.parse;\n  }\n});\nvar require_node_modules_paths = __commonJS2({\n  "node_modules/resolve/lib/node-modules-paths.js"(exports2, module2) {\n    var path = require("path");\n    var parse = path.parse || require_path_parse();\n    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {\n      var prefix = "/";\n      if (/^([A-Za-z]:)/.test(absoluteStart)) {\n        prefix = "";\n      } else if (/^\\\\\\\\/.test(absoluteStart)) {\n        prefix = "\\\\\\\\";\n      }\n      var paths = [absoluteStart];\n      var parsed = parse(absoluteStart);\n      while (parsed.dir !== paths[paths.length - 1]) {\n        paths.push(parsed.dir);\n        parsed = parse(parsed.dir);\n      }\n      return paths.reduce(function(dirs, aPath) {\n        return dirs.concat(modules.map(function(moduleDir) {\n          return path.resolve(prefix, aPath, moduleDir);\n        }));\n      }, []);\n    };\n    module2.exports = function nodeModulesPaths(start, opts, request) {\n      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];\n      if (opts && typeof opts.paths === "function") {\n        return opts.paths(request, start, function() {\n          return getNodeModulesDirs(start, modules);\n        }, opts);\n      }\n      var dirs = getNodeModulesDirs(start, modules);\n      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;\n    };\n  }\n});\nvar require_normalize_options = __commonJS2({\n  "node_modules/resolve/lib/normalize-options.js"(exports2, module2) {\n    module2.exports = function(x, opts) {\n      return opts || {};\n    };\n  }\n});\nvar require_implementation = __commonJS2({\n  "node_modules/function-bind/implementation.js"(exports2, module2) {\n    "use strict";\n    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";\n    var slice = Array.prototype.slice;\n    var toStr = Object.prototype.toString;\n    var funcType = "[object Function]";\n    module2.exports = function bind(that) {\n      var target = this;\n      if (typeof target !== "function" || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n      }\n      var args = slice.call(arguments, 1);\n      var bound;\n      var binder = function() {\n        if (this instanceof bound) {\n          var result = target.apply(this, args.concat(slice.call(arguments)));\n          if (Object(result) === result) {\n            return result;\n          }\n          return this;\n        } else {\n          return target.apply(that, args.concat(slice.call(arguments)));\n        }\n      };\n      var boundLength = Math.max(0, target.length - args.length);\n      var boundArgs = [];\n      for (var i = 0; i < boundLength; i++) {\n        boundArgs.push("$" + i);\n      }\n      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);\n      if (target.prototype) {\n        var Empty = function Empty2() {\n        };\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n      }\n      return bound;\n    };\n  }\n});\nvar require_function_bind = __commonJS2({\n  "node_modules/function-bind/index.js"(exports2, module2) {\n    "use strict";\n    var implementation = require_implementation();\n    module2.exports = Function.prototype.bind || implementation;\n  }\n});\nvar require_src = __commonJS2({\n  "node_modules/has/src/index.js"(exports2, module2) {\n    "use strict";\n    var bind = require_function_bind();\n    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n  }\n});\nvar require_core2 = __commonJS2({\n  "node_modules/is-core-module/core.json"(exports2, module2) {\n    module2.exports = {\n      assert: true,\n      "node:assert": [">= 14.18 && < 15", ">= 16"],\n      "assert/strict": ">= 15",\n      "node:assert/strict": ">= 16",\n      async_hooks: ">= 8",\n      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],\n      buffer_ieee754: ">= 0.5 && < 0.9.7",\n      buffer: true,\n      "node:buffer": [">= 14.18 && < 15", ">= 16"],\n      child_process: true,\n      "node:child_process": [">= 14.18 && < 15", ">= 16"],\n      cluster: ">= 0.5",\n      "node:cluster": [">= 14.18 && < 15", ">= 16"],\n      console: true,\n      "node:console": [">= 14.18 && < 15", ">= 16"],\n      constants: true,\n      "node:constants": [">= 14.18 && < 15", ">= 16"],\n      crypto: true,\n      "node:crypto": [">= 14.18 && < 15", ">= 16"],\n      _debug_agent: ">= 1 && < 8",\n      _debugger: "< 8",\n      dgram: true,\n      "node:dgram": [">= 14.18 && < 15", ">= 16"],\n      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],\n      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],\n      dns: true,\n      "node:dns": [">= 14.18 && < 15", ">= 16"],\n      "dns/promises": ">= 15",\n      "node:dns/promises": ">= 16",\n      domain: ">= 0.7.12",\n      "node:domain": [">= 14.18 && < 15", ">= 16"],\n      events: true,\n      "node:events": [">= 14.18 && < 15", ">= 16"],\n      freelist: "< 6",\n      fs: true,\n      "node:fs": [">= 14.18 && < 15", ">= 16"],\n      "fs/promises": [">= 10 && < 10.1", ">= 14"],\n      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],\n      _http_agent: ">= 0.11.1",\n      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],\n      _http_client: ">= 0.11.1",\n      "node:_http_client": [">= 14.18 && < 15", ">= 16"],\n      _http_common: ">= 0.11.1",\n      "node:_http_common": [">= 14.18 && < 15", ">= 16"],\n      _http_incoming: ">= 0.11.1",\n      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],\n      _http_outgoing: ">= 0.11.1",\n      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],\n      _http_server: ">= 0.11.1",\n      "node:_http_server": [">= 14.18 && < 15", ">= 16"],\n      http: true,\n      "node:http": [">= 14.18 && < 15", ">= 16"],\n      http2: ">= 8.8",\n      "node:http2": [">= 14.18 && < 15", ">= 16"],\n      https: true,\n      "node:https": [">= 14.18 && < 15", ">= 16"],\n      inspector: ">= 8",\n      "node:inspector": [">= 14.18 && < 15", ">= 16"],\n      "inspector/promises": [">= 19"],\n      "node:inspector/promises": [">= 19"],\n      _linklist: "< 8",\n      module: true,\n      "node:module": [">= 14.18 && < 15", ">= 16"],\n      net: true,\n      "node:net": [">= 14.18 && < 15", ">= 16"],\n      "node-inspect/lib/_inspect": ">= 7.6 && < 12",\n      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",\n      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",\n      os: true,\n      "node:os": [">= 14.18 && < 15", ">= 16"],\n      path: true,\n      "node:path": [">= 14.18 && < 15", ">= 16"],\n      "path/posix": ">= 15.3",\n      "node:path/posix": ">= 16",\n      "path/win32": ">= 15.3",\n      "node:path/win32": ">= 16",\n      perf_hooks: ">= 8.5",\n      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],\n      process: ">= 1",\n      "node:process": [">= 14.18 && < 15", ">= 16"],\n      punycode: ">= 0.5",\n      "node:punycode": [">= 14.18 && < 15", ">= 16"],\n      querystring: true,\n      "node:querystring": [">= 14.18 && < 15", ">= 16"],\n      readline: true,\n      "node:readline": [">= 14.18 && < 15", ">= 16"],\n      "readline/promises": ">= 17",\n      "node:readline/promises": ">= 17",\n      repl: true,\n      "node:repl": [">= 14.18 && < 15", ">= 16"],\n      smalloc: ">= 0.11.5 && < 3",\n      _stream_duplex: ">= 0.9.4",\n      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],\n      _stream_transform: ">= 0.9.4",\n      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],\n      _stream_wrap: ">= 1.4.1",\n      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],\n      _stream_passthrough: ">= 0.9.4",\n      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],\n      _stream_readable: ">= 0.9.4",\n      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],\n      _stream_writable: ">= 0.9.4",\n      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],\n      stream: true,\n      "node:stream": [">= 14.18 && < 15", ">= 16"],\n      "stream/consumers": ">= 16.7",\n      "node:stream/consumers": ">= 16.7",\n      "stream/promises": ">= 15",\n      "node:stream/promises": ">= 16",\n      "stream/web": ">= 16.5",\n      "node:stream/web": ">= 16.5",\n      string_decoder: true,\n      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],\n      sys: [">= 0.4 && < 0.7", ">= 0.8"],\n      "node:sys": [">= 14.18 && < 15", ">= 16"],\n      "node:test": [">= 16.17 && < 17", ">= 18"],\n      timers: true,\n      "node:timers": [">= 14.18 && < 15", ">= 16"],\n      "timers/promises": ">= 15",\n      "node:timers/promises": ">= 16",\n      _tls_common: ">= 0.11.13",\n      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],\n      _tls_legacy: ">= 0.11.3 && < 10",\n      _tls_wrap: ">= 0.11.3",\n      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],\n      tls: true,\n      "node:tls": [">= 14.18 && < 15", ">= 16"],\n      trace_events: ">= 10",\n      "node:trace_events": [">= 14.18 && < 15", ">= 16"],\n      tty: true,\n      "node:tty": [">= 14.18 && < 15", ">= 16"],\n      url: true,\n      "node:url": [">= 14.18 && < 15", ">= 16"],\n      util: true,\n      "node:util": [">= 14.18 && < 15", ">= 16"],\n      "util/types": ">= 15.3",\n      "node:util/types": ">= 16",\n      "v8/tools/arguments": ">= 10 && < 12",\n      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],\n      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],\n      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],\n      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],\n      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],\n      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],\n      v8: ">= 1",\n      "node:v8": [">= 14.18 && < 15", ">= 16"],\n      vm: true,\n      "node:vm": [">= 14.18 && < 15", ">= 16"],\n      wasi: ">= 13.4 && < 13.5",\n      worker_threads: ">= 11.7",\n      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],\n      zlib: ">= 0.5",\n      "node:zlib": [">= 14.18 && < 15", ">= 16"]\n    };\n  }\n});\nvar require_is_core_module = __commonJS2({\n  "node_modules/is-core-module/index.js"(exports2, module2) {\n    "use strict";\n    var has = require_src();\n    function specifierIncluded(current, specifier) {\n      var nodeParts = current.split(".");\n      var parts = specifier.split(" ");\n      var op = parts.length > 1 ? parts[0] : "=";\n      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");\n      for (var i = 0; i < 3; ++i) {\n        var cur = parseInt(nodeParts[i] || 0, 10);\n        var ver = parseInt(versionParts[i] || 0, 10);\n        if (cur === ver) {\n          continue;\n        }\n        if (op === "<") {\n          return cur < ver;\n        }\n        if (op === ">=") {\n          return cur >= ver;\n        }\n        return false;\n      }\n      return op === ">=";\n    }\n    function matchesRange(current, range) {\n      var specifiers = range.split(/ ?&& ?/);\n      if (specifiers.length === 0) {\n        return false;\n      }\n      for (var i = 0; i < specifiers.length; ++i) {\n        if (!specifierIncluded(current, specifiers[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    function versionIncluded(nodeVersion, specifierValue) {\n      if (typeof specifierValue === "boolean") {\n        return specifierValue;\n      }\n      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;\n      if (typeof current !== "string") {\n        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");\n      }\n      if (specifierValue && typeof specifierValue === "object") {\n        for (var i = 0; i < specifierValue.length; ++i) {\n          if (matchesRange(current, specifierValue[i])) {\n            return true;\n          }\n        }\n        return false;\n      }\n      return matchesRange(current, specifierValue);\n    }\n    var data = require_core2();\n    module2.exports = function isCore(x, nodeVersion) {\n      return has(data, x) && versionIncluded(nodeVersion, data[x]);\n    };\n  }\n});\nvar require_async = __commonJS2({\n  "node_modules/resolve/lib/async.js"(exports2, module2) {\n    var fs = require("fs");\n    var getHomedir = require_homedir();\n    var path = require("path");\n    var caller = require_caller();\n    var nodeModulesPaths = require_node_modules_paths();\n    var normalizeOptions = require_normalize_options();\n    var isCore = require_is_core_module();\n    var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;\n    var homedir = getHomedir();\n    var defaultPaths = function() {\n      return [path.join(homedir, ".node_modules"), path.join(homedir, ".node_libraries")];\n    };\n    var defaultIsFile = function isFile(file, cb) {\n      fs.stat(file, function(err, stat) {\n        if (!err) {\n          return cb(null, stat.isFile() || stat.isFIFO());\n        }\n        if (err.code === "ENOENT" || err.code === "ENOTDIR")\n          return cb(null, false);\n        return cb(err);\n      });\n    };\n    var defaultIsDir = function isDirectory(dir, cb) {\n      fs.stat(dir, function(err, stat) {\n        if (!err) {\n          return cb(null, stat.isDirectory());\n        }\n        if (err.code === "ENOENT" || err.code === "ENOTDIR")\n          return cb(null, false);\n        return cb(err);\n      });\n    };\n    var defaultRealpath = function realpath(x, cb) {\n      realpathFS(x, function(realpathErr, realPath) {\n        if (realpathErr && realpathErr.code !== "ENOENT")\n          cb(realpathErr);\n        else\n          cb(null, realpathErr ? x : realPath);\n      });\n    };\n    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {\n      if (opts && opts.preserveSymlinks === false) {\n        realpath(x, cb);\n      } else {\n        cb(null, x);\n      }\n    };\n    var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {\n      readFile(pkgfile, function(readFileErr, body) {\n        if (readFileErr)\n          cb(readFileErr);\n        else {\n          try {\n            var pkg = JSON.parse(body);\n            cb(null, pkg);\n          } catch (jsonErr) {\n            cb(null);\n          }\n        }\n      });\n    };\n    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {\n      var dirs = nodeModulesPaths(start, opts, x);\n      for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path.join(dirs[i], x);\n      }\n      return dirs;\n    };\n    module2.exports = function resolve(x, options, callback) {\n      var cb = callback;\n      var opts = options;\n      if (typeof options === "function") {\n        cb = opts;\n        opts = {};\n      }\n      if (typeof x !== "string") {\n        var err = new TypeError("Path must be a string.");\n        return process.nextTick(function() {\n          cb(err);\n        });\n      }\n      opts = normalizeOptions(x, opts);\n      var isFile = opts.isFile || defaultIsFile;\n      var isDirectory = opts.isDirectory || defaultIsDir;\n      var readFile = opts.readFile || fs.readFile;\n      var realpath = opts.realpath || defaultRealpath;\n      var readPackage = opts.readPackage || defaultReadPackage;\n      if (opts.readFile && opts.readPackage) {\n        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");\n        return process.nextTick(function() {\n          cb(conflictErr);\n        });\n      }\n      var packageIterator = opts.packageIterator;\n      var extensions = opts.extensions || [".js"];\n      var includeCoreModules = opts.includeCoreModules !== false;\n      var basedir = opts.basedir || path.dirname(caller());\n      var parent = opts.filename || basedir;\n      opts.paths = opts.paths || defaultPaths();\n      var absoluteStart = path.resolve(basedir);\n      maybeRealpath(realpath, absoluteStart, opts, function(err2, realStart) {\n        if (err2)\n          cb(err2);\n        else\n          init(realStart);\n      });\n      var res;\n      function init(basedir2) {\n        if (/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/.test(x)) {\n          res = path.resolve(basedir2, x);\n          if (x === "." || x === ".." || x.slice(-1) === "/")\n            res += "/";\n          if (/\\/$/.test(x) && res === basedir2) {\n            loadAsDirectory(res, opts.package, onfile);\n          } else\n            loadAsFile(res, opts.package, onfile);\n        } else if (includeCoreModules && isCore(x)) {\n          return cb(null, x);\n        } else\n          loadNodeModules(x, basedir2, function(err2, n, pkg) {\n            if (err2)\n              cb(err2);\n            else if (n) {\n              return maybeRealpath(realpath, n, opts, function(err3, realN) {\n                if (err3) {\n                  cb(err3);\n                } else {\n                  cb(null, realN, pkg);\n                }\n              });\n            } else {\n              var moduleError = new Error("Cannot find module \'" + x + "\' from \'" + parent + "\'");\n              moduleError.code = "MODULE_NOT_FOUND";\n              cb(moduleError);\n            }\n          });\n      }\n      function onfile(err2, m, pkg) {\n        if (err2)\n          cb(err2);\n        else if (m)\n          cb(null, m, pkg);\n        else\n          loadAsDirectory(res, function(err3, d, pkg2) {\n            if (err3)\n              cb(err3);\n            else if (d) {\n              maybeRealpath(realpath, d, opts, function(err4, realD) {\n                if (err4) {\n                  cb(err4);\n                } else {\n                  cb(null, realD, pkg2);\n                }\n              });\n            } else {\n              var moduleError = new Error("Cannot find module \'" + x + "\' from \'" + parent + "\'");\n              moduleError.code = "MODULE_NOT_FOUND";\n              cb(moduleError);\n            }\n          });\n      }\n      function loadAsFile(x2, thePackage, callback2) {\n        var loadAsFilePackage = thePackage;\n        var cb2 = callback2;\n        if (typeof loadAsFilePackage === "function") {\n          cb2 = loadAsFilePackage;\n          loadAsFilePackage = void 0;\n        }\n        var exts = [""].concat(extensions);\n        load(exts, x2, loadAsFilePackage);\n        function load(exts2, x3, loadPackage) {\n          if (exts2.length === 0)\n            return cb2(null, void 0, loadPackage);\n          var file = x3 + exts2[0];\n          var pkg = loadPackage;\n          if (pkg)\n            onpkg(null, pkg);\n          else\n            loadpkg(path.dirname(file), onpkg);\n          function onpkg(err2, pkg_, dir) {\n            pkg = pkg_;\n            if (err2)\n              return cb2(err2);\n            if (dir && pkg && opts.pathFilter) {\n              var rfile = path.relative(dir, file);\n              var rel = rfile.slice(0, rfile.length - exts2[0].length);\n              var r = opts.pathFilter(pkg, x3, rel);\n              if (r)\n                return load([""].concat(extensions.slice()), path.resolve(dir, r), pkg);\n            }\n            isFile(file, onex);\n          }\n          function onex(err2, ex) {\n            if (err2)\n              return cb2(err2);\n            if (ex)\n              return cb2(null, file, pkg);\n            load(exts2.slice(1), x3, pkg);\n          }\n        }\n      }\n      function loadpkg(dir, cb2) {\n        if (dir === "" || dir === "/")\n          return cb2(null);\n        if (process.platform === "win32" && /^\\w:[/\\\\]*$/.test(dir)) {\n          return cb2(null);\n        }\n        if (/[/\\\\]node_modules[/\\\\]*$/.test(dir))\n          return cb2(null);\n        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {\n          if (unwrapErr)\n            return loadpkg(path.dirname(dir), cb2);\n          var pkgfile = path.join(pkgdir, "package.json");\n          isFile(pkgfile, function(err2, ex) {\n            if (!ex)\n              return loadpkg(path.dirname(dir), cb2);\n            readPackage(readFile, pkgfile, function(err3, pkgParam) {\n              if (err3)\n                cb2(err3);\n              var pkg = pkgParam;\n              if (pkg && opts.packageFilter) {\n                pkg = opts.packageFilter(pkg, pkgfile);\n              }\n              cb2(null, pkg, dir);\n            });\n          });\n        });\n      }\n      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {\n        var cb2 = callback2;\n        var fpkg = loadAsDirectoryPackage;\n        if (typeof fpkg === "function") {\n          cb2 = fpkg;\n          fpkg = opts.package;\n        }\n        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {\n          if (unwrapErr)\n            return cb2(unwrapErr);\n          var pkgfile = path.join(pkgdir, "package.json");\n          isFile(pkgfile, function(err2, ex) {\n            if (err2)\n              return cb2(err2);\n            if (!ex)\n              return loadAsFile(path.join(x2, "index"), fpkg, cb2);\n            readPackage(readFile, pkgfile, function(err3, pkgParam) {\n              if (err3)\n                return cb2(err3);\n              var pkg = pkgParam;\n              if (pkg && opts.packageFilter) {\n                pkg = opts.packageFilter(pkg, pkgfile);\n              }\n              if (pkg && pkg.main) {\n                if (typeof pkg.main !== "string") {\n                  var mainError = new TypeError("package \\u201C" + pkg.name + "\\u201D `main` must be a string");\n                  mainError.code = "INVALID_PACKAGE_MAIN";\n                  return cb2(mainError);\n                }\n                if (pkg.main === "." || pkg.main === "./") {\n                  pkg.main = "index";\n                }\n                loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {\n                  if (err4)\n                    return cb2(err4);\n                  if (m)\n                    return cb2(null, m, pkg2);\n                  if (!pkg2)\n                    return loadAsFile(path.join(x2, "index"), pkg2, cb2);\n                  var dir = path.resolve(x2, pkg2.main);\n                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {\n                    if (err5)\n                      return cb2(err5);\n                    if (n)\n                      return cb2(null, n, pkg3);\n                    loadAsFile(path.join(x2, "index"), pkg3, cb2);\n                  });\n                });\n                return;\n              }\n              loadAsFile(path.join(x2, "/index"), pkg, cb2);\n            });\n          });\n        });\n      }\n      function processDirs(cb2, dirs) {\n        if (dirs.length === 0)\n          return cb2(null, void 0);\n        var dir = dirs[0];\n        isDirectory(path.dirname(dir), isdir);\n        function isdir(err2, isdir2) {\n          if (err2)\n            return cb2(err2);\n          if (!isdir2)\n            return processDirs(cb2, dirs.slice(1));\n          loadAsFile(dir, opts.package, onfile2);\n        }\n        function onfile2(err2, m, pkg) {\n          if (err2)\n            return cb2(err2);\n          if (m)\n            return cb2(null, m, pkg);\n          loadAsDirectory(dir, opts.package, ondir);\n        }\n        function ondir(err2, n, pkg) {\n          if (err2)\n            return cb2(err2);\n          if (n)\n            return cb2(null, n, pkg);\n          processDirs(cb2, dirs.slice(1));\n        }\n      }\n      function loadNodeModules(x2, start, cb2) {\n        var thunk = function() {\n          return getPackageCandidates(x2, start, opts);\n        };\n        processDirs(cb2, packageIterator ? packageIterator(x2, start, thunk, opts) : thunk());\n      }\n    };\n  }\n});\nvar require_core3 = __commonJS2({\n  "node_modules/resolve/lib/core.json"(exports2, module2) {\n    module2.exports = {\n      assert: true,\n      "node:assert": [">= 14.18 && < 15", ">= 16"],\n      "assert/strict": ">= 15",\n      "node:assert/strict": ">= 16",\n      async_hooks: ">= 8",\n      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],\n      buffer_ieee754: ">= 0.5 && < 0.9.7",\n      buffer: true,\n      "node:buffer": [">= 14.18 && < 15", ">= 16"],\n      child_process: true,\n      "node:child_process": [">= 14.18 && < 15", ">= 16"],\n      cluster: ">= 0.5",\n      "node:cluster": [">= 14.18 && < 15", ">= 16"],\n      console: true,\n      "node:console": [">= 14.18 && < 15", ">= 16"],\n      constants: true,\n      "node:constants": [">= 14.18 && < 15", ">= 16"],\n      crypto: true,\n      "node:crypto": [">= 14.18 && < 15", ">= 16"],\n      _debug_agent: ">= 1 && < 8",\n      _debugger: "< 8",\n      dgram: true,\n      "node:dgram": [">= 14.18 && < 15", ">= 16"],\n      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],\n      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],\n      dns: true,\n      "node:dns": [">= 14.18 && < 15", ">= 16"],\n      "dns/promises": ">= 15",\n      "node:dns/promises": ">= 16",\n      domain: ">= 0.7.12",\n      "node:domain": [">= 14.18 && < 15", ">= 16"],\n      events: true,\n      "node:events": [">= 14.18 && < 15", ">= 16"],\n      freelist: "< 6",\n      fs: true,\n      "node:fs": [">= 14.18 && < 15", ">= 16"],\n      "fs/promises": [">= 10 && < 10.1", ">= 14"],\n      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],\n      _http_agent: ">= 0.11.1",\n      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],\n      _http_client: ">= 0.11.1",\n      "node:_http_client": [">= 14.18 && < 15", ">= 16"],\n      _http_common: ">= 0.11.1",\n      "node:_http_common": [">= 14.18 && < 15", ">= 16"],\n      _http_incoming: ">= 0.11.1",\n      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],\n      _http_outgoing: ">= 0.11.1",\n      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],\n      _http_server: ">= 0.11.1",\n      "node:_http_server": [">= 14.18 && < 15", ">= 16"],\n      http: true,\n      "node:http": [">= 14.18 && < 15", ">= 16"],\n      http2: ">= 8.8",\n      "node:http2": [">= 14.18 && < 15", ">= 16"],\n      https: true,\n      "node:https": [">= 14.18 && < 15", ">= 16"],\n      inspector: ">= 8",\n      "node:inspector": [">= 14.18 && < 15", ">= 16"],\n      _linklist: "< 8",\n      module: true,\n      "node:module": [">= 14.18 && < 15", ">= 16"],\n      net: true,\n      "node:net": [">= 14.18 && < 15", ">= 16"],\n      "node-inspect/lib/_inspect": ">= 7.6 && < 12",\n      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",\n      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",\n      os: true,\n      "node:os": [">= 14.18 && < 15", ">= 16"],\n      path: true,\n      "node:path": [">= 14.18 && < 15", ">= 16"],\n      "path/posix": ">= 15.3",\n      "node:path/posix": ">= 16",\n      "path/win32": ">= 15.3",\n      "node:path/win32": ">= 16",\n      perf_hooks: ">= 8.5",\n      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],\n      process: ">= 1",\n      "node:process": [">= 14.18 && < 15", ">= 16"],\n      punycode: ">= 0.5",\n      "node:punycode": [">= 14.18 && < 15", ">= 16"],\n      querystring: true,\n      "node:querystring": [">= 14.18 && < 15", ">= 16"],\n      readline: true,\n      "node:readline": [">= 14.18 && < 15", ">= 16"],\n      "readline/promises": ">= 17",\n      "node:readline/promises": ">= 17",\n      repl: true,\n      "node:repl": [">= 14.18 && < 15", ">= 16"],\n      smalloc: ">= 0.11.5 && < 3",\n      _stream_duplex: ">= 0.9.4",\n      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],\n      _stream_transform: ">= 0.9.4",\n      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],\n      _stream_wrap: ">= 1.4.1",\n      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],\n      _stream_passthrough: ">= 0.9.4",\n      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],\n      _stream_readable: ">= 0.9.4",\n      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],\n      _stream_writable: ">= 0.9.4",\n      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],\n      stream: true,\n      "node:stream": [">= 14.18 && < 15", ">= 16"],\n      "stream/consumers": ">= 16.7",\n      "node:stream/consumers": ">= 16.7",\n      "stream/promises": ">= 15",\n      "node:stream/promises": ">= 16",\n      "stream/web": ">= 16.5",\n      "node:stream/web": ">= 16.5",\n      string_decoder: true,\n      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],\n      sys: [">= 0.4 && < 0.7", ">= 0.8"],\n      "node:sys": [">= 14.18 && < 15", ">= 16"],\n      "node:test": ">= 18",\n      timers: true,\n      "node:timers": [">= 14.18 && < 15", ">= 16"],\n      "timers/promises": ">= 15",\n      "node:timers/promises": ">= 16",\n      _tls_common: ">= 0.11.13",\n      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],\n      _tls_legacy: ">= 0.11.3 && < 10",\n      _tls_wrap: ">= 0.11.3",\n      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],\n      tls: true,\n      "node:tls": [">= 14.18 && < 15", ">= 16"],\n      trace_events: ">= 10",\n      "node:trace_events": [">= 14.18 && < 15", ">= 16"],\n      tty: true,\n      "node:tty": [">= 14.18 && < 15", ">= 16"],\n      url: true,\n      "node:url": [">= 14.18 && < 15", ">= 16"],\n      util: true,\n      "node:util": [">= 14.18 && < 15", ">= 16"],\n      "util/types": ">= 15.3",\n      "node:util/types": ">= 16",\n      "v8/tools/arguments": ">= 10 && < 12",\n      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],\n      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],\n      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],\n      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],\n      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],\n      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],\n      v8: ">= 1",\n      "node:v8": [">= 14.18 && < 15", ">= 16"],\n      vm: true,\n      "node:vm": [">= 14.18 && < 15", ">= 16"],\n      wasi: ">= 13.4 && < 13.5",\n      worker_threads: ">= 11.7",\n      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],\n      zlib: ">= 0.5",\n      "node:zlib": [">= 14.18 && < 15", ">= 16"]\n    };\n  }\n});\nvar require_core4 = __commonJS2({\n  "node_modules/resolve/lib/core.js"(exports2, module2) {\n    var current = process.versions && process.versions.node && process.versions.node.split(".") || [];\n    function specifierIncluded(specifier) {\n      var parts = specifier.split(" ");\n      var op = parts.length > 1 ? parts[0] : "=";\n      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");\n      for (var i = 0; i < 3; ++i) {\n        var cur = parseInt(current[i] || 0, 10);\n        var ver = parseInt(versionParts[i] || 0, 10);\n        if (cur === ver) {\n          continue;\n        }\n        if (op === "<") {\n          return cur < ver;\n        } else if (op === ">=") {\n          return cur >= ver;\n        }\n        return false;\n      }\n      return op === ">=";\n    }\n    function matchesRange(range) {\n      var specifiers = range.split(/ ?&& ?/);\n      if (specifiers.length === 0) {\n        return false;\n      }\n      for (var i = 0; i < specifiers.length; ++i) {\n        if (!specifierIncluded(specifiers[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    function versionIncluded(specifierValue) {\n      if (typeof specifierValue === "boolean") {\n        return specifierValue;\n      }\n      if (specifierValue && typeof specifierValue === "object") {\n        for (var i = 0; i < specifierValue.length; ++i) {\n          if (matchesRange(specifierValue[i])) {\n            return true;\n          }\n        }\n        return false;\n      }\n      return matchesRange(specifierValue);\n    }\n    var data = require_core3();\n    var core2 = {};\n    for (mod in data) {\n      if (Object.prototype.hasOwnProperty.call(data, mod)) {\n        core2[mod] = versionIncluded(data[mod]);\n      }\n    }\n    var mod;\n    module2.exports = core2;\n  }\n});\nvar require_is_core = __commonJS2({\n  "node_modules/resolve/lib/is-core.js"(exports2, module2) {\n    var isCoreModule = require_is_core_module();\n    module2.exports = function isCore(x) {\n      return isCoreModule(x);\n    };\n  }\n});\nvar require_sync = __commonJS2({\n  "node_modules/resolve/lib/sync.js"(exports2, module2) {\n    var isCore = require_is_core_module();\n    var fs = require("fs");\n    var path = require("path");\n    var getHomedir = require_homedir();\n    var caller = require_caller();\n    var nodeModulesPaths = require_node_modules_paths();\n    var normalizeOptions = require_normalize_options();\n    var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;\n    var homedir = getHomedir();\n    var defaultPaths = function() {\n      return [path.join(homedir, ".node_modules"), path.join(homedir, ".node_libraries")];\n    };\n    var defaultIsFile = function isFile(file) {\n      try {\n        var stat = fs.statSync(file, {\n          throwIfNoEntry: false\n        });\n      } catch (e) {\n        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))\n          return false;\n        throw e;\n      }\n      return !!stat && (stat.isFile() || stat.isFIFO());\n    };\n    var defaultIsDir = function isDirectory(dir) {\n      try {\n        var stat = fs.statSync(dir, {\n          throwIfNoEntry: false\n        });\n      } catch (e) {\n        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))\n          return false;\n        throw e;\n      }\n      return !!stat && stat.isDirectory();\n    };\n    var defaultRealpathSync = function realpathSync(x) {\n      try {\n        return realpathFS(x);\n      } catch (realpathErr) {\n        if (realpathErr.code !== "ENOENT") {\n          throw realpathErr;\n        }\n      }\n      return x;\n    };\n    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {\n      if (opts && opts.preserveSymlinks === false) {\n        return realpathSync(x);\n      }\n      return x;\n    };\n    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {\n      var body = readFileSync(pkgfile);\n      try {\n        var pkg = JSON.parse(body);\n        return pkg;\n      } catch (jsonErr) {\n      }\n    };\n    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {\n      var dirs = nodeModulesPaths(start, opts, x);\n      for (var i = 0; i < dirs.length; i++) {\n        dirs[i] = path.join(dirs[i], x);\n      }\n      return dirs;\n    };\n    module2.exports = function resolveSync(x, options) {\n      if (typeof x !== "string") {\n        throw new TypeError("Path must be a string.");\n      }\n      var opts = normalizeOptions(x, options);\n      var isFile = opts.isFile || defaultIsFile;\n      var readFileSync = opts.readFileSync || fs.readFileSync;\n      var isDirectory = opts.isDirectory || defaultIsDir;\n      var realpathSync = opts.realpathSync || defaultRealpathSync;\n      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;\n      if (opts.readFileSync && opts.readPackageSync) {\n        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");\n      }\n      var packageIterator = opts.packageIterator;\n      var extensions = opts.extensions || [".js"];\n      var includeCoreModules = opts.includeCoreModules !== false;\n      var basedir = opts.basedir || path.dirname(caller());\n      var parent = opts.filename || basedir;\n      opts.paths = opts.paths || defaultPaths();\n      var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);\n      if (/^(?:\\.\\.?(?:\\/|$)|\\/|([A-Za-z]:)?[/\\\\])/.test(x)) {\n        var res = path.resolve(absoluteStart, x);\n        if (x === "." || x === ".." || x.slice(-1) === "/")\n          res += "/";\n        var m = loadAsFileSync(res) || loadAsDirectorySync(res);\n        if (m)\n          return maybeRealpathSync(realpathSync, m, opts);\n      } else if (includeCoreModules && isCore(x)) {\n        return x;\n      } else {\n        var n = loadNodeModulesSync(x, absoluteStart);\n        if (n)\n          return maybeRealpathSync(realpathSync, n, opts);\n      }\n      var err = new Error("Cannot find module \'" + x + "\' from \'" + parent + "\'");\n      err.code = "MODULE_NOT_FOUND";\n      throw err;\n      function loadAsFileSync(x2) {\n        var pkg = loadpkg(path.dirname(x2));\n        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {\n          var rfile = path.relative(pkg.dir, x2);\n          var r = opts.pathFilter(pkg.pkg, x2, rfile);\n          if (r) {\n            x2 = path.resolve(pkg.dir, r);\n          }\n        }\n        if (isFile(x2)) {\n          return x2;\n        }\n        for (var i = 0; i < extensions.length; i++) {\n          var file = x2 + extensions[i];\n          if (isFile(file)) {\n            return file;\n          }\n        }\n      }\n      function loadpkg(dir) {\n        if (dir === "" || dir === "/")\n          return;\n        if (process.platform === "win32" && /^\\w:[/\\\\]*$/.test(dir)) {\n          return;\n        }\n        if (/[/\\\\]node_modules[/\\\\]*$/.test(dir))\n          return;\n        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");\n        if (!isFile(pkgfile)) {\n          return loadpkg(path.dirname(dir));\n        }\n        var pkg = readPackageSync(readFileSync, pkgfile);\n        if (pkg && opts.packageFilter) {\n          pkg = opts.packageFilter(pkg, dir);\n        }\n        return {\n          pkg,\n          dir\n        };\n      }\n      function loadAsDirectorySync(x2) {\n        var pkgfile = path.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");\n        if (isFile(pkgfile)) {\n          try {\n            var pkg = readPackageSync(readFileSync, pkgfile);\n          } catch (e) {\n          }\n          if (pkg && opts.packageFilter) {\n            pkg = opts.packageFilter(pkg, x2);\n          }\n          if (pkg && pkg.main) {\n            if (typeof pkg.main !== "string") {\n              var mainError = new TypeError("package \\u201C" + pkg.name + "\\u201D `main` must be a string");\n              mainError.code = "INVALID_PACKAGE_MAIN";\n              throw mainError;\n            }\n            if (pkg.main === "." || pkg.main === "./") {\n              pkg.main = "index";\n            }\n            try {\n              var m2 = loadAsFileSync(path.resolve(x2, pkg.main));\n              if (m2)\n                return m2;\n              var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));\n              if (n2)\n                return n2;\n            } catch (e) {\n            }\n          }\n        }\n        return loadAsFileSync(path.join(x2, "/index"));\n      }\n      function loadNodeModulesSync(x2, start) {\n        var thunk = function() {\n          return getPackageCandidates(x2, start, opts);\n        };\n        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();\n        for (var i = 0; i < dirs.length; i++) {\n          var dir = dirs[i];\n          if (isDirectory(path.dirname(dir))) {\n            var m2 = loadAsFileSync(dir);\n            if (m2)\n              return m2;\n            var n2 = loadAsDirectorySync(dir);\n            if (n2)\n              return n2;\n          }\n        }\n      }\n    };\n  }\n});\nvar require_resolve = __commonJS2({\n  "node_modules/resolve/index.js"(exports2, module2) {\n    var async = require_async();\n    async.core = require_core4();\n    async.isCore = require_is_core();\n    async.sync = require_sync();\n    module2.exports = async;\n  }\n});\nvar require_resolve2 = __commonJS2({\n  "src/common/resolve.js"(exports2, module2) {\n    "use strict";\n    var {\n      resolve\n    } = require;\n    if (resolve.length === 1 || process.env.PRETTIER_FALLBACK_RESOLVE) {\n      resolve = (id, options) => {\n        let basedir;\n        if (options && options.paths && options.paths.length === 1) {\n          basedir = options.paths[0];\n        }\n        return require_resolve().sync(id, {\n          basedir\n        });\n      };\n    }\n    module2.exports = resolve;\n  }\n});\nfunction mimicFunction(to, from, {\n  ignoreNonConfigurable = false\n} = {}) {\n  const {\n    name\n  } = to;\n  for (const property of Reflect.ownKeys(from)) {\n    copyProperty(to, from, property, ignoreNonConfigurable);\n  }\n  changePrototype(to, from);\n  changeToString(to, from, name);\n  return to;\n}\nvar copyProperty;\nvar canCopyProperty;\nvar changePrototype;\nvar wrappedToString;\nvar toStringDescriptor;\nvar toStringName;\nvar changeToString;\nvar init_mimic_fn = __esm({\n  "node_modules/mimic-fn/index.js"() {\n    copyProperty = (to, from, property, ignoreNonConfigurable) => {\n      if (property === "length" || property === "prototype") {\n        return;\n      }\n      if (property === "arguments" || property === "caller") {\n        return;\n      }\n      const toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n      const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n      if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n        return;\n      }\n      Object.defineProperty(to, property, fromDescriptor);\n    };\n    canCopyProperty = function(toDescriptor, fromDescriptor) {\n      return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);\n    };\n    changePrototype = (to, from) => {\n      const fromPrototype = Object.getPrototypeOf(from);\n      if (fromPrototype === Object.getPrototypeOf(to)) {\n        return;\n      }\n      Object.setPrototypeOf(to, fromPrototype);\n    };\n    wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\n${fromBody}`;\n    toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");\n    toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");\n    changeToString = (to, from, name) => {\n      const withName = name === "" ? "" : `with ${name.trim()}() `;\n      const newToString = wrappedToString.bind(null, withName, from.toString());\n      Object.defineProperty(newToString, "name", toStringName);\n      Object.defineProperty(to, "toString", Object.assign(Object.assign({}, toStringDescriptor), {}, {\n        value: newToString\n      }));\n    };\n  }\n});\nvar require_p_defer = __commonJS2({\n  "node_modules/p-defer/index.js"(exports2, module2) {\n    "use strict";\n    module2.exports = () => {\n      const ret = {};\n      ret.promise = new Promise((resolve, reject) => {\n        ret.resolve = resolve;\n        ret.reject = reject;\n      });\n      return ret;\n    };\n  }\n});\nvar require_dist = __commonJS2({\n  "node_modules/map-age-cleaner/dist/index.js"(exports2, module2) {\n    "use strict";\n    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator["throw"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function(resolve2) {\n            resolve2(result.value);\n          }).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {\n      return mod && mod.__esModule ? mod : {\n        "default": mod\n      };\n    };\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var p_defer_1 = __importDefault2(require_p_defer());\n    function mapAgeCleaner2(map, property = "maxAge") {\n      let processingKey;\n      let processingTimer;\n      let processingDeferred;\n      const cleanup = () => __awaiter2(this, void 0, void 0, function* () {\n        if (processingKey !== void 0) {\n          return;\n        }\n        const setupTimer = (item) => __awaiter2(this, void 0, void 0, function* () {\n          processingDeferred = p_defer_1.default();\n          const delay = item[1][property] - Date.now();\n          if (delay <= 0) {\n            map.delete(item[0]);\n            processingDeferred.resolve();\n            return;\n          }\n          processingKey = item[0];\n          processingTimer = setTimeout(() => {\n            map.delete(item[0]);\n            if (processingDeferred) {\n              processingDeferred.resolve();\n            }\n          }, delay);\n          if (typeof processingTimer.unref === "function") {\n            processingTimer.unref();\n          }\n          return processingDeferred.promise;\n        });\n        try {\n          for (const entry of map) {\n            yield setupTimer(entry);\n          }\n        } catch (_a) {\n        }\n        processingKey = void 0;\n      });\n      const reset = () => {\n        processingKey = void 0;\n        if (processingTimer !== void 0) {\n          clearTimeout(processingTimer);\n          processingTimer = void 0;\n        }\n        if (processingDeferred !== void 0) {\n          processingDeferred.reject(void 0);\n          processingDeferred = void 0;\n        }\n      };\n      const originalSet = map.set.bind(map);\n      map.set = (key, value) => {\n        if (map.has(key)) {\n          map.delete(key);\n        }\n        const result = originalSet(key, value);\n        if (processingKey && processingKey === key) {\n          reset();\n        }\n        cleanup();\n        return result;\n      };\n      cleanup();\n      return map;\n    }\n    exports2.default = mapAgeCleaner2;\n    module2.exports = mapAgeCleaner2;\n    module2.exports.default = mapAgeCleaner2;\n  }\n});\nvar dist_exports = {};\n__export(dist_exports, {\n  default: () => mem,\n  memClear: () => memClear,\n  memDecorator: () => memDecorator\n});\nfunction mem(fn, {\n  cacheKey,\n  cache = /* @__PURE__ */ new Map(),\n  maxAge\n} = {}) {\n  if (typeof maxAge === "number") {\n    (0, import_map_age_cleaner.default)(cache);\n  }\n  const memoized = function(...arguments_) {\n    const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\n    const cacheItem = cache.get(key);\n    if (cacheItem) {\n      return cacheItem.data;\n    }\n    const result = fn.apply(this, arguments_);\n    cache.set(key, {\n      data: result,\n      maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY\n    });\n    return result;\n  };\n  mimicFunction(memoized, fn, {\n    ignoreNonConfigurable: true\n  });\n  cacheStore.set(memoized, cache);\n  return memoized;\n}\nfunction memDecorator(options = {}) {\n  const instanceMap = /* @__PURE__ */ new WeakMap();\n  return (target, propertyKey, descriptor) => {\n    const input = target[propertyKey];\n    if (typeof input !== "function") {\n      throw new TypeError("The decorated value must be a function");\n    }\n    delete descriptor.value;\n    delete descriptor.writable;\n    descriptor.get = function() {\n      if (!instanceMap.has(this)) {\n        const value = mem(input, options);\n        instanceMap.set(this, value);\n        return value;\n      }\n      return instanceMap.get(this);\n    };\n  };\n}\nfunction memClear(fn) {\n  const cache = cacheStore.get(fn);\n  if (!cache) {\n    throw new TypeError("Can\'t clear a function that was not memoized!");\n  }\n  if (typeof cache.clear !== "function") {\n    throw new TypeError("The cache Map can\'t be cleared!");\n  }\n  cache.clear();\n}\nvar import_map_age_cleaner;\nvar cacheStore;\nvar init_dist = __esm({\n  "node_modules/mem/dist/index.js"() {\n    init_mimic_fn();\n    import_map_age_cleaner = __toESM(require_dist());\n    cacheStore = /* @__PURE__ */ new WeakMap();\n  }\n});\nvar require_pseudomap = __commonJS2({\n  "node_modules/pseudomap/pseudomap.js"(exports2, module2) {\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    module2.exports = PseudoMap;\n    function PseudoMap(set2) {\n      if (!(this instanceof PseudoMap))\n        throw new TypeError("Constructor PseudoMap requires \'new\'");\n      this.clear();\n      if (set2) {\n        if (set2 instanceof PseudoMap || typeof Map === "function" && set2 instanceof Map)\n          set2.forEach(function(value, key) {\n            this.set(key, value);\n          }, this);\n        else if (Array.isArray(set2))\n          set2.forEach(function(kv) {\n            this.set(kv[0], kv[1]);\n          }, this);\n        else\n          throw new TypeError("invalid argument");\n      }\n    }\n    PseudoMap.prototype.forEach = function(fn, thisp) {\n      thisp = thisp || this;\n      Object.keys(this._data).forEach(function(k) {\n        if (k !== "size")\n          fn.call(thisp, this._data[k].value, this._data[k].key);\n      }, this);\n    };\n    PseudoMap.prototype.has = function(k) {\n      return !!find(this._data, k);\n    };\n    PseudoMap.prototype.get = function(k) {\n      var res = find(this._data, k);\n      return res && res.value;\n    };\n    PseudoMap.prototype.set = function(k, v) {\n      set(this._data, k, v);\n    };\n    PseudoMap.prototype.delete = function(k) {\n      var res = find(this._data, k);\n      if (res) {\n        delete this._data[res._index];\n        this._data.size--;\n      }\n    };\n    PseudoMap.prototype.clear = function() {\n      var data = /* @__PURE__ */ Object.create(null);\n      data.size = 0;\n      Object.defineProperty(this, "_data", {\n        value: data,\n        enumerable: false,\n        configurable: true,\n        writable: false\n      });\n    };\n    Object.defineProperty(PseudoMap.prototype, "size", {\n      get: function() {\n        return this._data.size;\n      },\n      set: function(n) {\n      },\n      enumerable: true,\n      configurable: true\n    });\n    PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function() {\n      throw new Error("iterators are not implemented in this version");\n    };\n    function same(a, b) {\n      return a === b || a !== a && b !== b;\n    }\n    function Entry(k, v, i) {\n      this.key = k;\n      this.value = v;\n      this._index = i;\n    }\n    function find(data, k) {\n      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {\n        if (same(data[key].key, k))\n          return data[key];\n      }\n    }\n    function set(data, k, v) {\n      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {\n        if (same(data[key].key, k)) {\n          data[key].value = v;\n          return;\n        }\n      }\n      data.size++;\n      data[key] = new Entry(k, v, key);\n    }\n  }\n});\nvar require_map = __commonJS2({\n  "node_modules/pseudomap/map.js"(exports2, module2) {\n    if (process.env.npm_package_name === "pseudomap" && process.env.npm_lifecycle_script === "test")\n      process.env.TEST_PSEUDOMAP = "true";\n    if (typeof Map === "function" && !process.env.TEST_PSEUDOMAP) {\n      module2.exports = Map;\n    } else {\n      module2.exports = require_pseudomap();\n    }\n  }\n});\nvar require_yallist = __commonJS2({\n  "node_modules/editorconfig/node_modules/yallist/yallist.js"(exports2, module2) {\n    module2.exports = Yallist;\n    Yallist.Node = Node;\n    Yallist.create = Yallist;\n    function Yallist(list) {\n      var self2 = this;\n      if (!(self2 instanceof Yallist)) {\n        self2 = new Yallist();\n      }\n      self2.tail = null;\n      self2.head = null;\n      self2.length = 0;\n      if (list && typeof list.forEach === "function") {\n        list.forEach(function(item) {\n          self2.push(item);\n        });\n      } else if (arguments.length > 0) {\n        for (var i = 0, l = arguments.length; i < l; i++) {\n          self2.push(arguments[i]);\n        }\n      }\n      return self2;\n    }\n    Yallist.prototype.removeNode = function(node) {\n      if (node.list !== this) {\n        throw new Error("removing node which does not belong to this list");\n      }\n      var next = node.next;\n      var prev = node.prev;\n      if (next) {\n        next.prev = prev;\n      }\n      if (prev) {\n        prev.next = next;\n      }\n      if (node === this.head) {\n        this.head = next;\n      }\n      if (node === this.tail) {\n        this.tail = prev;\n      }\n      node.list.length--;\n      node.next = null;\n      node.prev = null;\n      node.list = null;\n    };\n    Yallist.prototype.unshiftNode = function(node) {\n      if (node === this.head) {\n        return;\n      }\n      if (node.list) {\n        node.list.removeNode(node);\n      }\n      var head = this.head;\n      node.list = this;\n      node.next = head;\n      if (head) {\n        head.prev = node;\n      }\n      this.head = node;\n      if (!this.tail) {\n        this.tail = node;\n      }\n      this.length++;\n    };\n    Yallist.prototype.pushNode = function(node) {\n      if (node === this.tail) {\n        return;\n      }\n      if (node.list) {\n        node.list.removeNode(node);\n      }\n      var tail = this.tail;\n      node.list = this;\n      node.prev = tail;\n      if (tail) {\n        tail.next = node;\n      }\n      this.tail = node;\n      if (!this.head) {\n        this.head = node;\n      }\n      this.length++;\n    };\n    Yallist.prototype.push = function() {\n      for (var i = 0, l = arguments.length; i < l; i++) {\n        push(this, arguments[i]);\n      }\n      return this.length;\n    };\n    Yallist.prototype.unshift = function() {\n      for (var i = 0, l = arguments.length; i < l; i++) {\n        unshift(this, arguments[i]);\n      }\n      return this.length;\n    };\n    Yallist.prototype.pop = function() {\n      if (!this.tail) {\n        return void 0;\n      }\n      var res = this.tail.value;\n      this.tail = this.tail.prev;\n      if (this.tail) {\n        this.tail.next = null;\n      } else {\n        this.head = null;\n      }\n      this.length--;\n      return res;\n    };\n    Yallist.prototype.shift = function() {\n      if (!this.head) {\n        return void 0;\n      }\n      var res = this.head.value;\n      this.head = this.head.next;\n      if (this.head) {\n        this.head.prev = null;\n      } else {\n        this.tail = null;\n      }\n      this.length--;\n      return res;\n    };\n    Yallist.prototype.forEach = function(fn, thisp) {\n      thisp = thisp || this;\n      for (var walker = this.head, i = 0; walker !== null; i++) {\n        fn.call(thisp, walker.value, i, this);\n        walker = walker.next;\n      }\n    };\n    Yallist.prototype.forEachReverse = function(fn, thisp) {\n      thisp = thisp || this;\n      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n        fn.call(thisp, walker.value, i, this);\n        walker = walker.prev;\n      }\n    };\n    Yallist.prototype.get = function(n) {\n      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n        walker = walker.next;\n      }\n      if (i === n && walker !== null) {\n        return walker.value;\n      }\n    };\n    Yallist.prototype.getReverse = function(n) {\n      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n        walker = walker.prev;\n      }\n      if (i === n && walker !== null) {\n        return walker.value;\n      }\n    };\n    Yallist.prototype.map = function(fn, thisp) {\n      thisp = thisp || this;\n      var res = new Yallist();\n      for (var walker = this.head; walker !== null; ) {\n        res.push(fn.call(thisp, walker.value, this));\n        walker = walker.next;\n      }\n      return res;\n    };\n    Yallist.prototype.mapReverse = function(fn, thisp) {\n      thisp = thisp || this;\n      var res = new Yallist();\n      for (var walker = this.tail; walker !== null; ) {\n        res.push(fn.call(thisp, walker.value, this));\n        walker = walker.prev;\n      }\n      return res;\n    };\n    Yallist.prototype.reduce = function(fn, initial) {\n      var acc;\n      var walker = this.head;\n      if (arguments.length > 1) {\n        acc = initial;\n      } else if (this.head) {\n        walker = this.head.next;\n        acc = this.head.value;\n      } else {\n        throw new TypeError("Reduce of empty list with no initial value");\n      }\n      for (var i = 0; walker !== null; i++) {\n        acc = fn(acc, walker.value, i);\n        walker = walker.next;\n      }\n      return acc;\n    };\n    Yallist.prototype.reduceReverse = function(fn, initial) {\n      var acc;\n      var walker = this.tail;\n      if (arguments.length > 1) {\n        acc = initial;\n      } else if (this.tail) {\n        walker = this.tail.prev;\n        acc = this.tail.value;\n      } else {\n        throw new TypeError("Reduce of empty list with no initial value");\n      }\n      for (var i = this.length - 1; walker !== null; i--) {\n        acc = fn(acc, walker.value, i);\n        walker = walker.prev;\n      }\n      return acc;\n    };\n    Yallist.prototype.toArray = function() {\n      var arr = new Array(this.length);\n      for (var i = 0, walker = this.head; walker !== null; i++) {\n        arr[i] = walker.value;\n        walker = walker.next;\n      }\n      return arr;\n    };\n    Yallist.prototype.toArrayReverse = function() {\n      var arr = new Array(this.length);\n      for (var i = 0, walker = this.tail; walker !== null; i++) {\n        arr[i] = walker.value;\n        walker = walker.prev;\n      }\n      return arr;\n    };\n    Yallist.prototype.slice = function(from, to) {\n      to = to || this.length;\n      if (to < 0) {\n        to += this.length;\n      }\n      from = from || 0;\n      if (from < 0) {\n        from += this.length;\n      }\n      var ret = new Yallist();\n      if (to < from || to < 0) {\n        return ret;\n      }\n      if (from < 0) {\n        from = 0;\n      }\n      if (to > this.length) {\n        to = this.length;\n      }\n      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n        walker = walker.next;\n      }\n      for (; walker !== null && i < to; i++, walker = walker.next) {\n        ret.push(walker.value);\n      }\n      return ret;\n    };\n    Yallist.prototype.sliceReverse = function(from, to) {\n      to = to || this.length;\n      if (to < 0) {\n        to += this.length;\n      }\n      from = from || 0;\n      if (from < 0) {\n        from += this.length;\n      }\n      var ret = new Yallist();\n      if (to < from || to < 0) {\n        return ret;\n      }\n      if (from < 0) {\n        from = 0;\n      }\n      if (to > this.length) {\n        to = this.length;\n      }\n      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n        walker = walker.prev;\n      }\n      for (; walker !== null && i > from; i--, walker = walker.prev) {\n        ret.push(walker.value);\n      }\n      return ret;\n    };\n    Yallist.prototype.reverse = function() {\n      var head = this.head;\n      var tail = this.tail;\n      for (var walker = head; walker !== null; walker = walker.prev) {\n        var p = walker.prev;\n        walker.prev = walker.next;\n        walker.next = p;\n      }\n      this.head = tail;\n      this.tail = head;\n      return this;\n    };\n    function push(self2, item) {\n      self2.tail = new Node(item, self2.tail, null, self2);\n      if (!self2.head) {\n        self2.head = self2.tail;\n      }\n      self2.length++;\n    }\n    function unshift(self2, item) {\n      self2.head = new Node(item, null, self2.head, self2);\n      if (!self2.tail) {\n        self2.tail = self2.head;\n      }\n      self2.length++;\n    }\n    function Node(value, prev, next, list) {\n      if (!(this instanceof Node)) {\n        return new Node(value, prev, next, list);\n      }\n      this.list = list;\n      this.value = value;\n      if (prev) {\n        prev.next = this;\n        this.prev = prev;\n      } else {\n        this.prev = null;\n      }\n      if (next) {\n        next.prev = this;\n        this.next = next;\n      } else {\n        this.next = null;\n      }\n    }\n  }\n});\nvar require_lru_cache = __commonJS2({\n  "node_modules/editorconfig/node_modules/lru-cache/index.js"(exports2, module2) {\n    "use strict";\n    module2.exports = LRUCache;\n    var Map2 = require_map();\n    var util = require("util");\n    var Yallist = require_yallist();\n    var hasSymbol = typeof Symbol === "function" && process.env._nodeLRUCacheForceNoSymbol !== "1";\n    var makeSymbol;\n    if (hasSymbol) {\n      makeSymbol = function(key) {\n        return Symbol(key);\n      };\n    } else {\n      makeSymbol = function(key) {\n        return "_" + key;\n      };\n    }\n    var MAX = makeSymbol("max");\n    var LENGTH = makeSymbol("length");\n    var LENGTH_CALCULATOR = makeSymbol("lengthCalculator");\n    var ALLOW_STALE = makeSymbol("allowStale");\n    var MAX_AGE = makeSymbol("maxAge");\n    var DISPOSE = makeSymbol("dispose");\n    var NO_DISPOSE_ON_SET = makeSymbol("noDisposeOnSet");\n    var LRU_LIST = makeSymbol("lruList");\n    var CACHE = makeSymbol("cache");\n    function naiveLength() {\n      return 1;\n    }\n    function LRUCache(options) {\n      if (!(this instanceof LRUCache)) {\n        return new LRUCache(options);\n      }\n      if (typeof options === "number") {\n        options = {\n          max: options\n        };\n      }\n      if (!options) {\n        options = {};\n      }\n      var max = this[MAX] = options.max;\n      if (!max || !(typeof max === "number") || max <= 0) {\n        this[MAX] = Infinity;\n      }\n      var lc = options.length || naiveLength;\n      if (typeof lc !== "function") {\n        lc = naiveLength;\n      }\n      this[LENGTH_CALCULATOR] = lc;\n      this[ALLOW_STALE] = options.stale || false;\n      this[MAX_AGE] = options.maxAge || 0;\n      this[DISPOSE] = options.dispose;\n      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;\n      this.reset();\n    }\n    Object.defineProperty(LRUCache.prototype, "max", {\n      set: function(mL) {\n        if (!mL || !(typeof mL === "number") || mL <= 0) {\n          mL = Infinity;\n        }\n        this[MAX] = mL;\n        trim(this);\n      },\n      get: function() {\n        return this[MAX];\n      },\n      enumerable: true\n    });\n    Object.defineProperty(LRUCache.prototype, "allowStale", {\n      set: function(allowStale) {\n        this[ALLOW_STALE] = !!allowStale;\n      },\n      get: function() {\n        return this[ALLOW_STALE];\n      },\n      enumerable: true\n    });\n    Object.defineProperty(LRUCache.prototype, "maxAge", {\n      set: function(mA) {\n        if (!mA || !(typeof mA === "number") || mA < 0) {\n          mA = 0;\n        }\n        this[MAX_AGE] = mA;\n        trim(this);\n      },\n      get: function() {\n        return this[MAX_AGE];\n      },\n      enumerable: true\n    });\n    Object.defineProperty(LRUCache.prototype, "lengthCalculator", {\n      set: function(lC) {\n        if (typeof lC !== "function") {\n          lC = naiveLength;\n        }\n        if (lC !== this[LENGTH_CALCULATOR]) {\n          this[LENGTH_CALCULATOR] = lC;\n          this[LENGTH] = 0;\n          this[LRU_LIST].forEach(function(hit) {\n            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);\n            this[LENGTH] += hit.length;\n          }, this);\n        }\n        trim(this);\n      },\n      get: function() {\n        return this[LENGTH_CALCULATOR];\n      },\n      enumerable: true\n    });\n    Object.defineProperty(LRUCache.prototype, "length", {\n      get: function() {\n        return this[LENGTH];\n      },\n      enumerable: true\n    });\n    Object.defineProperty(LRUCache.prototype, "itemCount", {\n      get: function() {\n        return this[LRU_LIST].length;\n      },\n      enumerable: true\n    });\n    LRUCache.prototype.rforEach = function(fn, thisp) {\n      thisp = thisp || this;\n      for (var walker = this[LRU_LIST].tail; walker !== null; ) {\n        var prev = walker.prev;\n        forEachStep(this, fn, walker, thisp);\n        walker = prev;\n      }\n    };\n    function forEachStep(self2, fn, node, thisp) {\n      var hit = node.value;\n      if (isStale(self2, hit)) {\n        del(self2, node);\n        if (!self2[ALLOW_STALE]) {\n          hit = void 0;\n        }\n      }\n      if (hit) {\n        fn.call(thisp, hit.value, hit.key, self2);\n      }\n    }\n    LRUCache.prototype.forEach = function(fn, thisp) {\n      thisp = thisp || this;\n      for (var walker = this[LRU_LIST].head; walker !== null; ) {\n        var next = walker.next;\n        forEachStep(this, fn, walker, thisp);\n        walker = next;\n      }\n    };\n    LRUCache.prototype.keys = function() {\n      return this[LRU_LIST].toArray().map(function(k) {\n        return k.key;\n      }, this);\n    };\n    LRUCache.prototype.values = function() {\n      return this[LRU_LIST].toArray().map(function(k) {\n        return k.value;\n      }, this);\n    };\n    LRUCache.prototype.reset = function() {\n      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {\n        this[LRU_LIST].forEach(function(hit) {\n          this[DISPOSE](hit.key, hit.value);\n        }, this);\n      }\n      this[CACHE] = new Map2();\n      this[LRU_LIST] = new Yallist();\n      this[LENGTH] = 0;\n    };\n    LRUCache.prototype.dump = function() {\n      return this[LRU_LIST].map(function(hit) {\n        if (!isStale(this, hit)) {\n          return {\n            k: hit.key,\n            v: hit.value,\n            e: hit.now + (hit.maxAge || 0)\n          };\n        }\n      }, this).toArray().filter(function(h) {\n        return h;\n      });\n    };\n    LRUCache.prototype.dumpLru = function() {\n      return this[LRU_LIST];\n    };\n    LRUCache.prototype.inspect = function(n, opts) {\n      var str = "LRUCache {";\n      var extras = false;\n      var as = this[ALLOW_STALE];\n      if (as) {\n        str += "\\n  allowStale: true";\n        extras = true;\n      }\n      var max = this[MAX];\n      if (max && max !== Infinity) {\n        if (extras) {\n          str += ",";\n        }\n        str += "\\n  max: " + util.inspect(max, opts);\n        extras = true;\n      }\n      var maxAge = this[MAX_AGE];\n      if (maxAge) {\n        if (extras) {\n          str += ",";\n        }\n        str += "\\n  maxAge: " + util.inspect(maxAge, opts);\n        extras = true;\n      }\n      var lc = this[LENGTH_CALCULATOR];\n      if (lc && lc !== naiveLength) {\n        if (extras) {\n          str += ",";\n        }\n        str += "\\n  length: " + util.inspect(this[LENGTH], opts);\n        extras = true;\n      }\n      var didFirst = false;\n      this[LRU_LIST].forEach(function(item) {\n        if (didFirst) {\n          str += ",\\n  ";\n        } else {\n          if (extras) {\n            str += ",\\n";\n          }\n          didFirst = true;\n          str += "\\n  ";\n        }\n        var key = util.inspect(item.key).split("\\n").join("\\n  ");\n        var val = {\n          value: item.value\n        };\n        if (item.maxAge !== maxAge) {\n          val.maxAge = item.maxAge;\n        }\n        if (lc !== naiveLength) {\n          val.length = item.length;\n        }\n        if (isStale(this, item)) {\n          val.stale = true;\n        }\n        val = util.inspect(val, opts).split("\\n").join("\\n  ");\n        str += key + " => " + val;\n      });\n      if (didFirst || extras) {\n        str += "\\n";\n      }\n      str += "}";\n      return str;\n    };\n    LRUCache.prototype.set = function(key, value, maxAge) {\n      maxAge = maxAge || this[MAX_AGE];\n      var now = maxAge ? Date.now() : 0;\n      var len = this[LENGTH_CALCULATOR](value, key);\n      if (this[CACHE].has(key)) {\n        if (len > this[MAX]) {\n          del(this, this[CACHE].get(key));\n          return false;\n        }\n        var node = this[CACHE].get(key);\n        var item = node.value;\n        if (this[DISPOSE]) {\n          if (!this[NO_DISPOSE_ON_SET]) {\n            this[DISPOSE](key, item.value);\n          }\n        }\n        item.now = now;\n        item.maxAge = maxAge;\n        item.value = value;\n        this[LENGTH] += len - item.length;\n        item.length = len;\n        this.get(key);\n        trim(this);\n        return true;\n      }\n      var hit = new Entry(key, value, len, now, maxAge);\n      if (hit.length > this[MAX]) {\n        if (this[DISPOSE]) {\n          this[DISPOSE](key, value);\n        }\n        return false;\n      }\n      this[LENGTH] += hit.length;\n      this[LRU_LIST].unshift(hit);\n      this[CACHE].set(key, this[LRU_LIST].head);\n      trim(this);\n      return true;\n    };\n    LRUCache.prototype.has = function(key) {\n      if (!this[CACHE].has(key))\n        return false;\n      var hit = this[CACHE].get(key).value;\n      if (isStale(this, hit)) {\n        return false;\n      }\n      return true;\n    };\n    LRUCache.prototype.get = function(key) {\n      return get(this, key, true);\n    };\n    LRUCache.prototype.peek = function(key) {\n      return get(this, key, false);\n    };\n    LRUCache.prototype.pop = function() {\n      var node = this[LRU_LIST].tail;\n      if (!node)\n        return null;\n      del(this, node);\n      return node.value;\n    };\n    LRUCache.prototype.del = function(key) {\n      del(this, this[CACHE].get(key));\n    };\n    LRUCache.prototype.load = function(arr) {\n      this.reset();\n      var now = Date.now();\n      for (var l = arr.length - 1; l >= 0; l--) {\n        var hit = arr[l];\n        var expiresAt = hit.e || 0;\n        if (expiresAt === 0) {\n          this.set(hit.k, hit.v);\n        } else {\n          var maxAge = expiresAt - now;\n          if (maxAge > 0) {\n            this.set(hit.k, hit.v, maxAge);\n          }\n        }\n      }\n    };\n    LRUCache.prototype.prune = function() {\n      var self2 = this;\n      this[CACHE].forEach(function(value, key) {\n        get(self2, key, false);\n      });\n    };\n    function get(self2, key, doUse) {\n      var node = self2[CACHE].get(key);\n      if (node) {\n        var hit = node.value;\n        if (isStale(self2, hit)) {\n          del(self2, node);\n          if (!self2[ALLOW_STALE])\n            hit = void 0;\n        } else {\n          if (doUse) {\n            self2[LRU_LIST].unshiftNode(node);\n          }\n        }\n        if (hit)\n          hit = hit.value;\n      }\n      return hit;\n    }\n    function isStale(self2, hit) {\n      if (!hit || !hit.maxAge && !self2[MAX_AGE]) {\n        return false;\n      }\n      var stale = false;\n      var diff = Date.now() - hit.now;\n      if (hit.maxAge) {\n        stale = diff > hit.maxAge;\n      } else {\n        stale = self2[MAX_AGE] && diff > self2[MAX_AGE];\n      }\n      return stale;\n    }\n    function trim(self2) {\n      if (self2[LENGTH] > self2[MAX]) {\n        for (var walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {\n          var prev = walker.prev;\n          del(self2, walker);\n          walker = prev;\n        }\n      }\n    }\n    function del(self2, node) {\n      if (node) {\n        var hit = node.value;\n        if (self2[DISPOSE]) {\n          self2[DISPOSE](hit.key, hit.value);\n        }\n        self2[LENGTH] -= hit.length;\n        self2[CACHE].delete(hit.key);\n        self2[LRU_LIST].removeNode(node);\n      }\n    }\n    function Entry(key, value, length, now, maxAge) {\n      this.key = key;\n      this.value = value;\n      this.length = length;\n      this.now = now;\n      this.maxAge = maxAge || 0;\n    }\n  }\n});\nvar require_sigmund = __commonJS2({\n  "node_modules/sigmund/sigmund.js"(exports2, module2) {\n    module2.exports = sigmund;\n    function sigmund(subject, maxSessions) {\n      maxSessions = maxSessions || 10;\n      var notes = [];\n      var analysis = "";\n      var RE = RegExp;\n      function psychoAnalyze(subject2, session) {\n        if (session > maxSessions)\n          return;\n        if (typeof subject2 === "function" || typeof subject2 === "undefined") {\n          return;\n        }\n        if (typeof subject2 !== "object" || !subject2 || subject2 instanceof RE) {\n          analysis += subject2;\n          return;\n        }\n        if (notes.indexOf(subject2) !== -1 || session === maxSessions)\n          return;\n        notes.push(subject2);\n        analysis += "{";\n        Object.keys(subject2).forEach(function(issue, _, __) {\n          if (issue.charAt(0) === "_")\n            return;\n          var to = typeof subject2[issue];\n          if (to === "function" || to === "undefined")\n            return;\n          analysis += issue;\n          psychoAnalyze(subject2[issue], session + 1);\n        });\n      }\n      psychoAnalyze(subject, 0);\n      return analysis;\n    }\n  }\n});\nvar require_fnmatch = __commonJS2({\n  "node_modules/editorconfig/src/lib/fnmatch.js"(exports2, module2) {\n    var platform = typeof process === "object" ? process.platform : "win32";\n    if (module2)\n      module2.exports = minimatch;\n    else\n      exports2.minimatch = minimatch;\n    minimatch.Minimatch = Minimatch;\n    var LRU = require_lru_cache();\n    var cache = minimatch.cache = new LRU({\n      max: 100\n    });\n    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};\n    var sigmund = require_sigmund();\n    var path = require("path");\n    var qmark = "[^/]";\n    var star = qmark + "*?";\n    var twoStarDot = "(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?";\n    var twoStarNoDot = "(?:(?!(?:\\\\/|^)\\\\.).)*?";\n    var reSpecials = charSet("().*{}+?[]^$\\\\!");\n    function charSet(s) {\n      return s.split("").reduce(function(set, c) {\n        set[c] = true;\n        return set;\n      }, {});\n    }\n    var slashSplit = /\\/+/;\n    minimatch.monkeyPatch = monkeyPatch;\n    function monkeyPatch() {\n      var desc = Object.getOwnPropertyDescriptor(String.prototype, "match");\n      var orig = desc.value;\n      desc.value = function(p) {\n        if (p instanceof Minimatch)\n          return p.match(this);\n        return orig.call(this, p);\n      };\n      Object.defineProperty(String.prototype, desc);\n    }\n    minimatch.filter = filter;\n    function filter(pattern, options) {\n      options = options || {};\n      return function(p, i, list) {\n        return minimatch(p, pattern, options);\n      };\n    }\n    function ext(a, b) {\n      a = a || {};\n      b = b || {};\n      var t = {};\n      Object.keys(b).forEach(function(k) {\n        t[k] = b[k];\n      });\n      Object.keys(a).forEach(function(k) {\n        t[k] = a[k];\n      });\n      return t;\n    }\n    minimatch.defaults = function(def) {\n      if (!def || !Object.keys(def).length)\n        return minimatch;\n      var orig = minimatch;\n      var m = function minimatch2(p, pattern, options) {\n        return orig.minimatch(p, pattern, ext(def, options));\n      };\n      m.Minimatch = function Minimatch2(pattern, options) {\n        return new orig.Minimatch(pattern, ext(def, options));\n      };\n      return m;\n    };\n    Minimatch.defaults = function(def) {\n      if (!def || !Object.keys(def).length)\n        return Minimatch;\n      return minimatch.defaults(def).Minimatch;\n    };\n    function minimatch(p, pattern, options) {\n      if (typeof pattern !== "string") {\n        throw new TypeError("glob pattern string required");\n      }\n      if (!options)\n        options = {};\n      if (!options.nocomment && pattern.charAt(0) === "#") {\n        return false;\n      }\n      if (pattern.trim() === "")\n        return p === "";\n      return new Minimatch(pattern, options).match(p);\n    }\n    function Minimatch(pattern, options) {\n      if (!(this instanceof Minimatch)) {\n        return new Minimatch(pattern, options, cache);\n      }\n      if (typeof pattern !== "string") {\n        throw new TypeError("glob pattern string required");\n      }\n      if (!options)\n        options = {};\n      if (platform === "win32") {\n        pattern = pattern.split("\\\\").join("/");\n      }\n      var cacheKey = pattern + "\\n" + sigmund(options);\n      var cached = minimatch.cache.get(cacheKey);\n      if (cached)\n        return cached;\n      minimatch.cache.set(cacheKey, this);\n      this.options = options;\n      this.set = [];\n      this.pattern = pattern;\n      this.regexp = null;\n      this.negate = false;\n      this.comment = false;\n      this.empty = false;\n      this.make();\n    }\n    Minimatch.prototype.make = make;\n    function make() {\n      if (this._made)\n        return;\n      var pattern = this.pattern;\n      var options = this.options;\n      if (!options.nocomment && pattern.charAt(0) === "#") {\n        this.comment = true;\n        return;\n      }\n      if (!pattern) {\n        this.empty = true;\n        return;\n      }\n      this.parseNegate();\n      var set = this.globSet = this.braceExpand();\n      if (options.debug)\n        console.error(this.pattern, set);\n      set = this.globParts = set.map(function(s) {\n        return s.split(slashSplit);\n      });\n      if (options.debug)\n        console.error(this.pattern, set);\n      set = set.map(function(s, si, set2) {\n        return s.map(this.parse, this);\n      }, this);\n      if (options.debug)\n        console.error(this.pattern, set);\n      set = set.filter(function(s) {\n        return -1 === s.indexOf(false);\n      });\n      if (options.debug)\n        console.error(this.pattern, set);\n      this.set = set;\n    }\n    Minimatch.prototype.parseNegate = parseNegate;\n    function parseNegate() {\n      var pattern = this.pattern, negate = false, options = this.options, negateOffset = 0;\n      if (options.nonegate)\n        return;\n      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {\n        negate = !negate;\n        negateOffset++;\n      }\n      if (negateOffset)\n        this.pattern = pattern.substr(negateOffset);\n      this.negate = negate;\n    }\n    minimatch.braceExpand = function(pattern, options) {\n      return new Minimatch(pattern, options).braceExpand();\n    };\n    Minimatch.prototype.braceExpand = braceExpand;\n    function braceExpand(pattern, options) {\n      options = options || this.options;\n      pattern = typeof pattern === "undefined" ? this.pattern : pattern;\n      if (typeof pattern === "undefined") {\n        throw new Error("undefined pattern");\n      }\n      if (options.nobrace || !pattern.match(/\\{.*\\}/)) {\n        return [pattern];\n      }\n      var escaping = false;\n      if (pattern.charAt(0) !== "{") {\n        var prefix = null;\n        for (var i = 0, l = pattern.length; i < l; i++) {\n          var c = pattern.charAt(i);\n          if (c === "\\\\") {\n            escaping = !escaping;\n          } else if (c === "{" && !escaping) {\n            prefix = pattern.substr(0, i);\n            break;\n          }\n        }\n        if (prefix === null) {\n          return [pattern];\n        }\n        var tail = braceExpand(pattern.substr(i), options);\n        return tail.map(function(t) {\n          return prefix + t;\n        });\n      }\n      var numset = pattern.match(/^\\{(-?[0-9]+)\\.\\.(-?[0-9]+)\\}/);\n      if (numset) {\n        var suf = braceExpand(pattern.substr(numset[0].length), options), start = +numset[1], end = +numset[2], inc = start > end ? -1 : 1, set = [];\n        for (var i = start; i != end + inc; i += inc) {\n          for (var ii = 0, ll = suf.length; ii < ll; ii++) {\n            set.push(i + suf[ii]);\n          }\n        }\n        return set;\n      }\n      var i = 1, depth = 1, set = [], member = "", sawEnd = false, escaping = false;\n      function addMember() {\n        set.push(member);\n        member = "";\n      }\n      FOR:\n        for (i = 1, l = pattern.length; i < l; i++) {\n          var c = pattern.charAt(i);\n          if (escaping) {\n            escaping = false;\n            member += "\\\\" + c;\n          } else {\n            switch (c) {\n              case "\\\\":\n                escaping = true;\n                continue;\n              case "{":\n                depth++;\n                member += "{";\n                continue;\n              case "}":\n                depth--;\n                if (depth === 0) {\n                  addMember();\n                  i++;\n                  break FOR;\n                } else {\n                  member += c;\n                  continue;\n                }\n              case ",":\n                if (depth === 1) {\n                  addMember();\n                } else {\n                  member += c;\n                }\n                continue;\n              default:\n                member += c;\n                continue;\n            }\n          }\n        }\n      if (depth !== 0) {\n        return braceExpand("\\\\" + pattern, options);\n      }\n      var suf = braceExpand(pattern.substr(i), options);\n      var addBraces = set.length === 1;\n      set = set.map(function(p) {\n        return braceExpand(p, options);\n      });\n      set = set.reduce(function(l2, r) {\n        return l2.concat(r);\n      });\n      if (addBraces) {\n        set = set.map(function(s) {\n          return "{" + s + "}";\n        });\n      }\n      var ret = [];\n      for (var i = 0, l = set.length; i < l; i++) {\n        for (var ii = 0, ll = suf.length; ii < ll; ii++) {\n          ret.push(set[i] + suf[ii]);\n        }\n      }\n      return ret;\n    }\n    Minimatch.prototype.parse = parse;\n    var SUBPARSE = {};\n    function parse(pattern, isSub) {\n      var options = this.options;\n      if (!options.noglobstar && pattern === "**")\n        return GLOBSTAR;\n      if (pattern === "")\n        return "";\n      var re = "", hasMagic = !!options.nocase, escaping = false, patternListStack = [], plType, stateChar, inClass = false, reClassStart = -1, classStart = -1, patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))" : "(?!\\\\.)";\n      function clearStateChar() {\n        if (stateChar) {\n          switch (stateChar) {\n            case "*":\n              re += star;\n              hasMagic = true;\n              break;\n            case "?":\n              re += qmark;\n              hasMagic = true;\n              break;\n            default:\n              re += "\\\\" + stateChar;\n              break;\n          }\n          stateChar = false;\n        }\n      }\n      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {\n        if (options.debug) {\n          console.error("%s\t%s %s %j", pattern, i, re, c);\n        }\n        if (escaping && reSpecials[c]) {\n          re += "\\\\" + c;\n          escaping = false;\n          continue;\n        }\n        SWITCH:\n          switch (c) {\n            case "/":\n              return false;\n            case "\\\\":\n              clearStateChar();\n              escaping = true;\n              continue;\n            case "?":\n            case "*":\n            case "+":\n            case "@":\n            case "!":\n              if (options.debug) {\n                console.error("%s\t%s %s %j <-- stateChar", pattern, i, re, c);\n              }\n              if (inClass) {\n                if (c === "!" && i === classStart + 1)\n                  c = "^";\n                re += c;\n                continue;\n              }\n              clearStateChar();\n              stateChar = c;\n              if (options.noext)\n                clearStateChar();\n              continue;\n            case "(":\n              if (inClass) {\n                re += "(";\n                continue;\n              }\n              if (!stateChar) {\n                re += "\\\\(";\n                continue;\n              }\n              plType = stateChar;\n              patternListStack.push({\n                type: plType,\n                start: i - 1,\n                reStart: re.length\n              });\n              re += stateChar === "!" ? "(?:(?!" : "(?:";\n              stateChar = false;\n              continue;\n            case ")":\n              if (inClass || !patternListStack.length) {\n                re += "\\\\)";\n                continue;\n              }\n              hasMagic = true;\n              re += ")";\n              plType = patternListStack.pop().type;\n              switch (plType) {\n                case "!":\n                  re += "[^/]*?)";\n                  break;\n                case "?":\n                case "+":\n                case "*":\n                  re += plType;\n                case "@":\n                  break;\n              }\n              continue;\n            case "|":\n              if (inClass || !patternListStack.length || escaping) {\n                re += "\\\\|";\n                escaping = false;\n                continue;\n              }\n              re += "|";\n              continue;\n            case "[":\n              clearStateChar();\n              if (inClass) {\n                re += "\\\\" + c;\n                continue;\n              }\n              inClass = true;\n              classStart = i;\n              reClassStart = re.length;\n              re += c;\n              continue;\n            case "]":\n              if (i === classStart + 1 || !inClass) {\n                re += "\\\\" + c;\n                escaping = false;\n                continue;\n              }\n              hasMagic = true;\n              inClass = false;\n              re += c;\n              continue;\n            default:\n              clearStateChar();\n              if (escaping) {\n                escaping = false;\n              } else if (reSpecials[c] && !(c === "^" && inClass)) {\n                re += "\\\\";\n              }\n              re += c;\n          }\n      }\n      if (inClass) {\n        var cs = pattern.substr(classStart + 1), sp = this.parse(cs, SUBPARSE);\n        re = re.substr(0, reClassStart) + "\\\\[" + sp[0];\n        hasMagic = hasMagic || sp[1];\n      }\n      var pl;\n      while (pl = patternListStack.pop()) {\n        var tail = re.slice(pl.reStart + 3);\n        tail = tail.replace(/((?:\\\\{2})*)(\\\\?)\\|/g, function(_, $1, $2) {\n          if (!$2) {\n            $2 = "\\\\";\n          }\n          return $1 + $1 + $2 + "|";\n        });\n        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\\\" + pl.type;\n        hasMagic = true;\n        re = re.slice(0, pl.reStart) + t + "\\\\(" + tail;\n      }\n      clearStateChar();\n      if (escaping) {\n        re += "\\\\\\\\";\n      }\n      var addPatternStart = false;\n      switch (re.charAt(0)) {\n        case ".":\n        case "[":\n        case "(":\n          addPatternStart = true;\n      }\n      if (re !== "" && hasMagic)\n        re = "(?=.)" + re;\n      if (addPatternStart)\n        re = patternStart + re;\n      if (isSub === SUBPARSE) {\n        return [re, hasMagic];\n      }\n      if (!hasMagic) {\n        return globUnescape(pattern);\n      }\n      var flags = options.nocase ? "i" : "", regExp = new RegExp("^" + re + "$", flags);\n      regExp._glob = pattern;\n      regExp._src = re;\n      return regExp;\n    }\n    minimatch.makeRe = function(pattern, options) {\n      return new Minimatch(pattern, options || {}).makeRe();\n    };\n    Minimatch.prototype.makeRe = makeRe;\n    function makeRe() {\n      if (this.regexp || this.regexp === false)\n        return this.regexp;\n      var set = this.set;\n      if (!set.length)\n        return this.regexp = false;\n      var options = this.options;\n      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot, flags = options.nocase ? "i" : "";\n      var re = set.map(function(pattern) {\n        return pattern.map(function(p) {\n          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;\n        }).join("\\\\/");\n      }).join("|");\n      re = "^(?:" + re + ")$";\n      if (this.negate)\n        re = "^(?!" + re + ").*$";\n      try {\n        return this.regexp = new RegExp(re, flags);\n      } catch (ex) {\n        return this.regexp = false;\n      }\n    }\n    minimatch.match = function(list, pattern, options) {\n      var mm = new Minimatch(pattern, options);\n      list = list.filter(function(f) {\n        return mm.match(f);\n      });\n      if (options.nonull && !list.length) {\n        list.push(pattern);\n      }\n      return list;\n    };\n    Minimatch.prototype.match = match;\n    function match(f, partial) {\n      if (this.comment)\n        return false;\n      if (this.empty)\n        return f === "";\n      if (f === "/" && partial)\n        return true;\n      var options = this.options;\n      if (platform === "win32") {\n        f = f.split("\\\\").join("/");\n      }\n      f = f.split(slashSplit);\n      if (options.debug) {\n        console.error(this.pattern, "split", f);\n      }\n      var set = this.set;\n      for (var i = 0, l = set.length; i < l; i++) {\n        var pattern = set[i];\n        var hit = this.matchOne(f, pattern, partial);\n        if (hit) {\n          if (options.flipNegate)\n            return true;\n          return !this.negate;\n        }\n      }\n      if (options.flipNegate)\n        return false;\n      return this.negate;\n    }\n    Minimatch.prototype.matchOne = function(file, pattern, partial) {\n      var options = this.options;\n      if (options.debug) {\n        console.error("matchOne", {\n          "this": this,\n          file,\n          pattern\n        });\n      }\n      if (options.matchBase && pattern.length === 1) {\n        file = path.basename(file.join("/")).split("/");\n      }\n      if (options.debug) {\n        console.error("matchOne", file.length, pattern.length);\n      }\n      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n        if (options.debug) {\n          console.error("matchOne loop");\n        }\n        var p = pattern[pi], f = file[fi];\n        if (options.debug) {\n          console.error(pattern, p, f);\n        }\n        if (p === false)\n          return false;\n        if (p === GLOBSTAR) {\n          if (options.debug)\n            console.error("GLOBSTAR", [pattern, p, f]);\n          var fr = fi, pr = pi + 1;\n          if (pr === pl) {\n            if (options.debug)\n              console.error("** at the end");\n            for (; fi < fl; fi++) {\n              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")\n                return false;\n            }\n            return true;\n          }\n          WHILE:\n            while (fr < fl) {\n              var swallowee = file[fr];\n              if (options.debug) {\n                console.error("\\nglobstar while", file, fr, pattern, pr, swallowee);\n              }\n              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                if (options.debug)\n                  console.error("globstar found match!", fr, fl, swallowee);\n                return true;\n              } else {\n                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {\n                  if (options.debug)\n                    console.error("dot detected!", file, fr, pattern, pr);\n                  break WHILE;\n                }\n                if (options.debug)\n                  console.error("globstar swallow a segment, and continue");\n                fr++;\n              }\n            }\n          if (partial) {\n            if (fr === fl)\n              return true;\n          }\n          return false;\n        }\n        var hit;\n        if (typeof p === "string") {\n          if (options.nocase) {\n            hit = f.toLowerCase() === p.toLowerCase();\n          } else {\n            hit = f === p;\n          }\n          if (options.debug) {\n            console.error("string match", p, f, hit);\n          }\n        } else {\n          hit = f.match(p);\n          if (options.debug) {\n            console.error("pattern match", p, f, hit);\n          }\n        }\n        if (!hit)\n          return false;\n      }\n      if (fi === fl && pi === pl) {\n        return true;\n      } else if (fi === fl) {\n        return partial;\n      } else if (pi === pl) {\n        var emptyFileEnd = fi === fl - 1 && file[fi] === "";\n        return emptyFileEnd;\n      }\n      throw new Error("wtf?");\n    };\n    function globUnescape(s) {\n      return s.replace(/\\\\(.)/g, "$1");\n    }\n    function regExpEscape(s) {\n      return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, "\\\\$&");\n    }\n  }\n});\nvar require_ini = __commonJS2({\n  "node_modules/editorconfig/src/lib/ini.js"(exports2) {\n    "use strict";\n    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator["throw"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function(resolve2) {\n            resolve2(result.value);\n          }).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function() {\n          if (t[0] & 1)\n            throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      }, f, y, t, g;\n      return g = {\n        next: verb(0),\n        "throw": verb(1),\n        "return": verb(2)\n      }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n) {\n        return function(v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError("Generator is already executing.");\n        while (_)\n          try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n              return t;\n            if (y = 0, t)\n              op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return {\n                  value: op[1],\n                  done: false\n                };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n    var __importStar2 = exports2 && exports2.__importStar || function(mod) {\n      if (mod && mod.__esModule)\n        return mod;\n      var result = {};\n      if (mod != null) {\n        for (var k in mod)\n          if (Object.hasOwnProperty.call(mod, k))\n            result[k] = mod[k];\n      }\n      result["default"] = mod;\n      return result;\n    };\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var fs = __importStar2(require("fs"));\n    var regex = {\n      section: /^\\s*\\[(([^#;]|\\\\#|\\\\;)+)\\]\\s*([#;].*)?$/,\n      param: /^\\s*([\\w\\.\\-\\_]+)\\s*[=:]\\s*(.*?)\\s*([#;].*)?$/,\n      comment: /^\\s*[#;].*$/\n    };\n    function parse(file) {\n      return __awaiter2(this, void 0, void 0, function() {\n        return __generator2(this, function(_a) {\n          return [2, new Promise(function(resolve, reject) {\n            fs.readFile(file, "utf8", function(err, data) {\n              if (err) {\n                reject(err);\n                return;\n              }\n              resolve(parseString(data));\n            });\n          })];\n        });\n      });\n    }\n    exports2.parse = parse;\n    function parseSync(file) {\n      return parseString(fs.readFileSync(file, "utf8"));\n    }\n    exports2.parseSync = parseSync;\n    function parseString(data) {\n      var sectionBody = {};\n      var sectionName = null;\n      var value = [[sectionName, sectionBody]];\n      var lines = data.split(/\\r\\n|\\r|\\n/);\n      lines.forEach(function(line) {\n        var match;\n        if (regex.comment.test(line)) {\n          return;\n        }\n        if (regex.param.test(line)) {\n          match = line.match(regex.param);\n          sectionBody[match[1]] = match[2];\n        } else if (regex.section.test(line)) {\n          match = line.match(regex.section);\n          sectionName = match[1];\n          sectionBody = {};\n          value.push([sectionName, sectionBody]);\n        }\n      });\n      return value;\n    }\n    exports2.parseString = parseString;\n  }\n});\nvar require_package = __commonJS2({\n  "node_modules/editorconfig/package.json"(exports2, module2) {\n    module2.exports = {\n      name: "editorconfig",\n      version: "0.15.3",\n      description: "EditorConfig File Locator and Interpreter for Node.js",\n      keywords: ["editorconfig", "core"],\n      main: "src/index.js",\n      contributors: ["Hong Xu (topbug.net)", "Jed Mao (https://github.com/jedmao/)", "Trey Hunner (http://treyhunner.com)"],\n      directories: {\n        bin: "./bin",\n        lib: "./lib"\n      },\n      scripts: {\n        clean: "rimraf dist",\n        prebuild: "npm run clean",\n        build: "tsc",\n        pretest: "npm run lint && npm run build && npm run copy && cmake .",\n        test: "ctest .",\n        "pretest:ci": "npm run pretest",\n        "test:ci": "ctest -VV --output-on-failure .",\n        lint: "npm run eclint && npm run tslint",\n        eclint: \'eclint check --indent_size ignore "src/**"\',\n        tslint: "tslint --project tsconfig.json --exclude package.json",\n        copy: "cpy .npmignore LICENSE README.md CHANGELOG.md dist && cpy bin/* dist/bin && cpy src/lib/fnmatch*.* dist/src/lib",\n        prepub: "npm run lint && npm run build && npm run copy",\n        pub: "npm publish ./dist"\n      },\n      repository: {\n        type: "git",\n        url: "git://github.com/editorconfig/editorconfig-core-js.git"\n      },\n      bugs: "https://github.com/editorconfig/editorconfig-core-js/issues",\n      author: "EditorConfig Team",\n      license: "MIT",\n      dependencies: {\n        commander: "^2.19.0",\n        "lru-cache": "^4.1.5",\n        semver: "^5.6.0",\n        sigmund: "^1.0.1"\n      },\n      devDependencies: {\n        "@types/mocha": "^5.2.6",\n        "@types/node": "^10.12.29",\n        "@types/semver": "^5.5.0",\n        "cpy-cli": "^2.0.0",\n        eclint: "^2.8.1",\n        mocha: "^5.2.0",\n        rimraf: "^2.6.3",\n        should: "^13.2.3",\n        tslint: "^5.13.1",\n        typescript: "^3.3.3333"\n      }\n    };\n  }\n});\nvar require_src2 = __commonJS2({\n  "node_modules/editorconfig/src/index.js"(exports2) {\n    "use strict";\n    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {\n      return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n          try {\n            step(generator.next(value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function rejected(value) {\n          try {\n            step(generator["throw"](value));\n          } catch (e) {\n            reject(e);\n          }\n        }\n        function step(result) {\n          result.done ? resolve(result.value) : new P(function(resolve2) {\n            resolve2(result.value);\n          }).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n      });\n    };\n    var __generator2 = exports2 && exports2.__generator || function(thisArg, body) {\n      var _ = {\n        label: 0,\n        sent: function() {\n          if (t[0] & 1)\n            throw t[1];\n          return t[1];\n        },\n        trys: [],\n        ops: []\n      }, f, y, t, g;\n      return g = {\n        next: verb(0),\n        "throw": verb(1),\n        "return": verb(2)\n      }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {\n        return this;\n      }), g;\n      function verb(n) {\n        return function(v) {\n          return step([n, v]);\n        };\n      }\n      function step(op) {\n        if (f)\n          throw new TypeError("Generator is already executing.");\n        while (_)\n          try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)\n              return t;\n            if (y = 0, t)\n              op = [op[0] & 2, t.value];\n            switch (op[0]) {\n              case 0:\n              case 1:\n                t = op;\n                break;\n              case 4:\n                _.label++;\n                return {\n                  value: op[1],\n                  done: false\n                };\n              case 5:\n                _.label++;\n                y = op[1];\n                op = [0];\n                continue;\n              case 7:\n                op = _.ops.pop();\n                _.trys.pop();\n                continue;\n              default:\n                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                  _ = 0;\n                  continue;\n                }\n                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                  _.label = op[1];\n                  break;\n                }\n                if (op[0] === 6 && _.label < t[1]) {\n                  _.label = t[1];\n                  t = op;\n                  break;\n                }\n                if (t && _.label < t[2]) {\n                  _.label = t[2];\n                  _.ops.push(op);\n                  break;\n                }\n                if (t[2])\n                  _.ops.pop();\n                _.trys.pop();\n                continue;\n            }\n            op = body.call(thisArg, _);\n          } catch (e) {\n            op = [6, e];\n            y = 0;\n          } finally {\n            f = t = 0;\n          }\n        if (op[0] & 5)\n          throw op[1];\n        return {\n          value: op[0] ? op[1] : void 0,\n          done: true\n        };\n      }\n    };\n    var __importStar2 = exports2 && exports2.__importStar || function(mod) {\n      if (mod && mod.__esModule)\n        return mod;\n      var result = {};\n      if (mod != null) {\n        for (var k in mod)\n          if (Object.hasOwnProperty.call(mod, k))\n            result[k] = mod[k];\n      }\n      result["default"] = mod;\n      return result;\n    };\n    var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {\n      return mod && mod.__esModule ? mod : {\n        "default": mod\n      };\n    };\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var fs = __importStar2(require("fs"));\n    var path = __importStar2(require("path"));\n    var semver = {\n      gte: require_gte()\n    };\n    var fnmatch_1 = __importDefault2(require_fnmatch());\n    var ini_1 = require_ini();\n    exports2.parseString = ini_1.parseString;\n    var package_json_1 = __importDefault2(require_package());\n    var knownProps = {\n      end_of_line: true,\n      indent_style: true,\n      indent_size: true,\n      insert_final_newline: true,\n      trim_trailing_whitespace: true,\n      charset: true\n    };\n    function fnmatch(filepath, glob) {\n      var matchOptions = {\n        matchBase: true,\n        dot: true,\n        noext: true\n      };\n      glob = glob.replace(/\\*\\*/g, "{*,**/**/**}");\n      return fnmatch_1.default(filepath, glob, matchOptions);\n    }\n    function getConfigFileNames(filepath, options) {\n      var paths = [];\n      do {\n        filepath = path.dirname(filepath);\n        paths.push(path.join(filepath, options.config));\n      } while (filepath !== options.root);\n      return paths;\n    }\n    function processMatches(matches, version2) {\n      if ("indent_style" in matches && matches.indent_style === "tab" && !("indent_size" in matches) && semver.gte(version2, "0.10.0")) {\n        matches.indent_size = "tab";\n      }\n      if ("indent_size" in matches && !("tab_width" in matches) && matches.indent_size !== "tab") {\n        matches.tab_width = matches.indent_size;\n      }\n      if ("indent_size" in matches && "tab_width" in matches && matches.indent_size === "tab") {\n        matches.indent_size = matches.tab_width;\n      }\n      return matches;\n    }\n    function processOptions(options, filepath) {\n      if (options === void 0) {\n        options = {};\n      }\n      return {\n        config: options.config || ".editorconfig",\n        version: options.version || package_json_1.default.version,\n        root: path.resolve(options.root || path.parse(filepath).root)\n      };\n    }\n    function buildFullGlob(pathPrefix, glob) {\n      switch (glob.indexOf("/")) {\n        case -1:\n          glob = "**/" + glob;\n          break;\n        case 0:\n          glob = glob.substring(1);\n          break;\n        default:\n          break;\n      }\n      return path.join(pathPrefix, glob);\n    }\n    function extendProps(props, options) {\n      if (props === void 0) {\n        props = {};\n      }\n      if (options === void 0) {\n        options = {};\n      }\n      for (var key in options) {\n        if (options.hasOwnProperty(key)) {\n          var value = options[key];\n          var key2 = key.toLowerCase();\n          var value2 = value;\n          if (knownProps[key2]) {\n            value2 = value.toLowerCase();\n          }\n          try {\n            value2 = JSON.parse(value);\n          } catch (e) {\n          }\n          if (typeof value === "undefined" || value === null) {\n            value2 = String(value);\n          }\n          props[key2] = value2;\n        }\n      }\n      return props;\n    }\n    function parseFromConfigs(configs, filepath, options) {\n      return processMatches(configs.reverse().reduce(function(matches, file) {\n        var pathPrefix = path.dirname(file.name);\n        file.contents.forEach(function(section) {\n          var glob = section[0];\n          var options2 = section[1];\n          if (!glob) {\n            return;\n          }\n          var fullGlob = buildFullGlob(pathPrefix, glob);\n          if (!fnmatch(filepath, fullGlob)) {\n            return;\n          }\n          matches = extendProps(matches, options2);\n        });\n        return matches;\n      }, {}), options.version);\n    }\n    function getConfigsForFiles(files) {\n      var configs = [];\n      for (var i in files) {\n        if (files.hasOwnProperty(i)) {\n          var file = files[i];\n          var contents = ini_1.parseString(file.contents);\n          configs.push({\n            name: file.name,\n            contents\n          });\n          if ((contents[0][1].root || "").toLowerCase() === "true") {\n            break;\n          }\n        }\n      }\n      return configs;\n    }\n    function readConfigFiles(filepaths) {\n      return __awaiter2(this, void 0, void 0, function() {\n        return __generator2(this, function(_a) {\n          return [2, Promise.all(filepaths.map(function(name) {\n            return new Promise(function(resolve) {\n              fs.readFile(name, "utf8", function(err, data) {\n                resolve({\n                  name,\n                  contents: err ? "" : data\n                });\n              });\n            });\n          }))];\n        });\n      });\n    }\n    function readConfigFilesSync(filepaths) {\n      var files = [];\n      var file;\n      filepaths.forEach(function(filepath) {\n        try {\n          file = fs.readFileSync(filepath, "utf8");\n        } catch (e) {\n          file = "";\n        }\n        files.push({\n          name: filepath,\n          contents: file\n        });\n      });\n      return files;\n    }\n    function opts(filepath, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      var resolvedFilePath = path.resolve(filepath);\n      return [resolvedFilePath, processOptions(options, resolvedFilePath)];\n    }\n    function parseFromFiles(filepath, files, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      return __awaiter2(this, void 0, void 0, function() {\n        var _a, resolvedFilePath, processedOptions;\n        return __generator2(this, function(_b) {\n          _a = opts(filepath, options), resolvedFilePath = _a[0], processedOptions = _a[1];\n          return [2, files.then(getConfigsForFiles).then(function(configs) {\n            return parseFromConfigs(configs, resolvedFilePath, processedOptions);\n          })];\n        });\n      });\n    }\n    exports2.parseFromFiles = parseFromFiles;\n    function parseFromFilesSync(filepath, files, options) {\n      if (options === void 0) {\n        options = {};\n      }\n      var _a = opts(filepath, options), resolvedFilePath = _a[0], processedOptions = _a[1];\n      return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);\n    }\n    exports2.parseFromFilesSync = parseFromFilesSync;\n    function parse(_filepath, _options) {\n      if (_options === void 0) {\n        _options = {};\n      }\n      return __awaiter2(this, void 0, void 0, function() {\n        var _a, resolvedFilePath, processedOptions, filepaths;\n        return __generator2(this, function(_b) {\n          _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1];\n          filepaths = getConfigFileNames(resolvedFilePath, processedOptions);\n          return [2, readConfigFiles(filepaths).then(getConfigsForFiles).then(function(configs) {\n            return parseFromConfigs(configs, resolvedFilePath, processedOptions);\n          })];\n        });\n      });\n    }\n    exports2.parse = parse;\n    function parseSync(_filepath, _options) {\n      if (_options === void 0) {\n        _options = {};\n      }\n      var _a = opts(_filepath, _options), resolvedFilePath = _a[0], processedOptions = _a[1];\n      var filepaths = getConfigFileNames(resolvedFilePath, processedOptions);\n      var files = readConfigFilesSync(filepaths);\n      return parseFromConfigs(getConfigsForFiles(files), resolvedFilePath, processedOptions);\n    }\n    exports2.parseSync = parseSync;\n  }\n});\nvar require_editorconfig_to_prettier = __commonJS2({\n  "node_modules/editorconfig-to-prettier/index.js"(exports2, module2) {\n    module2.exports = editorConfigToPrettier;\n    function removeUnset(editorConfig) {\n      const result = {};\n      const keys = Object.keys(editorConfig);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (editorConfig[key] === "unset") {\n          continue;\n        }\n        result[key] = editorConfig[key];\n      }\n      return result;\n    }\n    function editorConfigToPrettier(editorConfig) {\n      if (!editorConfig) {\n        return null;\n      }\n      editorConfig = removeUnset(editorConfig);\n      if (Object.keys(editorConfig).length === 0) {\n        return null;\n      }\n      const result = {};\n      if (editorConfig.indent_style) {\n        result.useTabs = editorConfig.indent_style === "tab";\n      }\n      if (editorConfig.indent_size === "tab") {\n        result.useTabs = true;\n      }\n      if (result.useTabs && editorConfig.tab_width) {\n        result.tabWidth = editorConfig.tab_width;\n      } else if (editorConfig.indent_style === "space" && editorConfig.indent_size && editorConfig.indent_size !== "tab") {\n        result.tabWidth = editorConfig.indent_size;\n      } else if (editorConfig.tab_width !== void 0) {\n        result.tabWidth = editorConfig.tab_width;\n      }\n      if (editorConfig.max_line_length) {\n        if (editorConfig.max_line_length === "off") {\n          result.printWidth = Number.POSITIVE_INFINITY;\n        } else {\n          result.printWidth = editorConfig.max_line_length;\n        }\n      }\n      if (editorConfig.quote_type === "single") {\n        result.singleQuote = true;\n      } else if (editorConfig.quote_type === "double") {\n        result.singleQuote = false;\n      }\n      if (["cr", "crlf", "lf"].indexOf(editorConfig.end_of_line) !== -1) {\n        result.endOfLine = editorConfig.end_of_line;\n      }\n      if (editorConfig.insert_final_newline === false || editorConfig.insert_final_newline === true) {\n        result.insertFinalNewline = editorConfig.insert_final_newline;\n      }\n      return result;\n    }\n  }\n});\nvar require_find_project_root = __commonJS2({\n  "src/config/find-project-root.js"(exports2, module2) {\n    "use strict";\n    var fs = require("fs");\n    var path = require("path");\n    var MARKERS = [".git", ".hg"];\n    var markerExists = (directory) => MARKERS.some((mark) => fs.existsSync(path.join(directory, mark)));\n    function findProjectRoot(directory) {\n      while (!markerExists(directory)) {\n        const parentDirectory = path.resolve(directory, "..");\n        if (parentDirectory === directory) {\n          break;\n        }\n        directory = parentDirectory;\n      }\n      return directory;\n    }\n    module2.exports = findProjectRoot;\n  }\n});\nvar require_resolve_config_editorconfig = __commonJS2({\n  "src/config/resolve-config-editorconfig.js"(exports2, module2) {\n    "use strict";\n    var path = require("path");\n    var editorconfig = require_src2();\n    var editorConfigToPrettier = require_editorconfig_to_prettier();\n    var {\n      default: mem2,\n      memClear: memClear2\n    } = (init_dist(), __toCommonJS(dist_exports));\n    var findProjectRoot = require_find_project_root();\n    var jsonStringifyMem = (fn) => mem2(fn, {\n      cacheKey: JSON.stringify\n    });\n    var maybeParse = (filePath, parse) => filePath && parse(filePath, {\n      root: findProjectRoot(path.dirname(path.resolve(filePath)))\n    });\n    var editorconfigAsyncNoCache = async (filePath) => editorConfigToPrettier(await maybeParse(filePath, editorconfig.parse));\n    var editorconfigAsyncWithCache = jsonStringifyMem(editorconfigAsyncNoCache);\n    var editorconfigSyncNoCache = (filePath) => editorConfigToPrettier(maybeParse(filePath, editorconfig.parseSync));\n    var editorconfigSyncWithCache = jsonStringifyMem(editorconfigSyncNoCache);\n    function getLoadFunction(opts) {\n      if (!opts.editorconfig) {\n        return () => null;\n      }\n      if (opts.sync) {\n        return opts.cache ? editorconfigSyncWithCache : editorconfigSyncNoCache;\n      }\n      return opts.cache ? editorconfigAsyncWithCache : editorconfigAsyncNoCache;\n    }\n    function clearCache() {\n      memClear2(editorconfigSyncWithCache);\n      memClear2(editorconfigAsyncWithCache);\n    }\n    module2.exports = {\n      getLoadFunction,\n      clearCache\n    };\n  }\n});\nvar require_resolve_config = __commonJS2({\n  "src/config/resolve-config.js"(exports2, module2) {\n    "use strict";\n    var path = require("path");\n    var micromatch = require_micromatch();\n    var thirdParty = require("./third-party.js");\n    var loadToml = require_load_toml();\n    var loadJson5 = require_load_json5();\n    var partition = require_partition();\n    var resolve = require_resolve2();\n    var {\n      default: mem2,\n      memClear: memClear2\n    } = (init_dist(), __toCommonJS(dist_exports));\n    var resolveEditorConfig = require_resolve_config_editorconfig();\n    var getExplorerMemoized = mem2((opts) => {\n      const cosmiconfig = thirdParty["cosmiconfig" + (opts.sync ? "Sync" : "")];\n      const explorer = cosmiconfig("prettier", {\n        cache: opts.cache,\n        transform: (result) => {\n          if (result && result.config) {\n            if (typeof result.config === "string") {\n              const dir = path.dirname(result.filepath);\n              const modulePath = resolve(result.config, {\n                paths: [dir]\n              });\n              result.config = require(modulePath);\n            }\n            if (typeof result.config !== "object") {\n              throw new TypeError(`Config is only allowed to be an object, but received ${typeof result.config} in "${result.filepath}"`);\n            }\n            delete result.config.$schema;\n          }\n          return result;\n        },\n        searchPlaces: ["package.json", ".prettierrc", ".prettierrc.json", ".prettierrc.yaml", ".prettierrc.yml", ".prettierrc.json5", ".prettierrc.js", ".prettierrc.cjs", "prettier.config.js", "prettier.config.cjs", ".prettierrc.toml"],\n        loaders: {\n          ".toml": loadToml,\n          ".json5": loadJson5\n        }\n      });\n      return explorer;\n    }, {\n      cacheKey: JSON.stringify\n    });\n    function getExplorer(opts) {\n      opts = Object.assign({\n        sync: false,\n        cache: false\n      }, opts);\n      return getExplorerMemoized(opts);\n    }\n    function _resolveConfig(filePath, opts, sync) {\n      opts = Object.assign({\n        useCache: true\n      }, opts);\n      const loadOpts = {\n        cache: Boolean(opts.useCache),\n        sync: Boolean(sync),\n        editorconfig: Boolean(opts.editorconfig)\n      };\n      const {\n        load,\n        search\n      } = getExplorer(loadOpts);\n      const loadEditorConfig = resolveEditorConfig.getLoadFunction(loadOpts);\n      const arr = [opts.config ? load(opts.config) : search(filePath), loadEditorConfig(filePath)];\n      const unwrapAndMerge = ([result, editorConfigured]) => {\n        const merged = Object.assign(Object.assign({}, editorConfigured), mergeOverrides(result, filePath));\n        for (const optionName of ["plugins", "pluginSearchDirs"]) {\n          if (Array.isArray(merged[optionName])) {\n            merged[optionName] = merged[optionName].map((value) => typeof value === "string" && value.startsWith(".") ? path.resolve(path.dirname(result.filepath), value) : value);\n          }\n        }\n        if (!result && !editorConfigured) {\n          return null;\n        }\n        delete merged.insertFinalNewline;\n        return merged;\n      };\n      if (loadOpts.sync) {\n        return unwrapAndMerge(arr);\n      }\n      return Promise.all(arr).then(unwrapAndMerge);\n    }\n    var resolveConfig = (filePath, opts) => _resolveConfig(filePath, opts, false);\n    resolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);\n    function clearCache() {\n      memClear2(getExplorerMemoized);\n      resolveEditorConfig.clearCache();\n    }\n    async function resolveConfigFile(filePath) {\n      const {\n        search\n      } = getExplorer({\n        sync: false\n      });\n      const result = await search(filePath);\n      return result ? result.filepath : null;\n    }\n    resolveConfigFile.sync = (filePath) => {\n      const {\n        search\n      } = getExplorer({\n        sync: true\n      });\n      const result = search(filePath);\n      return result ? result.filepath : null;\n    };\n    function mergeOverrides(configResult, filePath) {\n      const {\n        config: config2,\n        filepath: configPath\n      } = configResult || {};\n      const _ref = config2 || {}, {\n        overrides\n      } = _ref, options = _objectWithoutProperties(_ref, _excluded3);\n      if (filePath && overrides) {\n        const relativeFilePath = path.relative(path.dirname(configPath), filePath);\n        for (const override of overrides) {\n          if (pathMatchesGlobs(relativeFilePath, override.files, override.excludeFiles)) {\n            Object.assign(options, override.options);\n          }\n        }\n      }\n      return options;\n    }\n    function pathMatchesGlobs(filePath, patterns, excludedPatterns) {\n      const patternList = Array.isArray(patterns) ? patterns : [patterns];\n      const [withSlashes, withoutSlashes] = partition(patternList, (pattern) => pattern.includes("/"));\n      return micromatch.isMatch(filePath, withoutSlashes, {\n        ignore: excludedPatterns,\n        basename: true,\n        dot: true\n      }) || micromatch.isMatch(filePath, withSlashes, {\n        ignore: excludedPatterns,\n        basename: false,\n        dot: true\n      });\n    }\n    module2.exports = {\n      resolveConfig,\n      resolveConfigFile,\n      clearCache\n    };\n  }\n});\nvar require_ignore = __commonJS2({\n  "node_modules/ignore/index.js"(exports2, module2) {\n    function makeArray(subject) {\n      return Array.isArray(subject) ? subject : [subject];\n    }\n    var EMPTY = "";\n    var SPACE = " ";\n    var ESCAPE = "\\\\";\n    var REGEX_TEST_BLANK_LINE = /^\\s+$/;\n    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/;\n    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/;\n    var REGEX_SPLITALL_CRLF = /\\r?\\n/g;\n    var REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/;\n    var SLASH = "/";\n    var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";\n    var define2 = (object, key, value) => Object.defineProperty(object, key, {\n      value\n    });\n    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;\n    var RETURN_FALSE = () => false;\n    var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);\n    var cleanRangeBackSlash = (slashes) => {\n      const {\n        length\n      } = slashes;\n      return slashes.slice(0, length - length % 2);\n    };\n    var REPLACERS = [[/\\\\?\\s+$/, (match) => match.indexOf("\\\\") === 0 ? SPACE : EMPTY], [/\\\\\\s/g, () => SPACE], [/[\\\\$.|*+(){^]/g, (match) => `\\\\${match}`], [/(?!\\\\)\\?/g, () => "[^/]"], [/^\\//, () => "^"], [/\\//g, () => "\\\\/"], [/^\\^*\\\\\\*\\\\\\*\\\\\\//, () => "^(?:.*\\\\/)?"], [/^(?=[^^])/, function startingReplacer() {\n      return !/\\/(?!$)/.test(this) ? "(?:^|\\\\/)" : "^";\n    }], [/\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g, (_, index, str) => index + 6 < str.length ? "(?:\\\\/[^\\\\/]+)*" : "\\\\/.+"], [/(^|[^\\\\]+)\\\\\\*(?=.+)/g, (_, p1) => `${p1}[^\\\\/]*`], [/\\\\\\\\\\\\(?=[$.|*+(){^])/g, () => ESCAPE], [/\\\\\\\\/g, () => ESCAPE], [/(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g, (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"], [/(?:[^*])$/, (match) => /\\/$/.test(match) ? `${match}$` : `${match}(?=$|\\\\/$)`], [/(\\^|\\\\\\/)?\\\\\\*$/, (_, p1) => {\n      const prefix = p1 ? `${p1}[^/]+` : "[^/]*";\n      return `${prefix}(?=$|\\\\/$)`;\n    }]];\n    var regexCache = /* @__PURE__ */ Object.create(null);\n    var makeRegex = (pattern, ignoreCase) => {\n      let source = regexCache[pattern];\n      if (!source) {\n        source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);\n        regexCache[pattern] = source;\n      }\n      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);\n    };\n    var isString = (subject) => typeof subject === "string";\n    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;\n    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);\n    var IgnoreRule = class {\n      constructor(origin, pattern, negative, regex) {\n        this.origin = origin;\n        this.pattern = pattern;\n        this.negative = negative;\n        this.regex = regex;\n      }\n    };\n    var createRule = (pattern, ignoreCase) => {\n      const origin = pattern;\n      let negative = false;\n      if (pattern.indexOf("!") === 0) {\n        negative = true;\n        pattern = pattern.substr(1);\n      }\n      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");\n      const regex = makeRegex(pattern, ignoreCase);\n      return new IgnoreRule(origin, pattern, negative, regex);\n    };\n    var throwError = (message, Ctor) => {\n      throw new Ctor(message);\n    };\n    var checkPath = (path, originalPath, doThrow) => {\n      if (!isString(path)) {\n        return doThrow(`path must be a string, but got \\`${originalPath}\\``, TypeError);\n      }\n      if (!path) {\n        return doThrow(`path must not be empty`, TypeError);\n      }\n      if (checkPath.isNotRelative(path)) {\n        const r = "`path.relative()`d";\n        return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);\n      }\n      return true;\n    };\n    var isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);\n    checkPath.isNotRelative = isNotRelative;\n    checkPath.convert = (p) => p;\n    var Ignore = class {\n      constructor({\n        ignorecase = true,\n        ignoreCase = ignorecase,\n        allowRelativePaths = false\n      } = {}) {\n        define2(this, KEY_IGNORE, true);\n        this._rules = [];\n        this._ignoreCase = ignoreCase;\n        this._allowRelativePaths = allowRelativePaths;\n        this._initCache();\n      }\n      _initCache() {\n        this._ignoreCache = /* @__PURE__ */ Object.create(null);\n        this._testCache = /* @__PURE__ */ Object.create(null);\n      }\n      _addPattern(pattern) {\n        if (pattern && pattern[KEY_IGNORE]) {\n          this._rules = this._rules.concat(pattern._rules);\n          this._added = true;\n          return;\n        }\n        if (checkPattern(pattern)) {\n          const rule = createRule(pattern, this._ignoreCase);\n          this._added = true;\n          this._rules.push(rule);\n        }\n      }\n      add(pattern) {\n        this._added = false;\n        makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);\n        if (this._added) {\n          this._initCache();\n        }\n        return this;\n      }\n      addPattern(pattern) {\n        return this.add(pattern);\n      }\n      _testOne(path, checkUnignored) {\n        let ignored = false;\n        let unignored = false;\n        this._rules.forEach((rule) => {\n          const {\n            negative\n          } = rule;\n          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {\n            return;\n          }\n          const matched = rule.regex.test(path);\n          if (matched) {\n            ignored = !negative;\n            unignored = negative;\n          }\n        });\n        return {\n          ignored,\n          unignored\n        };\n      }\n      _test(originalPath, cache, checkUnignored, slices) {\n        const path = originalPath && checkPath.convert(originalPath);\n        checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);\n        return this._t(path, cache, checkUnignored, slices);\n      }\n      _t(path, cache, checkUnignored, slices) {\n        if (path in cache) {\n          return cache[path];\n        }\n        if (!slices) {\n          slices = path.split(SLASH);\n        }\n        slices.pop();\n        if (!slices.length) {\n          return cache[path] = this._testOne(path, checkUnignored);\n        }\n        const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);\n        return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);\n      }\n      ignores(path) {\n        return this._test(path, this._ignoreCache, false).ignored;\n      }\n      createFilter() {\n        return (path) => !this.ignores(path);\n      }\n      filter(paths) {\n        return makeArray(paths).filter(this.createFilter());\n      }\n      test(path) {\n        return this._test(path, this._testCache, true);\n      }\n    };\n    var factory = (options) => new Ignore(options);\n    var isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);\n    factory.isPathValid = isPathValid;\n    factory.default = factory;\n    module2.exports = factory;\n    if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {\n      const makePosix = (str) => /^\\\\\\\\\\?\\\\/.test(str) || /["<>|\\u0000-\\u001F]+/u.test(str) ? str : str.replace(/\\\\/g, "/");\n      checkPath.convert = makePosix;\n      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i;\n      checkPath.isNotRelative = (path) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);\n    }\n  }\n});\nvar require_get_file_content_or_null = __commonJS2({\n  "src/utils/get-file-content-or-null.js"(exports2, module2) {\n    "use strict";\n    var fs = require("fs");\n    var fsAsync = fs.promises;\n    async function getFileContentOrNull(filename) {\n      try {\n        return await fsAsync.readFile(filename, "utf8");\n      } catch (error) {\n        return handleError(filename, error);\n      }\n    }\n    getFileContentOrNull.sync = function(filename) {\n      try {\n        return fs.readFileSync(filename, "utf8");\n      } catch (error) {\n        return handleError(filename, error);\n      }\n    };\n    function handleError(filename, error) {\n      if (error && error.code === "ENOENT") {\n        return null;\n      }\n      throw new Error(`Unable to read ${filename}: ${error.message}`);\n    }\n    module2.exports = getFileContentOrNull;\n  }\n});\nvar require_create_ignorer = __commonJS2({\n  "src/common/create-ignorer.js"(exports2, module2) {\n    "use strict";\n    var path = require("path");\n    var ignore = require_ignore().default;\n    var getFileContentOrNull = require_get_file_content_or_null();\n    async function createIgnorer(ignorePath, withNodeModules) {\n      const ignoreContent = ignorePath ? await getFileContentOrNull(path.resolve(ignorePath)) : null;\n      return _createIgnorer(ignoreContent, withNodeModules);\n    }\n    createIgnorer.sync = function(ignorePath, withNodeModules) {\n      const ignoreContent = !ignorePath ? null : getFileContentOrNull.sync(path.resolve(ignorePath));\n      return _createIgnorer(ignoreContent, withNodeModules);\n    };\n    function _createIgnorer(ignoreContent, withNodeModules) {\n      const ignorer = ignore({\n        allowRelativePaths: true\n      }).add(ignoreContent || "");\n      if (!withNodeModules) {\n        ignorer.add("node_modules");\n      }\n      return ignorer;\n    }\n    module2.exports = createIgnorer;\n  }\n});\nvar require_get_file_info = __commonJS2({\n  "src/common/get-file-info.js"(exports2, module2) {\n    "use strict";\n    var path = require("path");\n    var options = require_options();\n    var config2 = require_resolve_config();\n    var createIgnorer = require_create_ignorer();\n    async function getFileInfo2(filePath, opts) {\n      if (typeof filePath !== "string") {\n        throw new TypeError(`expect \\`filePath\\` to be a string, got \\`${typeof filePath}\\``);\n      }\n      const ignorer = await createIgnorer(opts.ignorePath, opts.withNodeModules);\n      return _getFileInfo({\n        ignorer,\n        filePath,\n        plugins: opts.plugins,\n        resolveConfig: opts.resolveConfig,\n        ignorePath: opts.ignorePath,\n        sync: false\n      });\n    }\n    getFileInfo2.sync = function(filePath, opts) {\n      if (typeof filePath !== "string") {\n        throw new TypeError(`expect \\`filePath\\` to be a string, got \\`${typeof filePath}\\``);\n      }\n      const ignorer = createIgnorer.sync(opts.ignorePath, opts.withNodeModules);\n      return _getFileInfo({\n        ignorer,\n        filePath,\n        plugins: opts.plugins,\n        resolveConfig: opts.resolveConfig,\n        ignorePath: opts.ignorePath,\n        sync: true\n      });\n    };\n    function getFileParser(resolvedConfig, filePath, plugins2) {\n      if (resolvedConfig && resolvedConfig.parser) {\n        return resolvedConfig.parser;\n      }\n      const inferredParser = options.inferParser(filePath, plugins2);\n      if (inferredParser) {\n        return inferredParser;\n      }\n      return null;\n    }\n    function _getFileInfo({\n      ignorer,\n      filePath,\n      plugins: plugins2,\n      resolveConfig = false,\n      ignorePath,\n      sync = false\n    }) {\n      const normalizedFilePath = normalizeFilePath(filePath, ignorePath);\n      const fileInfo = {\n        ignored: ignorer.ignores(normalizedFilePath),\n        inferredParser: null\n      };\n      if (fileInfo.ignored) {\n        return fileInfo;\n      }\n      let resolvedConfig;\n      if (resolveConfig) {\n        if (sync) {\n          resolvedConfig = config2.resolveConfig.sync(filePath);\n        } else {\n          return config2.resolveConfig(filePath).then((resolvedConfig2) => {\n            fileInfo.inferredParser = getFileParser(resolvedConfig2, filePath, plugins2);\n            return fileInfo;\n          });\n        }\n      }\n      fileInfo.inferredParser = getFileParser(resolvedConfig, filePath, plugins2);\n      return fileInfo;\n    }\n    function normalizeFilePath(filePath, ignorePath) {\n      return ignorePath ? path.relative(path.dirname(ignorePath), filePath) : filePath;\n    }\n    module2.exports = getFileInfo2;\n  }\n});\nvar require_util_shared = __commonJS2({\n  "src/common/util-shared.js"(exports2, module2) {\n    "use strict";\n    var {\n      getMaxContinuousCount,\n      getStringWidth,\n      getAlignmentSize,\n      getIndentSize,\n      skip,\n      skipWhitespace,\n      skipSpaces,\n      skipNewline,\n      skipToLineEnd,\n      skipEverythingButNewLine,\n      skipInlineComment,\n      skipTrailingComment,\n      hasNewline,\n      hasNewlineInRange,\n      hasSpaces,\n      isNextLineEmpty,\n      isNextLineEmptyAfterIndex,\n      isPreviousLineEmpty,\n      getNextNonSpaceNonCommentCharacterIndex,\n      makeString,\n      addLeadingComment,\n      addDanglingComment,\n      addTrailingComment\n    } = require_util();\n    module2.exports = {\n      getMaxContinuousCount,\n      getStringWidth,\n      getAlignmentSize,\n      getIndentSize,\n      skip,\n      skipWhitespace,\n      skipSpaces,\n      skipNewline,\n      skipToLineEnd,\n      skipEverythingButNewLine,\n      skipInlineComment,\n      skipTrailingComment,\n      hasNewline,\n      hasNewlineInRange,\n      hasSpaces,\n      isNextLineEmpty,\n      isNextLineEmptyAfterIndex,\n      isPreviousLineEmpty,\n      getNextNonSpaceNonCommentCharacterIndex,\n      makeString,\n      addLeadingComment,\n      addDanglingComment,\n      addTrailingComment\n    };\n  }\n});\nvar require_array3 = __commonJS2({\n  "node_modules/fast-glob/out/utils/array.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.splitWhen = exports2.flatten = void 0;\n    function flatten(items) {\n      return items.reduce((collection, item) => [].concat(collection, item), []);\n    }\n    exports2.flatten = flatten;\n    function splitWhen(items, predicate) {\n      const result = [[]];\n      let groupIndex = 0;\n      for (const item of items) {\n        if (predicate(item)) {\n          groupIndex++;\n          result[groupIndex] = [];\n        } else {\n          result[groupIndex].push(item);\n        }\n      }\n      return result;\n    }\n    exports2.splitWhen = splitWhen;\n  }\n});\nvar require_errno = __commonJS2({\n  "node_modules/fast-glob/out/utils/errno.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.isEnoentCodeError = void 0;\n    function isEnoentCodeError(error) {\n      return error.code === "ENOENT";\n    }\n    exports2.isEnoentCodeError = isEnoentCodeError;\n  }\n});\nvar require_fs = __commonJS2({\n  "node_modules/fast-glob/out/utils/fs.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.createDirentFromStats = void 0;\n    var DirentFromStats = class {\n      constructor(name, stats) {\n        this.name = name;\n        this.isBlockDevice = stats.isBlockDevice.bind(stats);\n        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);\n        this.isDirectory = stats.isDirectory.bind(stats);\n        this.isFIFO = stats.isFIFO.bind(stats);\n        this.isFile = stats.isFile.bind(stats);\n        this.isSocket = stats.isSocket.bind(stats);\n        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);\n      }\n    };\n    function createDirentFromStats(name, stats) {\n      return new DirentFromStats(name, stats);\n    }\n    exports2.createDirentFromStats = createDirentFromStats;\n  }\n});\nvar require_path = __commonJS2({\n  "node_modules/fast-glob/out/utils/path.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.removeLeadingDotSegment = exports2.escape = exports2.makeAbsolute = exports2.unixify = void 0;\n    var path = require("path");\n    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;\n    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\\\?)([()*?[\\]{|}]|^!|[!+@](?=\\())/g;\n    function unixify(filepath) {\n      return filepath.replace(/\\\\/g, "/");\n    }\n    exports2.unixify = unixify;\n    function makeAbsolute(cwd, filepath) {\n      return path.resolve(cwd, filepath);\n    }\n    exports2.makeAbsolute = makeAbsolute;\n    function escape(pattern) {\n      return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\\\$2");\n    }\n    exports2.escape = escape;\n    function removeLeadingDotSegment(entry) {\n      if (entry.charAt(0) === ".") {\n        const secondCharactery = entry.charAt(1);\n        if (secondCharactery === "/" || secondCharactery === "\\\\") {\n          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);\n        }\n      }\n      return entry;\n    }\n    exports2.removeLeadingDotSegment = removeLeadingDotSegment;\n  }\n});\nvar require_is_extglob = __commonJS2({\n  "node_modules/is-extglob/index.js"(exports2, module2) {\n    module2.exports = function isExtglob(str) {\n      if (typeof str !== "string" || str === "") {\n        return false;\n      }\n      var match;\n      while (match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str)) {\n        if (match[2])\n          return true;\n        str = str.slice(match.index + match[0].length);\n      }\n      return false;\n    };\n  }\n});\nvar require_is_glob = __commonJS2({\n  "node_modules/is-glob/index.js"(exports2, module2) {\n    var isExtglob = require_is_extglob();\n    var chars = {\n      "{": "}",\n      "(": ")",\n      "[": "]"\n    };\n    var strictCheck = function(str) {\n      if (str[0] === "!") {\n        return true;\n      }\n      var index = 0;\n      var pipeIndex = -2;\n      var closeSquareIndex = -2;\n      var closeCurlyIndex = -2;\n      var closeParenIndex = -2;\n      var backSlashIndex = -2;\n      while (index < str.length) {\n        if (str[index] === "*") {\n          return true;\n        }\n        if (str[index + 1] === "?" && /[\\].+)]/.test(str[index])) {\n          return true;\n        }\n        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {\n          if (closeSquareIndex < index) {\n            closeSquareIndex = str.indexOf("]", index);\n          }\n          if (closeSquareIndex > index) {\n            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n              return true;\n            }\n            backSlashIndex = str.indexOf("\\\\", index);\n            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n              return true;\n            }\n          }\n        }\n        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {\n          closeCurlyIndex = str.indexOf("}", index);\n          if (closeCurlyIndex > index) {\n            backSlashIndex = str.indexOf("\\\\", index);\n            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n              return true;\n            }\n          }\n        }\n        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {\n          closeParenIndex = str.indexOf(")", index);\n          if (closeParenIndex > index) {\n            backSlashIndex = str.indexOf("\\\\", index);\n            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n              return true;\n            }\n          }\n        }\n        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {\n          if (pipeIndex < index) {\n            pipeIndex = str.indexOf("|", index);\n          }\n          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {\n            closeParenIndex = str.indexOf(")", pipeIndex);\n            if (closeParenIndex > pipeIndex) {\n              backSlashIndex = str.indexOf("\\\\", pipeIndex);\n              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n                return true;\n              }\n            }\n          }\n        }\n        if (str[index] === "\\\\") {\n          var open = str[index + 1];\n          index += 2;\n          var close = chars[open];\n          if (close) {\n            var n = str.indexOf(close, index);\n            if (n !== -1) {\n              index = n + 1;\n            }\n          }\n          if (str[index] === "!") {\n            return true;\n          }\n        } else {\n          index++;\n        }\n      }\n      return false;\n    };\n    var relaxedCheck = function(str) {\n      if (str[0] === "!") {\n        return true;\n      }\n      var index = 0;\n      while (index < str.length) {\n        if (/[*?{}()[\\]]/.test(str[index])) {\n          return true;\n        }\n        if (str[index] === "\\\\") {\n          var open = str[index + 1];\n          index += 2;\n          var close = chars[open];\n          if (close) {\n            var n = str.indexOf(close, index);\n            if (n !== -1) {\n              index = n + 1;\n            }\n          }\n          if (str[index] === "!") {\n            return true;\n          }\n        } else {\n          index++;\n        }\n      }\n      return false;\n    };\n    module2.exports = function isGlob(str, options) {\n      if (typeof str !== "string" || str === "") {\n        return false;\n      }\n      if (isExtglob(str)) {\n        return true;\n      }\n      var check = strictCheck;\n      if (options && options.strict === false) {\n        check = relaxedCheck;\n      }\n      return check(str);\n    };\n  }\n});\nvar require_glob_parent = __commonJS2({\n  "node_modules/glob-parent/index.js"(exports2, module2) {\n    "use strict";\n    var isGlob = require_is_glob();\n    var pathPosixDirname = require("path").posix.dirname;\n    var isWin32 = require("os").platform() === "win32";\n    var slash = "/";\n    var backslash = /\\\\/g;\n    var enclosure = /[\\{\\[].*[\\}\\]]$/;\n    var globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\n    var escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n    module2.exports = function globParent(str, opts) {\n      var options = Object.assign({\n        flipBackslashes: true\n      }, opts);\n      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n        str = str.replace(backslash, slash);\n      }\n      if (enclosure.test(str)) {\n        str += slash;\n      }\n      str += "a";\n      do {\n        str = pathPosixDirname(str);\n      } while (isGlob(str) || globby.test(str));\n      return str.replace(escaped, "$1");\n    };\n  }\n});\nvar require_pattern = __commonJS2({\n  "node_modules/fast-glob/out/utils/pattern.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.isPatternRelatedToParentDirectory = exports2.getPatternsOutsideCurrentDirectory = exports2.getPatternsInsideCurrentDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;\n    var path = require("path");\n    var globParent = require_glob_parent();\n    var micromatch = require_micromatch();\n    var GLOBSTAR = "**";\n    var ESCAPE_SYMBOL = "\\\\";\n    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\n    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\n    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\n    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\n    var BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\n    function isStaticPattern(pattern, options = {}) {\n      return !isDynamicPattern(pattern, options);\n    }\n    exports2.isStaticPattern = isStaticPattern;\n    function isDynamicPattern(pattern, options = {}) {\n      if (pattern === "") {\n        return false;\n      }\n      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n        return true;\n      }\n      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n        return true;\n      }\n      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n        return true;\n      }\n      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\n        return true;\n      }\n      return false;\n    }\n    exports2.isDynamicPattern = isDynamicPattern;\n    function hasBraceExpansion(pattern) {\n      const openingBraceIndex = pattern.indexOf("{");\n      if (openingBraceIndex === -1) {\n        return false;\n      }\n      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);\n      if (closingBraceIndex === -1) {\n        return false;\n      }\n      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\n      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\n    }\n    function convertToPositivePattern(pattern) {\n      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n    }\n    exports2.convertToPositivePattern = convertToPositivePattern;\n    function convertToNegativePattern(pattern) {\n      return "!" + pattern;\n    }\n    exports2.convertToNegativePattern = convertToNegativePattern;\n    function isNegativePattern(pattern) {\n      return pattern.startsWith("!") && pattern[1] !== "(";\n    }\n    exports2.isNegativePattern = isNegativePattern;\n    function isPositivePattern(pattern) {\n      return !isNegativePattern(pattern);\n    }\n    exports2.isPositivePattern = isPositivePattern;\n    function getNegativePatterns(patterns) {\n      return patterns.filter(isNegativePattern);\n    }\n    exports2.getNegativePatterns = getNegativePatterns;\n    function getPositivePatterns(patterns) {\n      return patterns.filter(isPositivePattern);\n    }\n    exports2.getPositivePatterns = getPositivePatterns;\n    function getPatternsInsideCurrentDirectory(patterns) {\n      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));\n    }\n    exports2.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n    function getPatternsOutsideCurrentDirectory(patterns) {\n      return patterns.filter(isPatternRelatedToParentDirectory);\n    }\n    exports2.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\n    function isPatternRelatedToParentDirectory(pattern) {\n      return pattern.startsWith("..") || pattern.startsWith("./..");\n    }\n    exports2.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\n    function getBaseDirectory(pattern) {\n      return globParent(pattern, {\n        flipBackslashes: false\n      });\n    }\n    exports2.getBaseDirectory = getBaseDirectory;\n    function hasGlobStar(pattern) {\n      return pattern.includes(GLOBSTAR);\n    }\n    exports2.hasGlobStar = hasGlobStar;\n    function endsWithSlashGlobStar(pattern) {\n      return pattern.endsWith("/" + GLOBSTAR);\n    }\n    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;\n    function isAffectDepthOfReadingPattern(pattern) {\n      const basename = path.basename(pattern);\n      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n    }\n    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\n    function expandPatternsWithBraceExpansion(patterns) {\n      return patterns.reduce((collection, pattern) => {\n        return collection.concat(expandBraceExpansion(pattern));\n      }, []);\n    }\n    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\n    function expandBraceExpansion(pattern) {\n      return micromatch.braces(pattern, {\n        expand: true,\n        nodupes: true\n      });\n    }\n    exports2.expandBraceExpansion = expandBraceExpansion;\n    function getPatternParts(pattern, options) {\n      let {\n        parts\n      } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), {\n        parts: true\n      }));\n      if (parts.length === 0) {\n        parts = [pattern];\n      }\n      if (parts[0].startsWith("/")) {\n        parts[0] = parts[0].slice(1);\n        parts.unshift("");\n      }\n      return parts;\n    }\n    exports2.getPatternParts = getPatternParts;\n    function makeRe(pattern, options) {\n      return micromatch.makeRe(pattern, options);\n    }\n    exports2.makeRe = makeRe;\n    function convertPatternsToRe(patterns, options) {\n      return patterns.map((pattern) => makeRe(pattern, options));\n    }\n    exports2.convertPatternsToRe = convertPatternsToRe;\n    function matchAny(entry, patternsRe) {\n      return patternsRe.some((patternRe) => patternRe.test(entry));\n    }\n    exports2.matchAny = matchAny;\n  }\n});\nvar require_merge2 = __commonJS2({\n  "node_modules/merge2/index.js"(exports2, module2) {\n    "use strict";\n    var Stream = require("stream");\n    var PassThrough = Stream.PassThrough;\n    var slice = Array.prototype.slice;\n    module2.exports = merge2;\n    function merge2() {\n      const streamsQueue = [];\n      const args = slice.call(arguments);\n      let merging = false;\n      let options = args[args.length - 1];\n      if (options && !Array.isArray(options) && options.pipe == null) {\n        args.pop();\n      } else {\n        options = {};\n      }\n      const doEnd = options.end !== false;\n      const doPipeError = options.pipeError === true;\n      if (options.objectMode == null) {\n        options.objectMode = true;\n      }\n      if (options.highWaterMark == null) {\n        options.highWaterMark = 64 * 1024;\n      }\n      const mergedStream = PassThrough(options);\n      function addStream() {\n        for (let i = 0, len = arguments.length; i < len; i++) {\n          streamsQueue.push(pauseStreams(arguments[i], options));\n        }\n        mergeStream();\n        return this;\n      }\n      function mergeStream() {\n        if (merging) {\n          return;\n        }\n        merging = true;\n        let streams = streamsQueue.shift();\n        if (!streams) {\n          process.nextTick(endStream);\n          return;\n        }\n        if (!Array.isArray(streams)) {\n          streams = [streams];\n        }\n        let pipesCount = streams.length + 1;\n        function next() {\n          if (--pipesCount > 0) {\n            return;\n          }\n          merging = false;\n          mergeStream();\n        }\n        function pipe(stream) {\n          function onend() {\n            stream.removeListener("merge2UnpipeEnd", onend);\n            stream.removeListener("end", onend);\n            if (doPipeError) {\n              stream.removeListener("error", onerror);\n            }\n            next();\n          }\n          function onerror(err) {\n            mergedStream.emit("error", err);\n          }\n          if (stream._readableState.endEmitted) {\n            return next();\n          }\n          stream.on("merge2UnpipeEnd", onend);\n          stream.on("end", onend);\n          if (doPipeError) {\n            stream.on("error", onerror);\n          }\n          stream.pipe(mergedStream, {\n            end: false\n          });\n          stream.resume();\n        }\n        for (let i = 0; i < streams.length; i++) {\n          pipe(streams[i]);\n        }\n        next();\n      }\n      function endStream() {\n        merging = false;\n        mergedStream.emit("queueDrain");\n        if (doEnd) {\n          mergedStream.end();\n        }\n      }\n      mergedStream.setMaxListeners(0);\n      mergedStream.add = addStream;\n      mergedStream.on("unpipe", function(stream) {\n        stream.emit("merge2UnpipeEnd");\n      });\n      if (args.length) {\n        addStream.apply(null, args);\n      }\n      return mergedStream;\n    }\n    function pauseStreams(streams, options) {\n      if (!Array.isArray(streams)) {\n        if (!streams._readableState && streams.pipe) {\n          streams = streams.pipe(PassThrough(options));\n        }\n        if (!streams._readableState || !streams.pause || !streams.pipe) {\n          throw new Error("Only readable stream can be merged.");\n        }\n        streams.pause();\n      } else {\n        for (let i = 0, len = streams.length; i < len; i++) {\n          streams[i] = pauseStreams(streams[i], options);\n        }\n      }\n      return streams;\n    }\n  }\n});\nvar require_stream = __commonJS2({\n  "node_modules/fast-glob/out/utils/stream.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.merge = void 0;\n    var merge2 = require_merge2();\n    function merge(streams) {\n      const mergedStream = merge2(streams);\n      streams.forEach((stream) => {\n        stream.once("error", (error) => mergedStream.emit("error", error));\n      });\n      mergedStream.once("close", () => propagateCloseEventToSources(streams));\n      mergedStream.once("end", () => propagateCloseEventToSources(streams));\n      return mergedStream;\n    }\n    exports2.merge = merge;\n    function propagateCloseEventToSources(streams) {\n      streams.forEach((stream) => stream.emit("close"));\n    }\n  }\n});\nvar require_string2 = __commonJS2({\n  "node_modules/fast-glob/out/utils/string.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.isEmpty = exports2.isString = void 0;\n    function isString(input) {\n      return typeof input === "string";\n    }\n    exports2.isString = isString;\n    function isEmpty(input) {\n      return input === "";\n    }\n    exports2.isEmpty = isEmpty;\n  }\n});\nvar require_utils4 = __commonJS2({\n  "node_modules/fast-glob/out/utils/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;\n    var array = require_array3();\n    exports2.array = array;\n    var errno = require_errno();\n    exports2.errno = errno;\n    var fs = require_fs();\n    exports2.fs = fs;\n    var path = require_path();\n    exports2.path = path;\n    var pattern = require_pattern();\n    exports2.pattern = pattern;\n    var stream = require_stream();\n    exports2.stream = stream;\n    var string = require_string2();\n    exports2.string = string;\n  }\n});\nvar require_tasks = __commonJS2({\n  "node_modules/fast-glob/out/managers/tasks.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;\n    var utils = require_utils4();\n    function generate(patterns, settings) {\n      const positivePatterns = getPositivePatterns(patterns);\n      const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);\n      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));\n      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));\n      const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);\n      const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);\n      return staticTasks.concat(dynamicTasks);\n    }\n    exports2.generate = generate;\n    function convertPatternsToTasks(positive, negative, dynamic) {\n      const tasks = [];\n      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);\n      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);\n      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);\n      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);\n      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));\n      if ("." in insideCurrentDirectoryGroup) {\n        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));\n      } else {\n        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));\n      }\n      return tasks;\n    }\n    exports2.convertPatternsToTasks = convertPatternsToTasks;\n    function getPositivePatterns(patterns) {\n      return utils.pattern.getPositivePatterns(patterns);\n    }\n    exports2.getPositivePatterns = getPositivePatterns;\n    function getNegativePatternsAsPositive(patterns, ignore) {\n      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);\n      const positive = negative.map(utils.pattern.convertToPositivePattern);\n      return positive;\n    }\n    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;\n    function groupPatternsByBaseDirectory(patterns) {\n      const group = {};\n      return patterns.reduce((collection, pattern) => {\n        const base = utils.pattern.getBaseDirectory(pattern);\n        if (base in collection) {\n          collection[base].push(pattern);\n        } else {\n          collection[base] = [pattern];\n        }\n        return collection;\n      }, group);\n    }\n    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;\n    function convertPatternGroupsToTasks(positive, negative, dynamic) {\n      return Object.keys(positive).map((base) => {\n        return convertPatternGroupToTask(base, positive[base], negative, dynamic);\n      });\n    }\n    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;\n    function convertPatternGroupToTask(base, positive, negative, dynamic) {\n      return {\n        dynamic,\n        positive,\n        negative,\n        base,\n        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))\n      };\n    }\n    exports2.convertPatternGroupToTask = convertPatternGroupToTask;\n  }\n});\nvar require_patterns = __commonJS2({\n  "node_modules/fast-glob/out/managers/patterns.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.removeDuplicateSlashes = exports2.transform = void 0;\n    var DOUBLE_SLASH_RE = /(?!^)\\/{2,}/g;\n    function transform(patterns) {\n      return patterns.map((pattern) => removeDuplicateSlashes(pattern));\n    }\n    exports2.transform = transform;\n    function removeDuplicateSlashes(pattern) {\n      return pattern.replace(DOUBLE_SLASH_RE, "/");\n    }\n    exports2.removeDuplicateSlashes = removeDuplicateSlashes;\n  }\n});\nvar require_async2 = __commonJS2({\n  "node_modules/@nodelib/fs.stat/out/providers/async.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.read = void 0;\n    function read(path, settings, callback) {\n      settings.fs.lstat(path, (lstatError, lstat) => {\n        if (lstatError !== null) {\n          callFailureCallback(callback, lstatError);\n          return;\n        }\n        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {\n          callSuccessCallback(callback, lstat);\n          return;\n        }\n        settings.fs.stat(path, (statError, stat) => {\n          if (statError !== null) {\n            if (settings.throwErrorOnBrokenSymbolicLink) {\n              callFailureCallback(callback, statError);\n              return;\n            }\n            callSuccessCallback(callback, lstat);\n            return;\n          }\n          if (settings.markSymbolicLink) {\n            stat.isSymbolicLink = () => true;\n          }\n          callSuccessCallback(callback, stat);\n        });\n      });\n    }\n    exports2.read = read;\n    function callFailureCallback(callback, error) {\n      callback(error);\n    }\n    function callSuccessCallback(callback, result) {\n      callback(null, result);\n    }\n  }\n});\nvar require_sync2 = __commonJS2({\n  "node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.read = void 0;\n    function read(path, settings) {\n      const lstat = settings.fs.lstatSync(path);\n      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {\n        return lstat;\n      }\n      try {\n        const stat = settings.fs.statSync(path);\n        if (settings.markSymbolicLink) {\n          stat.isSymbolicLink = () => true;\n        }\n        return stat;\n      } catch (error) {\n        if (!settings.throwErrorOnBrokenSymbolicLink) {\n          return lstat;\n        }\n        throw error;\n      }\n    }\n    exports2.read = read;\n  }\n});\nvar require_fs2 = __commonJS2({\n  "node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;\n    var fs = require("fs");\n    exports2.FILE_SYSTEM_ADAPTER = {\n      lstat: fs.lstat,\n      stat: fs.stat,\n      lstatSync: fs.lstatSync,\n      statSync: fs.statSync\n    };\n    function createFileSystemAdapter(fsMethods) {\n      if (fsMethods === void 0) {\n        return exports2.FILE_SYSTEM_ADAPTER;\n      }\n      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);\n    }\n    exports2.createFileSystemAdapter = createFileSystemAdapter;\n  }\n});\nvar require_settings = __commonJS2({\n  "node_modules/@nodelib/fs.stat/out/settings.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var fs = require_fs2();\n    var Settings = class {\n      constructor(_options = {}) {\n        this._options = _options;\n        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);\n        this.fs = fs.createFileSystemAdapter(this._options.fs);\n        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);\n      }\n      _getValue(option, value) {\n        return option !== null && option !== void 0 ? option : value;\n      }\n    };\n    exports2.default = Settings;\n  }\n});\nvar require_out = __commonJS2({\n  "node_modules/@nodelib/fs.stat/out/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.statSync = exports2.stat = exports2.Settings = void 0;\n    var async = require_async2();\n    var sync = require_sync2();\n    var settings_1 = require_settings();\n    exports2.Settings = settings_1.default;\n    function stat(path, optionsOrSettingsOrCallback, callback) {\n      if (typeof optionsOrSettingsOrCallback === "function") {\n        async.read(path, getSettings(), optionsOrSettingsOrCallback);\n        return;\n      }\n      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);\n    }\n    exports2.stat = stat;\n    function statSync(path, optionsOrSettings) {\n      const settings = getSettings(optionsOrSettings);\n      return sync.read(path, settings);\n    }\n    exports2.statSync = statSync;\n    function getSettings(settingsOrOptions = {}) {\n      if (settingsOrOptions instanceof settings_1.default) {\n        return settingsOrOptions;\n      }\n      return new settings_1.default(settingsOrOptions);\n    }\n  }\n});\nvar require_queue_microtask = __commonJS2({\n  "node_modules/queue-microtask/index.js"(exports2, module2) {\n    var promise;\n    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {\n      throw err;\n    }, 0));\n  }\n});\nvar require_run_parallel = __commonJS2({\n  "node_modules/run-parallel/index.js"(exports2, module2) {\n    module2.exports = runParallel;\n    var queueMicrotask2 = require_queue_microtask();\n    function runParallel(tasks, cb) {\n      let results, pending, keys;\n      let isSync = true;\n      if (Array.isArray(tasks)) {\n        results = [];\n        pending = tasks.length;\n      } else {\n        keys = Object.keys(tasks);\n        results = {};\n        pending = keys.length;\n      }\n      function done(err) {\n        function end() {\n          if (cb)\n            cb(err, results);\n          cb = null;\n        }\n        if (isSync)\n          queueMicrotask2(end);\n        else\n          end();\n      }\n      function each(i, err, result) {\n        results[i] = result;\n        if (--pending === 0 || err) {\n          done(err);\n        }\n      }\n      if (!pending) {\n        done(null);\n      } else if (keys) {\n        keys.forEach(function(key) {\n          tasks[key](function(err, result) {\n            each(key, err, result);\n          });\n        });\n      } else {\n        tasks.forEach(function(task, i) {\n          task(function(err, result) {\n            each(i, err, result);\n          });\n        });\n      }\n      isSync = false;\n    }\n  }\n});\nvar require_constants4 = __commonJS2({\n  "node_modules/@nodelib/fs.scandir/out/constants.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;\n    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");\n    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {\n      throw new Error(`Unexpected behavior. The \'process.versions.node\' variable has invalid value: ${process.versions.node}`);\n    }\n    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);\n    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);\n    var SUPPORTED_MAJOR_VERSION = 10;\n    var SUPPORTED_MINOR_VERSION = 10;\n    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;\n    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;\n    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;\n  }\n});\nvar require_fs3 = __commonJS2({\n  "node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.createDirentFromStats = void 0;\n    var DirentFromStats = class {\n      constructor(name, stats) {\n        this.name = name;\n        this.isBlockDevice = stats.isBlockDevice.bind(stats);\n        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);\n        this.isDirectory = stats.isDirectory.bind(stats);\n        this.isFIFO = stats.isFIFO.bind(stats);\n        this.isFile = stats.isFile.bind(stats);\n        this.isSocket = stats.isSocket.bind(stats);\n        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);\n      }\n    };\n    function createDirentFromStats(name, stats) {\n      return new DirentFromStats(name, stats);\n    }\n    exports2.createDirentFromStats = createDirentFromStats;\n  }\n});\nvar require_utils5 = __commonJS2({\n  "node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.fs = void 0;\n    var fs = require_fs3();\n    exports2.fs = fs;\n  }\n});\nvar require_common3 = __commonJS2({\n  "node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.joinPathSegments = void 0;\n    function joinPathSegments(a, b, separator) {\n      if (a.endsWith(separator)) {\n        return a + b;\n      }\n      return a + separator + b;\n    }\n    exports2.joinPathSegments = joinPathSegments;\n  }\n});\nvar require_async3 = __commonJS2({\n  "node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;\n    var fsStat = require_out();\n    var rpl = require_run_parallel();\n    var constants_1 = require_constants4();\n    var utils = require_utils5();\n    var common = require_common3();\n    function read(directory, settings, callback) {\n      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {\n        readdirWithFileTypes(directory, settings, callback);\n        return;\n      }\n      readdir(directory, settings, callback);\n    }\n    exports2.read = read;\n    function readdirWithFileTypes(directory, settings, callback) {\n      settings.fs.readdir(directory, {\n        withFileTypes: true\n      }, (readdirError, dirents) => {\n        if (readdirError !== null) {\n          callFailureCallback(callback, readdirError);\n          return;\n        }\n        const entries = dirents.map((dirent) => ({\n          dirent,\n          name: dirent.name,\n          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)\n        }));\n        if (!settings.followSymbolicLinks) {\n          callSuccessCallback(callback, entries);\n          return;\n        }\n        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));\n        rpl(tasks, (rplError, rplEntries) => {\n          if (rplError !== null) {\n            callFailureCallback(callback, rplError);\n            return;\n          }\n          callSuccessCallback(callback, rplEntries);\n        });\n      });\n    }\n    exports2.readdirWithFileTypes = readdirWithFileTypes;\n    function makeRplTaskEntry(entry, settings) {\n      return (done) => {\n        if (!entry.dirent.isSymbolicLink()) {\n          done(null, entry);\n          return;\n        }\n        settings.fs.stat(entry.path, (statError, stats) => {\n          if (statError !== null) {\n            if (settings.throwErrorOnBrokenSymbolicLink) {\n              done(statError);\n              return;\n            }\n            done(null, entry);\n            return;\n          }\n          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);\n          done(null, entry);\n        });\n      };\n    }\n    function readdir(directory, settings, callback) {\n      settings.fs.readdir(directory, (readdirError, names) => {\n        if (readdirError !== null) {\n          callFailureCallback(callback, readdirError);\n          return;\n        }\n        const tasks = names.map((name) => {\n          const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);\n          return (done) => {\n            fsStat.stat(path, settings.fsStatSettings, (error, stats) => {\n              if (error !== null) {\n                done(error);\n                return;\n              }\n              const entry = {\n                name,\n                path,\n                dirent: utils.fs.createDirentFromStats(name, stats)\n              };\n              if (settings.stats) {\n                entry.stats = stats;\n              }\n              done(null, entry);\n            });\n          };\n        });\n        rpl(tasks, (rplError, entries) => {\n          if (rplError !== null) {\n            callFailureCallback(callback, rplError);\n            return;\n          }\n          callSuccessCallback(callback, entries);\n        });\n      });\n    }\n    exports2.readdir = readdir;\n    function callFailureCallback(callback, error) {\n      callback(error);\n    }\n    function callSuccessCallback(callback, result) {\n      callback(null, result);\n    }\n  }\n});\nvar require_sync3 = __commonJS2({\n  "node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;\n    var fsStat = require_out();\n    var constants_1 = require_constants4();\n    var utils = require_utils5();\n    var common = require_common3();\n    function read(directory, settings) {\n      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {\n        return readdirWithFileTypes(directory, settings);\n      }\n      return readdir(directory, settings);\n    }\n    exports2.read = read;\n    function readdirWithFileTypes(directory, settings) {\n      const dirents = settings.fs.readdirSync(directory, {\n        withFileTypes: true\n      });\n      return dirents.map((dirent) => {\n        const entry = {\n          dirent,\n          name: dirent.name,\n          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)\n        };\n        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {\n          try {\n            const stats = settings.fs.statSync(entry.path);\n            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);\n          } catch (error) {\n            if (settings.throwErrorOnBrokenSymbolicLink) {\n              throw error;\n            }\n          }\n        }\n        return entry;\n      });\n    }\n    exports2.readdirWithFileTypes = readdirWithFileTypes;\n    function readdir(directory, settings) {\n      const names = settings.fs.readdirSync(directory);\n      return names.map((name) => {\n        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);\n        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);\n        const entry = {\n          name,\n          path: entryPath,\n          dirent: utils.fs.createDirentFromStats(name, stats)\n        };\n        if (settings.stats) {\n          entry.stats = stats;\n        }\n        return entry;\n      });\n    }\n    exports2.readdir = readdir;\n  }\n});\nvar require_fs4 = __commonJS2({\n  "node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;\n    var fs = require("fs");\n    exports2.FILE_SYSTEM_ADAPTER = {\n      lstat: fs.lstat,\n      stat: fs.stat,\n      lstatSync: fs.lstatSync,\n      statSync: fs.statSync,\n      readdir: fs.readdir,\n      readdirSync: fs.readdirSync\n    };\n    function createFileSystemAdapter(fsMethods) {\n      if (fsMethods === void 0) {\n        return exports2.FILE_SYSTEM_ADAPTER;\n      }\n      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);\n    }\n    exports2.createFileSystemAdapter = createFileSystemAdapter;\n  }\n});\nvar require_settings2 = __commonJS2({\n  "node_modules/@nodelib/fs.scandir/out/settings.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var path = require("path");\n    var fsStat = require_out();\n    var fs = require_fs4();\n    var Settings = class {\n      constructor(_options = {}) {\n        this._options = _options;\n        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);\n        this.fs = fs.createFileSystemAdapter(this._options.fs);\n        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);\n        this.stats = this._getValue(this._options.stats, false);\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);\n        this.fsStatSettings = new fsStat.Settings({\n          followSymbolicLink: this.followSymbolicLinks,\n          fs: this.fs,\n          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink\n        });\n      }\n      _getValue(option, value) {\n        return option !== null && option !== void 0 ? option : value;\n      }\n    };\n    exports2.default = Settings;\n  }\n});\nvar require_out2 = __commonJS2({\n  "node_modules/@nodelib/fs.scandir/out/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;\n    var async = require_async3();\n    var sync = require_sync3();\n    var settings_1 = require_settings2();\n    exports2.Settings = settings_1.default;\n    function scandir(path, optionsOrSettingsOrCallback, callback) {\n      if (typeof optionsOrSettingsOrCallback === "function") {\n        async.read(path, getSettings(), optionsOrSettingsOrCallback);\n        return;\n      }\n      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);\n    }\n    exports2.scandir = scandir;\n    function scandirSync(path, optionsOrSettings) {\n      const settings = getSettings(optionsOrSettings);\n      return sync.read(path, settings);\n    }\n    exports2.scandirSync = scandirSync;\n    function getSettings(settingsOrOptions = {}) {\n      if (settingsOrOptions instanceof settings_1.default) {\n        return settingsOrOptions;\n      }\n      return new settings_1.default(settingsOrOptions);\n    }\n  }\n});\nvar require_reusify = __commonJS2({\n  "node_modules/reusify/reusify.js"(exports2, module2) {\n    "use strict";\n    function reusify(Constructor) {\n      var head = new Constructor();\n      var tail = head;\n      function get() {\n        var current = head;\n        if (current.next) {\n          head = current.next;\n        } else {\n          head = new Constructor();\n          tail = head;\n        }\n        current.next = null;\n        return current;\n      }\n      function release(obj) {\n        tail.next = obj;\n        tail = obj;\n      }\n      return {\n        get,\n        release\n      };\n    }\n    module2.exports = reusify;\n  }\n});\nvar require_queue = __commonJS2({\n  "node_modules/fastq/queue.js"(exports2, module2) {\n    "use strict";\n    var reusify = require_reusify();\n    function fastqueue(context, worker, concurrency) {\n      if (typeof context === "function") {\n        concurrency = worker;\n        worker = context;\n        context = null;\n      }\n      if (concurrency < 1) {\n        throw new Error("fastqueue concurrency must be greater than 1");\n      }\n      var cache = reusify(Task);\n      var queueHead = null;\n      var queueTail = null;\n      var _running = 0;\n      var errorHandler = null;\n      var self2 = {\n        push,\n        drain: noop,\n        saturated: noop,\n        pause,\n        paused: false,\n        concurrency,\n        running,\n        resume,\n        idle,\n        length,\n        getQueue,\n        unshift,\n        empty: noop,\n        kill,\n        killAndDrain,\n        error\n      };\n      return self2;\n      function running() {\n        return _running;\n      }\n      function pause() {\n        self2.paused = true;\n      }\n      function length() {\n        var current = queueHead;\n        var counter = 0;\n        while (current) {\n          current = current.next;\n          counter++;\n        }\n        return counter;\n      }\n      function getQueue() {\n        var current = queueHead;\n        var tasks = [];\n        while (current) {\n          tasks.push(current.value);\n          current = current.next;\n        }\n        return tasks;\n      }\n      function resume() {\n        if (!self2.paused)\n          return;\n        self2.paused = false;\n        for (var i = 0; i < self2.concurrency; i++) {\n          _running++;\n          release();\n        }\n      }\n      function idle() {\n        return _running === 0 && self2.length() === 0;\n      }\n      function push(value, done) {\n        var current = cache.get();\n        current.context = context;\n        current.release = release;\n        current.value = value;\n        current.callback = done || noop;\n        current.errorHandler = errorHandler;\n        if (_running === self2.concurrency || self2.paused) {\n          if (queueTail) {\n            queueTail.next = current;\n            queueTail = current;\n          } else {\n            queueHead = current;\n            queueTail = current;\n            self2.saturated();\n          }\n        } else {\n          _running++;\n          worker.call(context, current.value, current.worked);\n        }\n      }\n      function unshift(value, done) {\n        var current = cache.get();\n        current.context = context;\n        current.release = release;\n        current.value = value;\n        current.callback = done || noop;\n        if (_running === self2.concurrency || self2.paused) {\n          if (queueHead) {\n            current.next = queueHead;\n            queueHead = current;\n          } else {\n            queueHead = current;\n            queueTail = current;\n            self2.saturated();\n          }\n        } else {\n          _running++;\n          worker.call(context, current.value, current.worked);\n        }\n      }\n      function release(holder) {\n        if (holder) {\n          cache.release(holder);\n        }\n        var next = queueHead;\n        if (next) {\n          if (!self2.paused) {\n            if (queueTail === queueHead) {\n              queueTail = null;\n            }\n            queueHead = next.next;\n            next.next = null;\n            worker.call(context, next.value, next.worked);\n            if (queueTail === null) {\n              self2.empty();\n            }\n          } else {\n            _running--;\n          }\n        } else if (--_running === 0) {\n          self2.drain();\n        }\n      }\n      function kill() {\n        queueHead = null;\n        queueTail = null;\n        self2.drain = noop;\n      }\n      function killAndDrain() {\n        queueHead = null;\n        queueTail = null;\n        self2.drain();\n        self2.drain = noop;\n      }\n      function error(handler) {\n        errorHandler = handler;\n      }\n    }\n    function noop() {\n    }\n    function Task() {\n      this.value = null;\n      this.callback = noop;\n      this.next = null;\n      this.release = noop;\n      this.context = null;\n      this.errorHandler = null;\n      var self2 = this;\n      this.worked = function worked(err, result) {\n        var callback = self2.callback;\n        var errorHandler = self2.errorHandler;\n        var val = self2.value;\n        self2.value = null;\n        self2.callback = noop;\n        if (self2.errorHandler) {\n          errorHandler(err, val);\n        }\n        callback.call(self2.context, err, result);\n        self2.release(self2);\n      };\n    }\n    function queueAsPromised(context, worker, concurrency) {\n      if (typeof context === "function") {\n        concurrency = worker;\n        worker = context;\n        context = null;\n      }\n      function asyncWrapper(arg, cb) {\n        worker.call(this, arg).then(function(res) {\n          cb(null, res);\n        }, cb);\n      }\n      var queue = fastqueue(context, asyncWrapper, concurrency);\n      var pushCb = queue.push;\n      var unshiftCb = queue.unshift;\n      queue.push = push;\n      queue.unshift = unshift;\n      queue.drained = drained;\n      return queue;\n      function push(value) {\n        var p = new Promise(function(resolve, reject) {\n          pushCb(value, function(err, result) {\n            if (err) {\n              reject(err);\n              return;\n            }\n            resolve(result);\n          });\n        });\n        p.catch(noop);\n        return p;\n      }\n      function unshift(value) {\n        var p = new Promise(function(resolve, reject) {\n          unshiftCb(value, function(err, result) {\n            if (err) {\n              reject(err);\n              return;\n            }\n            resolve(result);\n          });\n        });\n        p.catch(noop);\n        return p;\n      }\n      function drained() {\n        var previousDrain = queue.drain;\n        var p = new Promise(function(resolve) {\n          queue.drain = function() {\n            previousDrain();\n            resolve();\n          };\n        });\n        return p;\n      }\n    }\n    module2.exports = fastqueue;\n    module2.exports.promise = queueAsPromised;\n  }\n});\nvar require_common4 = __commonJS2({\n  "node_modules/@nodelib/fs.walk/out/readers/common.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;\n    function isFatalError(settings, error) {\n      if (settings.errorFilter === null) {\n        return true;\n      }\n      return !settings.errorFilter(error);\n    }\n    exports2.isFatalError = isFatalError;\n    function isAppliedFilter(filter, value) {\n      return filter === null || filter(value);\n    }\n    exports2.isAppliedFilter = isAppliedFilter;\n    function replacePathSegmentSeparator(filepath, separator) {\n      return filepath.split(/[/\\\\]/).join(separator);\n    }\n    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;\n    function joinPathSegments(a, b, separator) {\n      if (a === "") {\n        return b;\n      }\n      if (a.endsWith(separator)) {\n        return a + b;\n      }\n      return a + separator + b;\n    }\n    exports2.joinPathSegments = joinPathSegments;\n  }\n});\nvar require_reader = __commonJS2({\n  "node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var common = require_common4();\n    var Reader = class {\n      constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);\n      }\n    };\n    exports2.default = Reader;\n  }\n});\nvar require_async4 = __commonJS2({\n  "node_modules/@nodelib/fs.walk/out/readers/async.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var events_1 = require("events");\n    var fsScandir = require_out2();\n    var fastq = require_queue();\n    var common = require_common4();\n    var reader_1 = require_reader();\n    var AsyncReader = class extends reader_1.default {\n      constructor(_root, _settings) {\n        super(_root, _settings);\n        this._settings = _settings;\n        this._scandir = fsScandir.scandir;\n        this._emitter = new events_1.EventEmitter();\n        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        this._queue.drain = () => {\n          if (!this._isFatalError) {\n            this._emitter.emit("end");\n          }\n        };\n      }\n      read() {\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        setImmediate(() => {\n          this._pushToQueue(this._root, this._settings.basePath);\n        });\n        return this._emitter;\n      }\n      get isDestroyed() {\n        return this._isDestroyed;\n      }\n      destroy() {\n        if (this._isDestroyed) {\n          throw new Error("The reader is already destroyed");\n        }\n        this._isDestroyed = true;\n        this._queue.killAndDrain();\n      }\n      onEntry(callback) {\n        this._emitter.on("entry", callback);\n      }\n      onError(callback) {\n        this._emitter.once("error", callback);\n      }\n      onEnd(callback) {\n        this._emitter.once("end", callback);\n      }\n      _pushToQueue(directory, base) {\n        const queueItem = {\n          directory,\n          base\n        };\n        this._queue.push(queueItem, (error) => {\n          if (error !== null) {\n            this._handleError(error);\n          }\n        });\n      }\n      _worker(item, done) {\n        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {\n          if (error !== null) {\n            done(error, void 0);\n            return;\n          }\n          for (const entry of entries) {\n            this._handleEntry(entry, item.base);\n          }\n          done(null, void 0);\n        });\n      }\n      _handleError(error) {\n        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {\n          return;\n        }\n        this._isFatalError = true;\n        this._isDestroyed = true;\n        this._emitter.emit("error", error);\n      }\n      _handleEntry(entry, base) {\n        if (this._isDestroyed || this._isFatalError) {\n          return;\n        }\n        const fullpath = entry.path;\n        if (base !== void 0) {\n          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n        }\n        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\n          this._emitEntry(entry);\n        }\n        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\n          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);\n        }\n      }\n      _emitEntry(entry) {\n        this._emitter.emit("entry", entry);\n      }\n    };\n    exports2.default = AsyncReader;\n  }\n});\nvar require_async5 = __commonJS2({\n  "node_modules/@nodelib/fs.walk/out/providers/async.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var async_1 = require_async4();\n    var AsyncProvider = class {\n      constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._reader = new async_1.default(this._root, this._settings);\n        this._storage = [];\n      }\n      read(callback) {\n        this._reader.onError((error) => {\n          callFailureCallback(callback, error);\n        });\n        this._reader.onEntry((entry) => {\n          this._storage.push(entry);\n        });\n        this._reader.onEnd(() => {\n          callSuccessCallback(callback, this._storage);\n        });\n        this._reader.read();\n      }\n    };\n    exports2.default = AsyncProvider;\n    function callFailureCallback(callback, error) {\n      callback(error);\n    }\n    function callSuccessCallback(callback, entries) {\n      callback(null, entries);\n    }\n  }\n});\nvar require_stream2 = __commonJS2({\n  "node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var stream_1 = require("stream");\n    var async_1 = require_async4();\n    var StreamProvider = class {\n      constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._reader = new async_1.default(this._root, this._settings);\n        this._stream = new stream_1.Readable({\n          objectMode: true,\n          read: () => {\n          },\n          destroy: () => {\n            if (!this._reader.isDestroyed) {\n              this._reader.destroy();\n            }\n          }\n        });\n      }\n      read() {\n        this._reader.onError((error) => {\n          this._stream.emit("error", error);\n        });\n        this._reader.onEntry((entry) => {\n          this._stream.push(entry);\n        });\n        this._reader.onEnd(() => {\n          this._stream.push(null);\n        });\n        this._reader.read();\n        return this._stream;\n      }\n    };\n    exports2.default = StreamProvider;\n  }\n});\nvar require_sync4 = __commonJS2({\n  "node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var fsScandir = require_out2();\n    var common = require_common4();\n    var reader_1 = require_reader();\n    var SyncReader = class extends reader_1.default {\n      constructor() {\n        super(...arguments);\n        this._scandir = fsScandir.scandirSync;\n        this._storage = [];\n        this._queue = /* @__PURE__ */ new Set();\n      }\n      read() {\n        this._pushToQueue(this._root, this._settings.basePath);\n        this._handleQueue();\n        return this._storage;\n      }\n      _pushToQueue(directory, base) {\n        this._queue.add({\n          directory,\n          base\n        });\n      }\n      _handleQueue() {\n        for (const item of this._queue.values()) {\n          this._handleDirectory(item.directory, item.base);\n        }\n      }\n      _handleDirectory(directory, base) {\n        try {\n          const entries = this._scandir(directory, this._settings.fsScandirSettings);\n          for (const entry of entries) {\n            this._handleEntry(entry, base);\n          }\n        } catch (error) {\n          this._handleError(error);\n        }\n      }\n      _handleError(error) {\n        if (!common.isFatalError(this._settings, error)) {\n          return;\n        }\n        throw error;\n      }\n      _handleEntry(entry, base) {\n        const fullpath = entry.path;\n        if (base !== void 0) {\n          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n        }\n        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\n          this._pushToStorage(entry);\n        }\n        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\n          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);\n        }\n      }\n      _pushToStorage(entry) {\n        this._storage.push(entry);\n      }\n    };\n    exports2.default = SyncReader;\n  }\n});\nvar require_sync5 = __commonJS2({\n  "node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var sync_1 = require_sync4();\n    var SyncProvider = class {\n      constructor(_root, _settings) {\n        this._root = _root;\n        this._settings = _settings;\n        this._reader = new sync_1.default(this._root, this._settings);\n      }\n      read() {\n        return this._reader.read();\n      }\n    };\n    exports2.default = SyncProvider;\n  }\n});\nvar require_settings3 = __commonJS2({\n  "node_modules/@nodelib/fs.walk/out/settings.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var path = require("path");\n    var fsScandir = require_out2();\n    var Settings = class {\n      constructor(_options = {}) {\n        this._options = _options;\n        this.basePath = this._getValue(this._options.basePath, void 0);\n        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);\n        this.deepFilter = this._getValue(this._options.deepFilter, null);\n        this.entryFilter = this._getValue(this._options.entryFilter, null);\n        this.errorFilter = this._getValue(this._options.errorFilter, null);\n        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);\n        this.fsScandirSettings = new fsScandir.Settings({\n          followSymbolicLinks: this._options.followSymbolicLinks,\n          fs: this._options.fs,\n          pathSegmentSeparator: this._options.pathSegmentSeparator,\n          stats: this._options.stats,\n          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink\n        });\n      }\n      _getValue(option, value) {\n        return option !== null && option !== void 0 ? option : value;\n      }\n    };\n    exports2.default = Settings;\n  }\n});\nvar require_out3 = __commonJS2({\n  "node_modules/@nodelib/fs.walk/out/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;\n    var async_1 = require_async5();\n    var stream_1 = require_stream2();\n    var sync_1 = require_sync5();\n    var settings_1 = require_settings3();\n    exports2.Settings = settings_1.default;\n    function walk(directory, optionsOrSettingsOrCallback, callback) {\n      if (typeof optionsOrSettingsOrCallback === "function") {\n        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);\n        return;\n      }\n      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);\n    }\n    exports2.walk = walk;\n    function walkSync(directory, optionsOrSettings) {\n      const settings = getSettings(optionsOrSettings);\n      const provider = new sync_1.default(directory, settings);\n      return provider.read();\n    }\n    exports2.walkSync = walkSync;\n    function walkStream(directory, optionsOrSettings) {\n      const settings = getSettings(optionsOrSettings);\n      const provider = new stream_1.default(directory, settings);\n      return provider.read();\n    }\n    exports2.walkStream = walkStream;\n    function getSettings(settingsOrOptions = {}) {\n      if (settingsOrOptions instanceof settings_1.default) {\n        return settingsOrOptions;\n      }\n      return new settings_1.default(settingsOrOptions);\n    }\n  }\n});\nvar require_reader2 = __commonJS2({\n  "node_modules/fast-glob/out/readers/reader.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var path = require("path");\n    var fsStat = require_out();\n    var utils = require_utils4();\n    var Reader = class {\n      constructor(_settings) {\n        this._settings = _settings;\n        this._fsStatSettings = new fsStat.Settings({\n          followSymbolicLink: this._settings.followSymbolicLinks,\n          fs: this._settings.fs,\n          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks\n        });\n      }\n      _getFullEntryPath(filepath) {\n        return path.resolve(this._settings.cwd, filepath);\n      }\n      _makeEntry(stats, pattern) {\n        const entry = {\n          name: pattern,\n          path: pattern,\n          dirent: utils.fs.createDirentFromStats(pattern, stats)\n        };\n        if (this._settings.stats) {\n          entry.stats = stats;\n        }\n        return entry;\n      }\n      _isFatalError(error) {\n        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;\n      }\n    };\n    exports2.default = Reader;\n  }\n});\nvar require_stream3 = __commonJS2({\n  "node_modules/fast-glob/out/readers/stream.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var stream_1 = require("stream");\n    var fsStat = require_out();\n    var fsWalk = require_out3();\n    var reader_1 = require_reader2();\n    var ReaderStream = class extends reader_1.default {\n      constructor() {\n        super(...arguments);\n        this._walkStream = fsWalk.walkStream;\n        this._stat = fsStat.stat;\n      }\n      dynamic(root, options) {\n        return this._walkStream(root, options);\n      }\n      static(patterns, options) {\n        const filepaths = patterns.map(this._getFullEntryPath, this);\n        const stream = new stream_1.PassThrough({\n          objectMode: true\n        });\n        stream._write = (index, _enc, done) => {\n          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {\n            if (entry !== null && options.entryFilter(entry)) {\n              stream.push(entry);\n            }\n            if (index === filepaths.length - 1) {\n              stream.end();\n            }\n            done();\n          }).catch(done);\n        };\n        for (let i = 0; i < filepaths.length; i++) {\n          stream.write(i);\n        }\n        return stream;\n      }\n      _getEntry(filepath, pattern, options) {\n        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {\n          if (options.errorFilter(error)) {\n            return null;\n          }\n          throw error;\n        });\n      }\n      _getStat(filepath) {\n        return new Promise((resolve, reject) => {\n          this._stat(filepath, this._fsStatSettings, (error, stats) => {\n            return error === null ? resolve(stats) : reject(error);\n          });\n        });\n      }\n    };\n    exports2.default = ReaderStream;\n  }\n});\nvar require_async6 = __commonJS2({\n  "node_modules/fast-glob/out/readers/async.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var fsWalk = require_out3();\n    var reader_1 = require_reader2();\n    var stream_1 = require_stream3();\n    var ReaderAsync = class extends reader_1.default {\n      constructor() {\n        super(...arguments);\n        this._walkAsync = fsWalk.walk;\n        this._readerStream = new stream_1.default(this._settings);\n      }\n      dynamic(root, options) {\n        return new Promise((resolve, reject) => {\n          this._walkAsync(root, options, (error, entries) => {\n            if (error === null) {\n              resolve(entries);\n            } else {\n              reject(error);\n            }\n          });\n        });\n      }\n      async static(patterns, options) {\n        const entries = [];\n        const stream = this._readerStream.static(patterns, options);\n        return new Promise((resolve, reject) => {\n          stream.once("error", reject);\n          stream.on("data", (entry) => entries.push(entry));\n          stream.once("end", () => resolve(entries));\n        });\n      }\n    };\n    exports2.default = ReaderAsync;\n  }\n});\nvar require_matcher = __commonJS2({\n  "node_modules/fast-glob/out/providers/matchers/matcher.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var utils = require_utils4();\n    var Matcher = class {\n      constructor(_patterns, _settings, _micromatchOptions) {\n        this._patterns = _patterns;\n        this._settings = _settings;\n        this._micromatchOptions = _micromatchOptions;\n        this._storage = [];\n        this._fillStorage();\n      }\n      _fillStorage() {\n        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);\n        for (const pattern of patterns) {\n          const segments = this._getPatternSegments(pattern);\n          const sections = this._splitSegmentsIntoSections(segments);\n          this._storage.push({\n            complete: sections.length <= 1,\n            pattern,\n            segments,\n            sections\n          });\n        }\n      }\n      _getPatternSegments(pattern) {\n        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\n        return parts.map((part) => {\n          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);\n          if (!dynamic) {\n            return {\n              dynamic: false,\n              pattern: part\n            };\n          }\n          return {\n            dynamic: true,\n            pattern: part,\n            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)\n          };\n        });\n      }\n      _splitSegmentsIntoSections(segments) {\n        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));\n      }\n    };\n    exports2.default = Matcher;\n  }\n});\nvar require_partial = __commonJS2({\n  "node_modules/fast-glob/out/providers/matchers/partial.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var matcher_1 = require_matcher();\n    var PartialMatcher = class extends matcher_1.default {\n      match(filepath) {\n        const parts = filepath.split("/");\n        const levels = parts.length;\n        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);\n        for (const pattern of patterns) {\n          const section = pattern.sections[0];\n          if (!pattern.complete && levels > section.length) {\n            return true;\n          }\n          const match = parts.every((part, index) => {\n            const segment = pattern.segments[index];\n            if (segment.dynamic && segment.patternRe.test(part)) {\n              return true;\n            }\n            if (!segment.dynamic && segment.pattern === part) {\n              return true;\n            }\n            return false;\n          });\n          if (match) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n    exports2.default = PartialMatcher;\n  }\n});\nvar require_deep = __commonJS2({\n  "node_modules/fast-glob/out/providers/filters/deep.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var utils = require_utils4();\n    var partial_1 = require_partial();\n    var DeepFilter = class {\n      constructor(_settings, _micromatchOptions) {\n        this._settings = _settings;\n        this._micromatchOptions = _micromatchOptions;\n      }\n      getFilter(basePath, positive, negative) {\n        const matcher = this._getMatcher(positive);\n        const negativeRe = this._getNegativePatternsRe(negative);\n        return (entry) => this._filter(basePath, entry, matcher, negativeRe);\n      }\n      _getMatcher(patterns) {\n        return new partial_1.default(patterns, this._settings, this._micromatchOptions);\n      }\n      _getNegativePatternsRe(patterns) {\n        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);\n        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);\n      }\n      _filter(basePath, entry, matcher, negativeRe) {\n        if (this._isSkippedByDeep(basePath, entry.path)) {\n          return false;\n        }\n        if (this._isSkippedSymbolicLink(entry)) {\n          return false;\n        }\n        const filepath = utils.path.removeLeadingDotSegment(entry.path);\n        if (this._isSkippedByPositivePatterns(filepath, matcher)) {\n          return false;\n        }\n        return this._isSkippedByNegativePatterns(filepath, negativeRe);\n      }\n      _isSkippedByDeep(basePath, entryPath) {\n        if (this._settings.deep === Infinity) {\n          return false;\n        }\n        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;\n      }\n      _getEntryLevel(basePath, entryPath) {\n        const entryPathDepth = entryPath.split("/").length;\n        if (basePath === "") {\n          return entryPathDepth;\n        }\n        const basePathDepth = basePath.split("/").length;\n        return entryPathDepth - basePathDepth;\n      }\n      _isSkippedSymbolicLink(entry) {\n        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();\n      }\n      _isSkippedByPositivePatterns(entryPath, matcher) {\n        return !this._settings.baseNameMatch && !matcher.match(entryPath);\n      }\n      _isSkippedByNegativePatterns(entryPath, patternsRe) {\n        return !utils.pattern.matchAny(entryPath, patternsRe);\n      }\n    };\n    exports2.default = DeepFilter;\n  }\n});\nvar require_entry = __commonJS2({\n  "node_modules/fast-glob/out/providers/filters/entry.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var utils = require_utils4();\n    var EntryFilter = class {\n      constructor(_settings, _micromatchOptions) {\n        this._settings = _settings;\n        this._micromatchOptions = _micromatchOptions;\n        this.index = /* @__PURE__ */ new Map();\n      }\n      getFilter(positive, negative) {\n        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);\n        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);\n        return (entry) => this._filter(entry, positiveRe, negativeRe);\n      }\n      _filter(entry, positiveRe, negativeRe) {\n        if (this._settings.unique && this._isDuplicateEntry(entry)) {\n          return false;\n        }\n        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {\n          return false;\n        }\n        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {\n          return false;\n        }\n        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;\n        const isDirectory = entry.dirent.isDirectory();\n        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(entry.path, negativeRe, isDirectory);\n        if (this._settings.unique && isMatched) {\n          this._createIndexRecord(entry);\n        }\n        return isMatched;\n      }\n      _isDuplicateEntry(entry) {\n        return this.index.has(entry.path);\n      }\n      _createIndexRecord(entry) {\n        this.index.set(entry.path, void 0);\n      }\n      _onlyFileFilter(entry) {\n        return this._settings.onlyFiles && !entry.dirent.isFile();\n      }\n      _onlyDirectoryFilter(entry) {\n        return this._settings.onlyDirectories && !entry.dirent.isDirectory();\n      }\n      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {\n        if (!this._settings.absolute) {\n          return false;\n        }\n        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);\n        return utils.pattern.matchAny(fullpath, patternsRe);\n      }\n      _isMatchToPatterns(entryPath, patternsRe, isDirectory) {\n        const filepath = utils.path.removeLeadingDotSegment(entryPath);\n        const isMatched = utils.pattern.matchAny(filepath, patternsRe);\n        if (!isMatched && isDirectory) {\n          return utils.pattern.matchAny(filepath + "/", patternsRe);\n        }\n        return isMatched;\n      }\n    };\n    exports2.default = EntryFilter;\n  }\n});\nvar require_error = __commonJS2({\n  "node_modules/fast-glob/out/providers/filters/error.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var utils = require_utils4();\n    var ErrorFilter = class {\n      constructor(_settings) {\n        this._settings = _settings;\n      }\n      getFilter() {\n        return (error) => this._isNonFatalError(error);\n      }\n      _isNonFatalError(error) {\n        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;\n      }\n    };\n    exports2.default = ErrorFilter;\n  }\n});\nvar require_entry2 = __commonJS2({\n  "node_modules/fast-glob/out/providers/transformers/entry.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var utils = require_utils4();\n    var EntryTransformer = class {\n      constructor(_settings) {\n        this._settings = _settings;\n      }\n      getTransformer() {\n        return (entry) => this._transform(entry);\n      }\n      _transform(entry) {\n        let filepath = entry.path;\n        if (this._settings.absolute) {\n          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);\n          filepath = utils.path.unixify(filepath);\n        }\n        if (this._settings.markDirectories && entry.dirent.isDirectory()) {\n          filepath += "/";\n        }\n        if (!this._settings.objectMode) {\n          return filepath;\n        }\n        return Object.assign(Object.assign({}, entry), {\n          path: filepath\n        });\n      }\n    };\n    exports2.default = EntryTransformer;\n  }\n});\nvar require_provider = __commonJS2({\n  "node_modules/fast-glob/out/providers/provider.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var path = require("path");\n    var deep_1 = require_deep();\n    var entry_1 = require_entry();\n    var error_1 = require_error();\n    var entry_2 = require_entry2();\n    var Provider = class {\n      constructor(_settings) {\n        this._settings = _settings;\n        this.errorFilter = new error_1.default(this._settings);\n        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());\n        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());\n        this.entryTransformer = new entry_2.default(this._settings);\n      }\n      _getRootDirectory(task) {\n        return path.resolve(this._settings.cwd, task.base);\n      }\n      _getReaderOptions(task) {\n        const basePath = task.base === "." ? "" : task.base;\n        return {\n          basePath,\n          pathSegmentSeparator: "/",\n          concurrency: this._settings.concurrency,\n          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),\n          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),\n          errorFilter: this.errorFilter.getFilter(),\n          followSymbolicLinks: this._settings.followSymbolicLinks,\n          fs: this._settings.fs,\n          stats: this._settings.stats,\n          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,\n          transform: this.entryTransformer.getTransformer()\n        };\n      }\n      _getMicromatchOptions() {\n        return {\n          dot: this._settings.dot,\n          matchBase: this._settings.baseNameMatch,\n          nobrace: !this._settings.braceExpansion,\n          nocase: !this._settings.caseSensitiveMatch,\n          noext: !this._settings.extglob,\n          noglobstar: !this._settings.globstar,\n          posix: true,\n          strictSlashes: false\n        };\n      }\n    };\n    exports2.default = Provider;\n  }\n});\nvar require_async7 = __commonJS2({\n  "node_modules/fast-glob/out/providers/async.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var async_1 = require_async6();\n    var provider_1 = require_provider();\n    var ProviderAsync = class extends provider_1.default {\n      constructor() {\n        super(...arguments);\n        this._reader = new async_1.default(this._settings);\n      }\n      async read(task) {\n        const root = this._getRootDirectory(task);\n        const options = this._getReaderOptions(task);\n        const entries = await this.api(root, task, options);\n        return entries.map((entry) => options.transform(entry));\n      }\n      api(root, task, options) {\n        if (task.dynamic) {\n          return this._reader.dynamic(root, options);\n        }\n        return this._reader.static(task.patterns, options);\n      }\n    };\n    exports2.default = ProviderAsync;\n  }\n});\nvar require_stream4 = __commonJS2({\n  "node_modules/fast-glob/out/providers/stream.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var stream_1 = require("stream");\n    var stream_2 = require_stream3();\n    var provider_1 = require_provider();\n    var ProviderStream = class extends provider_1.default {\n      constructor() {\n        super(...arguments);\n        this._reader = new stream_2.default(this._settings);\n      }\n      read(task) {\n        const root = this._getRootDirectory(task);\n        const options = this._getReaderOptions(task);\n        const source = this.api(root, task, options);\n        const destination = new stream_1.Readable({\n          objectMode: true,\n          read: () => {\n          }\n        });\n        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));\n        destination.once("close", () => source.destroy());\n        return destination;\n      }\n      api(root, task, options) {\n        if (task.dynamic) {\n          return this._reader.dynamic(root, options);\n        }\n        return this._reader.static(task.patterns, options);\n      }\n    };\n    exports2.default = ProviderStream;\n  }\n});\nvar require_sync6 = __commonJS2({\n  "node_modules/fast-glob/out/readers/sync.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var fsStat = require_out();\n    var fsWalk = require_out3();\n    var reader_1 = require_reader2();\n    var ReaderSync = class extends reader_1.default {\n      constructor() {\n        super(...arguments);\n        this._walkSync = fsWalk.walkSync;\n        this._statSync = fsStat.statSync;\n      }\n      dynamic(root, options) {\n        return this._walkSync(root, options);\n      }\n      static(patterns, options) {\n        const entries = [];\n        for (const pattern of patterns) {\n          const filepath = this._getFullEntryPath(pattern);\n          const entry = this._getEntry(filepath, pattern, options);\n          if (entry === null || !options.entryFilter(entry)) {\n            continue;\n          }\n          entries.push(entry);\n        }\n        return entries;\n      }\n      _getEntry(filepath, pattern, options) {\n        try {\n          const stats = this._getStat(filepath);\n          return this._makeEntry(stats, pattern);\n        } catch (error) {\n          if (options.errorFilter(error)) {\n            return null;\n          }\n          throw error;\n        }\n      }\n      _getStat(filepath) {\n        return this._statSync(filepath, this._fsStatSettings);\n      }\n    };\n    exports2.default = ReaderSync;\n  }\n});\nvar require_sync7 = __commonJS2({\n  "node_modules/fast-glob/out/providers/sync.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var sync_1 = require_sync6();\n    var provider_1 = require_provider();\n    var ProviderSync = class extends provider_1.default {\n      constructor() {\n        super(...arguments);\n        this._reader = new sync_1.default(this._settings);\n      }\n      read(task) {\n        const root = this._getRootDirectory(task);\n        const options = this._getReaderOptions(task);\n        const entries = this.api(root, task, options);\n        return entries.map(options.transform);\n      }\n      api(root, task, options) {\n        if (task.dynamic) {\n          return this._reader.dynamic(root, options);\n        }\n        return this._reader.static(task.patterns, options);\n      }\n    };\n    exports2.default = ProviderSync;\n  }\n});\nvar require_settings4 = __commonJS2({\n  "node_modules/fast-glob/out/settings.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;\n    var fs = require("fs");\n    var os = require("os");\n    var CPU_COUNT = Math.max(os.cpus().length, 1);\n    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {\n      lstat: fs.lstat,\n      lstatSync: fs.lstatSync,\n      stat: fs.stat,\n      statSync: fs.statSync,\n      readdir: fs.readdir,\n      readdirSync: fs.readdirSync\n    };\n    var Settings = class {\n      constructor(_options = {}) {\n        this._options = _options;\n        this.absolute = this._getValue(this._options.absolute, false);\n        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);\n        this.braceExpansion = this._getValue(this._options.braceExpansion, true);\n        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);\n        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);\n        this.cwd = this._getValue(this._options.cwd, process.cwd());\n        this.deep = this._getValue(this._options.deep, Infinity);\n        this.dot = this._getValue(this._options.dot, false);\n        this.extglob = this._getValue(this._options.extglob, true);\n        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);\n        this.fs = this._getFileSystemMethods(this._options.fs);\n        this.globstar = this._getValue(this._options.globstar, true);\n        this.ignore = this._getValue(this._options.ignore, []);\n        this.markDirectories = this._getValue(this._options.markDirectories, false);\n        this.objectMode = this._getValue(this._options.objectMode, false);\n        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);\n        this.onlyFiles = this._getValue(this._options.onlyFiles, true);\n        this.stats = this._getValue(this._options.stats, false);\n        this.suppressErrors = this._getValue(this._options.suppressErrors, false);\n        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);\n        this.unique = this._getValue(this._options.unique, true);\n        if (this.onlyDirectories) {\n          this.onlyFiles = false;\n        }\n        if (this.stats) {\n          this.objectMode = true;\n        }\n      }\n      _getValue(option, value) {\n        return option === void 0 ? value : option;\n      }\n      _getFileSystemMethods(methods = {}) {\n        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);\n      }\n    };\n    exports2.default = Settings;\n  }\n});\nvar require_out4 = __commonJS2({\n  "node_modules/fast-glob/out/index.js"(exports2, module2) {\n    "use strict";\n    var taskManager = require_tasks();\n    var patternManager = require_patterns();\n    var async_1 = require_async7();\n    var stream_1 = require_stream4();\n    var sync_1 = require_sync7();\n    var settings_1 = require_settings4();\n    var utils = require_utils4();\n    async function FastGlob(source, options) {\n      assertPatternsInput(source);\n      const works = getWorks(source, async_1.default, options);\n      const result = await Promise.all(works);\n      return utils.array.flatten(result);\n    }\n    (function(FastGlob2) {\n      function sync(source, options) {\n        assertPatternsInput(source);\n        const works = getWorks(source, sync_1.default, options);\n        return utils.array.flatten(works);\n      }\n      FastGlob2.sync = sync;\n      function stream(source, options) {\n        assertPatternsInput(source);\n        const works = getWorks(source, stream_1.default, options);\n        return utils.stream.merge(works);\n      }\n      FastGlob2.stream = stream;\n      function generateTasks(source, options) {\n        assertPatternsInput(source);\n        const patterns = patternManager.transform([].concat(source));\n        const settings = new settings_1.default(options);\n        return taskManager.generate(patterns, settings);\n      }\n      FastGlob2.generateTasks = generateTasks;\n      function isDynamicPattern(source, options) {\n        assertPatternsInput(source);\n        const settings = new settings_1.default(options);\n        return utils.pattern.isDynamicPattern(source, settings);\n      }\n      FastGlob2.isDynamicPattern = isDynamicPattern;\n      function escapePath(source) {\n        assertPatternsInput(source);\n        return utils.path.escape(source);\n      }\n      FastGlob2.escapePath = escapePath;\n    })(FastGlob || (FastGlob = {}));\n    function getWorks(source, _Provider, options) {\n      const patterns = patternManager.transform([].concat(source));\n      const settings = new settings_1.default(options);\n      const tasks = taskManager.generate(patterns, settings);\n      const provider = new _Provider(settings);\n      return tasks.map(provider.read, provider);\n    }\n    function assertPatternsInput(input) {\n      const source = [].concat(input);\n      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));\n      if (!isValidSource) {\n        throw new TypeError("Patterns must be a string (non empty) or an array of strings");\n      }\n    }\n    module2.exports = FastGlob;\n  }\n});\nvar require_uniq_by_key = __commonJS2({\n  "src/utils/uniq-by-key.js"(exports2, module2) {\n    "use strict";\n    function uniqByKey(array, key) {\n      const result = [];\n      const seen = /* @__PURE__ */ new Set();\n      for (const element of array) {\n        const value = element[key];\n        if (!seen.has(value)) {\n          seen.add(value);\n          result.push(element);\n        }\n      }\n      return result;\n    }\n    module2.exports = uniqByKey;\n  }\n});\nvar require_create_language = __commonJS2({\n  "src/utils/create-language.js"(exports2, module2) {\n    "use strict";\n    module2.exports = function(linguistData, override) {\n      const {\n        languageId\n      } = linguistData, rest = _objectWithoutProperties(linguistData, _excluded4);\n      return Object.assign(Object.assign({\n        linguistLanguageId: languageId\n      }, rest), override(linguistData));\n    };\n  }\n});\nvar require_ast = __commonJS2({\n  "node_modules/esutils/lib/ast.js"(exports2, module2) {\n    (function() {\n      "use strict";\n      function isExpression(node) {\n        if (node == null) {\n          return false;\n        }\n        switch (node.type) {\n          case "ArrayExpression":\n          case "AssignmentExpression":\n          case "BinaryExpression":\n          case "CallExpression":\n          case "ConditionalExpression":\n          case "FunctionExpression":\n          case "Identifier":\n          case "Literal":\n          case "LogicalExpression":\n          case "MemberExpression":\n          case "NewExpression":\n          case "ObjectExpression":\n          case "SequenceExpression":\n          case "ThisExpression":\n          case "UnaryExpression":\n          case "UpdateExpression":\n            return true;\n        }\n        return false;\n      }\n      function isIterationStatement(node) {\n        if (node == null) {\n          return false;\n        }\n        switch (node.type) {\n          case "DoWhileStatement":\n          case "ForInStatement":\n          case "ForStatement":\n          case "WhileStatement":\n            return true;\n        }\n        return false;\n      }\n      function isStatement(node) {\n        if (node == null) {\n          return false;\n        }\n        switch (node.type) {\n          case "BlockStatement":\n          case "BreakStatement":\n          case "ContinueStatement":\n          case "DebuggerStatement":\n          case "DoWhileStatement":\n          case "EmptyStatement":\n          case "ExpressionStatement":\n          case "ForInStatement":\n          case "ForStatement":\n          case "IfStatement":\n          case "LabeledStatement":\n          case "ReturnStatement":\n          case "SwitchStatement":\n          case "ThrowStatement":\n          case "TryStatement":\n          case "VariableDeclaration":\n          case "WhileStatement":\n          case "WithStatement":\n            return true;\n        }\n        return false;\n      }\n      function isSourceElement(node) {\n        return isStatement(node) || node != null && node.type === "FunctionDeclaration";\n      }\n      function trailingStatement(node) {\n        switch (node.type) {\n          case "IfStatement":\n            if (node.alternate != null) {\n              return node.alternate;\n            }\n            return node.consequent;\n          case "LabeledStatement":\n          case "ForStatement":\n          case "ForInStatement":\n          case "WhileStatement":\n          case "WithStatement":\n            return node.body;\n        }\n        return null;\n      }\n      function isProblematicIfStatement(node) {\n        var current;\n        if (node.type !== "IfStatement") {\n          return false;\n        }\n        if (node.alternate == null) {\n          return false;\n        }\n        current = node.consequent;\n        do {\n          if (current.type === "IfStatement") {\n            if (current.alternate == null) {\n              return true;\n            }\n          }\n          current = trailingStatement(current);\n        } while (current);\n        return false;\n      }\n      module2.exports = {\n        isExpression,\n        isStatement,\n        isIterationStatement,\n        isSourceElement,\n        isProblematicIfStatement,\n        trailingStatement\n      };\n    })();\n  }\n});\nvar require_code = __commonJS2({\n  "node_modules/esutils/lib/code.js"(exports2, module2) {\n    (function() {\n      "use strict";\n      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;\n      ES5Regex = {\n        NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n        NonAsciiIdentifierPart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/\n      };\n      ES6Regex = {\n        NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u08B6-\\u08BD\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDF00-\\uDF19]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]/,\n        NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B4\\u08B6-\\u08BD\\u08D4-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AE\\uA7B0-\\uA7B7\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDCA-\\uDDCC\\uDDD0-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9\\uDF00-\\uDF19\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F\\uDFE0]|\\uD821[\\uDC00-\\uDFEC]|\\uD822[\\uDC00-\\uDEF2]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4A\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n      };\n      function isDecimalDigit(ch2) {\n        return 48 <= ch2 && ch2 <= 57;\n      }\n      function isHexDigit(ch2) {\n        return 48 <= ch2 && ch2 <= 57 || 97 <= ch2 && ch2 <= 102 || 65 <= ch2 && ch2 <= 70;\n      }\n      function isOctalDigit(ch2) {\n        return ch2 >= 48 && ch2 <= 55;\n      }\n      NON_ASCII_WHITESPACES = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];\n      function isWhiteSpace(ch2) {\n        return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;\n      }\n      function isLineTerminator(ch2) {\n        return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;\n      }\n      function fromCodePoint(cp) {\n        if (cp <= 65535) {\n          return String.fromCharCode(cp);\n        }\n        var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);\n        var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);\n        return cu1 + cu2;\n      }\n      IDENTIFIER_START = new Array(128);\n      for (ch = 0; ch < 128; ++ch) {\n        IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch === 36 || ch === 95;\n      }\n      IDENTIFIER_PART = new Array(128);\n      for (ch = 0; ch < 128; ++ch) {\n        IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57 || ch === 36 || ch === 95;\n      }\n      function isIdentifierStartES5(ch2) {\n        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));\n      }\n      function isIdentifierPartES5(ch2) {\n        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));\n      }\n      function isIdentifierStartES6(ch2) {\n        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));\n      }\n      function isIdentifierPartES6(ch2) {\n        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));\n      }\n      module2.exports = {\n        isDecimalDigit,\n        isHexDigit,\n        isOctalDigit,\n        isWhiteSpace,\n        isLineTerminator,\n        isIdentifierStartES5,\n        isIdentifierPartES5,\n        isIdentifierStartES6,\n        isIdentifierPartES6\n      };\n    })();\n  }\n});\nvar require_keyword2 = __commonJS2({\n  "node_modules/esutils/lib/keyword.js"(exports2, module2) {\n    (function() {\n      "use strict";\n      var code = require_code();\n      function isStrictModeReservedWordES6(id) {\n        switch (id) {\n          case "implements":\n          case "interface":\n          case "package":\n          case "private":\n          case "protected":\n          case "public":\n          case "static":\n          case "let":\n            return true;\n          default:\n            return false;\n        }\n      }\n      function isKeywordES5(id, strict) {\n        if (!strict && id === "yield") {\n          return false;\n        }\n        return isKeywordES6(id, strict);\n      }\n      function isKeywordES6(id, strict) {\n        if (strict && isStrictModeReservedWordES6(id)) {\n          return true;\n        }\n        switch (id.length) {\n          case 2:\n            return id === "if" || id === "in" || id === "do";\n          case 3:\n            return id === "var" || id === "for" || id === "new" || id === "try";\n          case 4:\n            return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";\n          case 5:\n            return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";\n          case 6:\n            return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";\n          case 7:\n            return id === "default" || id === "finally" || id === "extends";\n          case 8:\n            return id === "function" || id === "continue" || id === "debugger";\n          case 10:\n            return id === "instanceof";\n          default:\n            return false;\n        }\n      }\n      function isReservedWordES5(id, strict) {\n        return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);\n      }\n      function isReservedWordES6(id, strict) {\n        return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);\n      }\n      function isRestrictedWord(id) {\n        return id === "eval" || id === "arguments";\n      }\n      function isIdentifierNameES5(id) {\n        var i, iz, ch;\n        if (id.length === 0) {\n          return false;\n        }\n        ch = id.charCodeAt(0);\n        if (!code.isIdentifierStartES5(ch)) {\n          return false;\n        }\n        for (i = 1, iz = id.length; i < iz; ++i) {\n          ch = id.charCodeAt(i);\n          if (!code.isIdentifierPartES5(ch)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      function decodeUtf16(lead, trail) {\n        return (lead - 55296) * 1024 + (trail - 56320) + 65536;\n      }\n      function isIdentifierNameES6(id) {\n        var i, iz, ch, lowCh, check;\n        if (id.length === 0) {\n          return false;\n        }\n        check = code.isIdentifierStartES6;\n        for (i = 0, iz = id.length; i < iz; ++i) {\n          ch = id.charCodeAt(i);\n          if (55296 <= ch && ch <= 56319) {\n            ++i;\n            if (i >= iz) {\n              return false;\n            }\n            lowCh = id.charCodeAt(i);\n            if (!(56320 <= lowCh && lowCh <= 57343)) {\n              return false;\n            }\n            ch = decodeUtf16(ch, lowCh);\n          }\n          if (!check(ch)) {\n            return false;\n          }\n          check = code.isIdentifierPartES6;\n        }\n        return true;\n      }\n      function isIdentifierES5(id, strict) {\n        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);\n      }\n      function isIdentifierES6(id, strict) {\n        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);\n      }\n      module2.exports = {\n        isKeywordES5,\n        isKeywordES6,\n        isReservedWordES5,\n        isReservedWordES6,\n        isRestrictedWord,\n        isIdentifierNameES5,\n        isIdentifierNameES6,\n        isIdentifierES5,\n        isIdentifierES6\n      };\n    })();\n  }\n});\nvar require_utils6 = __commonJS2({\n  "node_modules/esutils/lib/utils.js"(exports2) {\n    (function() {\n      "use strict";\n      exports2.ast = require_ast();\n      exports2.code = require_code();\n      exports2.keyword = require_keyword2();\n    })();\n  }\n});\nvar require_is_block_comment = __commonJS2({\n  "src/language-js/utils/is-block-comment.js"(exports2, module2) {\n    "use strict";\n    var BLOCK_COMMENT_TYPES = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]);\n    var isBlockComment = (comment) => BLOCK_COMMENT_TYPES.has(comment === null || comment === void 0 ? void 0 : comment.type);\n    module2.exports = isBlockComment;\n  }\n});\nvar require_is_node_matches = __commonJS2({\n  "src/language-js/utils/is-node-matches.js"(exports2, module2) {\n    "use strict";\n    function isNodeMatchesNameOrPath(node, nameOrPath) {\n      const names = nameOrPath.split(".");\n      for (let index = names.length - 1; index >= 0; index--) {\n        const name = names[index];\n        if (index === 0) {\n          return node.type === "Identifier" && node.name === name;\n        }\n        if (node.type !== "MemberExpression" || node.optional || node.computed || node.property.type !== "Identifier" || node.property.name !== name) {\n          return false;\n        }\n        node = node.object;\n      }\n    }\n    function isNodeMatches(node, nameOrPaths) {\n      return nameOrPaths.some((nameOrPath) => isNodeMatchesNameOrPath(node, nameOrPath));\n    }\n    module2.exports = isNodeMatches;\n  }\n});\nvar require_utils7 = __commonJS2({\n  "src/language-js/utils/index.js"(exports2, module2) {\n    "use strict";\n    var isIdentifierName = require_utils6().keyword.isIdentifierNameES5;\n    var {\n      getLast,\n      hasNewline,\n      skipWhitespace,\n      isNonEmptyArray,\n      isNextLineEmptyAfterIndex,\n      getStringWidth\n    } = require_util();\n    var {\n      locStart,\n      locEnd,\n      hasSameLocStart\n    } = require_loc();\n    var isBlockComment = require_is_block_comment();\n    var isNodeMatches = require_is_node_matches();\n    var NON_LINE_TERMINATING_WHITE_SPACE = "(?:(?=.)\\\\s)";\n    var FLOW_SHORTHAND_ANNOTATION = new RegExp(`^${NON_LINE_TERMINATING_WHITE_SPACE}*:`);\n    var FLOW_ANNOTATION = new RegExp(`^${NON_LINE_TERMINATING_WHITE_SPACE}*::`);\n    function hasFlowShorthandAnnotationComment(node) {\n      var _node$extra, _node$trailingComment;\n      return ((_node$extra = node.extra) === null || _node$extra === void 0 ? void 0 : _node$extra.parenthesized) && isBlockComment((_node$trailingComment = node.trailingComments) === null || _node$trailingComment === void 0 ? void 0 : _node$trailingComment[0]) && FLOW_SHORTHAND_ANNOTATION.test(node.trailingComments[0].value);\n    }\n    function hasFlowAnnotationComment(comments) {\n      const firstComment = comments === null || comments === void 0 ? void 0 : comments[0];\n      return isBlockComment(firstComment) && FLOW_ANNOTATION.test(firstComment.value);\n    }\n    function hasNode(node, fn) {\n      if (!node || typeof node !== "object") {\n        return false;\n      }\n      if (Array.isArray(node)) {\n        return node.some((value) => hasNode(value, fn));\n      }\n      const result = fn(node);\n      return typeof result === "boolean" ? result : Object.values(node).some((value) => hasNode(value, fn));\n    }\n    function hasNakedLeftSide(node) {\n      return node.type === "AssignmentExpression" || node.type === "BinaryExpression" || node.type === "LogicalExpression" || node.type === "NGPipeExpression" || node.type === "ConditionalExpression" || isCallExpression(node) || isMemberExpression(node) || node.type === "SequenceExpression" || node.type === "TaggedTemplateExpression" || node.type === "BindExpression" || node.type === "UpdateExpression" && !node.prefix || isTSTypeExpression(node) || node.type === "TSNonNullExpression";\n    }\n    function getLeftSide(node) {\n      var _ref2, _ref3, _ref4, _ref5, _ref6, _node$left;\n      if (node.expressions) {\n        return node.expressions[0];\n      }\n      return (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_ref6 = (_node$left = node.left) !== null && _node$left !== void 0 ? _node$left : node.test) !== null && _ref6 !== void 0 ? _ref6 : node.callee) !== null && _ref5 !== void 0 ? _ref5 : node.object) !== null && _ref4 !== void 0 ? _ref4 : node.tag) !== null && _ref3 !== void 0 ? _ref3 : node.argument) !== null && _ref2 !== void 0 ? _ref2 : node.expression;\n    }\n    function getLeftSidePathName(path, node) {\n      if (node.expressions) {\n        return ["expressions", 0];\n      }\n      if (node.left) {\n        return ["left"];\n      }\n      if (node.test) {\n        return ["test"];\n      }\n      if (node.object) {\n        return ["object"];\n      }\n      if (node.callee) {\n        return ["callee"];\n      }\n      if (node.tag) {\n        return ["tag"];\n      }\n      if (node.argument) {\n        return ["argument"];\n      }\n      if (node.expression) {\n        return ["expression"];\n      }\n      throw new Error("Unexpected node has no left side.");\n    }\n    function createTypeCheckFunction(types) {\n      types = new Set(types);\n      return (node) => types.has(node === null || node === void 0 ? void 0 : node.type);\n    }\n    var isLineComment = createTypeCheckFunction(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]);\n    var isExportDeclaration = createTypeCheckFunction(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);\n    function getParentExportDeclaration(path) {\n      const parentNode = path.getParentNode();\n      if (path.getName() === "declaration" && isExportDeclaration(parentNode)) {\n        return parentNode;\n      }\n      return null;\n    }\n    var isLiteral = createTypeCheckFunction(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);\n    function isNumericLiteral(node) {\n      return node.type === "NumericLiteral" || node.type === "Literal" && typeof node.value === "number";\n    }\n    function isSignedNumericLiteral(node) {\n      return node.type === "UnaryExpression" && (node.operator === "+" || node.operator === "-") && isNumericLiteral(node.argument);\n    }\n    function isStringLiteral(node) {\n      return node.type === "StringLiteral" || node.type === "Literal" && typeof node.value === "string";\n    }\n    var isObjectType = createTypeCheckFunction(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]);\n    var isFunctionOrArrowExpression = createTypeCheckFunction(["FunctionExpression", "ArrowFunctionExpression"]);\n    function isFunctionOrArrowExpressionWithBody(node) {\n      return node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement";\n    }\n    function isAngularTestWrapper(node) {\n      return isCallExpression(node) && node.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(node.callee.name);\n    }\n    var isJsxNode = createTypeCheckFunction(["JSXElement", "JSXFragment"]);\n    function isTheOnlyJsxElementInMarkdown(options, path) {\n      if (options.parentParser !== "markdown" && options.parentParser !== "mdx") {\n        return false;\n      }\n      const node = path.getNode();\n      if (!node.expression || !isJsxNode(node.expression)) {\n        return false;\n      }\n      const parent = path.getParentNode();\n      return parent.type === "Program" && parent.body.length === 1;\n    }\n    function isGetterOrSetter(node) {\n      return node.kind === "get" || node.kind === "set";\n    }\n    function isFunctionNotation(node) {\n      return isGetterOrSetter(node) || hasSameLocStart(node, node.value);\n    }\n    function isObjectTypePropertyAFunction(node) {\n      return (node.type === "ObjectTypeProperty" || node.type === "ObjectTypeInternalSlot") && node.value.type === "FunctionTypeAnnotation" && !node.static && !isFunctionNotation(node);\n    }\n    function isTypeAnnotationAFunction(node) {\n      return (node.type === "TypeAnnotation" || node.type === "TSTypeAnnotation") && node.typeAnnotation.type === "FunctionTypeAnnotation" && !node.static && !hasSameLocStart(node, node.typeAnnotation);\n    }\n    var isBinaryish = createTypeCheckFunction(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);\n    function isMemberish(node) {\n      return isMemberExpression(node) || node.type === "BindExpression" && Boolean(node.object);\n    }\n    var simpleTypeAnnotations = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);\n    function isSimpleType(node) {\n      if (!node) {\n        return false;\n      }\n      if ((node.type === "GenericTypeAnnotation" || node.type === "TSTypeReference") && !node.typeParameters) {\n        return true;\n      }\n      if (simpleTypeAnnotations.has(node.type)) {\n        return true;\n      }\n      return false;\n    }\n    function isUnitTestSetUp(node) {\n      const unitTestSetUpRe = /^(?:before|after)(?:Each|All)$/;\n      return node.callee.type === "Identifier" && unitTestSetUpRe.test(node.callee.name) && node.arguments.length === 1;\n    }\n    var testCallCalleePatterns = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];\n    function isTestCallCallee(node) {\n      return isNodeMatches(node, testCallCalleePatterns);\n    }\n    function isTestCall(node, parent) {\n      if (node.type !== "CallExpression") {\n        return false;\n      }\n      if (node.arguments.length === 1) {\n        if (isAngularTestWrapper(node) && parent && isTestCall(parent)) {\n          return isFunctionOrArrowExpression(node.arguments[0]);\n        }\n        if (isUnitTestSetUp(node)) {\n          return isAngularTestWrapper(node.arguments[0]);\n        }\n      } else if (node.arguments.length === 2 || node.arguments.length === 3) {\n        if ((node.arguments[0].type === "TemplateLiteral" || isStringLiteral(node.arguments[0])) && isTestCallCallee(node.callee)) {\n          if (node.arguments[2] && !isNumericLiteral(node.arguments[2])) {\n            return false;\n          }\n          return (node.arguments.length === 2 ? isFunctionOrArrowExpression(node.arguments[1]) : isFunctionOrArrowExpressionWithBody(node.arguments[1]) && getFunctionParameters(node.arguments[1]).length <= 1) || isAngularTestWrapper(node.arguments[1]);\n        }\n      }\n      return false;\n    }\n    var isCallExpression = createTypeCheckFunction(["CallExpression", "OptionalCallExpression"]);\n    var isMemberExpression = createTypeCheckFunction(["MemberExpression", "OptionalMemberExpression"]);\n    function isSimpleTemplateLiteral(node) {\n      let expressionsKey = "expressions";\n      if (node.type === "TSTemplateLiteralType") {\n        expressionsKey = "types";\n      }\n      const expressions = node[expressionsKey];\n      if (expressions.length === 0) {\n        return false;\n      }\n      return expressions.every((expr) => {\n        if (hasComment(expr)) {\n          return false;\n        }\n        if (expr.type === "Identifier" || expr.type === "ThisExpression") {\n          return true;\n        }\n        if (isMemberExpression(expr)) {\n          let head = expr;\n          while (isMemberExpression(head)) {\n            if (head.property.type !== "Identifier" && head.property.type !== "Literal" && head.property.type !== "StringLiteral" && head.property.type !== "NumericLiteral") {\n              return false;\n            }\n            head = head.object;\n            if (hasComment(head)) {\n              return false;\n            }\n          }\n          if (head.type === "Identifier" || head.type === "ThisExpression") {\n            return true;\n          }\n          return false;\n        }\n        return false;\n      });\n    }\n    function getTypeScriptMappedTypeModifier(tokenNode, keyword) {\n      if (tokenNode === "+" || tokenNode === "-") {\n        return tokenNode + keyword;\n      }\n      return keyword;\n    }\n    function isFlowAnnotationComment(text, typeAnnotation) {\n      const start = locStart(typeAnnotation);\n      const end = skipWhitespace(text, locEnd(typeAnnotation));\n      return end !== false && text.slice(start, start + 2) === "/*" && text.slice(end, end + 2) === "*/";\n    }\n    function hasLeadingOwnLineComment(text, node) {\n      if (isJsxNode(node)) {\n        return hasNodeIgnoreComment(node);\n      }\n      return hasComment(node, CommentCheckFlags.Leading, (comment) => hasNewline(text, locEnd(comment)));\n    }\n    function isStringPropSafeToUnquote(node, options) {\n      return options.parser !== "json" && isStringLiteral(node.key) && rawText(node.key).slice(1, -1) === node.key.value && (isIdentifierName(node.key.value) && !(options.parser === "babel-ts" && node.type === "ClassProperty" || options.parser === "typescript" && node.type === "PropertyDefinition") || isSimpleNumber(node.key.value) && String(Number(node.key.value)) === node.key.value && (options.parser === "babel" || options.parser === "acorn" || options.parser === "espree" || options.parser === "meriyah" || options.parser === "__babel_estree"));\n    }\n    function isSimpleNumber(numberString) {\n      return /^(?:\\d+|\\d+\\.\\d+)$/.test(numberString);\n    }\n    function isJestEachTemplateLiteral(node, parentNode) {\n      const jestEachTriggerRegex = /^[fx]?(?:describe|it|test)$/;\n      return parentNode.type === "TaggedTemplateExpression" && parentNode.quasi === node && parentNode.tag.type === "MemberExpression" && parentNode.tag.property.type === "Identifier" && parentNode.tag.property.name === "each" && (parentNode.tag.object.type === "Identifier" && jestEachTriggerRegex.test(parentNode.tag.object.name) || parentNode.tag.object.type === "MemberExpression" && parentNode.tag.object.property.type === "Identifier" && (parentNode.tag.object.property.name === "only" || parentNode.tag.object.property.name === "skip") && parentNode.tag.object.object.type === "Identifier" && jestEachTriggerRegex.test(parentNode.tag.object.object.name));\n    }\n    function templateLiteralHasNewLines(template) {\n      return template.quasis.some((quasi) => quasi.value.raw.includes("\\n"));\n    }\n    function isTemplateOnItsOwnLine(node, text) {\n      return (node.type === "TemplateLiteral" && templateLiteralHasNewLines(node) || node.type === "TaggedTemplateExpression" && templateLiteralHasNewLines(node.quasi)) && !hasNewline(text, locStart(node), {\n        backwards: true\n      });\n    }\n    function needsHardlineAfterDanglingComment(node) {\n      if (!hasComment(node)) {\n        return false;\n      }\n      const lastDanglingComment = getLast(getComments(node, CommentCheckFlags.Dangling));\n      return lastDanglingComment && !isBlockComment(lastDanglingComment);\n    }\n    function isFunctionCompositionArgs(args) {\n      if (args.length <= 1) {\n        return false;\n      }\n      let count = 0;\n      for (const arg of args) {\n        if (isFunctionOrArrowExpression(arg)) {\n          count += 1;\n          if (count > 1) {\n            return true;\n          }\n        } else if (isCallExpression(arg)) {\n          for (const childArg of arg.arguments) {\n            if (isFunctionOrArrowExpression(childArg)) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    }\n    function isLongCurriedCallExpression(path) {\n      const node = path.getValue();\n      const parent = path.getParentNode();\n      return isCallExpression(node) && isCallExpression(parent) && parent.callee === node && node.arguments.length > parent.arguments.length && parent.arguments.length > 0;\n    }\n    function isSimpleCallArgument(node, depth) {\n      if (depth >= 2) {\n        return false;\n      }\n      const isChildSimple = (child) => isSimpleCallArgument(child, depth + 1);\n      const regexpPattern = node.type === "Literal" && "regex" in node && node.regex.pattern || node.type === "RegExpLiteral" && node.pattern;\n      if (regexpPattern && getStringWidth(regexpPattern) > 5) {\n        return false;\n      }\n      if (node.type === "Literal" || node.type === "BigIntLiteral" || node.type === "DecimalLiteral" || node.type === "BooleanLiteral" || node.type === "NullLiteral" || node.type === "NumericLiteral" || node.type === "RegExpLiteral" || node.type === "StringLiteral" || node.type === "Identifier" || node.type === "ThisExpression" || node.type === "Super" || node.type === "PrivateName" || node.type === "PrivateIdentifier" || node.type === "ArgumentPlaceholder" || node.type === "Import") {\n        return true;\n      }\n      if (node.type === "TemplateLiteral") {\n        return node.quasis.every((element) => !element.value.raw.includes("\\n")) && node.expressions.every(isChildSimple);\n      }\n      if (node.type === "ObjectExpression") {\n        return node.properties.every((p) => !p.computed && (p.shorthand || p.value && isChildSimple(p.value)));\n      }\n      if (node.type === "ArrayExpression") {\n        return node.elements.every((x) => x === null || isChildSimple(x));\n      }\n      if (isCallLikeExpression(node)) {\n        return (node.type === "ImportExpression" || isSimpleCallArgument(node.callee, depth)) && getCallArguments(node).every(isChildSimple);\n      }\n      if (isMemberExpression(node)) {\n        return isSimpleCallArgument(node.object, depth) && isSimpleCallArgument(node.property, depth);\n      }\n      const targetUnaryExpressionOperators = {\n        "!": true,\n        "-": true,\n        "+": true,\n        "~": true\n      };\n      if (node.type === "UnaryExpression" && targetUnaryExpressionOperators[node.operator]) {\n        return isSimpleCallArgument(node.argument, depth);\n      }\n      const targetUpdateExpressionOperators = {\n        "++": true,\n        "--": true\n      };\n      if (node.type === "UpdateExpression" && targetUpdateExpressionOperators[node.operator]) {\n        return isSimpleCallArgument(node.argument, depth);\n      }\n      if (node.type === "TSNonNullExpression") {\n        return isSimpleCallArgument(node.expression, depth);\n      }\n      return false;\n    }\n    function rawText(node) {\n      var _node$extra$raw, _node$extra2;\n      return (_node$extra$raw = (_node$extra2 = node.extra) === null || _node$extra2 === void 0 ? void 0 : _node$extra2.raw) !== null && _node$extra$raw !== void 0 ? _node$extra$raw : node.raw;\n    }\n    function identity(x) {\n      return x;\n    }\n    function isTSXFile(options) {\n      return options.filepath && /\\.tsx$/i.test(options.filepath);\n    }\n    function shouldPrintComma(options, level = "es5") {\n      return options.trailingComma === "es5" && level === "es5" || options.trailingComma === "all" && (level === "all" || level === "es5");\n    }\n    function startsWithNoLookaheadToken(node, predicate) {\n      switch (node.type) {\n        case "BinaryExpression":\n        case "LogicalExpression":\n        case "AssignmentExpression":\n        case "NGPipeExpression":\n          return startsWithNoLookaheadToken(node.left, predicate);\n        case "MemberExpression":\n        case "OptionalMemberExpression":\n          return startsWithNoLookaheadToken(node.object, predicate);\n        case "TaggedTemplateExpression":\n          if (node.tag.type === "FunctionExpression") {\n            return false;\n          }\n          return startsWithNoLookaheadToken(node.tag, predicate);\n        case "CallExpression":\n        case "OptionalCallExpression":\n          if (node.callee.type === "FunctionExpression") {\n            return false;\n          }\n          return startsWithNoLookaheadToken(node.callee, predicate);\n        case "ConditionalExpression":\n          return startsWithNoLookaheadToken(node.test, predicate);\n        case "UpdateExpression":\n          return !node.prefix && startsWithNoLookaheadToken(node.argument, predicate);\n        case "BindExpression":\n          return node.object && startsWithNoLookaheadToken(node.object, predicate);\n        case "SequenceExpression":\n          return startsWithNoLookaheadToken(node.expressions[0], predicate);\n        case "TSSatisfiesExpression":\n        case "TSAsExpression":\n        case "TSNonNullExpression":\n          return startsWithNoLookaheadToken(node.expression, predicate);\n        default:\n          return predicate(node);\n      }\n    }\n    var equalityOperators = {\n      "==": true,\n      "!=": true,\n      "===": true,\n      "!==": true\n    };\n    var multiplicativeOperators = {\n      "*": true,\n      "/": true,\n      "%": true\n    };\n    var bitshiftOperators = {\n      ">>": true,\n      ">>>": true,\n      "<<": true\n    };\n    function shouldFlatten(parentOp, nodeOp) {\n      if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {\n        return false;\n      }\n      if (parentOp === "**") {\n        return false;\n      }\n      if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {\n        return false;\n      }\n      if (nodeOp === "%" && multiplicativeOperators[parentOp] || parentOp === "%" && multiplicativeOperators[nodeOp]) {\n        return false;\n      }\n      if (nodeOp !== parentOp && multiplicativeOperators[nodeOp] && multiplicativeOperators[parentOp]) {\n        return false;\n      }\n      if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {\n        return false;\n      }\n      return true;\n    }\n    var PRECEDENCE = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((operators, index) => operators.map((operator) => [operator, index])));\n    function getPrecedence(operator) {\n      return PRECEDENCE.get(operator);\n    }\n    function isBitwiseOperator(operator) {\n      return Boolean(bitshiftOperators[operator]) || operator === "|" || operator === "^" || operator === "&";\n    }\n    function hasRestParameter(node) {\n      var _getLast;\n      if (node.rest) {\n        return true;\n      }\n      const parameters = getFunctionParameters(node);\n      return ((_getLast = getLast(parameters)) === null || _getLast === void 0 ? void 0 : _getLast.type) === "RestElement";\n    }\n    var functionParametersCache = /* @__PURE__ */ new WeakMap();\n    function getFunctionParameters(node) {\n      if (functionParametersCache.has(node)) {\n        return functionParametersCache.get(node);\n      }\n      const parameters = [];\n      if (node.this) {\n        parameters.push(node.this);\n      }\n      if (Array.isArray(node.parameters)) {\n        parameters.push(...node.parameters);\n      } else if (Array.isArray(node.params)) {\n        parameters.push(...node.params);\n      }\n      if (node.rest) {\n        parameters.push(node.rest);\n      }\n      functionParametersCache.set(node, parameters);\n      return parameters;\n    }\n    function iterateFunctionParametersPath(path, iteratee) {\n      const node = path.getValue();\n      let index = 0;\n      const callback = (childPath) => iteratee(childPath, index++);\n      if (node.this) {\n        path.call(callback, "this");\n      }\n      if (Array.isArray(node.parameters)) {\n        path.each(callback, "parameters");\n      } else if (Array.isArray(node.params)) {\n        path.each(callback, "params");\n      }\n      if (node.rest) {\n        path.call(callback, "rest");\n      }\n    }\n    var callArgumentsCache = /* @__PURE__ */ new WeakMap();\n    function getCallArguments(node) {\n      if (callArgumentsCache.has(node)) {\n        return callArgumentsCache.get(node);\n      }\n      let args = node.arguments;\n      if (node.type === "ImportExpression") {\n        args = [node.source];\n        if (node.attributes) {\n          args.push(node.attributes);\n        }\n      }\n      callArgumentsCache.set(node, args);\n      return args;\n    }\n    function iterateCallArgumentsPath(path, iteratee) {\n      const node = path.getValue();\n      if (node.type === "ImportExpression") {\n        path.call((sourcePath) => iteratee(sourcePath, 0), "source");\n        if (node.attributes) {\n          path.call((sourcePath) => iteratee(sourcePath, 1), "attributes");\n        }\n      } else {\n        path.each(iteratee, "arguments");\n      }\n    }\n    function isPrettierIgnoreComment(comment) {\n      return comment.value.trim() === "prettier-ignore" && !comment.unignore;\n    }\n    function hasNodeIgnoreComment(node) {\n      return node && (node.prettierIgnore || hasComment(node, CommentCheckFlags.PrettierIgnore));\n    }\n    function hasIgnoreComment(path) {\n      const node = path.getValue();\n      return hasNodeIgnoreComment(node);\n    }\n    var CommentCheckFlags = {\n      Leading: 1 << 1,\n      Trailing: 1 << 2,\n      Dangling: 1 << 3,\n      Block: 1 << 4,\n      Line: 1 << 5,\n      PrettierIgnore: 1 << 6,\n      First: 1 << 7,\n      Last: 1 << 8\n    };\n    var getCommentTestFunction = (flags, fn) => {\n      if (typeof flags === "function") {\n        fn = flags;\n        flags = 0;\n      }\n      if (flags || fn) {\n        return (comment, index, comments) => !(flags & CommentCheckFlags.Leading && !comment.leading || flags & CommentCheckFlags.Trailing && !comment.trailing || flags & CommentCheckFlags.Dangling && (comment.leading || comment.trailing) || flags & CommentCheckFlags.Block && !isBlockComment(comment) || flags & CommentCheckFlags.Line && !isLineComment(comment) || flags & CommentCheckFlags.First && index !== 0 || flags & CommentCheckFlags.Last && index !== comments.length - 1 || flags & CommentCheckFlags.PrettierIgnore && !isPrettierIgnoreComment(comment) || fn && !fn(comment));\n      }\n    };\n    function hasComment(node, flags, fn) {\n      if (!isNonEmptyArray(node === null || node === void 0 ? void 0 : node.comments)) {\n        return false;\n      }\n      const test = getCommentTestFunction(flags, fn);\n      return test ? node.comments.some(test) : true;\n    }\n    function getComments(node, flags, fn) {\n      if (!Array.isArray(node === null || node === void 0 ? void 0 : node.comments)) {\n        return [];\n      }\n      const test = getCommentTestFunction(flags, fn);\n      return test ? node.comments.filter(test) : node.comments;\n    }\n    var isNextLineEmpty = (node, {\n      originalText\n    }) => isNextLineEmptyAfterIndex(originalText, locEnd(node));\n    function isCallLikeExpression(node) {\n      return isCallExpression(node) || node.type === "NewExpression" || node.type === "ImportExpression";\n    }\n    function isObjectProperty(node) {\n      return node && (node.type === "ObjectProperty" || node.type === "Property" && !node.method && node.kind === "init");\n    }\n    function isEnabledHackPipeline(options) {\n      return Boolean(options.__isUsingHackPipeline);\n    }\n    var markerForIfWithoutBlockAndSameLineComment = Symbol("ifWithoutBlockAndSameLineComment");\n    function isTSTypeExpression(node) {\n      return node.type === "TSAsExpression" || node.type === "TSSatisfiesExpression";\n    }\n    module2.exports = {\n      getFunctionParameters,\n      iterateFunctionParametersPath,\n      getCallArguments,\n      iterateCallArgumentsPath,\n      hasRestParameter,\n      getLeftSide,\n      getLeftSidePathName,\n      getParentExportDeclaration,\n      getTypeScriptMappedTypeModifier,\n      hasFlowAnnotationComment,\n      hasFlowShorthandAnnotationComment,\n      hasLeadingOwnLineComment,\n      hasNakedLeftSide,\n      hasNode,\n      hasIgnoreComment,\n      hasNodeIgnoreComment,\n      identity,\n      isBinaryish,\n      isCallLikeExpression,\n      isEnabledHackPipeline,\n      isLineComment,\n      isPrettierIgnoreComment,\n      isCallExpression,\n      isMemberExpression,\n      isExportDeclaration,\n      isFlowAnnotationComment,\n      isFunctionCompositionArgs,\n      isFunctionNotation,\n      isFunctionOrArrowExpression,\n      isGetterOrSetter,\n      isJestEachTemplateLiteral,\n      isJsxNode,\n      isLiteral,\n      isLongCurriedCallExpression,\n      isSimpleCallArgument,\n      isMemberish,\n      isNumericLiteral,\n      isSignedNumericLiteral,\n      isObjectProperty,\n      isObjectType,\n      isObjectTypePropertyAFunction,\n      isSimpleType,\n      isSimpleNumber,\n      isSimpleTemplateLiteral,\n      isStringLiteral,\n      isStringPropSafeToUnquote,\n      isTemplateOnItsOwnLine,\n      isTestCall,\n      isTheOnlyJsxElementInMarkdown,\n      isTSXFile,\n      isTypeAnnotationAFunction,\n      isNextLineEmpty,\n      needsHardlineAfterDanglingComment,\n      rawText,\n      shouldPrintComma,\n      isBitwiseOperator,\n      shouldFlatten,\n      startsWithNoLookaheadToken,\n      getPrecedence,\n      hasComment,\n      getComments,\n      CommentCheckFlags,\n      markerForIfWithoutBlockAndSameLineComment,\n      isTSTypeExpression\n    };\n  }\n});\nvar require_template_literal = __commonJS2({\n  "src/language-js/print/template-literal.js"(exports2, module2) {\n    "use strict";\n    var getLast = require_get_last();\n    var {\n      getStringWidth,\n      getIndentSize\n    } = require_util();\n    var {\n      builders: {\n        join,\n        hardline,\n        softline,\n        group,\n        indent,\n        align,\n        lineSuffixBoundary,\n        addAlignmentToDoc\n      },\n      printer: {\n        printDocToString\n      },\n      utils: {\n        mapDoc\n      }\n    } = require("./doc.js");\n    var {\n      isBinaryish,\n      isJestEachTemplateLiteral,\n      isSimpleTemplateLiteral,\n      hasComment,\n      isMemberExpression,\n      isTSTypeExpression\n    } = require_utils7();\n    function printTemplateLiteral(path, print, options) {\n      const node = path.getValue();\n      const isTemplateLiteral = node.type === "TemplateLiteral";\n      if (isTemplateLiteral && isJestEachTemplateLiteral(node, path.getParentNode())) {\n        const printed = printJestEachTemplateLiteral(path, options, print);\n        if (printed) {\n          return printed;\n        }\n      }\n      let expressionsKey = "expressions";\n      if (node.type === "TSTemplateLiteralType") {\n        expressionsKey = "types";\n      }\n      const parts = [];\n      let expressions = path.map(print, expressionsKey);\n      const isSimple = isSimpleTemplateLiteral(node);\n      if (isSimple) {\n        expressions = expressions.map((doc2) => printDocToString(doc2, Object.assign(Object.assign({}, options), {}, {\n          printWidth: Number.POSITIVE_INFINITY\n        })).formatted);\n      }\n      parts.push(lineSuffixBoundary, "`");\n      path.each((childPath) => {\n        const i = childPath.getName();\n        parts.push(print());\n        if (i < expressions.length) {\n          const {\n            tabWidth\n          } = options;\n          const quasi = childPath.getValue();\n          const indentSize = getIndentSize(quasi.value.raw, tabWidth);\n          let printed = expressions[i];\n          if (!isSimple) {\n            const expression = node[expressionsKey][i];\n            if (hasComment(expression) || isMemberExpression(expression) || expression.type === "ConditionalExpression" || expression.type === "SequenceExpression" || isTSTypeExpression(expression) || isBinaryish(expression)) {\n              printed = [indent([softline, printed]), softline];\n            }\n          }\n          const aligned = indentSize === 0 && quasi.value.raw.endsWith("\\n") ? align(Number.NEGATIVE_INFINITY, printed) : addAlignmentToDoc(printed, indentSize, tabWidth);\n          parts.push(group(["${", aligned, lineSuffixBoundary, "}"]));\n        }\n      }, "quasis");\n      parts.push("`");\n      return parts;\n    }\n    function printJestEachTemplateLiteral(path, options, print) {\n      const node = path.getNode();\n      const headerNames = node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);\n      if (headerNames.length > 1 || headerNames.some((headerName) => headerName.length > 0)) {\n        options.__inJestEach = true;\n        const expressions = path.map(print, "expressions");\n        options.__inJestEach = false;\n        const parts = [];\n        const stringifiedExpressions = expressions.map((doc2) => "${" + printDocToString(doc2, Object.assign(Object.assign({}, options), {}, {\n          printWidth: Number.POSITIVE_INFINITY,\n          endOfLine: "lf"\n        })).formatted + "}");\n        const tableBody = [{\n          hasLineBreak: false,\n          cells: []\n        }];\n        for (let i = 1; i < node.quasis.length; i++) {\n          const row = getLast(tableBody);\n          const correspondingExpression = stringifiedExpressions[i - 1];\n          row.cells.push(correspondingExpression);\n          if (correspondingExpression.includes("\\n")) {\n            row.hasLineBreak = true;\n          }\n          if (node.quasis[i].value.raw.includes("\\n")) {\n            tableBody.push({\n              hasLineBreak: false,\n              cells: []\n            });\n          }\n        }\n        const maxColumnCount = Math.max(headerNames.length, ...tableBody.map((row) => row.cells.length));\n        const maxColumnWidths = Array.from({\n          length: maxColumnCount\n        }).fill(0);\n        const table = [{\n          cells: headerNames\n        }, ...tableBody.filter((row) => row.cells.length > 0)];\n        for (const {\n          cells\n        } of table.filter((row) => !row.hasLineBreak)) {\n          for (const [index, cell] of cells.entries()) {\n            maxColumnWidths[index] = Math.max(maxColumnWidths[index], getStringWidth(cell));\n          }\n        }\n        parts.push(lineSuffixBoundary, "`", indent([hardline, join(hardline, table.map((row) => join(" | ", row.cells.map((cell, index) => row.hasLineBreak ? cell : cell + " ".repeat(maxColumnWidths[index] - getStringWidth(cell))))))]), hardline, "`");\n        return parts;\n      }\n    }\n    function printTemplateExpression(path, print) {\n      const node = path.getValue();\n      let printed = print();\n      if (hasComment(node)) {\n        printed = group([indent([softline, printed]), softline]);\n      }\n      return ["${", printed, lineSuffixBoundary, "}"];\n    }\n    function printTemplateExpressions(path, print) {\n      return path.map((path2) => printTemplateExpression(path2, print), "expressions");\n    }\n    function escapeTemplateCharacters(doc2, raw) {\n      return mapDoc(doc2, (currentDoc) => {\n        if (typeof currentDoc === "string") {\n          return raw ? currentDoc.replace(/(\\\\*)`/g, "$1$1\\\\`") : uncookTemplateElementValue(currentDoc);\n        }\n        return currentDoc;\n      });\n    }\n    function uncookTemplateElementValue(cookedValue) {\n      return cookedValue.replace(/([\\\\`]|\\${)/g, "\\\\$1");\n    }\n    module2.exports = {\n      printTemplateLiteral,\n      printTemplateExpressions,\n      escapeTemplateCharacters,\n      uncookTemplateElementValue\n    };\n  }\n});\nvar require_markdown = __commonJS2({\n  "src/language-js/embed/markdown.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        indent,\n        softline,\n        literalline,\n        dedentToRoot\n      }\n    } = require("./doc.js");\n    var {\n      escapeTemplateCharacters\n    } = require_template_literal();\n    function format(path, print, textToDoc) {\n      const node = path.getValue();\n      let text = node.quasis[0].value.raw.replace(/((?:\\\\\\\\)*)\\\\`/g, (_, backslashes) => "\\\\".repeat(backslashes.length / 2) + "`");\n      const indentation = getIndentation(text);\n      const hasIndent = indentation !== "";\n      if (hasIndent) {\n        text = text.replace(new RegExp(`^${indentation}`, "gm"), "");\n      }\n      const doc2 = escapeTemplateCharacters(textToDoc(text, {\n        parser: "markdown",\n        __inJsTemplate: true\n      }, {\n        stripTrailingHardline: true\n      }), true);\n      return ["`", hasIndent ? indent([softline, doc2]) : [literalline, dedentToRoot(doc2)], softline, "`"];\n    }\n    function getIndentation(str) {\n      const firstMatchedIndent = str.match(/^([^\\S\\n]*)\\S/m);\n      return firstMatchedIndent === null ? "" : firstMatchedIndent[1];\n    }\n    module2.exports = format;\n  }\n});\nvar require_css = __commonJS2({\n  "src/language-js/embed/css.js"(exports2, module2) {\n    "use strict";\n    var {\n      isNonEmptyArray\n    } = require_util();\n    var {\n      builders: {\n        indent,\n        hardline,\n        softline\n      },\n      utils: {\n        mapDoc,\n        replaceEndOfLine,\n        cleanDoc\n      }\n    } = require("./doc.js");\n    var {\n      printTemplateExpressions\n    } = require_template_literal();\n    function format(path, print, textToDoc) {\n      const node = path.getValue();\n      const rawQuasis = node.quasis.map((q) => q.value.raw);\n      let placeholderID = 0;\n      const text = rawQuasis.reduce((prevVal, currVal, idx) => idx === 0 ? currVal : prevVal + "@prettier-placeholder-" + placeholderID++ + "-id" + currVal, "");\n      const doc2 = textToDoc(text, {\n        parser: "scss"\n      }, {\n        stripTrailingHardline: true\n      });\n      const expressionDocs = printTemplateExpressions(path, print);\n      return transformCssDoc(doc2, node, expressionDocs);\n    }\n    function transformCssDoc(quasisDoc, parentNode, expressionDocs) {\n      const isEmpty = parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();\n      if (isEmpty) {\n        return "``";\n      }\n      const newDoc = replacePlaceholders(quasisDoc, expressionDocs);\n      if (!newDoc) {\n        throw new Error("Couldn\'t insert all the expressions");\n      }\n      return ["`", indent([hardline, newDoc]), softline, "`"];\n    }\n    function replacePlaceholders(quasisDoc, expressionDocs) {\n      if (!isNonEmptyArray(expressionDocs)) {\n        return quasisDoc;\n      }\n      let replaceCounter = 0;\n      const newDoc = mapDoc(cleanDoc(quasisDoc), (doc2) => {\n        if (typeof doc2 !== "string" || !doc2.includes("@prettier-placeholder")) {\n          return doc2;\n        }\n        return doc2.split(/@prettier-placeholder-(\\d+)-id/).map((component, idx) => {\n          if (idx % 2 === 0) {\n            return replaceEndOfLine(component);\n          }\n          replaceCounter++;\n          return expressionDocs[component];\n        });\n      });\n      return expressionDocs.length === replaceCounter ? newDoc : null;\n    }\n    module2.exports = format;\n  }\n});\nvar require_graphql = __commonJS2({\n  "src/language-js/embed/graphql.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        indent,\n        join,\n        hardline\n      }\n    } = require("./doc.js");\n    var {\n      escapeTemplateCharacters,\n      printTemplateExpressions\n    } = require_template_literal();\n    function format(path, print, textToDoc) {\n      const node = path.getValue();\n      const numQuasis = node.quasis.length;\n      if (numQuasis === 1 && node.quasis[0].value.raw.trim() === "") {\n        return "``";\n      }\n      const expressionDocs = printTemplateExpressions(path, print);\n      const parts = [];\n      for (let i = 0; i < numQuasis; i++) {\n        const templateElement = node.quasis[i];\n        const isFirst = i === 0;\n        const isLast = i === numQuasis - 1;\n        const text = templateElement.value.cooked;\n        const lines = text.split("\\n");\n        const numLines = lines.length;\n        const expressionDoc = expressionDocs[i];\n        const startsWithBlankLine = numLines > 2 && lines[0].trim() === "" && lines[1].trim() === "";\n        const endsWithBlankLine = numLines > 2 && lines[numLines - 1].trim() === "" && lines[numLines - 2].trim() === "";\n        const commentsAndWhitespaceOnly = lines.every((line) => /^\\s*(?:#[^\\n\\r]*)?$/.test(line));\n        if (!isLast && /#[^\\n\\r]*$/.test(lines[numLines - 1])) {\n          return null;\n        }\n        let doc2 = null;\n        if (commentsAndWhitespaceOnly) {\n          doc2 = printGraphqlComments(lines);\n        } else {\n          doc2 = textToDoc(text, {\n            parser: "graphql"\n          }, {\n            stripTrailingHardline: true\n          });\n        }\n        if (doc2) {\n          doc2 = escapeTemplateCharacters(doc2, false);\n          if (!isFirst && startsWithBlankLine) {\n            parts.push("");\n          }\n          parts.push(doc2);\n          if (!isLast && endsWithBlankLine) {\n            parts.push("");\n          }\n        } else if (!isFirst && !isLast && startsWithBlankLine) {\n          parts.push("");\n        }\n        if (expressionDoc) {\n          parts.push(expressionDoc);\n        }\n      }\n      return ["`", indent([hardline, join(hardline, parts)]), hardline, "`"];\n    }\n    function printGraphqlComments(lines) {\n      const parts = [];\n      let seenComment = false;\n      const array = lines.map((textLine) => textLine.trim());\n      for (const [i, textLine] of array.entries()) {\n        if (textLine === "") {\n          continue;\n        }\n        if (array[i - 1] === "" && seenComment) {\n          parts.push([hardline, textLine]);\n        } else {\n          parts.push(textLine);\n        }\n        seenComment = true;\n      }\n      return parts.length === 0 ? null : join(hardline, parts);\n    }\n    module2.exports = format;\n  }\n});\nvar require_html = __commonJS2({\n  "src/language-js/embed/html.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        indent,\n        line,\n        hardline,\n        group\n      },\n      utils: {\n        mapDoc\n      }\n    } = require("./doc.js");\n    var {\n      printTemplateExpressions,\n      uncookTemplateElementValue\n    } = require_template_literal();\n    var htmlTemplateLiteralCounter = 0;\n    function format(path, print, textToDoc, options, {\n      parser\n    }) {\n      const node = path.getValue();\n      const counter = htmlTemplateLiteralCounter;\n      htmlTemplateLiteralCounter = htmlTemplateLiteralCounter + 1 >>> 0;\n      const composePlaceholder = (index) => `PRETTIER_HTML_PLACEHOLDER_${index}_${counter}_IN_JS`;\n      const text = node.quasis.map((quasi, index, quasis) => index === quasis.length - 1 ? quasi.value.cooked : quasi.value.cooked + composePlaceholder(index)).join("");\n      const expressionDocs = printTemplateExpressions(path, print);\n      if (expressionDocs.length === 0 && text.trim().length === 0) {\n        return "``";\n      }\n      const placeholderRegex = new RegExp(composePlaceholder("(\\\\d+)"), "g");\n      let topLevelCount = 0;\n      const doc2 = textToDoc(text, {\n        parser,\n        __onHtmlRoot(root) {\n          topLevelCount = root.children.length;\n        }\n      }, {\n        stripTrailingHardline: true\n      });\n      const contentDoc = mapDoc(doc2, (doc3) => {\n        if (typeof doc3 !== "string") {\n          return doc3;\n        }\n        const parts = [];\n        const components = doc3.split(placeholderRegex);\n        for (let i = 0; i < components.length; i++) {\n          let component = components[i];\n          if (i % 2 === 0) {\n            if (component) {\n              component = uncookTemplateElementValue(component);\n              if (options.__embeddedInHtml) {\n                component = component.replace(/<\\/(script)\\b/gi, "<\\\\/$1");\n              }\n              parts.push(component);\n            }\n            continue;\n          }\n          const placeholderIndex = Number(component);\n          parts.push(expressionDocs[placeholderIndex]);\n        }\n        return parts;\n      });\n      const leadingWhitespace = /^\\s/.test(text) ? " " : "";\n      const trailingWhitespace = /\\s$/.test(text) ? " " : "";\n      const linebreak = options.htmlWhitespaceSensitivity === "ignore" ? hardline : leadingWhitespace && trailingWhitespace ? line : null;\n      if (linebreak) {\n        return group(["`", indent([linebreak, group(contentDoc)]), linebreak, "`"]);\n      }\n      return group(["`", leadingWhitespace, topLevelCount > 1 ? indent(group(contentDoc)) : group(contentDoc), trailingWhitespace, "`"]);\n    }\n    module2.exports = format;\n  }\n});\nvar require_embed = __commonJS2({\n  "src/language-js/embed.js"(exports2, module2) {\n    "use strict";\n    var {\n      hasComment,\n      CommentCheckFlags,\n      isObjectProperty\n    } = require_utils7();\n    var formatMarkdown = require_markdown();\n    var formatCss = require_css();\n    var formatGraphql = require_graphql();\n    var formatHtml = require_html();\n    function getLanguage(path) {\n      if (isStyledJsx(path) || isStyledComponents(path) || isCssProp(path) || isAngularComponentStyles(path)) {\n        return "css";\n      }\n      if (isGraphQL(path)) {\n        return "graphql";\n      }\n      if (isHtml(path)) {\n        return "html";\n      }\n      if (isAngularComponentTemplate(path)) {\n        return "angular";\n      }\n      if (isMarkdown(path)) {\n        return "markdown";\n      }\n    }\n    function embed(path, print, textToDoc, options) {\n      const node = path.getValue();\n      if (node.type !== "TemplateLiteral" || hasInvalidCookedValue(node)) {\n        return;\n      }\n      const language = getLanguage(path);\n      if (!language) {\n        return;\n      }\n      if (language === "markdown") {\n        return formatMarkdown(path, print, textToDoc);\n      }\n      if (language === "css") {\n        return formatCss(path, print, textToDoc);\n      }\n      if (language === "graphql") {\n        return formatGraphql(path, print, textToDoc);\n      }\n      if (language === "html" || language === "angular") {\n        return formatHtml(path, print, textToDoc, options, {\n          parser: language\n        });\n      }\n    }\n    function isMarkdown(path) {\n      const node = path.getValue();\n      const parent = path.getParentNode();\n      return parent && parent.type === "TaggedTemplateExpression" && node.quasis.length === 1 && parent.tag.type === "Identifier" && (parent.tag.name === "md" || parent.tag.name === "markdown");\n    }\n    function isStyledJsx(path) {\n      const node = path.getValue();\n      const parent = path.getParentNode();\n      const parentParent = path.getParentNode(1);\n      return parentParent && node.quasis && parent.type === "JSXExpressionContainer" && parentParent.type === "JSXElement" && parentParent.openingElement.name.name === "style" && parentParent.openingElement.attributes.some((attribute) => attribute.name.name === "jsx") || parent && parent.type === "TaggedTemplateExpression" && parent.tag.type === "Identifier" && parent.tag.name === "css" || parent && parent.type === "TaggedTemplateExpression" && parent.tag.type === "MemberExpression" && parent.tag.object.name === "css" && (parent.tag.property.name === "global" || parent.tag.property.name === "resolve");\n    }\n    function isAngularComponentStyles(path) {\n      return path.match((node) => node.type === "TemplateLiteral", (node, name) => node.type === "ArrayExpression" && name === "elements", (node, name) => isObjectProperty(node) && node.key.type === "Identifier" && node.key.name === "styles" && name === "value", ...angularComponentObjectExpressionPredicates);\n    }\n    function isAngularComponentTemplate(path) {\n      return path.match((node) => node.type === "TemplateLiteral", (node, name) => isObjectProperty(node) && node.key.type === "Identifier" && node.key.name === "template" && name === "value", ...angularComponentObjectExpressionPredicates);\n    }\n    var angularComponentObjectExpressionPredicates = [(node, name) => node.type === "ObjectExpression" && name === "properties", (node, name) => node.type === "CallExpression" && node.callee.type === "Identifier" && node.callee.name === "Component" && name === "arguments", (node, name) => node.type === "Decorator" && name === "expression"];\n    function isStyledComponents(path) {\n      const parent = path.getParentNode();\n      if (!parent || parent.type !== "TaggedTemplateExpression") {\n        return false;\n      }\n      const tag = parent.tag.type === "ParenthesizedExpression" ? parent.tag.expression : parent.tag;\n      switch (tag.type) {\n        case "MemberExpression":\n          return isStyledIdentifier(tag.object) || isStyledExtend(tag);\n        case "CallExpression":\n          return isStyledIdentifier(tag.callee) || tag.callee.type === "MemberExpression" && (tag.callee.object.type === "MemberExpression" && (isStyledIdentifier(tag.callee.object.object) || isStyledExtend(tag.callee.object)) || tag.callee.object.type === "CallExpression" && isStyledIdentifier(tag.callee.object.callee));\n        case "Identifier":\n          return tag.name === "css";\n        default:\n          return false;\n      }\n    }\n    function isCssProp(path) {\n      const parent = path.getParentNode();\n      const parentParent = path.getParentNode(1);\n      return parentParent && parent.type === "JSXExpressionContainer" && parentParent.type === "JSXAttribute" && parentParent.name.type === "JSXIdentifier" && parentParent.name.name === "css";\n    }\n    function isStyledIdentifier(node) {\n      return node.type === "Identifier" && node.name === "styled";\n    }\n    function isStyledExtend(node) {\n      return /^[A-Z]/.test(node.object.name) && node.property.name === "extend";\n    }\n    function isGraphQL(path) {\n      const node = path.getValue();\n      const parent = path.getParentNode();\n      return hasLanguageComment(node, "GraphQL") || parent && (parent.type === "TaggedTemplateExpression" && (parent.tag.type === "MemberExpression" && parent.tag.object.name === "graphql" && parent.tag.property.name === "experimental" || parent.tag.type === "Identifier" && (parent.tag.name === "gql" || parent.tag.name === "graphql")) || parent.type === "CallExpression" && parent.callee.type === "Identifier" && parent.callee.name === "graphql");\n    }\n    function hasLanguageComment(node, languageName) {\n      return hasComment(node, CommentCheckFlags.Block | CommentCheckFlags.Leading, ({\n        value\n      }) => value === ` ${languageName} `);\n    }\n    function isHtml(path) {\n      return hasLanguageComment(path.getValue(), "HTML") || path.match((node) => node.type === "TemplateLiteral", (node, name) => node.type === "TaggedTemplateExpression" && node.tag.type === "Identifier" && node.tag.name === "html" && name === "quasi");\n    }\n    function hasInvalidCookedValue({\n      quasis\n    }) {\n      return quasis.some(({\n        value: {\n          cooked\n        }\n      }) => cooked === null);\n    }\n    module2.exports = embed;\n  }\n});\nvar require_clean = __commonJS2({\n  "src/language-js/clean.js"(exports2, module2) {\n    "use strict";\n    var isBlockComment = require_is_block_comment();\n    var ignoredProperties = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]);\n    var removeTemplateElementsValue = (node) => {\n      for (const templateElement of node.quasis) {\n        delete templateElement.value;\n      }\n    };\n    function clean(ast, newObj, parent) {\n      if (ast.type === "Program") {\n        delete newObj.sourceType;\n      }\n      if (ast.type === "BigIntLiteral" || ast.type === "BigIntLiteralTypeAnnotation") {\n        if (newObj.value) {\n          newObj.value = newObj.value.toLowerCase();\n        }\n      }\n      if (ast.type === "BigIntLiteral" || ast.type === "Literal") {\n        if (newObj.bigint) {\n          newObj.bigint = newObj.bigint.toLowerCase();\n        }\n      }\n      if (ast.type === "DecimalLiteral") {\n        newObj.value = Number(newObj.value);\n      }\n      if (ast.type === "Literal" && newObj.decimal) {\n        newObj.decimal = Number(newObj.decimal);\n      }\n      if (ast.type === "EmptyStatement") {\n        return null;\n      }\n      if (ast.type === "JSXText") {\n        return null;\n      }\n      if (ast.type === "JSXExpressionContainer" && (ast.expression.type === "Literal" || ast.expression.type === "StringLiteral") && ast.expression.value === " ") {\n        return null;\n      }\n      if ((ast.type === "Property" || ast.type === "ObjectProperty" || ast.type === "MethodDefinition" || ast.type === "ClassProperty" || ast.type === "ClassMethod" || ast.type === "PropertyDefinition" || ast.type === "TSDeclareMethod" || ast.type === "TSPropertySignature" || ast.type === "ObjectTypeProperty") && typeof ast.key === "object" && ast.key && (ast.key.type === "Literal" || ast.key.type === "NumericLiteral" || ast.key.type === "StringLiteral" || ast.key.type === "Identifier")) {\n        delete newObj.key;\n      }\n      if (ast.type === "JSXElement" && ast.openingElement.name.name === "style" && ast.openingElement.attributes.some((attr) => attr.name.name === "jsx")) {\n        for (const {\n          type,\n          expression: expression2\n        } of newObj.children) {\n          if (type === "JSXExpressionContainer" && expression2.type === "TemplateLiteral") {\n            removeTemplateElementsValue(expression2);\n          }\n        }\n      }\n      if (ast.type === "JSXAttribute" && ast.name.name === "css" && ast.value.type === "JSXExpressionContainer" && ast.value.expression.type === "TemplateLiteral") {\n        removeTemplateElementsValue(newObj.value.expression);\n      }\n      if (ast.type === "JSXAttribute" && ast.value && ast.value.type === "Literal" && /["\']|&quot;|&apos;/.test(ast.value.value)) {\n        newObj.value.value = newObj.value.value.replace(/["\']|&quot;|&apos;/g, \'"\');\n      }\n      const expression = ast.expression || ast.callee;\n      if (ast.type === "Decorator" && expression.type === "CallExpression" && expression.callee.name === "Component" && expression.arguments.length === 1) {\n        const astProps = ast.expression.arguments[0].properties;\n        for (const [index, prop] of newObj.expression.arguments[0].properties.entries()) {\n          switch (astProps[index].key.name) {\n            case "styles":\n              if (prop.value.type === "ArrayExpression") {\n                removeTemplateElementsValue(prop.value.elements[0]);\n              }\n              break;\n            case "template":\n              if (prop.value.type === "TemplateLiteral") {\n                removeTemplateElementsValue(prop.value);\n              }\n              break;\n          }\n        }\n      }\n      if (ast.type === "TaggedTemplateExpression" && (ast.tag.type === "MemberExpression" || ast.tag.type === "Identifier" && (ast.tag.name === "gql" || ast.tag.name === "graphql" || ast.tag.name === "css" || ast.tag.name === "md" || ast.tag.name === "markdown" || ast.tag.name === "html") || ast.tag.type === "CallExpression")) {\n        removeTemplateElementsValue(newObj.quasi);\n      }\n      if (ast.type === "TemplateLiteral") {\n        var _ast$leadingComments;\n        const hasLanguageComment = (_ast$leadingComments = ast.leadingComments) === null || _ast$leadingComments === void 0 ? void 0 : _ast$leadingComments.some((comment) => isBlockComment(comment) && ["GraphQL", "HTML"].some((languageName) => comment.value === ` ${languageName} `));\n        if (hasLanguageComment || parent.type === "CallExpression" && parent.callee.name === "graphql" || !ast.leadingComments) {\n          removeTemplateElementsValue(newObj);\n        }\n      }\n      if (ast.type === "InterpreterDirective") {\n        newObj.value = newObj.value.trimEnd();\n      }\n      if ((ast.type === "TSIntersectionType" || ast.type === "TSUnionType") && ast.types.length === 1) {\n        return newObj.types[0];\n      }\n    }\n    clean.ignoredProperties = ignoredProperties;\n    module2.exports = clean;\n  }\n});\nvar require_detect_newline = __commonJS2({\n  "node_modules/detect-newline/index.js"(exports2, module2) {\n    "use strict";\n    var detectNewline = (string) => {\n      if (typeof string !== "string") {\n        throw new TypeError("Expected a string");\n      }\n      const newlines = string.match(/(?:\\r?\\n)/g) || [];\n      if (newlines.length === 0) {\n        return;\n      }\n      const crlf = newlines.filter((newline) => newline === "\\r\\n").length;\n      const lf = newlines.length - crlf;\n      return crlf > lf ? "\\r\\n" : "\\n";\n    };\n    module2.exports = detectNewline;\n    module2.exports.graceful = (string) => typeof string === "string" && detectNewline(string) || "\\n";\n  }\n});\nvar require_build = __commonJS2({\n  "node_modules/jest-docblock/build/index.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.extract = extract;\n    exports2.parse = parse;\n    exports2.parseWithComments = parseWithComments;\n    exports2.print = print;\n    exports2.strip = strip;\n    function _os() {\n      const data = require("os");\n      _os = function() {\n        return data;\n      };\n      return data;\n    }\n    function _detectNewline() {\n      const data = _interopRequireDefault(require_detect_newline());\n      _detectNewline = function() {\n        return data;\n      };\n      return data;\n    }\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n    var commentEndRe = /\\*\\/$/;\n    var commentStartRe = /^\\/\\*\\*?/;\n    var docblockRe = /^\\s*(\\/\\*\\*?(.|\\r?\\n)*?\\*\\/)/;\n    var lineCommentRe = /(^|\\s+)\\/\\/([^\\r\\n]*)/g;\n    var ltrimNewlineRe = /^(\\r?\\n)+/;\n    var multilineRe = /(?:^|\\r?\\n) *(@[^\\r\\n]*?) *\\r?\\n *(?![^@\\r\\n]*\\/\\/[^]*)([^@\\r\\n\\s][^@\\r\\n]+?) *\\r?\\n/g;\n    var propertyRe = /(?:^|\\r?\\n) *@(\\S+) *([^\\r\\n]*)/g;\n    var stringStartRe = /(\\r?\\n|^) *\\* ?/g;\n    var STRING_ARRAY = [];\n    function extract(contents) {\n      const match = contents.match(docblockRe);\n      return match ? match[0].trimLeft() : "";\n    }\n    function strip(contents) {\n      const match = contents.match(docblockRe);\n      return match && match[0] ? contents.substring(match[0].length) : contents;\n    }\n    function parse(docblock) {\n      return parseWithComments(docblock).pragmas;\n    }\n    function parseWithComments(docblock) {\n      const line = (0, _detectNewline().default)(docblock) || _os().EOL;\n      docblock = docblock.replace(commentStartRe, "").replace(commentEndRe, "").replace(stringStartRe, "$1");\n      let prev = "";\n      while (prev !== docblock) {\n        prev = docblock;\n        docblock = docblock.replace(multilineRe, `${line}$1 $2${line}`);\n      }\n      docblock = docblock.replace(ltrimNewlineRe, "").trimRight();\n      const result = /* @__PURE__ */ Object.create(null);\n      const comments = docblock.replace(propertyRe, "").replace(ltrimNewlineRe, "").trimRight();\n      let match;\n      while (match = propertyRe.exec(docblock)) {\n        const nextPragma = match[2].replace(lineCommentRe, "");\n        if (typeof result[match[1]] === "string" || Array.isArray(result[match[1]])) {\n          result[match[1]] = STRING_ARRAY.concat(result[match[1]], nextPragma);\n        } else {\n          result[match[1]] = nextPragma;\n        }\n      }\n      return {\n        comments,\n        pragmas: result\n      };\n    }\n    function print({\n      comments = "",\n      pragmas = {}\n    }) {\n      const line = (0, _detectNewline().default)(comments) || _os().EOL;\n      const head = "/**";\n      const start = " *";\n      const tail = " */";\n      const keys = Object.keys(pragmas);\n      const printedObject = keys.map((key) => printKeyValues(key, pragmas[key])).reduce((arr, next) => arr.concat(next), []).map((keyValue) => `${start} ${keyValue}${line}`).join("");\n      if (!comments) {\n        if (keys.length === 0) {\n          return "";\n        }\n        if (keys.length === 1 && !Array.isArray(pragmas[keys[0]])) {\n          const value = pragmas[keys[0]];\n          return `${head} ${printKeyValues(keys[0], value)[0]}${tail}`;\n        }\n      }\n      const printedComments = comments.split(line).map((textLine) => `${start} ${textLine}`).join(line) + line;\n      return head + line + (comments ? printedComments : "") + (comments && keys.length ? start + line : "") + printedObject + tail;\n    }\n    function printKeyValues(key, valueOrArray) {\n      return STRING_ARRAY.concat(valueOrArray).map((value) => `@${key} ${value}`.trim());\n    }\n  }\n});\nvar require_get_shebang = __commonJS2({\n  "src/language-js/utils/get-shebang.js"(exports2, module2) {\n    "use strict";\n    function getShebang(text) {\n      if (!text.startsWith("#!")) {\n        return "";\n      }\n      const index = text.indexOf("\\n");\n      if (index === -1) {\n        return text;\n      }\n      return text.slice(0, index);\n    }\n    module2.exports = getShebang;\n  }\n});\nvar require_pragma = __commonJS2({\n  "src/language-js/pragma.js"(exports2, module2) {\n    "use strict";\n    var {\n      parseWithComments,\n      strip,\n      extract,\n      print\n    } = require_build();\n    var {\n      normalizeEndOfLine\n    } = require_end_of_line();\n    var getShebang = require_get_shebang();\n    function parseDocBlock(text) {\n      const shebang = getShebang(text);\n      if (shebang) {\n        text = text.slice(shebang.length + 1);\n      }\n      const docBlock = extract(text);\n      const {\n        pragmas,\n        comments\n      } = parseWithComments(docBlock);\n      return {\n        shebang,\n        text,\n        pragmas,\n        comments\n      };\n    }\n    function hasPragma(text) {\n      const pragmas = Object.keys(parseDocBlock(text).pragmas);\n      return pragmas.includes("prettier") || pragmas.includes("format");\n    }\n    function insertPragma(originalText) {\n      const {\n        shebang,\n        text,\n        pragmas,\n        comments\n      } = parseDocBlock(originalText);\n      const strippedText = strip(text);\n      const docBlock = print({\n        pragmas: Object.assign({\n          format: ""\n        }, pragmas),\n        comments: comments.trimStart()\n      });\n      return (shebang ? `${shebang}\n` : "") + normalizeEndOfLine(docBlock) + (strippedText.startsWith("\\n") ? "\\n" : "\\n\\n") + strippedText;\n    }\n    module2.exports = {\n      hasPragma,\n      insertPragma\n    };\n  }\n});\nvar require_is_type_cast_comment = __commonJS2({\n  "src/language-js/utils/is-type-cast-comment.js"(exports2, module2) {\n    "use strict";\n    var isBlockComment = require_is_block_comment();\n    function isTypeCastComment(comment) {\n      return isBlockComment(comment) && comment.value[0] === "*" && /@(?:type|satisfies)\\b/.test(comment.value);\n    }\n    module2.exports = isTypeCastComment;\n  }\n});\nvar require_comments2 = __commonJS2({\n  "src/language-js/comments.js"(exports2, module2) {\n    "use strict";\n    var {\n      getLast,\n      hasNewline,\n      getNextNonSpaceNonCommentCharacterIndexWithStartIndex,\n      getNextNonSpaceNonCommentCharacter,\n      hasNewlineInRange,\n      addLeadingComment,\n      addTrailingComment,\n      addDanglingComment,\n      getNextNonSpaceNonCommentCharacterIndex,\n      isNonEmptyArray\n    } = require_util();\n    var {\n      getFunctionParameters,\n      isPrettierIgnoreComment,\n      isJsxNode,\n      hasFlowShorthandAnnotationComment,\n      hasFlowAnnotationComment,\n      hasIgnoreComment,\n      isCallLikeExpression,\n      getCallArguments,\n      isCallExpression,\n      isMemberExpression,\n      isObjectProperty,\n      isLineComment,\n      getComments,\n      CommentCheckFlags,\n      markerForIfWithoutBlockAndSameLineComment\n    } = require_utils7();\n    var {\n      locStart,\n      locEnd\n    } = require_loc();\n    var isBlockComment = require_is_block_comment();\n    var isTypeCastComment = require_is_type_cast_comment();\n    function handleOwnLineComment(context) {\n      return [handleIgnoreComments, handleLastFunctionArgComments, handleMemberExpressionComments, handleIfStatementComments, handleWhileComments, handleTryStatementComments, handleClassComments, handleForComments, handleUnionTypeComments, handleOnlyComments, handleModuleSpecifiersComments, handleAssignmentPatternComments, handleMethodNameComments, handleLabeledStatementComments, handleBreakAndContinueStatementComments].some((fn) => fn(context));\n    }\n    function handleEndOfLineComment(context) {\n      return [handleClosureTypeCastComments, handleLastFunctionArgComments, handleConditionalExpressionComments, handleModuleSpecifiersComments, handleIfStatementComments, handleWhileComments, handleTryStatementComments, handleClassComments, handleLabeledStatementComments, handleCallExpressionComments, handlePropertyComments, handleOnlyComments, handleVariableDeclaratorComments, handleBreakAndContinueStatementComments, handleSwitchDefaultCaseComments].some((fn) => fn(context));\n    }\n    function handleRemainingComment(context) {\n      return [handleIgnoreComments, handleIfStatementComments, handleWhileComments, handleObjectPropertyAssignment, handleCommentInEmptyParens, handleMethodNameComments, handleOnlyComments, handleCommentAfterArrowParams, handleFunctionNameComments, handleTSMappedTypeComments, handleBreakAndContinueStatementComments, handleTSFunctionTrailingComments].some((fn) => fn(context));\n    }\n    function addBlockStatementFirstComment(node, comment) {\n      const firstNonEmptyNode = (node.body || node.properties).find(({\n        type\n      }) => type !== "EmptyStatement");\n      if (firstNonEmptyNode) {\n        addLeadingComment(firstNonEmptyNode, comment);\n      } else {\n        addDanglingComment(node, comment);\n      }\n    }\n    function addBlockOrNotComment(node, comment) {\n      if (node.type === "BlockStatement") {\n        addBlockStatementFirstComment(node, comment);\n      } else {\n        addLeadingComment(node, comment);\n      }\n    }\n    function handleClosureTypeCastComments({\n      comment,\n      followingNode\n    }) {\n      if (followingNode && isTypeCastComment(comment)) {\n        addLeadingComment(followingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleIfStatementComments({\n      comment,\n      precedingNode,\n      enclosingNode,\n      followingNode,\n      text\n    }) {\n      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) !== "IfStatement" || !followingNode) {\n        return false;\n      }\n      const nextCharacter = getNextNonSpaceNonCommentCharacter(text, comment, locEnd);\n      if (nextCharacter === ")") {\n        addTrailingComment(precedingNode, comment);\n        return true;\n      }\n      if (precedingNode === enclosingNode.consequent && followingNode === enclosingNode.alternate) {\n        if (precedingNode.type === "BlockStatement") {\n          addTrailingComment(precedingNode, comment);\n        } else {\n          const isSingleLineComment = comment.type === "SingleLine" || comment.loc.start.line === comment.loc.end.line;\n          const isSameLineComment = comment.loc.start.line === precedingNode.loc.start.line;\n          if (isSingleLineComment && isSameLineComment) {\n            addDanglingComment(precedingNode, comment, markerForIfWithoutBlockAndSameLineComment);\n          } else {\n            addDanglingComment(enclosingNode, comment);\n          }\n        }\n        return true;\n      }\n      if (followingNode.type === "BlockStatement") {\n        addBlockStatementFirstComment(followingNode, comment);\n        return true;\n      }\n      if (followingNode.type === "IfStatement") {\n        addBlockOrNotComment(followingNode.consequent, comment);\n        return true;\n      }\n      if (enclosingNode.consequent === followingNode) {\n        addLeadingComment(followingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleWhileComments({\n      comment,\n      precedingNode,\n      enclosingNode,\n      followingNode,\n      text\n    }) {\n      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) !== "WhileStatement" || !followingNode) {\n        return false;\n      }\n      const nextCharacter = getNextNonSpaceNonCommentCharacter(text, comment, locEnd);\n      if (nextCharacter === ")") {\n        addTrailingComment(precedingNode, comment);\n        return true;\n      }\n      if (followingNode.type === "BlockStatement") {\n        addBlockStatementFirstComment(followingNode, comment);\n        return true;\n      }\n      if (enclosingNode.body === followingNode) {\n        addLeadingComment(followingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleTryStatementComments({\n      comment,\n      precedingNode,\n      enclosingNode,\n      followingNode\n    }) {\n      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) !== "TryStatement" && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) !== "CatchClause" || !followingNode) {\n        return false;\n      }\n      if (enclosingNode.type === "CatchClause" && precedingNode) {\n        addTrailingComment(precedingNode, comment);\n        return true;\n      }\n      if (followingNode.type === "BlockStatement") {\n        addBlockStatementFirstComment(followingNode, comment);\n        return true;\n      }\n      if (followingNode.type === "TryStatement") {\n        addBlockOrNotComment(followingNode.finalizer, comment);\n        return true;\n      }\n      if (followingNode.type === "CatchClause") {\n        addBlockOrNotComment(followingNode.body, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleMemberExpressionComments({\n      comment,\n      enclosingNode,\n      followingNode\n    }) {\n      if (isMemberExpression(enclosingNode) && (followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "Identifier") {\n        addLeadingComment(enclosingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleConditionalExpressionComments({\n      comment,\n      precedingNode,\n      enclosingNode,\n      followingNode,\n      text\n    }) {\n      const isSameLineAsPrecedingNode = precedingNode && !hasNewlineInRange(text, locEnd(precedingNode), locStart(comment));\n      if ((!precedingNode || !isSameLineAsPrecedingNode) && ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ConditionalExpression" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSConditionalType") && followingNode) {\n        addLeadingComment(followingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleObjectPropertyAssignment({\n      comment,\n      precedingNode,\n      enclosingNode\n    }) {\n      if (isObjectProperty(enclosingNode) && enclosingNode.shorthand && enclosingNode.key === precedingNode && enclosingNode.value.type === "AssignmentPattern") {\n        addTrailingComment(enclosingNode.value.left, comment);\n        return true;\n      }\n      return false;\n    }\n    var classLikeNodeTypes = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);\n    function handleClassComments({\n      comment,\n      precedingNode,\n      enclosingNode,\n      followingNode\n    }) {\n      if (classLikeNodeTypes.has(enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type)) {\n        if (isNonEmptyArray(enclosingNode.decorators) && !(followingNode && followingNode.type === "Decorator")) {\n          addTrailingComment(getLast(enclosingNode.decorators), comment);\n          return true;\n        }\n        if (enclosingNode.body && followingNode === enclosingNode.body) {\n          addBlockStatementFirstComment(enclosingNode.body, comment);\n          return true;\n        }\n        if (followingNode) {\n          if (enclosingNode.superClass && followingNode === enclosingNode.superClass && precedingNode && (precedingNode === enclosingNode.id || precedingNode === enclosingNode.typeParameters)) {\n            addTrailingComment(precedingNode, comment);\n            return true;\n          }\n          for (const prop of ["implements", "extends", "mixins"]) {\n            if (enclosingNode[prop] && followingNode === enclosingNode[prop][0]) {\n              if (precedingNode && (precedingNode === enclosingNode.id || precedingNode === enclosingNode.typeParameters || precedingNode === enclosingNode.superClass)) {\n                addTrailingComment(precedingNode, comment);\n              } else {\n                addDanglingComment(enclosingNode, comment, prop);\n              }\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    }\n    var propertyLikeNodeTypes = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);\n    function handleMethodNameComments({\n      comment,\n      precedingNode,\n      enclosingNode,\n      text\n    }) {\n      if (enclosingNode && precedingNode && getNextNonSpaceNonCommentCharacter(text, comment, locEnd) === "(" && (enclosingNode.type === "Property" || enclosingNode.type === "TSDeclareMethod" || enclosingNode.type === "TSAbstractMethodDefinition") && precedingNode.type === "Identifier" && enclosingNode.key === precedingNode && getNextNonSpaceNonCommentCharacter(text, precedingNode, locEnd) !== ":") {\n        addTrailingComment(precedingNode, comment);\n        return true;\n      }\n      if ((precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "Decorator" && propertyLikeNodeTypes.has(enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type)) {\n        addTrailingComment(precedingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    var functionLikeNodeTypes = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);\n    function handleFunctionNameComments({\n      comment,\n      precedingNode,\n      enclosingNode,\n      text\n    }) {\n      if (getNextNonSpaceNonCommentCharacter(text, comment, locEnd) !== "(") {\n        return false;\n      }\n      if (precedingNode && functionLikeNodeTypes.has(enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type)) {\n        addTrailingComment(precedingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleCommentAfterArrowParams({\n      comment,\n      enclosingNode,\n      text\n    }) {\n      if (!((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ArrowFunctionExpression")) {\n        return false;\n      }\n      const index = getNextNonSpaceNonCommentCharacterIndex(text, comment, locEnd);\n      if (index !== false && text.slice(index, index + 2) === "=>") {\n        addDanglingComment(enclosingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleCommentInEmptyParens({\n      comment,\n      enclosingNode,\n      text\n    }) {\n      if (getNextNonSpaceNonCommentCharacter(text, comment, locEnd) !== ")") {\n        return false;\n      }\n      if (enclosingNode && (isRealFunctionLikeNode(enclosingNode) && getFunctionParameters(enclosingNode).length === 0 || isCallLikeExpression(enclosingNode) && getCallArguments(enclosingNode).length === 0)) {\n        addDanglingComment(enclosingNode, comment);\n        return true;\n      }\n      if (((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "MethodDefinition" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSAbstractMethodDefinition") && getFunctionParameters(enclosingNode.value).length === 0) {\n        addDanglingComment(enclosingNode.value, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleLastFunctionArgComments({\n      comment,\n      precedingNode,\n      enclosingNode,\n      followingNode,\n      text\n    }) {\n      if ((precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "FunctionTypeParam" && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "FunctionTypeAnnotation" && (followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) !== "FunctionTypeParam") {\n        addTrailingComment(precedingNode, comment);\n        return true;\n      }\n      if (((precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "Identifier" || (precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "AssignmentPattern") && enclosingNode && isRealFunctionLikeNode(enclosingNode) && getNextNonSpaceNonCommentCharacter(text, comment, locEnd) === ")") {\n        addTrailingComment(precedingNode, comment);\n        return true;\n      }\n      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "FunctionDeclaration" && (followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "BlockStatement") {\n        const functionParamRightParenIndex = (() => {\n          const parameters = getFunctionParameters(enclosingNode);\n          if (parameters.length > 0) {\n            return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, locEnd(getLast(parameters)));\n          }\n          const functionParamLeftParenIndex = getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, locEnd(enclosingNode.id));\n          return functionParamLeftParenIndex !== false && getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, functionParamLeftParenIndex + 1);\n        })();\n        if (locStart(comment) > functionParamRightParenIndex) {\n          addBlockStatementFirstComment(followingNode, comment);\n          return true;\n        }\n      }\n      return false;\n    }\n    function handleLabeledStatementComments({\n      comment,\n      enclosingNode\n    }) {\n      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "LabeledStatement") {\n        addLeadingComment(enclosingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleBreakAndContinueStatementComments({\n      comment,\n      enclosingNode\n    }) {\n      if (((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ContinueStatement" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "BreakStatement") && !enclosingNode.label) {\n        addTrailingComment(enclosingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleCallExpressionComments({\n      comment,\n      precedingNode,\n      enclosingNode\n    }) {\n      if (isCallExpression(enclosingNode) && precedingNode && enclosingNode.callee === precedingNode && enclosingNode.arguments.length > 0) {\n        addLeadingComment(enclosingNode.arguments[0], comment);\n        return true;\n      }\n      return false;\n    }\n    function handleUnionTypeComments({\n      comment,\n      precedingNode,\n      enclosingNode,\n      followingNode\n    }) {\n      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "UnionTypeAnnotation" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSUnionType") {\n        if (isPrettierIgnoreComment(comment)) {\n          followingNode.prettierIgnore = true;\n          comment.unignore = true;\n        }\n        if (precedingNode) {\n          addTrailingComment(precedingNode, comment);\n          return true;\n        }\n        return false;\n      }\n      if (((followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "UnionTypeAnnotation" || (followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "TSUnionType") && isPrettierIgnoreComment(comment)) {\n        followingNode.types[0].prettierIgnore = true;\n        comment.unignore = true;\n      }\n      return false;\n    }\n    function handlePropertyComments({\n      comment,\n      enclosingNode\n    }) {\n      if (isObjectProperty(enclosingNode)) {\n        addLeadingComment(enclosingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleOnlyComments({\n      comment,\n      enclosingNode,\n      followingNode,\n      ast,\n      isLastComment\n    }) {\n      if (ast && ast.body && ast.body.length === 0) {\n        if (isLastComment) {\n          addDanglingComment(ast, comment);\n        } else {\n          addLeadingComment(ast, comment);\n        }\n        return true;\n      }\n      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "Program" && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.body.length) === 0 && !isNonEmptyArray(enclosingNode.directives)) {\n        if (isLastComment) {\n          addDanglingComment(enclosingNode, comment);\n        } else {\n          addLeadingComment(enclosingNode, comment);\n        }\n        return true;\n      }\n      if ((followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "Program" && (followingNode === null || followingNode === void 0 ? void 0 : followingNode.body.length) === 0 && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ModuleExpression") {\n        addDanglingComment(followingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleForComments({\n      comment,\n      enclosingNode\n    }) {\n      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ForInStatement" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ForOfStatement") {\n        addLeadingComment(enclosingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleModuleSpecifiersComments({\n      comment,\n      precedingNode,\n      enclosingNode,\n      text\n    }) {\n      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ImportSpecifier" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ExportSpecifier") {\n        addLeadingComment(enclosingNode, comment);\n        return true;\n      }\n      const isImportDeclaration = (precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "ImportSpecifier" && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ImportDeclaration";\n      const isExportDeclaration = (precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "ExportSpecifier" && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "ExportNamedDeclaration";\n      if ((isImportDeclaration || isExportDeclaration) && hasNewline(text, locEnd(comment))) {\n        addTrailingComment(precedingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleAssignmentPatternComments({\n      comment,\n      enclosingNode\n    }) {\n      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "AssignmentPattern") {\n        addLeadingComment(enclosingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    var assignmentLikeNodeTypes = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]);\n    var complexExprNodeTypes = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);\n    function handleVariableDeclaratorComments({\n      comment,\n      enclosingNode,\n      followingNode\n    }) {\n      if (assignmentLikeNodeTypes.has(enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) && followingNode && (complexExprNodeTypes.has(followingNode.type) || isBlockComment(comment))) {\n        addLeadingComment(followingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleTSFunctionTrailingComments({\n      comment,\n      enclosingNode,\n      followingNode,\n      text\n    }) {\n      if (!followingNode && ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSMethodSignature" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSDeclareFunction" || (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSAbstractMethodDefinition") && getNextNonSpaceNonCommentCharacter(text, comment, locEnd) === ";") {\n        addTrailingComment(enclosingNode, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleIgnoreComments({\n      comment,\n      enclosingNode,\n      followingNode\n    }) {\n      if (isPrettierIgnoreComment(comment) && (enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) === "TSMappedType" && (followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "TSTypeParameter" && followingNode.constraint) {\n        enclosingNode.prettierIgnore = true;\n        comment.unignore = true;\n        return true;\n      }\n    }\n    function handleTSMappedTypeComments({\n      comment,\n      precedingNode,\n      enclosingNode,\n      followingNode\n    }) {\n      if ((enclosingNode === null || enclosingNode === void 0 ? void 0 : enclosingNode.type) !== "TSMappedType") {\n        return false;\n      }\n      if ((followingNode === null || followingNode === void 0 ? void 0 : followingNode.type) === "TSTypeParameter" && followingNode.name) {\n        addLeadingComment(followingNode.name, comment);\n        return true;\n      }\n      if ((precedingNode === null || precedingNode === void 0 ? void 0 : precedingNode.type) === "TSTypeParameter" && precedingNode.constraint) {\n        addTrailingComment(precedingNode.constraint, comment);\n        return true;\n      }\n      return false;\n    }\n    function handleSwitchDefaultCaseComments({\n      comment,\n      enclosingNode,\n      followingNode\n    }) {\n      if (!enclosingNode || enclosingNode.type !== "SwitchCase" || enclosingNode.test || !followingNode || followingNode !== enclosingNode.consequent[0]) {\n        return false;\n      }\n      if (followingNode.type === "BlockStatement" && isLineComment(comment)) {\n        addBlockStatementFirstComment(followingNode, comment);\n      } else {\n        addDanglingComment(enclosingNode, comment);\n      }\n      return true;\n    }\n    function isRealFunctionLikeNode(node) {\n      return node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression" || node.type === "FunctionDeclaration" || node.type === "ObjectMethod" || node.type === "ClassMethod" || node.type === "TSDeclareFunction" || node.type === "TSCallSignatureDeclaration" || node.type === "TSConstructSignatureDeclaration" || node.type === "TSMethodSignature" || node.type === "TSConstructorType" || node.type === "TSFunctionType" || node.type === "TSDeclareMethod";\n    }\n    function getCommentChildNodes(node, options) {\n      if ((options.parser === "typescript" || options.parser === "flow" || options.parser === "acorn" || options.parser === "espree" || options.parser === "meriyah" || options.parser === "__babel_estree") && node.type === "MethodDefinition" && node.value && node.value.type === "FunctionExpression" && getFunctionParameters(node.value).length === 0 && !node.value.returnType && !isNonEmptyArray(node.value.typeParameters) && node.value.body) {\n        return [...node.decorators || [], node.key, node.value.body];\n      }\n    }\n    function willPrintOwnComments(path) {\n      const node = path.getValue();\n      const parent = path.getParentNode();\n      const hasFlowAnnotations = (node2) => hasFlowAnnotationComment(getComments(node2, CommentCheckFlags.Leading)) || hasFlowAnnotationComment(getComments(node2, CommentCheckFlags.Trailing));\n      return (node && (isJsxNode(node) || hasFlowShorthandAnnotationComment(node) || isCallExpression(parent) && hasFlowAnnotations(node)) || parent && (parent.type === "JSXSpreadAttribute" || parent.type === "JSXSpreadChild" || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType" || (parent.type === "ClassDeclaration" || parent.type === "ClassExpression") && parent.superClass === node)) && (!hasIgnoreComment(path) || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType");\n    }\n    module2.exports = {\n      handleOwnLineComment,\n      handleEndOfLineComment,\n      handleRemainingComment,\n      getCommentChildNodes,\n      willPrintOwnComments\n    };\n  }\n});\nvar require_needs_parens = __commonJS2({\n  "src/language-js/needs-parens.js"(exports2, module2) {\n    "use strict";\n    var getLast = require_get_last();\n    var isNonEmptyArray = require_is_non_empty_array();\n    var {\n      getFunctionParameters,\n      getLeftSidePathName,\n      hasFlowShorthandAnnotationComment,\n      hasNakedLeftSide,\n      hasNode,\n      isBitwiseOperator,\n      startsWithNoLookaheadToken,\n      shouldFlatten,\n      getPrecedence,\n      isCallExpression,\n      isMemberExpression,\n      isObjectProperty,\n      isTSTypeExpression\n    } = require_utils7();\n    function needsParens(path, options) {\n      const parent = path.getParentNode();\n      if (!parent) {\n        return false;\n      }\n      const name = path.getName();\n      const node = path.getNode();\n      if (options.__isInHtmlInterpolation && !options.bracketSpacing && endsWithRightBracket(node) && isFollowedByRightBracket(path)) {\n        return true;\n      }\n      if (isStatement(node)) {\n        return false;\n      }\n      if (options.parser !== "flow" && hasFlowShorthandAnnotationComment(path.getValue())) {\n        return true;\n      }\n      if (node.type === "Identifier") {\n        if (node.extra && node.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)) {\n          return true;\n        }\n        if (name === "left" && (node.name === "async" && !parent.await || node.name === "let") && parent.type === "ForOfStatement") {\n          return true;\n        }\n        if (node.name === "let") {\n          var _path$findAncestor;\n          const expression = (_path$findAncestor = path.findAncestor((node2) => node2.type === "ForOfStatement")) === null || _path$findAncestor === void 0 ? void 0 : _path$findAncestor.left;\n          if (expression && startsWithNoLookaheadToken(expression, (leftmostNode) => leftmostNode === node)) {\n            return true;\n          }\n        }\n        if (name === "object" && node.name === "let" && parent.type === "MemberExpression" && parent.computed && !parent.optional) {\n          const statement = path.findAncestor((node2) => node2.type === "ExpressionStatement" || node2.type === "ForStatement" || node2.type === "ForInStatement");\n          const expression = !statement ? void 0 : statement.type === "ExpressionStatement" ? statement.expression : statement.type === "ForStatement" ? statement.init : statement.left;\n          if (expression && startsWithNoLookaheadToken(expression, (leftmostNode) => leftmostNode === node)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      if (node.type === "ObjectExpression" || node.type === "FunctionExpression" || node.type === "ClassExpression" || node.type === "DoExpression") {\n        var _path$findAncestor2;\n        const expression = (_path$findAncestor2 = path.findAncestor((node2) => node2.type === "ExpressionStatement")) === null || _path$findAncestor2 === void 0 ? void 0 : _path$findAncestor2.expression;\n        if (expression && startsWithNoLookaheadToken(expression, (leftmostNode) => leftmostNode === node)) {\n          return true;\n        }\n      }\n      switch (parent.type) {\n        case "ParenthesizedExpression":\n          return false;\n        case "ClassDeclaration":\n        case "ClassExpression": {\n          if (name === "superClass" && (node.type === "ArrowFunctionExpression" || node.type === "AssignmentExpression" || node.type === "AwaitExpression" || node.type === "BinaryExpression" || node.type === "ConditionalExpression" || node.type === "LogicalExpression" || node.type === "NewExpression" || node.type === "ObjectExpression" || node.type === "SequenceExpression" || node.type === "TaggedTemplateExpression" || node.type === "UnaryExpression" || node.type === "UpdateExpression" || node.type === "YieldExpression" || node.type === "TSNonNullExpression")) {\n            return true;\n          }\n          break;\n        }\n        case "ExportDefaultDeclaration": {\n          return shouldWrapFunctionForExportDefault(path, options) || node.type === "SequenceExpression";\n        }\n        case "Decorator": {\n          if (name === "expression") {\n            if (isMemberExpression(node) && node.computed) {\n              return true;\n            }\n            let hasCallExpression = false;\n            let hasMemberExpression = false;\n            let current = node;\n            while (current) {\n              switch (current.type) {\n                case "MemberExpression":\n                  hasMemberExpression = true;\n                  current = current.object;\n                  break;\n                case "CallExpression":\n                  if (hasMemberExpression || hasCallExpression) {\n                    return options.parser !== "typescript";\n                  }\n                  hasCallExpression = true;\n                  current = current.callee;\n                  break;\n                case "Identifier":\n                  return false;\n                case "TaggedTemplateExpression":\n                  return options.parser !== "typescript";\n                default:\n                  return true;\n              }\n            }\n            return true;\n          }\n          break;\n        }\n        case "ArrowFunctionExpression": {\n          if (name === "body" && node.type !== "SequenceExpression" && startsWithNoLookaheadToken(node, (node2) => node2.type === "ObjectExpression")) {\n            return true;\n          }\n          break;\n        }\n      }\n      switch (node.type) {\n        case "UpdateExpression":\n          if (parent.type === "UnaryExpression") {\n            return node.prefix && (node.operator === "++" && parent.operator === "+" || node.operator === "--" && parent.operator === "-");\n          }\n        case "UnaryExpression":\n          switch (parent.type) {\n            case "UnaryExpression":\n              return node.operator === parent.operator && (node.operator === "+" || node.operator === "-");\n            case "BindExpression":\n              return true;\n            case "MemberExpression":\n            case "OptionalMemberExpression":\n              return name === "object";\n            case "TaggedTemplateExpression":\n              return true;\n            case "NewExpression":\n            case "CallExpression":\n            case "OptionalCallExpression":\n              return name === "callee";\n            case "BinaryExpression":\n              return name === "left" && parent.operator === "**";\n            case "TSNonNullExpression":\n              return true;\n            default:\n              return false;\n          }\n        case "BinaryExpression": {\n          if (parent.type === "UpdateExpression") {\n            return true;\n          }\n          if (node.operator === "in" && isPathInForStatementInitializer(path)) {\n            return true;\n          }\n          if (node.operator === "|>" && node.extra && node.extra.parenthesized) {\n            const grandParent = path.getParentNode(1);\n            if (grandParent.type === "BinaryExpression" && grandParent.operator === "|>") {\n              return true;\n            }\n          }\n        }\n        case "TSTypeAssertion":\n        case "TSAsExpression":\n        case "TSSatisfiesExpression":\n        case "LogicalExpression":\n          switch (parent.type) {\n            case "TSSatisfiesExpression":\n            case "TSAsExpression":\n              return !isTSTypeExpression(node);\n            case "ConditionalExpression":\n              return isTSTypeExpression(node);\n            case "CallExpression":\n            case "NewExpression":\n            case "OptionalCallExpression":\n              return name === "callee";\n            case "ClassExpression":\n            case "ClassDeclaration":\n              return name === "superClass";\n            case "TSTypeAssertion":\n            case "TaggedTemplateExpression":\n            case "UnaryExpression":\n            case "JSXSpreadAttribute":\n            case "SpreadElement":\n            case "SpreadProperty":\n            case "BindExpression":\n            case "AwaitExpression":\n            case "TSNonNullExpression":\n            case "UpdateExpression":\n              return true;\n            case "MemberExpression":\n            case "OptionalMemberExpression":\n              return name === "object";\n            case "AssignmentExpression":\n            case "AssignmentPattern":\n              return name === "left" && (node.type === "TSTypeAssertion" || isTSTypeExpression(node));\n            case "LogicalExpression":\n              if (node.type === "LogicalExpression") {\n                return parent.operator !== node.operator;\n              }\n            case "BinaryExpression": {\n              const {\n                operator,\n                type\n              } = node;\n              if (!operator && type !== "TSTypeAssertion") {\n                return true;\n              }\n              const precedence = getPrecedence(operator);\n              const parentOperator = parent.operator;\n              const parentPrecedence = getPrecedence(parentOperator);\n              if (parentPrecedence > precedence) {\n                return true;\n              }\n              if (name === "right" && parentPrecedence === precedence) {\n                return true;\n              }\n              if (parentPrecedence === precedence && !shouldFlatten(parentOperator, operator)) {\n                return true;\n              }\n              if (parentPrecedence < precedence && operator === "%") {\n                return parentOperator === "+" || parentOperator === "-";\n              }\n              if (isBitwiseOperator(parentOperator)) {\n                return true;\n              }\n              return false;\n            }\n            default:\n              return false;\n          }\n        case "SequenceExpression":\n          switch (parent.type) {\n            case "ReturnStatement":\n              return false;\n            case "ForStatement":\n              return false;\n            case "ExpressionStatement":\n              return name !== "expression";\n            case "ArrowFunctionExpression":\n              return name !== "body";\n            default:\n              return true;\n          }\n        case "YieldExpression":\n          if (parent.type === "UnaryExpression" || parent.type === "AwaitExpression" || isTSTypeExpression(parent) || parent.type === "TSNonNullExpression") {\n            return true;\n          }\n        case "AwaitExpression":\n          switch (parent.type) {\n            case "TaggedTemplateExpression":\n            case "UnaryExpression":\n            case "LogicalExpression":\n            case "SpreadElement":\n            case "SpreadProperty":\n            case "TSAsExpression":\n            case "TSSatisfiesExpression":\n            case "TSNonNullExpression":\n            case "BindExpression":\n              return true;\n            case "MemberExpression":\n            case "OptionalMemberExpression":\n              return name === "object";\n            case "NewExpression":\n            case "CallExpression":\n            case "OptionalCallExpression":\n              return name === "callee";\n            case "ConditionalExpression":\n              return name === "test";\n            case "BinaryExpression": {\n              if (!node.argument && parent.operator === "|>") {\n                return false;\n              }\n              return true;\n            }\n            default:\n              return false;\n          }\n        case "TSConditionalType":\n        case "TSFunctionType":\n        case "TSConstructorType":\n          if (name === "extendsType" && parent.type === "TSConditionalType") {\n            if (node.type === "TSConditionalType") {\n              return true;\n            }\n            let {\n              typeAnnotation\n            } = node.returnType || node.typeAnnotation;\n            if (typeAnnotation.type === "TSTypePredicate" && typeAnnotation.typeAnnotation) {\n              typeAnnotation = typeAnnotation.typeAnnotation.typeAnnotation;\n            }\n            if (typeAnnotation.type === "TSInferType" && typeAnnotation.typeParameter.constraint) {\n              return true;\n            }\n          }\n          if (name === "checkType" && parent.type === "TSConditionalType") {\n            return true;\n          }\n        case "TSUnionType":\n        case "TSIntersectionType":\n          if ((parent.type === "TSUnionType" || parent.type === "TSIntersectionType") && parent.types.length > 1 && (!node.types || node.types.length > 1)) {\n            return true;\n          }\n        case "TSInferType":\n          if (node.type === "TSInferType" && parent.type === "TSRestType") {\n            return false;\n          }\n        case "TSTypeOperator":\n          return parent.type === "TSArrayType" || parent.type === "TSOptionalType" || parent.type === "TSRestType" || name === "objectType" && parent.type === "TSIndexedAccessType" || parent.type === "TSTypeOperator" || parent.type === "TSTypeAnnotation" && path.getParentNode(1).type.startsWith("TSJSDoc");\n        case "TSTypeQuery":\n          return name === "objectType" && parent.type === "TSIndexedAccessType" || name === "elementType" && parent.type === "TSArrayType";\n        case "TypeofTypeAnnotation":\n          return name === "objectType" && (parent.type === "IndexedAccessType" || parent.type === "OptionalIndexedAccessType") || name === "elementType" && parent.type === "ArrayTypeAnnotation";\n        case "ArrayTypeAnnotation":\n          return parent.type === "NullableTypeAnnotation";\n        case "IntersectionTypeAnnotation":\n        case "UnionTypeAnnotation":\n          return parent.type === "ArrayTypeAnnotation" || parent.type === "NullableTypeAnnotation" || parent.type === "IntersectionTypeAnnotation" || parent.type === "UnionTypeAnnotation" || name === "objectType" && (parent.type === "IndexedAccessType" || parent.type === "OptionalIndexedAccessType");\n        case "NullableTypeAnnotation":\n          return parent.type === "ArrayTypeAnnotation" || name === "objectType" && (parent.type === "IndexedAccessType" || parent.type === "OptionalIndexedAccessType");\n        case "FunctionTypeAnnotation": {\n          const ancestor = parent.type === "NullableTypeAnnotation" ? path.getParentNode(1) : parent;\n          return ancestor.type === "UnionTypeAnnotation" || ancestor.type === "IntersectionTypeAnnotation" || ancestor.type === "ArrayTypeAnnotation" || name === "objectType" && (ancestor.type === "IndexedAccessType" || ancestor.type === "OptionalIndexedAccessType") || ancestor.type === "NullableTypeAnnotation" || parent.type === "FunctionTypeParam" && parent.name === null && getFunctionParameters(node).some((param) => param.typeAnnotation && param.typeAnnotation.type === "NullableTypeAnnotation");\n        }\n        case "OptionalIndexedAccessType":\n          return name === "objectType" && parent.type === "IndexedAccessType";\n        case "StringLiteral":\n        case "NumericLiteral":\n        case "Literal":\n          if (typeof node.value === "string" && parent.type === "ExpressionStatement" && !parent.directive) {\n            const grandParent = path.getParentNode(1);\n            return grandParent.type === "Program" || grandParent.type === "BlockStatement";\n          }\n          return name === "object" && parent.type === "MemberExpression" && typeof node.value === "number";\n        case "AssignmentExpression": {\n          const grandParent = path.getParentNode(1);\n          if (name === "body" && parent.type === "ArrowFunctionExpression") {\n            return true;\n          }\n          if (name === "key" && (parent.type === "ClassProperty" || parent.type === "PropertyDefinition") && parent.computed) {\n            return false;\n          }\n          if ((name === "init" || name === "update") && parent.type === "ForStatement") {\n            return false;\n          }\n          if (parent.type === "ExpressionStatement") {\n            return node.left.type === "ObjectPattern";\n          }\n          if (name === "key" && parent.type === "TSPropertySignature") {\n            return false;\n          }\n          if (parent.type === "AssignmentExpression") {\n            return false;\n          }\n          if (parent.type === "SequenceExpression" && grandParent && grandParent.type === "ForStatement" && (grandParent.init === parent || grandParent.update === parent)) {\n            return false;\n          }\n          if (name === "value" && parent.type === "Property" && grandParent && grandParent.type === "ObjectPattern" && grandParent.properties.includes(parent)) {\n            return false;\n          }\n          if (parent.type === "NGChainedExpression") {\n            return false;\n          }\n          return true;\n        }\n        case "ConditionalExpression":\n          switch (parent.type) {\n            case "TaggedTemplateExpression":\n            case "UnaryExpression":\n            case "SpreadElement":\n            case "SpreadProperty":\n            case "BinaryExpression":\n            case "LogicalExpression":\n            case "NGPipeExpression":\n            case "ExportDefaultDeclaration":\n            case "AwaitExpression":\n            case "JSXSpreadAttribute":\n            case "TSTypeAssertion":\n            case "TypeCastExpression":\n            case "TSAsExpression":\n            case "TSSatisfiesExpression":\n            case "TSNonNullExpression":\n              return true;\n            case "NewExpression":\n            case "CallExpression":\n            case "OptionalCallExpression":\n              return name === "callee";\n            case "ConditionalExpression":\n              return name === "test";\n            case "MemberExpression":\n            case "OptionalMemberExpression":\n              return name === "object";\n            default:\n              return false;\n          }\n        case "FunctionExpression":\n          switch (parent.type) {\n            case "NewExpression":\n            case "CallExpression":\n            case "OptionalCallExpression":\n              return name === "callee";\n            case "TaggedTemplateExpression":\n              return true;\n            default:\n              return false;\n          }\n        case "ArrowFunctionExpression":\n          switch (parent.type) {\n            case "BinaryExpression":\n              return parent.operator !== "|>" || node.extra && node.extra.parenthesized;\n            case "NewExpression":\n            case "CallExpression":\n            case "OptionalCallExpression":\n              return name === "callee";\n            case "MemberExpression":\n            case "OptionalMemberExpression":\n              return name === "object";\n            case "TSAsExpression":\n            case "TSSatisfiesExpression":\n            case "TSNonNullExpression":\n            case "BindExpression":\n            case "TaggedTemplateExpression":\n            case "UnaryExpression":\n            case "LogicalExpression":\n            case "AwaitExpression":\n            case "TSTypeAssertion":\n              return true;\n            case "ConditionalExpression":\n              return name === "test";\n            default:\n              return false;\n          }\n        case "ClassExpression":\n          if (isNonEmptyArray(node.decorators)) {\n            return true;\n          }\n          switch (parent.type) {\n            case "NewExpression":\n              return name === "callee";\n            default:\n              return false;\n          }\n        case "OptionalMemberExpression":\n        case "OptionalCallExpression": {\n          const parentParent = path.getParentNode(1);\n          if (name === "object" && parent.type === "MemberExpression" || name === "callee" && (parent.type === "CallExpression" || parent.type === "NewExpression") || parent.type === "TSNonNullExpression" && parentParent.type === "MemberExpression" && parentParent.object === parent) {\n            return true;\n          }\n        }\n        case "CallExpression":\n        case "MemberExpression":\n        case "TaggedTemplateExpression":\n        case "TSNonNullExpression":\n          if (name === "callee" && (parent.type === "BindExpression" || parent.type === "NewExpression")) {\n            let object = node;\n            while (object) {\n              switch (object.type) {\n                case "CallExpression":\n                case "OptionalCallExpression":\n                  return true;\n                case "MemberExpression":\n                case "OptionalMemberExpression":\n                case "BindExpression":\n                  object = object.object;\n                  break;\n                case "TaggedTemplateExpression":\n                  object = object.tag;\n                  break;\n                case "TSNonNullExpression":\n                  object = object.expression;\n                  break;\n                default:\n                  return false;\n              }\n            }\n          }\n          return false;\n        case "BindExpression":\n          return name === "callee" && (parent.type === "BindExpression" || parent.type === "NewExpression") || name === "object" && isMemberExpression(parent);\n        case "NGPipeExpression":\n          if (parent.type === "NGRoot" || parent.type === "NGMicrosyntaxExpression" || parent.type === "ObjectProperty" && !(node.extra && node.extra.parenthesized) || parent.type === "ArrayExpression" || isCallExpression(parent) && parent.arguments[name] === node || name === "right" && parent.type === "NGPipeExpression" || name === "property" && parent.type === "MemberExpression" || parent.type === "AssignmentExpression") {\n            return false;\n          }\n          return true;\n        case "JSXFragment":\n        case "JSXElement":\n          return name === "callee" || name === "left" && parent.type === "BinaryExpression" && parent.operator === "<" || parent.type !== "ArrayExpression" && parent.type !== "ArrowFunctionExpression" && parent.type !== "AssignmentExpression" && parent.type !== "AssignmentPattern" && parent.type !== "BinaryExpression" && parent.type !== "NewExpression" && parent.type !== "ConditionalExpression" && parent.type !== "ExpressionStatement" && parent.type !== "JsExpressionRoot" && parent.type !== "JSXAttribute" && parent.type !== "JSXElement" && parent.type !== "JSXExpressionContainer" && parent.type !== "JSXFragment" && parent.type !== "LogicalExpression" && !isCallExpression(parent) && !isObjectProperty(parent) && parent.type !== "ReturnStatement" && parent.type !== "ThrowStatement" && parent.type !== "TypeCastExpression" && parent.type !== "VariableDeclarator" && parent.type !== "YieldExpression";\n        case "TypeAnnotation":\n          return name === "returnType" && parent.type === "ArrowFunctionExpression" && includesFunctionTypeInObjectType(node);\n      }\n      return false;\n    }\n    function isStatement(node) {\n      return node.type === "BlockStatement" || node.type === "BreakStatement" || node.type === "ClassBody" || node.type === "ClassDeclaration" || node.type === "ClassMethod" || node.type === "ClassProperty" || node.type === "PropertyDefinition" || node.type === "ClassPrivateProperty" || node.type === "ContinueStatement" || node.type === "DebuggerStatement" || node.type === "DeclareClass" || node.type === "DeclareExportAllDeclaration" || node.type === "DeclareExportDeclaration" || node.type === "DeclareFunction" || node.type === "DeclareInterface" || node.type === "DeclareModule" || node.type === "DeclareModuleExports" || node.type === "DeclareVariable" || node.type === "DoWhileStatement" || node.type === "EnumDeclaration" || node.type === "ExportAllDeclaration" || node.type === "ExportDefaultDeclaration" || node.type === "ExportNamedDeclaration" || node.type === "ExpressionStatement" || node.type === "ForInStatement" || node.type === "ForOfStatement" || node.type === "ForStatement" || node.type === "FunctionDeclaration" || node.type === "IfStatement" || node.type === "ImportDeclaration" || node.type === "InterfaceDeclaration" || node.type === "LabeledStatement" || node.type === "MethodDefinition" || node.type === "ReturnStatement" || node.type === "SwitchStatement" || node.type === "ThrowStatement" || node.type === "TryStatement" || node.type === "TSDeclareFunction" || node.type === "TSEnumDeclaration" || node.type === "TSImportEqualsDeclaration" || node.type === "TSInterfaceDeclaration" || node.type === "TSModuleDeclaration" || node.type === "TSNamespaceExportDeclaration" || node.type === "TypeAlias" || node.type === "VariableDeclaration" || node.type === "WhileStatement" || node.type === "WithStatement";\n    }\n    function isPathInForStatementInitializer(path) {\n      let i = 0;\n      let node = path.getValue();\n      while (node) {\n        const parent = path.getParentNode(i++);\n        if (parent && parent.type === "ForStatement" && parent.init === node) {\n          return true;\n        }\n        node = parent;\n      }\n      return false;\n    }\n    function includesFunctionTypeInObjectType(node) {\n      return hasNode(node, (n1) => n1.type === "ObjectTypeAnnotation" && hasNode(n1, (n2) => n2.type === "FunctionTypeAnnotation" || void 0) || void 0);\n    }\n    function endsWithRightBracket(node) {\n      switch (node.type) {\n        case "ObjectExpression":\n          return true;\n        default:\n          return false;\n      }\n    }\n    function isFollowedByRightBracket(path) {\n      const node = path.getValue();\n      const parent = path.getParentNode();\n      const name = path.getName();\n      switch (parent.type) {\n        case "NGPipeExpression":\n          if (typeof name === "number" && parent.arguments[name] === node && parent.arguments.length - 1 === name) {\n            return path.callParent(isFollowedByRightBracket);\n          }\n          break;\n        case "ObjectProperty":\n          if (name === "value") {\n            const parentParent = path.getParentNode(1);\n            return getLast(parentParent.properties) === parent;\n          }\n          break;\n        case "BinaryExpression":\n        case "LogicalExpression":\n          if (name === "right") {\n            return path.callParent(isFollowedByRightBracket);\n          }\n          break;\n        case "ConditionalExpression":\n          if (name === "alternate") {\n            return path.callParent(isFollowedByRightBracket);\n          }\n          break;\n        case "UnaryExpression":\n          if (parent.prefix) {\n            return path.callParent(isFollowedByRightBracket);\n          }\n          break;\n      }\n      return false;\n    }\n    function shouldWrapFunctionForExportDefault(path, options) {\n      const node = path.getValue();\n      const parent = path.getParentNode();\n      if (node.type === "FunctionExpression" || node.type === "ClassExpression") {\n        return parent.type === "ExportDefaultDeclaration" || !needsParens(path, options);\n      }\n      if (!hasNakedLeftSide(node) || parent.type !== "ExportDefaultDeclaration" && needsParens(path, options)) {\n        return false;\n      }\n      return path.call((childPath) => shouldWrapFunctionForExportDefault(childPath, options), ...getLeftSidePathName(path, node));\n    }\n    module2.exports = needsParens;\n  }\n});\nvar require_print_preprocess = __commonJS2({\n  "src/language-js/print-preprocess.js"(exports2, module2) {\n    "use strict";\n    function preprocess(ast, options) {\n      switch (options.parser) {\n        case "json":\n        case "json5":\n        case "json-stringify":\n        case "__js_expression":\n        case "__vue_expression":\n        case "__vue_ts_expression":\n          return Object.assign(Object.assign({}, ast), {}, {\n            type: options.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot",\n            node: ast,\n            comments: [],\n            rootMarker: options.rootMarker\n          });\n        default:\n          return ast;\n      }\n    }\n    module2.exports = preprocess;\n  }\n});\nvar require_html_binding = __commonJS2({\n  "src/language-js/print/html-binding.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        join,\n        line,\n        group,\n        softline,\n        indent\n      }\n    } = require("./doc.js");\n    function printHtmlBinding(path, options, print) {\n      const node = path.getValue();\n      if (options.__onHtmlBindingRoot && path.getName() === null) {\n        options.__onHtmlBindingRoot(node, options);\n      }\n      if (node.type !== "File") {\n        return;\n      }\n      if (options.__isVueForBindingLeft) {\n        return path.call((functionDeclarationPath) => {\n          const printed = join([",", line], functionDeclarationPath.map(print, "params"));\n          const {\n            params\n          } = functionDeclarationPath.getValue();\n          if (params.length === 1) {\n            return printed;\n          }\n          return ["(", indent([softline, group(printed)]), softline, ")"];\n        }, "program", "body", 0);\n      }\n      if (options.__isVueBindings) {\n        return path.call((functionDeclarationPath) => join([",", line], functionDeclarationPath.map(print, "params")), "program", "body", 0);\n      }\n    }\n    function isVueEventBindingExpression(node) {\n      switch (node.type) {\n        case "MemberExpression":\n          switch (node.property.type) {\n            case "Identifier":\n            case "NumericLiteral":\n            case "StringLiteral":\n              return isVueEventBindingExpression(node.object);\n          }\n          return false;\n        case "Identifier":\n          return true;\n        default:\n          return false;\n      }\n    }\n    module2.exports = {\n      isVueEventBindingExpression,\n      printHtmlBinding\n    };\n  }\n});\nvar require_binaryish = __commonJS2({\n  "src/language-js/print/binaryish.js"(exports2, module2) {\n    "use strict";\n    var {\n      printComments\n    } = require_comments();\n    var {\n      getLast\n    } = require_util();\n    var {\n      builders: {\n        join,\n        line,\n        softline,\n        group,\n        indent,\n        align,\n        indentIfBreak\n      },\n      utils: {\n        cleanDoc,\n        getDocParts,\n        isConcat\n      }\n    } = require("./doc.js");\n    var {\n      hasLeadingOwnLineComment,\n      isBinaryish,\n      isJsxNode,\n      shouldFlatten,\n      hasComment,\n      CommentCheckFlags,\n      isCallExpression,\n      isMemberExpression,\n      isObjectProperty,\n      isEnabledHackPipeline\n    } = require_utils7();\n    var uid = 0;\n    function printBinaryishExpression(path, options, print) {\n      const node = path.getValue();\n      const parent = path.getParentNode();\n      const parentParent = path.getParentNode(1);\n      const isInsideParenthesis = node !== parent.body && (parent.type === "IfStatement" || parent.type === "WhileStatement" || parent.type === "SwitchStatement" || parent.type === "DoWhileStatement");\n      const isHackPipeline = isEnabledHackPipeline(options) && node.operator === "|>";\n      const parts = printBinaryishExpressions(path, print, options, false, isInsideParenthesis);\n      if (isInsideParenthesis) {\n        return parts;\n      }\n      if (isHackPipeline) {\n        return group(parts);\n      }\n      if (isCallExpression(parent) && parent.callee === node || parent.type === "UnaryExpression" || isMemberExpression(parent) && !parent.computed) {\n        return group([indent([softline, ...parts]), softline]);\n      }\n      const shouldNotIndent = parent.type === "ReturnStatement" || parent.type === "ThrowStatement" || parent.type === "JSXExpressionContainer" && parentParent.type === "JSXAttribute" || node.operator !== "|" && parent.type === "JsExpressionRoot" || node.type !== "NGPipeExpression" && (parent.type === "NGRoot" && options.parser === "__ng_binding" || parent.type === "NGMicrosyntaxExpression" && parentParent.type === "NGMicrosyntax" && parentParent.body.length === 1) || node === parent.body && parent.type === "ArrowFunctionExpression" || node !== parent.body && parent.type === "ForStatement" || parent.type === "ConditionalExpression" && parentParent.type !== "ReturnStatement" && parentParent.type !== "ThrowStatement" && !isCallExpression(parentParent) || parent.type === "TemplateLiteral";\n      const shouldIndentIfInlining = parent.type === "AssignmentExpression" || parent.type === "VariableDeclarator" || parent.type === "ClassProperty" || parent.type === "PropertyDefinition" || parent.type === "TSAbstractPropertyDefinition" || parent.type === "ClassPrivateProperty" || isObjectProperty(parent);\n      const samePrecedenceSubExpression = isBinaryish(node.left) && shouldFlatten(node.operator, node.left.operator);\n      if (shouldNotIndent || shouldInlineLogicalExpression(node) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(node) && shouldIndentIfInlining) {\n        return group(parts);\n      }\n      if (parts.length === 0) {\n        return "";\n      }\n      const hasJsx = isJsxNode(node.right);\n      const firstGroupIndex = parts.findIndex((part) => typeof part !== "string" && !Array.isArray(part) && part.type === "group");\n      const headParts = parts.slice(0, firstGroupIndex === -1 ? 1 : firstGroupIndex + 1);\n      const rest = parts.slice(headParts.length, hasJsx ? -1 : void 0);\n      const groupId = Symbol("logicalChain-" + ++uid);\n      const chain = group([...headParts, indent(rest)], {\n        id: groupId\n      });\n      if (!hasJsx) {\n        return chain;\n      }\n      const jsxPart = getLast(parts);\n      return group([chain, indentIfBreak(jsxPart, {\n        groupId\n      })]);\n    }\n    function printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {\n      const node = path.getValue();\n      if (!isBinaryish(node)) {\n        return [group(print())];\n      }\n      let parts = [];\n      if (shouldFlatten(node.operator, node.left.operator)) {\n        parts = path.call((left) => printBinaryishExpressions(left, print, options, true, isInsideParenthesis), "left");\n      } else {\n        parts.push(group(print("left")));\n      }\n      const shouldInline = shouldInlineLogicalExpression(node);\n      const lineBeforeOperator = (node.operator === "|>" || node.type === "NGPipeExpression" || node.operator === "|" && options.parser === "__vue_expression") && !hasLeadingOwnLineComment(options.originalText, node.right);\n      const operator = node.type === "NGPipeExpression" ? "|" : node.operator;\n      const rightSuffix = node.type === "NGPipeExpression" && node.arguments.length > 0 ? group(indent([line, ": ", join([line, ": "], path.map(print, "arguments").map((arg) => align(2, group(arg))))])) : "";\n      let right;\n      if (shouldInline) {\n        right = [operator, " ", print("right"), rightSuffix];\n      } else {\n        const isHackPipeline = isEnabledHackPipeline(options) && operator === "|>";\n        const rightContent = isHackPipeline ? path.call((left) => printBinaryishExpressions(left, print, options, true, isInsideParenthesis), "right") : print("right");\n        right = [lineBeforeOperator ? line : "", operator, lineBeforeOperator ? " " : line, rightContent, rightSuffix];\n      }\n      const parent = path.getParentNode();\n      const shouldBreak = hasComment(node.left, CommentCheckFlags.Trailing | CommentCheckFlags.Line);\n      const shouldGroup = shouldBreak || !(isInsideParenthesis && node.type === "LogicalExpression") && parent.type !== node.type && node.left.type !== node.type && node.right.type !== node.type;\n      parts.push(lineBeforeOperator ? "" : " ", shouldGroup ? group(right, {\n        shouldBreak\n      }) : right);\n      if (isNested && hasComment(node)) {\n        const printed = cleanDoc(printComments(path, parts, options));\n        if (isConcat(printed) || printed.type === "fill") {\n          return getDocParts(printed);\n        }\n        return [printed];\n      }\n      return parts;\n    }\n    function shouldInlineLogicalExpression(node) {\n      if (node.type !== "LogicalExpression") {\n        return false;\n      }\n      if (node.right.type === "ObjectExpression" && node.right.properties.length > 0) {\n        return true;\n      }\n      if (node.right.type === "ArrayExpression" && node.right.elements.length > 0) {\n        return true;\n      }\n      if (isJsxNode(node.right)) {\n        return true;\n      }\n      return false;\n    }\n    module2.exports = {\n      printBinaryishExpression,\n      shouldInlineLogicalExpression\n    };\n  }\n});\nvar require_angular = __commonJS2({\n  "src/language-js/print/angular.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        join,\n        line,\n        group\n      }\n    } = require("./doc.js");\n    var {\n      hasNode,\n      hasComment,\n      getComments\n    } = require_utils7();\n    var {\n      printBinaryishExpression\n    } = require_binaryish();\n    function printAngular(path, options, print) {\n      const node = path.getValue();\n      if (!node.type.startsWith("NG")) {\n        return;\n      }\n      switch (node.type) {\n        case "NGRoot":\n          return [print("node"), !hasComment(node.node) ? "" : " //" + getComments(node.node)[0].value.trimEnd()];\n        case "NGPipeExpression":\n          return printBinaryishExpression(path, options, print);\n        case "NGChainedExpression":\n          return group(join([";", line], path.map((childPath) => hasNgSideEffect(childPath) ? print() : ["(", print(), ")"], "expressions")));\n        case "NGEmptyExpression":\n          return "";\n        case "NGQuotedExpression":\n          return [node.prefix, ": ", node.value.trim()];\n        case "NGMicrosyntax":\n          return path.map((childPath, index) => [index === 0 ? "" : isNgForOf(childPath.getValue(), index, node) ? " " : [";", line], print()], "body");\n        case "NGMicrosyntaxKey":\n          return /^[$_a-z][\\w$]*(?:-[$_a-z][\\w$])*$/i.test(node.name) ? node.name : JSON.stringify(node.name);\n        case "NGMicrosyntaxExpression":\n          return [print("expression"), node.alias === null ? "" : [" as ", print("alias")]];\n        case "NGMicrosyntaxKeyedExpression": {\n          const index = path.getName();\n          const parentNode = path.getParentNode();\n          const shouldNotPrintColon = isNgForOf(node, index, parentNode) || (index === 1 && (node.key.name === "then" || node.key.name === "else") || index === 2 && node.key.name === "else" && parentNode.body[index - 1].type === "NGMicrosyntaxKeyedExpression" && parentNode.body[index - 1].key.name === "then") && parentNode.body[0].type === "NGMicrosyntaxExpression";\n          return [print("key"), shouldNotPrintColon ? " " : ": ", print("expression")];\n        }\n        case "NGMicrosyntaxLet":\n          return ["let ", print("key"), node.value === null ? "" : [" = ", print("value")]];\n        case "NGMicrosyntaxAs":\n          return [print("key"), " as ", print("alias")];\n        default:\n          throw new Error(`Unknown Angular node type: ${JSON.stringify(node.type)}.`);\n      }\n    }\n    function isNgForOf(node, index, parentNode) {\n      return node.type === "NGMicrosyntaxKeyedExpression" && node.key.name === "of" && index === 1 && parentNode.body[0].type === "NGMicrosyntaxLet" && parentNode.body[0].value === null;\n    }\n    function hasNgSideEffect(path) {\n      return hasNode(path.getValue(), (node) => {\n        switch (node.type) {\n          case void 0:\n            return false;\n          case "CallExpression":\n          case "OptionalCallExpression":\n          case "AssignmentExpression":\n            return true;\n        }\n      });\n    }\n    module2.exports = {\n      printAngular\n    };\n  }\n});\nvar require_jsx = __commonJS2({\n  "src/language-js/print/jsx.js"(exports2, module2) {\n    "use strict";\n    var {\n      printComments,\n      printDanglingComments,\n      printCommentsSeparately\n    } = require_comments();\n    var {\n      builders: {\n        line,\n        hardline,\n        softline,\n        group,\n        indent,\n        conditionalGroup,\n        fill,\n        ifBreak,\n        lineSuffixBoundary,\n        join\n      },\n      utils: {\n        willBreak\n      }\n    } = require("./doc.js");\n    var {\n      getLast,\n      getPreferredQuote\n    } = require_util();\n    var {\n      isJsxNode,\n      rawText,\n      isCallExpression,\n      isStringLiteral,\n      isBinaryish,\n      hasComment,\n      CommentCheckFlags,\n      hasNodeIgnoreComment\n    } = require_utils7();\n    var pathNeedsParens = require_needs_parens();\n    var {\n      willPrintOwnComments\n    } = require_comments2();\n    var isEmptyStringOrAnyLine = (doc2) => doc2 === "" || doc2 === line || doc2 === hardline || doc2 === softline;\n    function printJsxElementInternal(path, options, print) {\n      const node = path.getValue();\n      if (node.type === "JSXElement" && isEmptyJsxElement(node)) {\n        return [print("openingElement"), print("closingElement")];\n      }\n      const openingLines = node.type === "JSXElement" ? print("openingElement") : print("openingFragment");\n      const closingLines = node.type === "JSXElement" ? print("closingElement") : print("closingFragment");\n      if (node.children.length === 1 && node.children[0].type === "JSXExpressionContainer" && (node.children[0].expression.type === "TemplateLiteral" || node.children[0].expression.type === "TaggedTemplateExpression")) {\n        return [openingLines, ...path.map(print, "children"), closingLines];\n      }\n      node.children = node.children.map((child) => {\n        if (isJsxWhitespaceExpression(child)) {\n          return {\n            type: "JSXText",\n            value: " ",\n            raw: " "\n          };\n        }\n        return child;\n      });\n      const containsTag = node.children.some(isJsxNode);\n      const containsMultipleExpressions = node.children.filter((child) => child.type === "JSXExpressionContainer").length > 1;\n      const containsMultipleAttributes = node.type === "JSXElement" && node.openingElement.attributes.length > 1;\n      let forcedBreak = willBreak(openingLines) || containsTag || containsMultipleAttributes || containsMultipleExpressions;\n      const isMdxBlock = path.getParentNode().rootMarker === "mdx";\n      const rawJsxWhitespace = options.singleQuote ? "{\' \'}" : \'{" "}\';\n      const jsxWhitespace = isMdxBlock ? " " : ifBreak([rawJsxWhitespace, softline], " ");\n      const isFacebookTranslationTag = node.openingElement && node.openingElement.name && node.openingElement.name.name === "fbt";\n      const children = printJsxChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag);\n      const containsText = node.children.some((child) => isMeaningfulJsxText(child));\n      for (let i = children.length - 2; i >= 0; i--) {\n        const isPairOfEmptyStrings = children[i] === "" && children[i + 1] === "";\n        const isPairOfHardlines = children[i] === hardline && children[i + 1] === "" && children[i + 2] === hardline;\n        const isLineFollowedByJsxWhitespace = (children[i] === softline || children[i] === hardline) && children[i + 1] === "" && children[i + 2] === jsxWhitespace;\n        const isJsxWhitespaceFollowedByLine = children[i] === jsxWhitespace && children[i + 1] === "" && (children[i + 2] === softline || children[i + 2] === hardline);\n        const isDoubleJsxWhitespace = children[i] === jsxWhitespace && children[i + 1] === "" && children[i + 2] === jsxWhitespace;\n        const isPairOfHardOrSoftLines = children[i] === softline && children[i + 1] === "" && children[i + 2] === hardline || children[i] === hardline && children[i + 1] === "" && children[i + 2] === softline;\n        if (isPairOfHardlines && containsText || isPairOfEmptyStrings || isLineFollowedByJsxWhitespace || isDoubleJsxWhitespace || isPairOfHardOrSoftLines) {\n          children.splice(i, 2);\n        } else if (isJsxWhitespaceFollowedByLine) {\n          children.splice(i + 1, 2);\n        }\n      }\n      while (children.length > 0 && isEmptyStringOrAnyLine(getLast(children))) {\n        children.pop();\n      }\n      while (children.length > 1 && isEmptyStringOrAnyLine(children[0]) && isEmptyStringOrAnyLine(children[1])) {\n        children.shift();\n        children.shift();\n      }\n      const multilineChildren = [];\n      for (const [i, child] of children.entries()) {\n        if (child === jsxWhitespace) {\n          if (i === 1 && children[i - 1] === "") {\n            if (children.length === 2) {\n              multilineChildren.push(rawJsxWhitespace);\n              continue;\n            }\n            multilineChildren.push([rawJsxWhitespace, hardline]);\n            continue;\n          } else if (i === children.length - 1) {\n            multilineChildren.push(rawJsxWhitespace);\n            continue;\n          } else if (children[i - 1] === "" && children[i - 2] === hardline) {\n            multilineChildren.push(rawJsxWhitespace);\n            continue;\n          }\n        }\n        multilineChildren.push(child);\n        if (willBreak(child)) {\n          forcedBreak = true;\n        }\n      }\n      const content = containsText ? fill(multilineChildren) : group(multilineChildren, {\n        shouldBreak: true\n      });\n      if (isMdxBlock) {\n        return content;\n      }\n      const multiLineElem = group([openingLines, indent([hardline, content]), hardline, closingLines]);\n      if (forcedBreak) {\n        return multiLineElem;\n      }\n      return conditionalGroup([group([openingLines, ...children, closingLines]), multiLineElem]);\n    }\n    function printJsxChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag) {\n      const parts = [];\n      path.each((childPath, i, children) => {\n        const child = childPath.getValue();\n        if (child.type === "JSXText") {\n          const text = rawText(child);\n          if (isMeaningfulJsxText(child)) {\n            const words = text.split(matchJsxWhitespaceRegex);\n            if (words[0] === "") {\n              parts.push("");\n              words.shift();\n              if (/\\n/.test(words[0])) {\n                const next = children[i + 1];\n                parts.push(separatorWithWhitespace(isFacebookTranslationTag, words[1], child, next));\n              } else {\n                parts.push(jsxWhitespace);\n              }\n              words.shift();\n            }\n            let endWhitespace;\n            if (getLast(words) === "") {\n              words.pop();\n              endWhitespace = words.pop();\n            }\n            if (words.length === 0) {\n              return;\n            }\n            for (const [i2, word] of words.entries()) {\n              if (i2 % 2 === 1) {\n                parts.push(line);\n              } else {\n                parts.push(word);\n              }\n            }\n            if (endWhitespace !== void 0) {\n              if (/\\n/.test(endWhitespace)) {\n                const next = children[i + 1];\n                parts.push(separatorWithWhitespace(isFacebookTranslationTag, getLast(parts), child, next));\n              } else {\n                parts.push(jsxWhitespace);\n              }\n            } else {\n              const next = children[i + 1];\n              parts.push(separatorNoWhitespace(isFacebookTranslationTag, getLast(parts), child, next));\n            }\n          } else if (/\\n/.test(text)) {\n            if (text.match(/\\n/g).length > 1) {\n              parts.push("", hardline);\n            }\n          } else {\n            parts.push("", jsxWhitespace);\n          }\n        } else {\n          const printedChild = print();\n          parts.push(printedChild);\n          const next = children[i + 1];\n          const directlyFollowedByMeaningfulText = next && isMeaningfulJsxText(next);\n          if (directlyFollowedByMeaningfulText) {\n            const firstWord = trimJsxWhitespace(rawText(next)).split(matchJsxWhitespaceRegex)[0];\n            parts.push(separatorNoWhitespace(isFacebookTranslationTag, firstWord, child, next));\n          } else {\n            parts.push(hardline);\n          }\n        }\n      }, "children");\n      return parts;\n    }\n    function separatorNoWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n      if (isFacebookTranslationTag) {\n        return "";\n      }\n      if (childNode.type === "JSXElement" && !childNode.closingElement || nextNode && nextNode.type === "JSXElement" && !nextNode.closingElement) {\n        return child.length === 1 ? softline : hardline;\n      }\n      return softline;\n    }\n    function separatorWithWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {\n      if (isFacebookTranslationTag) {\n        return hardline;\n      }\n      if (child.length === 1) {\n        return childNode.type === "JSXElement" && !childNode.closingElement || nextNode && nextNode.type === "JSXElement" && !nextNode.closingElement ? hardline : softline;\n      }\n      return hardline;\n    }\n    function maybeWrapJsxElementInParens(path, elem, options) {\n      const parent = path.getParentNode();\n      if (!parent) {\n        return elem;\n      }\n      const NO_WRAP_PARENTS = {\n        ArrayExpression: true,\n        JSXAttribute: true,\n        JSXElement: true,\n        JSXExpressionContainer: true,\n        JSXFragment: true,\n        ExpressionStatement: true,\n        CallExpression: true,\n        OptionalCallExpression: true,\n        ConditionalExpression: true,\n        JsExpressionRoot: true\n      };\n      if (NO_WRAP_PARENTS[parent.type]) {\n        return elem;\n      }\n      const shouldBreak = path.match(void 0, (node) => node.type === "ArrowFunctionExpression", isCallExpression, (node) => node.type === "JSXExpressionContainer");\n      const needsParens = pathNeedsParens(path, options);\n      return group([needsParens ? "" : ifBreak("("), indent([softline, elem]), softline, needsParens ? "" : ifBreak(")")], {\n        shouldBreak\n      });\n    }\n    function printJsxAttribute(path, options, print) {\n      const node = path.getValue();\n      const parts = [];\n      parts.push(print("name"));\n      if (node.value) {\n        let res;\n        if (isStringLiteral(node.value)) {\n          const raw = rawText(node.value);\n          let final = raw.slice(1, -1).replace(/&apos;/g, "\'").replace(/&quot;/g, \'"\');\n          const {\n            escaped,\n            quote,\n            regex\n          } = getPreferredQuote(final, options.jsxSingleQuote ? "\'" : \'"\');\n          final = final.replace(regex, escaped);\n          const {\n            leading,\n            trailing\n          } = path.call(() => printCommentsSeparately(path, options), "value");\n          res = [leading, quote, final, quote, trailing];\n        } else {\n          res = print("value");\n        }\n        parts.push("=", res);\n      }\n      return parts;\n    }\n    function printJsxExpressionContainer(path, options, print) {\n      const node = path.getValue();\n      const shouldInline = (node2, parent) => node2.type === "JSXEmptyExpression" || !hasComment(node2) && (node2.type === "ArrayExpression" || node2.type === "ObjectExpression" || node2.type === "ArrowFunctionExpression" || node2.type === "AwaitExpression" && (shouldInline(node2.argument, node2) || node2.argument.type === "JSXElement") || isCallExpression(node2) || node2.type === "FunctionExpression" || node2.type === "TemplateLiteral" || node2.type === "TaggedTemplateExpression" || node2.type === "DoExpression" || isJsxNode(parent) && (node2.type === "ConditionalExpression" || isBinaryish(node2)));\n      if (shouldInline(node.expression, path.getParentNode(0))) {\n        return group(["{", print("expression"), lineSuffixBoundary, "}"]);\n      }\n      return group(["{", indent([softline, print("expression")]), softline, lineSuffixBoundary, "}"]);\n    }\n    function printJsxOpeningElement(path, options, print) {\n      const node = path.getValue();\n      const nameHasComments = node.name && hasComment(node.name) || node.typeParameters && hasComment(node.typeParameters);\n      if (node.selfClosing && node.attributes.length === 0 && !nameHasComments) {\n        return ["<", print("name"), print("typeParameters"), " />"];\n      }\n      if (node.attributes && node.attributes.length === 1 && node.attributes[0].value && isStringLiteral(node.attributes[0].value) && !node.attributes[0].value.value.includes("\\n") && !nameHasComments && !hasComment(node.attributes[0])) {\n        return group(["<", print("name"), print("typeParameters"), " ", ...path.map(print, "attributes"), node.selfClosing ? " />" : ">"]);\n      }\n      const shouldBreak = node.attributes && node.attributes.some((attr) => attr.value && isStringLiteral(attr.value) && attr.value.value.includes("\\n"));\n      const attributeLine = options.singleAttributePerLine && node.attributes.length > 1 ? hardline : line;\n      return group(["<", print("name"), print("typeParameters"), indent(path.map(() => [attributeLine, print()], "attributes")), ...printEndOfOpeningTag(node, options, nameHasComments)], {\n        shouldBreak\n      });\n    }\n    function printEndOfOpeningTag(node, options, nameHasComments) {\n      if (node.selfClosing) {\n        return [line, "/>"];\n      }\n      const bracketSameLine = shouldPrintBracketSameLine(node, options, nameHasComments);\n      if (bracketSameLine) {\n        return [">"];\n      }\n      return [softline, ">"];\n    }\n    function shouldPrintBracketSameLine(node, options, nameHasComments) {\n      const lastAttrHasTrailingComments = node.attributes.length > 0 && hasComment(getLast(node.attributes), CommentCheckFlags.Trailing);\n      return node.attributes.length === 0 && !nameHasComments || (options.bracketSameLine || options.jsxBracketSameLine) && (!nameHasComments || node.attributes.length > 0) && !lastAttrHasTrailingComments;\n    }\n    function printJsxClosingElement(path, options, print) {\n      const node = path.getValue();\n      const parts = [];\n      parts.push("</");\n      const printed = print("name");\n      if (hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Line)) {\n        parts.push(indent([hardline, printed]), hardline);\n      } else if (hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Block)) {\n        parts.push(" ", printed);\n      } else {\n        parts.push(printed);\n      }\n      parts.push(">");\n      return parts;\n    }\n    function printJsxOpeningClosingFragment(path, options) {\n      const node = path.getValue();\n      const nodeHasComment = hasComment(node);\n      const hasOwnLineComment = hasComment(node, CommentCheckFlags.Line);\n      const isOpeningFragment = node.type === "JSXOpeningFragment";\n      return [isOpeningFragment ? "<" : "</", indent([hasOwnLineComment ? hardline : nodeHasComment && !isOpeningFragment ? " " : "", printDanglingComments(path, options, true)]), hasOwnLineComment ? hardline : "", ">"];\n    }\n    function printJsxElement(path, options, print) {\n      const elem = printComments(path, printJsxElementInternal(path, options, print), options);\n      return maybeWrapJsxElementInParens(path, elem, options);\n    }\n    function printJsxEmptyExpression(path, options) {\n      const node = path.getValue();\n      const requiresHardline = hasComment(node, CommentCheckFlags.Line);\n      return [printDanglingComments(path, options, !requiresHardline), requiresHardline ? hardline : ""];\n    }\n    function printJsxSpreadAttribute(path, options, print) {\n      const node = path.getValue();\n      return ["{", path.call((p) => {\n        const printed = ["...", print()];\n        const node2 = p.getValue();\n        if (!hasComment(node2) || !willPrintOwnComments(p)) {\n          return printed;\n        }\n        return [indent([softline, printComments(p, printed, options)]), softline];\n      }, node.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];\n    }\n    function printJsx(path, options, print) {\n      const node = path.getValue();\n      if (!node.type.startsWith("JSX")) {\n        return;\n      }\n      switch (node.type) {\n        case "JSXAttribute":\n          return printJsxAttribute(path, options, print);\n        case "JSXIdentifier":\n          return String(node.name);\n        case "JSXNamespacedName":\n          return join(":", [print("namespace"), print("name")]);\n        case "JSXMemberExpression":\n          return join(".", [print("object"), print("property")]);\n        case "JSXSpreadAttribute":\n          return printJsxSpreadAttribute(path, options, print);\n        case "JSXSpreadChild": {\n          const printJsxSpreadChild = printJsxSpreadAttribute;\n          return printJsxSpreadChild(path, options, print);\n        }\n        case "JSXExpressionContainer":\n          return printJsxExpressionContainer(path, options, print);\n        case "JSXFragment":\n        case "JSXElement":\n          return printJsxElement(path, options, print);\n        case "JSXOpeningElement":\n          return printJsxOpeningElement(path, options, print);\n        case "JSXClosingElement":\n          return printJsxClosingElement(path, options, print);\n        case "JSXOpeningFragment":\n        case "JSXClosingFragment":\n          return printJsxOpeningClosingFragment(path, options);\n        case "JSXEmptyExpression":\n          return printJsxEmptyExpression(path, options);\n        case "JSXText":\n          throw new Error("JSXText should be handled by JSXElement");\n        default:\n          throw new Error(`Unknown JSX node type: ${JSON.stringify(node.type)}.`);\n      }\n    }\n    var jsxWhitespaceChars = " \\n\\r\t";\n    var matchJsxWhitespaceRegex = new RegExp("([" + jsxWhitespaceChars + "]+)");\n    var containsNonJsxWhitespaceRegex = new RegExp("[^" + jsxWhitespaceChars + "]");\n    var trimJsxWhitespace = (text) => text.replace(new RegExp("(?:^" + matchJsxWhitespaceRegex.source + "|" + matchJsxWhitespaceRegex.source + "$)"), "");\n    function isEmptyJsxElement(node) {\n      if (node.children.length === 0) {\n        return true;\n      }\n      if (node.children.length > 1) {\n        return false;\n      }\n      const child = node.children[0];\n      return child.type === "JSXText" && !isMeaningfulJsxText(child);\n    }\n    function isMeaningfulJsxText(node) {\n      return node.type === "JSXText" && (containsNonJsxWhitespaceRegex.test(rawText(node)) || !/\\n/.test(rawText(node)));\n    }\n    function isJsxWhitespaceExpression(node) {\n      return node.type === "JSXExpressionContainer" && isStringLiteral(node.expression) && node.expression.value === " " && !hasComment(node.expression);\n    }\n    function hasJsxIgnoreComment(path) {\n      const node = path.getValue();\n      const parent = path.getParentNode();\n      if (!parent || !node || !isJsxNode(node) || !isJsxNode(parent)) {\n        return false;\n      }\n      const index = parent.children.indexOf(node);\n      let prevSibling = null;\n      for (let i = index; i > 0; i--) {\n        const candidate = parent.children[i - 1];\n        if (candidate.type === "JSXText" && !isMeaningfulJsxText(candidate)) {\n          continue;\n        }\n        prevSibling = candidate;\n        break;\n      }\n      return prevSibling && prevSibling.type === "JSXExpressionContainer" && prevSibling.expression.type === "JSXEmptyExpression" && hasNodeIgnoreComment(prevSibling.expression);\n    }\n    module2.exports = {\n      hasJsxIgnoreComment,\n      printJsx\n    };\n  }\n});\nvar require_doc_builders = __commonJS2({\n  "src/document/doc-builders.js"(exports2, module2) {\n    "use strict";\n    function concat(parts) {\n      if (false) {\n        for (const part of parts) {\n          assertDoc(part);\n        }\n      }\n      return {\n        type: "concat",\n        parts\n      };\n    }\n    function indent(contents) {\n      if (false) {\n        assertDoc(contents);\n      }\n      return {\n        type: "indent",\n        contents\n      };\n    }\n    function align(widthOrString, contents) {\n      if (false) {\n        assertDoc(contents);\n      }\n      return {\n        type: "align",\n        contents,\n        n: widthOrString\n      };\n    }\n    function group(contents, opts = {}) {\n      if (false) {\n        assertDoc(contents);\n      }\n      return {\n        type: "group",\n        id: opts.id,\n        contents,\n        break: Boolean(opts.shouldBreak),\n        expandedStates: opts.expandedStates\n      };\n    }\n    function dedentToRoot(contents) {\n      return align(Number.NEGATIVE_INFINITY, contents);\n    }\n    function markAsRoot(contents) {\n      return align({\n        type: "root"\n      }, contents);\n    }\n    function dedent(contents) {\n      return align(-1, contents);\n    }\n    function conditionalGroup(states, opts) {\n      return group(states[0], Object.assign(Object.assign({}, opts), {}, {\n        expandedStates: states\n      }));\n    }\n    function fill(parts) {\n      if (false) {\n        for (const part of parts) {\n          assertDoc(part);\n        }\n      }\n      return {\n        type: "fill",\n        parts\n      };\n    }\n    function ifBreak(breakContents, flatContents, opts = {}) {\n      if (false) {\n        if (breakContents) {\n          assertDoc(breakContents);\n        }\n        if (flatContents) {\n          assertDoc(flatContents);\n        }\n      }\n      return {\n        type: "if-break",\n        breakContents,\n        flatContents,\n        groupId: opts.groupId\n      };\n    }\n    function indentIfBreak(contents, opts) {\n      return {\n        type: "indent-if-break",\n        contents,\n        groupId: opts.groupId,\n        negate: opts.negate\n      };\n    }\n    function lineSuffix(contents) {\n      if (false) {\n        assertDoc(contents);\n      }\n      return {\n        type: "line-suffix",\n        contents\n      };\n    }\n    var lineSuffixBoundary = {\n      type: "line-suffix-boundary"\n    };\n    var breakParent = {\n      type: "break-parent"\n    };\n    var trim = {\n      type: "trim"\n    };\n    var hardlineWithoutBreakParent = {\n      type: "line",\n      hard: true\n    };\n    var literallineWithoutBreakParent = {\n      type: "line",\n      hard: true,\n      literal: true\n    };\n    var line = {\n      type: "line"\n    };\n    var softline = {\n      type: "line",\n      soft: true\n    };\n    var hardline = concat([hardlineWithoutBreakParent, breakParent]);\n    var literalline = concat([literallineWithoutBreakParent, breakParent]);\n    var cursor = {\n      type: "cursor",\n      placeholder: Symbol("cursor")\n    };\n    function join(sep, arr) {\n      const res = [];\n      for (let i = 0; i < arr.length; i++) {\n        if (i !== 0) {\n          res.push(sep);\n        }\n        res.push(arr[i]);\n      }\n      return concat(res);\n    }\n    function addAlignmentToDoc(doc2, size, tabWidth) {\n      let aligned = doc2;\n      if (size > 0) {\n        for (let i = 0; i < Math.floor(size / tabWidth); ++i) {\n          aligned = indent(aligned);\n        }\n        aligned = align(size % tabWidth, aligned);\n        aligned = align(Number.NEGATIVE_INFINITY, aligned);\n      }\n      return aligned;\n    }\n    function label(label2, contents) {\n      return {\n        type: "label",\n        label: label2,\n        contents\n      };\n    }\n    module2.exports = {\n      concat,\n      join,\n      line,\n      softline,\n      hardline,\n      literalline,\n      group,\n      conditionalGroup,\n      fill,\n      lineSuffix,\n      lineSuffixBoundary,\n      cursor,\n      breakParent,\n      ifBreak,\n      trim,\n      indent,\n      indentIfBreak,\n      align,\n      addAlignmentToDoc,\n      markAsRoot,\n      dedentToRoot,\n      dedent,\n      hardlineWithoutBreakParent,\n      literallineWithoutBreakParent,\n      label\n    };\n  }\n});\nvar require_doc_utils = __commonJS2({\n  "src/document/doc-utils.js"(exports2, module2) {\n    "use strict";\n    var getLast = require_get_last();\n    var {\n      literalline,\n      join\n    } = require_doc_builders();\n    var isConcat = (doc2) => Array.isArray(doc2) || doc2 && doc2.type === "concat";\n    var getDocParts = (doc2) => {\n      if (Array.isArray(doc2)) {\n        return doc2;\n      }\n      if (doc2.type !== "concat" && doc2.type !== "fill") {\n        throw new Error("Expect doc type to be `concat` or `fill`.");\n      }\n      return doc2.parts;\n    };\n    var traverseDocOnExitStackMarker = {};\n    function traverseDoc(doc2, onEnter, onExit, shouldTraverseConditionalGroups) {\n      const docsStack = [doc2];\n      while (docsStack.length > 0) {\n        const doc3 = docsStack.pop();\n        if (doc3 === traverseDocOnExitStackMarker) {\n          onExit(docsStack.pop());\n          continue;\n        }\n        if (onExit) {\n          docsStack.push(doc3, traverseDocOnExitStackMarker);\n        }\n        if (!onEnter || onEnter(doc3) !== false) {\n          if (isConcat(doc3) || doc3.type === "fill") {\n            const parts = getDocParts(doc3);\n            for (let ic = parts.length, i = ic - 1; i >= 0; --i) {\n              docsStack.push(parts[i]);\n            }\n          } else if (doc3.type === "if-break") {\n            if (doc3.flatContents) {\n              docsStack.push(doc3.flatContents);\n            }\n            if (doc3.breakContents) {\n              docsStack.push(doc3.breakContents);\n            }\n          } else if (doc3.type === "group" && doc3.expandedStates) {\n            if (shouldTraverseConditionalGroups) {\n              for (let ic = doc3.expandedStates.length, i = ic - 1; i >= 0; --i) {\n                docsStack.push(doc3.expandedStates[i]);\n              }\n            } else {\n              docsStack.push(doc3.contents);\n            }\n          } else if (doc3.contents) {\n            docsStack.push(doc3.contents);\n          }\n        }\n      }\n    }\n    function mapDoc(doc2, cb) {\n      const mapped = /* @__PURE__ */ new Map();\n      return rec(doc2);\n      function rec(doc3) {\n        if (mapped.has(doc3)) {\n          return mapped.get(doc3);\n        }\n        const result = process2(doc3);\n        mapped.set(doc3, result);\n        return result;\n      }\n      function process2(doc3) {\n        if (Array.isArray(doc3)) {\n          return cb(doc3.map(rec));\n        }\n        if (doc3.type === "concat" || doc3.type === "fill") {\n          const parts = doc3.parts.map(rec);\n          return cb(Object.assign(Object.assign({}, doc3), {}, {\n            parts\n          }));\n        }\n        if (doc3.type === "if-break") {\n          const breakContents = doc3.breakContents && rec(doc3.breakContents);\n          const flatContents = doc3.flatContents && rec(doc3.flatContents);\n          return cb(Object.assign(Object.assign({}, doc3), {}, {\n            breakContents,\n            flatContents\n          }));\n        }\n        if (doc3.type === "group" && doc3.expandedStates) {\n          const expandedStates = doc3.expandedStates.map(rec);\n          const contents = expandedStates[0];\n          return cb(Object.assign(Object.assign({}, doc3), {}, {\n            contents,\n            expandedStates\n          }));\n        }\n        if (doc3.contents) {\n          const contents = rec(doc3.contents);\n          return cb(Object.assign(Object.assign({}, doc3), {}, {\n            contents\n          }));\n        }\n        return cb(doc3);\n      }\n    }\n    function findInDoc(doc2, fn, defaultValue) {\n      let result = defaultValue;\n      let hasStopped = false;\n      function findInDocOnEnterFn(doc3) {\n        const maybeResult = fn(doc3);\n        if (maybeResult !== void 0) {\n          hasStopped = true;\n          result = maybeResult;\n        }\n        if (hasStopped) {\n          return false;\n        }\n      }\n      traverseDoc(doc2, findInDocOnEnterFn);\n      return result;\n    }\n    function willBreakFn(doc2) {\n      if (doc2.type === "group" && doc2.break) {\n        return true;\n      }\n      if (doc2.type === "line" && doc2.hard) {\n        return true;\n      }\n      if (doc2.type === "break-parent") {\n        return true;\n      }\n    }\n    function willBreak(doc2) {\n      return findInDoc(doc2, willBreakFn, false);\n    }\n    function breakParentGroup(groupStack) {\n      if (groupStack.length > 0) {\n        const parentGroup = getLast(groupStack);\n        if (!parentGroup.expandedStates && !parentGroup.break) {\n          parentGroup.break = "propagated";\n        }\n      }\n      return null;\n    }\n    function propagateBreaks(doc2) {\n      const alreadyVisitedSet = /* @__PURE__ */ new Set();\n      const groupStack = [];\n      function propagateBreaksOnEnterFn(doc3) {\n        if (doc3.type === "break-parent") {\n          breakParentGroup(groupStack);\n        }\n        if (doc3.type === "group") {\n          groupStack.push(doc3);\n          if (alreadyVisitedSet.has(doc3)) {\n            return false;\n          }\n          alreadyVisitedSet.add(doc3);\n        }\n      }\n      function propagateBreaksOnExitFn(doc3) {\n        if (doc3.type === "group") {\n          const group = groupStack.pop();\n          if (group.break) {\n            breakParentGroup(groupStack);\n          }\n        }\n      }\n      traverseDoc(doc2, propagateBreaksOnEnterFn, propagateBreaksOnExitFn, true);\n    }\n    function removeLinesFn(doc2) {\n      if (doc2.type === "line" && !doc2.hard) {\n        return doc2.soft ? "" : " ";\n      }\n      if (doc2.type === "if-break") {\n        return doc2.flatContents || "";\n      }\n      return doc2;\n    }\n    function removeLines(doc2) {\n      return mapDoc(doc2, removeLinesFn);\n    }\n    var isHardline = (doc2, nextDoc) => doc2 && doc2.type === "line" && doc2.hard && nextDoc && nextDoc.type === "break-parent";\n    function stripDocTrailingHardlineFromDoc(doc2) {\n      if (!doc2) {\n        return doc2;\n      }\n      if (isConcat(doc2) || doc2.type === "fill") {\n        const parts = getDocParts(doc2);\n        while (parts.length > 1 && isHardline(...parts.slice(-2))) {\n          parts.length -= 2;\n        }\n        if (parts.length > 0) {\n          const lastPart = stripDocTrailingHardlineFromDoc(getLast(parts));\n          parts[parts.length - 1] = lastPart;\n        }\n        return Array.isArray(doc2) ? parts : Object.assign(Object.assign({}, doc2), {}, {\n          parts\n        });\n      }\n      switch (doc2.type) {\n        case "align":\n        case "indent":\n        case "indent-if-break":\n        case "group":\n        case "line-suffix":\n        case "label": {\n          const contents = stripDocTrailingHardlineFromDoc(doc2.contents);\n          return Object.assign(Object.assign({}, doc2), {}, {\n            contents\n          });\n        }\n        case "if-break": {\n          const breakContents = stripDocTrailingHardlineFromDoc(doc2.breakContents);\n          const flatContents = stripDocTrailingHardlineFromDoc(doc2.flatContents);\n          return Object.assign(Object.assign({}, doc2), {}, {\n            breakContents,\n            flatContents\n          });\n        }\n      }\n      return doc2;\n    }\n    function stripTrailingHardline(doc2) {\n      return stripDocTrailingHardlineFromDoc(cleanDoc(doc2));\n    }\n    function cleanDocFn(doc2) {\n      switch (doc2.type) {\n        case "fill":\n          if (doc2.parts.every((part) => part === "")) {\n            return "";\n          }\n          break;\n        case "group":\n          if (!doc2.contents && !doc2.id && !doc2.break && !doc2.expandedStates) {\n            return "";\n          }\n          if (doc2.contents.type === "group" && doc2.contents.id === doc2.id && doc2.contents.break === doc2.break && doc2.contents.expandedStates === doc2.expandedStates) {\n            return doc2.contents;\n          }\n          break;\n        case "align":\n        case "indent":\n        case "indent-if-break":\n        case "line-suffix":\n          if (!doc2.contents) {\n            return "";\n          }\n          break;\n        case "if-break":\n          if (!doc2.flatContents && !doc2.breakContents) {\n            return "";\n          }\n          break;\n      }\n      if (!isConcat(doc2)) {\n        return doc2;\n      }\n      const parts = [];\n      for (const part of getDocParts(doc2)) {\n        if (!part) {\n          continue;\n        }\n        const [currentPart, ...restParts] = isConcat(part) ? getDocParts(part) : [part];\n        if (typeof currentPart === "string" && typeof getLast(parts) === "string") {\n          parts[parts.length - 1] += currentPart;\n        } else {\n          parts.push(currentPart);\n        }\n        parts.push(...restParts);\n      }\n      if (parts.length === 0) {\n        return "";\n      }\n      if (parts.length === 1) {\n        return parts[0];\n      }\n      return Array.isArray(doc2) ? parts : Object.assign(Object.assign({}, doc2), {}, {\n        parts\n      });\n    }\n    function cleanDoc(doc2) {\n      return mapDoc(doc2, (currentDoc) => cleanDocFn(currentDoc));\n    }\n    function normalizeParts(parts) {\n      const newParts = [];\n      const restParts = parts.filter(Boolean);\n      while (restParts.length > 0) {\n        const part = restParts.shift();\n        if (!part) {\n          continue;\n        }\n        if (isConcat(part)) {\n          restParts.unshift(...getDocParts(part));\n          continue;\n        }\n        if (newParts.length > 0 && typeof getLast(newParts) === "string" && typeof part === "string") {\n          newParts[newParts.length - 1] += part;\n          continue;\n        }\n        newParts.push(part);\n      }\n      return newParts;\n    }\n    function normalizeDoc(doc2) {\n      return mapDoc(doc2, (currentDoc) => {\n        if (Array.isArray(currentDoc)) {\n          return normalizeParts(currentDoc);\n        }\n        if (!currentDoc.parts) {\n          return currentDoc;\n        }\n        return Object.assign(Object.assign({}, currentDoc), {}, {\n          parts: normalizeParts(currentDoc.parts)\n        });\n      });\n    }\n    function replaceEndOfLine(doc2) {\n      return mapDoc(doc2, (currentDoc) => typeof currentDoc === "string" && currentDoc.includes("\\n") ? replaceTextEndOfLine(currentDoc) : currentDoc);\n    }\n    function replaceTextEndOfLine(text, replacement = literalline) {\n      return join(replacement, text.split("\\n")).parts;\n    }\n    function canBreakFn(doc2) {\n      if (doc2.type === "line") {\n        return true;\n      }\n    }\n    function canBreak(doc2) {\n      return findInDoc(doc2, canBreakFn, false);\n    }\n    module2.exports = {\n      isConcat,\n      getDocParts,\n      willBreak,\n      traverseDoc,\n      findInDoc,\n      mapDoc,\n      propagateBreaks,\n      removeLines,\n      stripTrailingHardline,\n      normalizeParts,\n      normalizeDoc,\n      cleanDoc,\n      replaceTextEndOfLine,\n      replaceEndOfLine,\n      canBreak\n    };\n  }\n});\nvar require_misc = __commonJS2({\n  "src/language-js/print/misc.js"(exports2, module2) {\n    "use strict";\n    var {\n      isNonEmptyArray\n    } = require_util();\n    var {\n      builders: {\n        indent,\n        join,\n        line\n      }\n    } = require("./doc.js");\n    var {\n      isFlowAnnotationComment\n    } = require_utils7();\n    function printOptionalToken(path) {\n      const node = path.getValue();\n      if (!node.optional || node.type === "Identifier" && node === path.getParentNode().key) {\n        return "";\n      }\n      if (node.type === "OptionalCallExpression" || node.type === "OptionalMemberExpression" && node.computed) {\n        return "?.";\n      }\n      return "?";\n    }\n    function printDefiniteToken(path) {\n      return path.getValue().definite || path.match(void 0, (node, name) => name === "id" && node.type === "VariableDeclarator" && node.definite) ? "!" : "";\n    }\n    function printFunctionTypeParameters(path, options, print) {\n      const fun = path.getValue();\n      if (fun.typeArguments) {\n        return print("typeArguments");\n      }\n      if (fun.typeParameters) {\n        return print("typeParameters");\n      }\n      return "";\n    }\n    function printTypeAnnotation(path, options, print) {\n      const node = path.getValue();\n      if (!node.typeAnnotation) {\n        return "";\n      }\n      const parentNode = path.getParentNode();\n      const isFunctionDeclarationIdentifier = parentNode.type === "DeclareFunction" && parentNode.id === node;\n      if (isFlowAnnotationComment(options.originalText, node.typeAnnotation)) {\n        return [" /*: ", print("typeAnnotation"), " */"];\n      }\n      return [isFunctionDeclarationIdentifier ? "" : ": ", print("typeAnnotation")];\n    }\n    function printBindExpressionCallee(path, options, print) {\n      return ["::", print("callee")];\n    }\n    function printTypeScriptModifiers(path, options, print) {\n      const node = path.getValue();\n      if (!isNonEmptyArray(node.modifiers)) {\n        return "";\n      }\n      return [join(" ", path.map(print, "modifiers")), " "];\n    }\n    function adjustClause(node, clause, forceSpace) {\n      if (node.type === "EmptyStatement") {\n        return ";";\n      }\n      if (node.type === "BlockStatement" || forceSpace) {\n        return [" ", clause];\n      }\n      return indent([line, clause]);\n    }\n    function printRestSpread(path, options, print) {\n      return ["...", print("argument"), printTypeAnnotation(path, options, print)];\n    }\n    function printDirective(rawText, options) {\n      const rawContent = rawText.slice(1, -1);\n      if (rawContent.includes(\'"\') || rawContent.includes("\'")) {\n        return rawText;\n      }\n      const enclosingQuote = options.singleQuote ? "\'" : \'"\';\n      return enclosingQuote + rawContent + enclosingQuote;\n    }\n    module2.exports = {\n      printOptionalToken,\n      printDefiniteToken,\n      printFunctionTypeParameters,\n      printBindExpressionCallee,\n      printTypeScriptModifiers,\n      printTypeAnnotation,\n      printRestSpread,\n      adjustClause,\n      printDirective\n    };\n  }\n});\nvar require_array4 = __commonJS2({\n  "src/language-js/print/array.js"(exports2, module2) {\n    "use strict";\n    var {\n      printDanglingComments\n    } = require_comments();\n    var {\n      builders: {\n        line,\n        softline,\n        hardline,\n        group,\n        indent,\n        ifBreak,\n        fill\n      }\n    } = require("./doc.js");\n    var {\n      getLast,\n      hasNewline\n    } = require_util();\n    var {\n      shouldPrintComma,\n      hasComment,\n      CommentCheckFlags,\n      isNextLineEmpty,\n      isNumericLiteral,\n      isSignedNumericLiteral\n    } = require_utils7();\n    var {\n      locStart\n    } = require_loc();\n    var {\n      printOptionalToken,\n      printTypeAnnotation\n    } = require_misc();\n    function printArray(path, options, print) {\n      const node = path.getValue();\n      const parts = [];\n      const openBracket = node.type === "TupleExpression" ? "#[" : "[";\n      const closeBracket = "]";\n      if (node.elements.length === 0) {\n        if (!hasComment(node, CommentCheckFlags.Dangling)) {\n          parts.push(openBracket, closeBracket);\n        } else {\n          parts.push(group([openBracket, printDanglingComments(path, options), softline, closeBracket]));\n        }\n      } else {\n        const lastElem = getLast(node.elements);\n        const canHaveTrailingComma = !(lastElem && lastElem.type === "RestElement");\n        const needsForcedTrailingComma = lastElem === null;\n        const groupId = Symbol("array");\n        const shouldBreak = !options.__inJestEach && node.elements.length > 1 && node.elements.every((element, i, elements) => {\n          const elementType = element && element.type;\n          if (elementType !== "ArrayExpression" && elementType !== "ObjectExpression") {\n            return false;\n          }\n          const nextElement = elements[i + 1];\n          if (nextElement && elementType !== nextElement.type) {\n            return false;\n          }\n          const itemsKey = elementType === "ArrayExpression" ? "elements" : "properties";\n          return element[itemsKey] && element[itemsKey].length > 1;\n        });\n        const shouldUseConciseFormatting = isConciselyPrintedArray(node, options);\n        const trailingComma = !canHaveTrailingComma ? "" : needsForcedTrailingComma ? "," : !shouldPrintComma(options) ? "" : shouldUseConciseFormatting ? ifBreak(",", "", {\n          groupId\n        }) : ifBreak(",");\n        parts.push(group([openBracket, indent([softline, shouldUseConciseFormatting ? printArrayItemsConcisely(path, options, print, trailingComma) : [printArrayItems(path, options, "elements", print), trailingComma], printDanglingComments(path, options, true)]), softline, closeBracket], {\n          shouldBreak,\n          id: groupId\n        }));\n      }\n      parts.push(printOptionalToken(path), printTypeAnnotation(path, options, print));\n      return parts;\n    }\n    function isConciselyPrintedArray(node, options) {\n      return node.elements.length > 1 && node.elements.every((element) => element && (isNumericLiteral(element) || isSignedNumericLiteral(element) && !hasComment(element.argument)) && !hasComment(element, CommentCheckFlags.Trailing | CommentCheckFlags.Line, (comment) => !hasNewline(options.originalText, locStart(comment), {\n        backwards: true\n      })));\n    }\n    function printArrayItems(path, options, printPath, print) {\n      const printedElements = [];\n      let separatorParts = [];\n      path.each((childPath) => {\n        printedElements.push(separatorParts, group(print()));\n        separatorParts = [",", line];\n        if (childPath.getValue() && isNextLineEmpty(childPath.getValue(), options)) {\n          separatorParts.push(softline);\n        }\n      }, printPath);\n      return printedElements;\n    }\n    function printArrayItemsConcisely(path, options, print, trailingComma) {\n      const parts = [];\n      path.each((childPath, i, elements) => {\n        const isLast = i === elements.length - 1;\n        parts.push([print(), isLast ? trailingComma : ","]);\n        if (!isLast) {\n          parts.push(isNextLineEmpty(childPath.getValue(), options) ? [hardline, hardline] : hasComment(elements[i + 1], CommentCheckFlags.Leading | CommentCheckFlags.Line) ? hardline : line);\n        }\n      }, "elements");\n      return fill(parts);\n    }\n    module2.exports = {\n      printArray,\n      printArrayItems,\n      isConciselyPrintedArray\n    };\n  }\n});\nvar require_call_arguments = __commonJS2({\n  "src/language-js/print/call-arguments.js"(exports2, module2) {\n    "use strict";\n    var {\n      printDanglingComments\n    } = require_comments();\n    var {\n      getLast,\n      getPenultimate\n    } = require_util();\n    var {\n      getFunctionParameters,\n      hasComment,\n      CommentCheckFlags,\n      isFunctionCompositionArgs,\n      isJsxNode,\n      isLongCurriedCallExpression,\n      shouldPrintComma,\n      getCallArguments,\n      iterateCallArgumentsPath,\n      isNextLineEmpty,\n      isCallExpression,\n      isStringLiteral,\n      isObjectProperty,\n      isTSTypeExpression\n    } = require_utils7();\n    var {\n      builders: {\n        line,\n        hardline,\n        softline,\n        group,\n        indent,\n        conditionalGroup,\n        ifBreak,\n        breakParent\n      },\n      utils: {\n        willBreak\n      }\n    } = require("./doc.js");\n    var {\n      ArgExpansionBailout\n    } = require_errors();\n    var {\n      isConciselyPrintedArray\n    } = require_array4();\n    function printCallArguments(path, options, print) {\n      const node = path.getValue();\n      const isDynamicImport = node.type === "ImportExpression";\n      const args = getCallArguments(node);\n      if (args.length === 0) {\n        return ["(", printDanglingComments(path, options, true), ")"];\n      }\n      if (isReactHookCallWithDepsArray(args)) {\n        return ["(", print(["arguments", 0]), ", ", print(["arguments", 1]), ")"];\n      }\n      let anyArgEmptyLine = false;\n      let hasEmptyLineFollowingFirstArg = false;\n      const lastArgIndex = args.length - 1;\n      const printedArguments = [];\n      iterateCallArgumentsPath(path, (argPath, index) => {\n        const arg = argPath.getNode();\n        const parts = [print()];\n        if (index === lastArgIndex) {\n        } else if (isNextLineEmpty(arg, options)) {\n          if (index === 0) {\n            hasEmptyLineFollowingFirstArg = true;\n          }\n          anyArgEmptyLine = true;\n          parts.push(",", hardline, hardline);\n        } else {\n          parts.push(",", line);\n        }\n        printedArguments.push(parts);\n      });\n      const maybeTrailingComma = !(isDynamicImport || node.callee && node.callee.type === "Import") && shouldPrintComma(options, "all") ? "," : "";\n      function allArgsBrokenOut() {\n        return group(["(", indent([line, ...printedArguments]), maybeTrailingComma, line, ")"], {\n          shouldBreak: true\n        });\n      }\n      if (anyArgEmptyLine || path.getParentNode().type !== "Decorator" && isFunctionCompositionArgs(args)) {\n        return allArgsBrokenOut();\n      }\n      const shouldGroupFirst = shouldGroupFirstArg(args);\n      const shouldGroupLast = shouldGroupLastArg(args, options);\n      if (shouldGroupFirst || shouldGroupLast) {\n        if (shouldGroupFirst ? printedArguments.slice(1).some(willBreak) : printedArguments.slice(0, -1).some(willBreak)) {\n          return allArgsBrokenOut();\n        }\n        let printedExpanded = [];\n        try {\n          path.try(() => {\n            iterateCallArgumentsPath(path, (argPath, i) => {\n              if (shouldGroupFirst && i === 0) {\n                printedExpanded = [[print([], {\n                  expandFirstArg: true\n                }), printedArguments.length > 1 ? "," : "", hasEmptyLineFollowingFirstArg ? hardline : line, hasEmptyLineFollowingFirstArg ? hardline : ""], ...printedArguments.slice(1)];\n              }\n              if (shouldGroupLast && i === lastArgIndex) {\n                printedExpanded = [...printedArguments.slice(0, -1), print([], {\n                  expandLastArg: true\n                })];\n              }\n            });\n          });\n        } catch (caught) {\n          if (caught instanceof ArgExpansionBailout) {\n            return allArgsBrokenOut();\n          }\n          throw caught;\n        }\n        return [printedArguments.some(willBreak) ? breakParent : "", conditionalGroup([["(", ...printedExpanded, ")"], shouldGroupFirst ? ["(", group(printedExpanded[0], {\n          shouldBreak: true\n        }), ...printedExpanded.slice(1), ")"] : ["(", ...printedArguments.slice(0, -1), group(getLast(printedExpanded), {\n          shouldBreak: true\n        }), ")"], allArgsBrokenOut()])];\n      }\n      const contents = ["(", indent([softline, ...printedArguments]), ifBreak(maybeTrailingComma), softline, ")"];\n      if (isLongCurriedCallExpression(path)) {\n        return contents;\n      }\n      return group(contents, {\n        shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine\n      });\n    }\n    function couldGroupArg(arg, arrowChainRecursion = false) {\n      return arg.type === "ObjectExpression" && (arg.properties.length > 0 || hasComment(arg)) || arg.type === "ArrayExpression" && (arg.elements.length > 0 || hasComment(arg)) || arg.type === "TSTypeAssertion" && couldGroupArg(arg.expression) || isTSTypeExpression(arg) && couldGroupArg(arg.expression) || arg.type === "FunctionExpression" || arg.type === "ArrowFunctionExpression" && (!arg.returnType || !arg.returnType.typeAnnotation || arg.returnType.typeAnnotation.type !== "TSTypeReference" || isNonEmptyBlockStatement(arg.body)) && (arg.body.type === "BlockStatement" || arg.body.type === "ArrowFunctionExpression" && couldGroupArg(arg.body, true) || arg.body.type === "ObjectExpression" || arg.body.type === "ArrayExpression" || !arrowChainRecursion && (isCallExpression(arg.body) || arg.body.type === "ConditionalExpression") || isJsxNode(arg.body)) || arg.type === "DoExpression" || arg.type === "ModuleExpression";\n    }\n    function shouldGroupLastArg(args, options) {\n      const lastArg = getLast(args);\n      const penultimateArg = getPenultimate(args);\n      return !hasComment(lastArg, CommentCheckFlags.Leading) && !hasComment(lastArg, CommentCheckFlags.Trailing) && couldGroupArg(lastArg) && (!penultimateArg || penultimateArg.type !== lastArg.type) && (args.length !== 2 || penultimateArg.type !== "ArrowFunctionExpression" || lastArg.type !== "ArrayExpression") && !(args.length > 1 && lastArg.type === "ArrayExpression" && isConciselyPrintedArray(lastArg, options));\n    }\n    function shouldGroupFirstArg(args) {\n      if (args.length !== 2) {\n        return false;\n      }\n      const [firstArg, secondArg] = args;\n      if (firstArg.type === "ModuleExpression" && isTypeModuleObjectExpression(secondArg)) {\n        return true;\n      }\n      return !hasComment(firstArg) && (firstArg.type === "FunctionExpression" || firstArg.type === "ArrowFunctionExpression" && firstArg.body.type === "BlockStatement") && secondArg.type !== "FunctionExpression" && secondArg.type !== "ArrowFunctionExpression" && secondArg.type !== "ConditionalExpression" && !couldGroupArg(secondArg);\n    }\n    function isReactHookCallWithDepsArray(args) {\n      return args.length === 2 && args[0].type === "ArrowFunctionExpression" && getFunctionParameters(args[0]).length === 0 && args[0].body.type === "BlockStatement" && args[1].type === "ArrayExpression" && !args.some((arg) => hasComment(arg));\n    }\n    function isNonEmptyBlockStatement(node) {\n      return node.type === "BlockStatement" && (node.body.some((node2) => node2.type !== "EmptyStatement") || hasComment(node, CommentCheckFlags.Dangling));\n    }\n    function isTypeModuleObjectExpression(node) {\n      return node.type === "ObjectExpression" && node.properties.length === 1 && isObjectProperty(node.properties[0]) && node.properties[0].key.type === "Identifier" && node.properties[0].key.name === "type" && isStringLiteral(node.properties[0].value) && node.properties[0].value.value === "module";\n    }\n    module2.exports = printCallArguments;\n  }\n});\nvar require_member = __commonJS2({\n  "src/language-js/print/member.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        softline,\n        group,\n        indent,\n        label\n      }\n    } = require("./doc.js");\n    var {\n      isNumericLiteral,\n      isMemberExpression,\n      isCallExpression\n    } = require_utils7();\n    var {\n      printOptionalToken\n    } = require_misc();\n    function printMemberExpression(path, options, print) {\n      const node = path.getValue();\n      const parent = path.getParentNode();\n      let firstNonMemberParent;\n      let i = 0;\n      do {\n        firstNonMemberParent = path.getParentNode(i);\n        i++;\n      } while (firstNonMemberParent && (isMemberExpression(firstNonMemberParent) || firstNonMemberParent.type === "TSNonNullExpression"));\n      const objectDoc = print("object");\n      const lookupDoc = printMemberLookup(path, options, print);\n      const shouldInline = firstNonMemberParent && (firstNonMemberParent.type === "NewExpression" || firstNonMemberParent.type === "BindExpression" || firstNonMemberParent.type === "AssignmentExpression" && firstNonMemberParent.left.type !== "Identifier") || node.computed || node.object.type === "Identifier" && node.property.type === "Identifier" && !isMemberExpression(parent) || (parent.type === "AssignmentExpression" || parent.type === "VariableDeclarator") && (isCallExpression(node.object) && node.object.arguments.length > 0 || node.object.type === "TSNonNullExpression" && isCallExpression(node.object.expression) && node.object.expression.arguments.length > 0 || objectDoc.label === "member-chain");\n      return label(objectDoc.label === "member-chain" ? "member-chain" : "member", [objectDoc, shouldInline ? lookupDoc : group(indent([softline, lookupDoc]))]);\n    }\n    function printMemberLookup(path, options, print) {\n      const property = print("property");\n      const node = path.getValue();\n      const optional = printOptionalToken(path);\n      if (!node.computed) {\n        return [optional, ".", property];\n      }\n      if (!node.property || isNumericLiteral(node.property)) {\n        return [optional, "[", property, "]"];\n      }\n      return group([optional, "[", indent([softline, property]), softline, "]"]);\n    }\n    module2.exports = {\n      printMemberExpression,\n      printMemberLookup\n    };\n  }\n});\nvar require_member_chain = __commonJS2({\n  "src/language-js/print/member-chain.js"(exports2, module2) {\n    "use strict";\n    var {\n      printComments\n    } = require_comments();\n    var {\n      getLast,\n      isNextLineEmptyAfterIndex,\n      getNextNonSpaceNonCommentCharacterIndex\n    } = require_util();\n    var pathNeedsParens = require_needs_parens();\n    var {\n      isCallExpression,\n      isMemberExpression,\n      isFunctionOrArrowExpression,\n      isLongCurriedCallExpression,\n      isMemberish,\n      isNumericLiteral,\n      isSimpleCallArgument,\n      hasComment,\n      CommentCheckFlags,\n      isNextLineEmpty\n    } = require_utils7();\n    var {\n      locEnd\n    } = require_loc();\n    var {\n      builders: {\n        join,\n        hardline,\n        group,\n        indent,\n        conditionalGroup,\n        breakParent,\n        label\n      },\n      utils: {\n        willBreak\n      }\n    } = require("./doc.js");\n    var printCallArguments = require_call_arguments();\n    var {\n      printMemberLookup\n    } = require_member();\n    var {\n      printOptionalToken,\n      printFunctionTypeParameters,\n      printBindExpressionCallee\n    } = require_misc();\n    function printMemberChain(path, options, print) {\n      const parent = path.getParentNode();\n      const isExpressionStatement = !parent || parent.type === "ExpressionStatement";\n      const printedNodes = [];\n      function shouldInsertEmptyLineAfter(node2) {\n        const {\n          originalText\n        } = options;\n        const nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(originalText, node2, locEnd);\n        const nextChar = originalText.charAt(nextCharIndex);\n        if (nextChar === ")") {\n          return nextCharIndex !== false && isNextLineEmptyAfterIndex(originalText, nextCharIndex + 1);\n        }\n        return isNextLineEmpty(node2, options);\n      }\n      function rec(path2) {\n        const node2 = path2.getValue();\n        if (isCallExpression(node2) && (isMemberish(node2.callee) || isCallExpression(node2.callee))) {\n          printedNodes.unshift({\n            node: node2,\n            printed: [printComments(path2, [printOptionalToken(path2), printFunctionTypeParameters(path2, options, print), printCallArguments(path2, options, print)], options), shouldInsertEmptyLineAfter(node2) ? hardline : ""]\n          });\n          path2.call((callee) => rec(callee), "callee");\n        } else if (isMemberish(node2)) {\n          printedNodes.unshift({\n            node: node2,\n            needsParens: pathNeedsParens(path2, options),\n            printed: printComments(path2, isMemberExpression(node2) ? printMemberLookup(path2, options, print) : printBindExpressionCallee(path2, options, print), options)\n          });\n          path2.call((object) => rec(object), "object");\n        } else if (node2.type === "TSNonNullExpression") {\n          printedNodes.unshift({\n            node: node2,\n            printed: printComments(path2, "!", options)\n          });\n          path2.call((expression) => rec(expression), "expression");\n        } else {\n          printedNodes.unshift({\n            node: node2,\n            printed: print()\n          });\n        }\n      }\n      const node = path.getValue();\n      printedNodes.unshift({\n        node,\n        printed: [printOptionalToken(path), printFunctionTypeParameters(path, options, print), printCallArguments(path, options, print)]\n      });\n      if (node.callee) {\n        path.call((callee) => rec(callee), "callee");\n      }\n      const groups = [];\n      let currentGroup = [printedNodes[0]];\n      let i = 1;\n      for (; i < printedNodes.length; ++i) {\n        if (printedNodes[i].node.type === "TSNonNullExpression" || isCallExpression(printedNodes[i].node) || isMemberExpression(printedNodes[i].node) && printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n          currentGroup.push(printedNodes[i]);\n        } else {\n          break;\n        }\n      }\n      if (!isCallExpression(printedNodes[0].node)) {\n        for (; i + 1 < printedNodes.length; ++i) {\n          if (isMemberish(printedNodes[i].node) && isMemberish(printedNodes[i + 1].node)) {\n            currentGroup.push(printedNodes[i]);\n          } else {\n            break;\n          }\n        }\n      }\n      groups.push(currentGroup);\n      currentGroup = [];\n      let hasSeenCallExpression = false;\n      for (; i < printedNodes.length; ++i) {\n        if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {\n          if (printedNodes[i].node.computed && isNumericLiteral(printedNodes[i].node.property)) {\n            currentGroup.push(printedNodes[i]);\n            continue;\n          }\n          groups.push(currentGroup);\n          currentGroup = [];\n          hasSeenCallExpression = false;\n        }\n        if (isCallExpression(printedNodes[i].node) || printedNodes[i].node.type === "ImportExpression") {\n          hasSeenCallExpression = true;\n        }\n        currentGroup.push(printedNodes[i]);\n        if (hasComment(printedNodes[i].node, CommentCheckFlags.Trailing)) {\n          groups.push(currentGroup);\n          currentGroup = [];\n          hasSeenCallExpression = false;\n        }\n      }\n      if (currentGroup.length > 0) {\n        groups.push(currentGroup);\n      }\n      function isFactory(name) {\n        return /^[A-Z]|^[$_]+$/.test(name);\n      }\n      function isShort(name) {\n        return name.length <= options.tabWidth;\n      }\n      function shouldNotWrap(groups2) {\n        const hasComputed = groups2[1].length > 0 && groups2[1][0].node.computed;\n        if (groups2[0].length === 1) {\n          const firstNode = groups2[0][0].node;\n          return firstNode.type === "ThisExpression" || firstNode.type === "Identifier" && (isFactory(firstNode.name) || isExpressionStatement && isShort(firstNode.name) || hasComputed);\n        }\n        const lastNode = getLast(groups2[0]).node;\n        return isMemberExpression(lastNode) && lastNode.property.type === "Identifier" && (isFactory(lastNode.property.name) || hasComputed);\n      }\n      const shouldMerge = groups.length >= 2 && !hasComment(groups[1][0].node) && shouldNotWrap(groups);\n      function printGroup(printedGroup) {\n        const printed = printedGroup.map((tuple) => tuple.printed);\n        if (printedGroup.length > 0 && getLast(printedGroup).needsParens) {\n          return ["(", ...printed, ")"];\n        }\n        return printed;\n      }\n      function printIndentedGroup(groups2) {\n        if (groups2.length === 0) {\n          return "";\n        }\n        return indent(group([hardline, join(hardline, groups2.map(printGroup))]));\n      }\n      const printedGroups = groups.map(printGroup);\n      const oneLine = printedGroups;\n      const cutoff = shouldMerge ? 3 : 2;\n      const flatGroups = groups.flat();\n      const nodeHasComment = flatGroups.slice(1, -1).some((node2) => hasComment(node2.node, CommentCheckFlags.Leading)) || flatGroups.slice(0, -1).some((node2) => hasComment(node2.node, CommentCheckFlags.Trailing)) || groups[cutoff] && hasComment(groups[cutoff][0].node, CommentCheckFlags.Leading);\n      if (groups.length <= cutoff && !nodeHasComment) {\n        if (isLongCurriedCallExpression(path)) {\n          return oneLine;\n        }\n        return group(oneLine);\n      }\n      const lastNodeBeforeIndent = getLast(groups[shouldMerge ? 1 : 0]).node;\n      const shouldHaveEmptyLineBeforeIndent = !isCallExpression(lastNodeBeforeIndent) && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);\n      const expanded = [printGroup(groups[0]), shouldMerge ? groups.slice(1, 2).map(printGroup) : "", shouldHaveEmptyLineBeforeIndent ? hardline : "", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))];\n      const callExpressions = printedNodes.map(({\n        node: node2\n      }) => node2).filter(isCallExpression);\n      function lastGroupWillBreakAndOtherCallsHaveFunctionArguments() {\n        const lastGroupNode = getLast(getLast(groups)).node;\n        const lastGroupDoc = getLast(printedGroups);\n        return isCallExpression(lastGroupNode) && willBreak(lastGroupDoc) && callExpressions.slice(0, -1).some((node2) => node2.arguments.some(isFunctionOrArrowExpression));\n      }\n      let result;\n      if (nodeHasComment || callExpressions.length > 2 && callExpressions.some((expr) => !expr.arguments.every((arg) => isSimpleCallArgument(arg, 0))) || printedGroups.slice(0, -1).some(willBreak) || lastGroupWillBreakAndOtherCallsHaveFunctionArguments()) {\n        result = group(expanded);\n      } else {\n        result = [willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : "", conditionalGroup([oneLine, expanded])];\n      }\n      return label("member-chain", result);\n    }\n    module2.exports = printMemberChain;\n  }\n});\nvar require_call_expression = __commonJS2({\n  "src/language-js/print/call-expression.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        join,\n        group\n      }\n    } = require("./doc.js");\n    var pathNeedsParens = require_needs_parens();\n    var {\n      getCallArguments,\n      hasFlowAnnotationComment,\n      isCallExpression,\n      isMemberish,\n      isStringLiteral,\n      isTemplateOnItsOwnLine,\n      isTestCall,\n      iterateCallArgumentsPath\n    } = require_utils7();\n    var printMemberChain = require_member_chain();\n    var printCallArguments = require_call_arguments();\n    var {\n      printOptionalToken,\n      printFunctionTypeParameters\n    } = require_misc();\n    function printCallExpression(path, options, print) {\n      const node = path.getValue();\n      const parentNode = path.getParentNode();\n      const isNew = node.type === "NewExpression";\n      const isDynamicImport = node.type === "ImportExpression";\n      const optional = printOptionalToken(path);\n      const args = getCallArguments(node);\n      if (args.length > 0 && (!isDynamicImport && !isNew && isCommonsJsOrAmdCall(node, parentNode) || args.length === 1 && isTemplateOnItsOwnLine(args[0], options.originalText) || !isNew && isTestCall(node, parentNode))) {\n        const printed = [];\n        iterateCallArgumentsPath(path, () => {\n          printed.push(print());\n        });\n        return [isNew ? "new " : "", print("callee"), optional, printFunctionTypeParameters(path, options, print), "(", join(", ", printed), ")"];\n      }\n      const isIdentifierWithFlowAnnotation = (options.parser === "babel" || options.parser === "babel-flow") && node.callee && node.callee.type === "Identifier" && hasFlowAnnotationComment(node.callee.trailingComments);\n      if (isIdentifierWithFlowAnnotation) {\n        node.callee.trailingComments[0].printed = true;\n      }\n      if (!isDynamicImport && !isNew && isMemberish(node.callee) && !path.call((path2) => pathNeedsParens(path2, options), "callee")) {\n        return printMemberChain(path, options, print);\n      }\n      const contents = [isNew ? "new " : "", isDynamicImport ? "import" : print("callee"), optional, isIdentifierWithFlowAnnotation ? `/*:: ${node.callee.trailingComments[0].value.slice(2).trim()} */` : "", printFunctionTypeParameters(path, options, print), printCallArguments(path, options, print)];\n      if (isDynamicImport || isCallExpression(node.callee)) {\n        return group(contents);\n      }\n      return contents;\n    }\n    function isCommonsJsOrAmdCall(node, parentNode) {\n      if (node.callee.type !== "Identifier") {\n        return false;\n      }\n      if (node.callee.name === "require") {\n        return true;\n      }\n      if (node.callee.name === "define") {\n        const args = getCallArguments(node);\n        return parentNode.type === "ExpressionStatement" && (args.length === 1 || args.length === 2 && args[0].type === "ArrayExpression" || args.length === 3 && isStringLiteral(args[0]) && args[1].type === "ArrayExpression");\n      }\n      return false;\n    }\n    module2.exports = {\n      printCallExpression\n    };\n  }\n});\nvar require_assignment = __commonJS2({\n  "src/language-js/print/assignment.js"(exports2, module2) {\n    "use strict";\n    var {\n      isNonEmptyArray,\n      getStringWidth\n    } = require_util();\n    var {\n      builders: {\n        line,\n        group,\n        indent,\n        indentIfBreak,\n        lineSuffixBoundary\n      },\n      utils: {\n        cleanDoc,\n        willBreak,\n        canBreak\n      }\n    } = require("./doc.js");\n    var {\n      hasLeadingOwnLineComment,\n      isBinaryish,\n      isStringLiteral,\n      isLiteral,\n      isNumericLiteral,\n      isCallExpression,\n      isMemberExpression,\n      getCallArguments,\n      rawText,\n      hasComment,\n      isSignedNumericLiteral,\n      isObjectProperty\n    } = require_utils7();\n    var {\n      shouldInlineLogicalExpression\n    } = require_binaryish();\n    var {\n      printCallExpression\n    } = require_call_expression();\n    function printAssignment(path, options, print, leftDoc, operator, rightPropertyName) {\n      const layout = chooseLayout(path, options, print, leftDoc, rightPropertyName);\n      const rightDoc = print(rightPropertyName, {\n        assignmentLayout: layout\n      });\n      switch (layout) {\n        case "break-after-operator":\n          return group([group(leftDoc), operator, group(indent([line, rightDoc]))]);\n        case "never-break-after-operator":\n          return group([group(leftDoc), operator, " ", rightDoc]);\n        case "fluid": {\n          const groupId = Symbol("assignment");\n          return group([group(leftDoc), operator, group(indent(line), {\n            id: groupId\n          }), lineSuffixBoundary, indentIfBreak(rightDoc, {\n            groupId\n          })]);\n        }\n        case "break-lhs":\n          return group([leftDoc, operator, " ", group(rightDoc)]);\n        case "chain":\n          return [group(leftDoc), operator, line, rightDoc];\n        case "chain-tail":\n          return [group(leftDoc), operator, indent([line, rightDoc])];\n        case "chain-tail-arrow-chain":\n          return [group(leftDoc), operator, rightDoc];\n        case "only-left":\n          return leftDoc;\n      }\n    }\n    function printAssignmentExpression(path, options, print) {\n      const node = path.getValue();\n      return printAssignment(path, options, print, print("left"), [" ", node.operator], "right");\n    }\n    function printVariableDeclarator(path, options, print) {\n      return printAssignment(path, options, print, print("id"), " =", "init");\n    }\n    function chooseLayout(path, options, print, leftDoc, rightPropertyName) {\n      const node = path.getValue();\n      const rightNode = node[rightPropertyName];\n      if (!rightNode) {\n        return "only-left";\n      }\n      const isTail = !isAssignment(rightNode);\n      const shouldUseChainFormatting = path.match(isAssignment, isAssignmentOrVariableDeclarator, (node2) => !isTail || node2.type !== "ExpressionStatement" && node2.type !== "VariableDeclaration");\n      if (shouldUseChainFormatting) {\n        return !isTail ? "chain" : rightNode.type === "ArrowFunctionExpression" && rightNode.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail";\n      }\n      const isHeadOfLongChain = !isTail && isAssignment(rightNode.right);\n      if (isHeadOfLongChain || hasLeadingOwnLineComment(options.originalText, rightNode)) {\n        return "break-after-operator";\n      }\n      if (rightNode.type === "CallExpression" && rightNode.callee.name === "require" || options.parser === "json5" || options.parser === "json") {\n        return "never-break-after-operator";\n      }\n      if (isComplexDestructuring(node) || isComplexTypeAliasParams(node) || hasComplexTypeAnnotation(node) || isArrowFunctionVariableDeclarator(node) && canBreak(leftDoc)) {\n        return "break-lhs";\n      }\n      const hasShortKey = isObjectPropertyWithShortKey(node, leftDoc, options);\n      if (path.call(() => shouldBreakAfterOperator(path, options, print, hasShortKey), rightPropertyName)) {\n        return "break-after-operator";\n      }\n      if (hasShortKey || rightNode.type === "TemplateLiteral" || rightNode.type === "TaggedTemplateExpression" || rightNode.type === "BooleanLiteral" || isNumericLiteral(rightNode) || rightNode.type === "ClassExpression") {\n        return "never-break-after-operator";\n      }\n      return "fluid";\n    }\n    function shouldBreakAfterOperator(path, options, print, hasShortKey) {\n      const rightNode = path.getValue();\n      if (isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode)) {\n        return true;\n      }\n      switch (rightNode.type) {\n        case "StringLiteralTypeAnnotation":\n        case "SequenceExpression":\n          return true;\n        case "ConditionalExpression": {\n          const {\n            test\n          } = rightNode;\n          return isBinaryish(test) && !shouldInlineLogicalExpression(test);\n        }\n        case "ClassExpression":\n          return isNonEmptyArray(rightNode.decorators);\n      }\n      if (hasShortKey) {\n        return false;\n      }\n      let node = rightNode;\n      const propertiesForPath = [];\n      for (; ; ) {\n        if (node.type === "UnaryExpression") {\n          node = node.argument;\n          propertiesForPath.push("argument");\n        } else if (node.type === "TSNonNullExpression") {\n          node = node.expression;\n          propertiesForPath.push("expression");\n        } else {\n          break;\n        }\n      }\n      if (isStringLiteral(node) || path.call(() => isPoorlyBreakableMemberOrCallChain(path, options, print), ...propertiesForPath)) {\n        return true;\n      }\n      return false;\n    }\n    function isComplexDestructuring(node) {\n      if (isAssignmentOrVariableDeclarator(node)) {\n        const leftNode = node.left || node.id;\n        return leftNode.type === "ObjectPattern" && leftNode.properties.length > 2 && leftNode.properties.some((property) => isObjectProperty(property) && (!property.shorthand || property.value && property.value.type === "AssignmentPattern"));\n      }\n      return false;\n    }\n    function isAssignment(node) {\n      return node.type === "AssignmentExpression";\n    }\n    function isAssignmentOrVariableDeclarator(node) {\n      return isAssignment(node) || node.type === "VariableDeclarator";\n    }\n    function isComplexTypeAliasParams(node) {\n      const typeParams = getTypeParametersFromTypeAlias(node);\n      if (isNonEmptyArray(typeParams)) {\n        const constraintPropertyName = node.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";\n        if (typeParams.length > 1 && typeParams.some((param) => param[constraintPropertyName] || param.default)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function getTypeParametersFromTypeAlias(node) {\n      if (isTypeAlias(node) && node.typeParameters && node.typeParameters.params) {\n        return node.typeParameters.params;\n      }\n      return null;\n    }\n    function isTypeAlias(node) {\n      return node.type === "TSTypeAliasDeclaration" || node.type === "TypeAlias";\n    }\n    function hasComplexTypeAnnotation(node) {\n      if (node.type !== "VariableDeclarator") {\n        return false;\n      }\n      const {\n        typeAnnotation\n      } = node.id;\n      if (!typeAnnotation || !typeAnnotation.typeAnnotation) {\n        return false;\n      }\n      const typeParams = getTypeParametersFromTypeReference(typeAnnotation.typeAnnotation);\n      return isNonEmptyArray(typeParams) && typeParams.length > 1 && typeParams.some((param) => isNonEmptyArray(getTypeParametersFromTypeReference(param)) || param.type === "TSConditionalType");\n    }\n    function isArrowFunctionVariableDeclarator(node) {\n      return node.type === "VariableDeclarator" && node.init && node.init.type === "ArrowFunctionExpression";\n    }\n    function getTypeParametersFromTypeReference(node) {\n      if (isTypeReference(node) && node.typeParameters && node.typeParameters.params) {\n        return node.typeParameters.params;\n      }\n      return null;\n    }\n    function isTypeReference(node) {\n      return node.type === "TSTypeReference" || node.type === "GenericTypeAnnotation";\n    }\n    function isPoorlyBreakableMemberOrCallChain(path, options, print, deep = false) {\n      const node = path.getValue();\n      const goDeeper = () => isPoorlyBreakableMemberOrCallChain(path, options, print, true);\n      if (node.type === "TSNonNullExpression") {\n        return path.call(goDeeper, "expression");\n      }\n      if (isCallExpression(node)) {\n        const doc2 = printCallExpression(path, options, print);\n        if (doc2.label === "member-chain") {\n          return false;\n        }\n        const args = getCallArguments(node);\n        const isPoorlyBreakableCall = args.length === 0 || args.length === 1 && isLoneShortArgument(args[0], options);\n        if (!isPoorlyBreakableCall) {\n          return false;\n        }\n        if (isCallExpressionWithComplexTypeArguments(node, print)) {\n          return false;\n        }\n        return path.call(goDeeper, "callee");\n      }\n      if (isMemberExpression(node)) {\n        return path.call(goDeeper, "object");\n      }\n      return deep && (node.type === "Identifier" || node.type === "ThisExpression");\n    }\n    var LONE_SHORT_ARGUMENT_THRESHOLD_RATE = 0.25;\n    function isLoneShortArgument(node, {\n      printWidth\n    }) {\n      if (hasComment(node)) {\n        return false;\n      }\n      const threshold = printWidth * LONE_SHORT_ARGUMENT_THRESHOLD_RATE;\n      if (node.type === "ThisExpression" || node.type === "Identifier" && node.name.length <= threshold || isSignedNumericLiteral(node) && !hasComment(node.argument)) {\n        return true;\n      }\n      const regexpPattern = node.type === "Literal" && "regex" in node && node.regex.pattern || node.type === "RegExpLiteral" && node.pattern;\n      if (regexpPattern) {\n        return regexpPattern.length <= threshold;\n      }\n      if (isStringLiteral(node)) {\n        return rawText(node).length <= threshold;\n      }\n      if (node.type === "TemplateLiteral") {\n        return node.expressions.length === 0 && node.quasis[0].value.raw.length <= threshold && !node.quasis[0].value.raw.includes("\\n");\n      }\n      return isLiteral(node);\n    }\n    function isObjectPropertyWithShortKey(node, keyDoc, options) {\n      if (!isObjectProperty(node)) {\n        return false;\n      }\n      keyDoc = cleanDoc(keyDoc);\n      const MIN_OVERLAP_FOR_BREAK = 3;\n      return typeof keyDoc === "string" && getStringWidth(keyDoc) < options.tabWidth + MIN_OVERLAP_FOR_BREAK;\n    }\n    function isCallExpressionWithComplexTypeArguments(node, print) {\n      const typeArgs = getTypeArgumentsFromCallExpression(node);\n      if (isNonEmptyArray(typeArgs)) {\n        if (typeArgs.length > 1) {\n          return true;\n        }\n        if (typeArgs.length === 1) {\n          const firstArg = typeArgs[0];\n          if (firstArg.type === "TSUnionType" || firstArg.type === "UnionTypeAnnotation" || firstArg.type === "TSIntersectionType" || firstArg.type === "IntersectionTypeAnnotation" || firstArg.type === "TSTypeLiteral" || firstArg.type === "ObjectTypeAnnotation") {\n            return true;\n          }\n        }\n        const typeArgsKeyName = node.typeParameters ? "typeParameters" : "typeArguments";\n        if (willBreak(print(typeArgsKeyName))) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function getTypeArgumentsFromCallExpression(node) {\n      return node.typeParameters && node.typeParameters.params || node.typeArguments && node.typeArguments.params;\n    }\n    module2.exports = {\n      printVariableDeclarator,\n      printAssignmentExpression,\n      printAssignment,\n      isArrowFunctionVariableDeclarator\n    };\n  }\n});\nvar require_function_parameters = __commonJS2({\n  "src/language-js/print/function-parameters.js"(exports2, module2) {\n    "use strict";\n    var {\n      getNextNonSpaceNonCommentCharacter\n    } = require_util();\n    var {\n      printDanglingComments\n    } = require_comments();\n    var {\n      builders: {\n        line,\n        hardline,\n        softline,\n        group,\n        indent,\n        ifBreak\n      },\n      utils: {\n        removeLines,\n        willBreak\n      }\n    } = require("./doc.js");\n    var {\n      getFunctionParameters,\n      iterateFunctionParametersPath,\n      isSimpleType,\n      isTestCall,\n      isTypeAnnotationAFunction,\n      isObjectType,\n      isObjectTypePropertyAFunction,\n      hasRestParameter,\n      shouldPrintComma,\n      hasComment,\n      isNextLineEmpty\n    } = require_utils7();\n    var {\n      locEnd\n    } = require_loc();\n    var {\n      ArgExpansionBailout\n    } = require_errors();\n    var {\n      printFunctionTypeParameters\n    } = require_misc();\n    function printFunctionParameters(path, print, options, expandArg, printTypeParams) {\n      const functionNode = path.getValue();\n      const parameters = getFunctionParameters(functionNode);\n      const typeParams = printTypeParams ? printFunctionTypeParameters(path, options, print) : "";\n      if (parameters.length === 0) {\n        return [typeParams, "(", printDanglingComments(path, options, true, (comment) => getNextNonSpaceNonCommentCharacter(options.originalText, comment, locEnd) === ")"), ")"];\n      }\n      const parent = path.getParentNode();\n      const isParametersInTestCall = isTestCall(parent);\n      const shouldHugParameters = shouldHugFunctionParameters(functionNode);\n      const printed = [];\n      iterateFunctionParametersPath(path, (parameterPath, index) => {\n        const isLastParameter = index === parameters.length - 1;\n        if (isLastParameter && functionNode.rest) {\n          printed.push("...");\n        }\n        printed.push(print());\n        if (isLastParameter) {\n          return;\n        }\n        printed.push(",");\n        if (isParametersInTestCall || shouldHugParameters) {\n          printed.push(" ");\n        } else if (isNextLineEmpty(parameters[index], options)) {\n          printed.push(hardline, hardline);\n        } else {\n          printed.push(line);\n        }\n      });\n      if (expandArg) {\n        if (willBreak(typeParams) || willBreak(printed)) {\n          throw new ArgExpansionBailout();\n        }\n        return group([removeLines(typeParams), "(", removeLines(printed), ")"]);\n      }\n      const hasNotParameterDecorator = parameters.every((node) => !node.decorators);\n      if (shouldHugParameters && hasNotParameterDecorator) {\n        return [typeParams, "(", ...printed, ")"];\n      }\n      if (isParametersInTestCall) {\n        return [typeParams, "(", ...printed, ")"];\n      }\n      const isFlowShorthandWithOneArg = (isObjectTypePropertyAFunction(parent) || isTypeAnnotationAFunction(parent) || parent.type === "TypeAlias" || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType" || parent.type === "IntersectionTypeAnnotation" || parent.type === "FunctionTypeAnnotation" && parent.returnType === functionNode) && parameters.length === 1 && parameters[0].name === null && functionNode.this !== parameters[0] && parameters[0].typeAnnotation && functionNode.typeParameters === null && isSimpleType(parameters[0].typeAnnotation) && !functionNode.rest;\n      if (isFlowShorthandWithOneArg) {\n        if (options.arrowParens === "always") {\n          return ["(", ...printed, ")"];\n        }\n        return printed;\n      }\n      return [typeParams, "(", indent([softline, ...printed]), ifBreak(!hasRestParameter(functionNode) && shouldPrintComma(options, "all") ? "," : ""), softline, ")"];\n    }\n    function shouldHugFunctionParameters(node) {\n      if (!node) {\n        return false;\n      }\n      const parameters = getFunctionParameters(node);\n      if (parameters.length !== 1) {\n        return false;\n      }\n      const [parameter] = parameters;\n      return !hasComment(parameter) && (parameter.type === "ObjectPattern" || parameter.type === "ArrayPattern" || parameter.type === "Identifier" && parameter.typeAnnotation && (parameter.typeAnnotation.type === "TypeAnnotation" || parameter.typeAnnotation.type === "TSTypeAnnotation") && isObjectType(parameter.typeAnnotation.typeAnnotation) || parameter.type === "FunctionTypeParam" && isObjectType(parameter.typeAnnotation) || parameter.type === "AssignmentPattern" && (parameter.left.type === "ObjectPattern" || parameter.left.type === "ArrayPattern") && (parameter.right.type === "Identifier" || parameter.right.type === "ObjectExpression" && parameter.right.properties.length === 0 || parameter.right.type === "ArrayExpression" && parameter.right.elements.length === 0));\n    }\n    function getReturnTypeNode(functionNode) {\n      let returnTypeNode;\n      if (functionNode.returnType) {\n        returnTypeNode = functionNode.returnType;\n        if (returnTypeNode.typeAnnotation) {\n          returnTypeNode = returnTypeNode.typeAnnotation;\n        }\n      } else if (functionNode.typeAnnotation) {\n        returnTypeNode = functionNode.typeAnnotation;\n      }\n      return returnTypeNode;\n    }\n    function shouldGroupFunctionParameters(functionNode, returnTypeDoc) {\n      const returnTypeNode = getReturnTypeNode(functionNode);\n      if (!returnTypeNode) {\n        return false;\n      }\n      const typeParameters = functionNode.typeParameters && functionNode.typeParameters.params;\n      if (typeParameters) {\n        if (typeParameters.length > 1) {\n          return false;\n        }\n        if (typeParameters.length === 1) {\n          const typeParameter = typeParameters[0];\n          if (typeParameter.constraint || typeParameter.default) {\n            return false;\n          }\n        }\n      }\n      return getFunctionParameters(functionNode).length === 1 && (isObjectType(returnTypeNode) || willBreak(returnTypeDoc));\n    }\n    module2.exports = {\n      printFunctionParameters,\n      shouldHugFunctionParameters,\n      shouldGroupFunctionParameters\n    };\n  }\n});\nvar require_type_annotation = __commonJS2({\n  "src/language-js/print/type-annotation.js"(exports2, module2) {\n    "use strict";\n    var {\n      printComments,\n      printDanglingComments\n    } = require_comments();\n    var {\n      isNonEmptyArray\n    } = require_util();\n    var {\n      builders: {\n        group,\n        join,\n        line,\n        softline,\n        indent,\n        align,\n        ifBreak\n      }\n    } = require("./doc.js");\n    var pathNeedsParens = require_needs_parens();\n    var {\n      locStart\n    } = require_loc();\n    var {\n      isSimpleType,\n      isObjectType,\n      hasLeadingOwnLineComment,\n      isObjectTypePropertyAFunction,\n      shouldPrintComma\n    } = require_utils7();\n    var {\n      printAssignment\n    } = require_assignment();\n    var {\n      printFunctionParameters,\n      shouldGroupFunctionParameters\n    } = require_function_parameters();\n    var {\n      printArrayItems\n    } = require_array4();\n    function shouldHugType(node) {\n      if (isSimpleType(node) || isObjectType(node)) {\n        return true;\n      }\n      if (node.type === "UnionTypeAnnotation" || node.type === "TSUnionType") {\n        const voidCount = node.types.filter((node2) => node2.type === "VoidTypeAnnotation" || node2.type === "TSVoidKeyword" || node2.type === "NullLiteralTypeAnnotation" || node2.type === "TSNullKeyword").length;\n        const hasObject = node.types.some((node2) => node2.type === "ObjectTypeAnnotation" || node2.type === "TSTypeLiteral" || node2.type === "GenericTypeAnnotation" || node2.type === "TSTypeReference");\n        if (node.types.length - 1 === voidCount && hasObject) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function printOpaqueType(path, options, print) {\n      const semi = options.semi ? ";" : "";\n      const node = path.getValue();\n      const parts = [];\n      parts.push("opaque type ", print("id"), print("typeParameters"));\n      if (node.supertype) {\n        parts.push(": ", print("supertype"));\n      }\n      if (node.impltype) {\n        parts.push(" = ", print("impltype"));\n      }\n      parts.push(semi);\n      return parts;\n    }\n    function printTypeAlias(path, options, print) {\n      const semi = options.semi ? ";" : "";\n      const node = path.getValue();\n      const parts = [];\n      if (node.declare) {\n        parts.push("declare ");\n      }\n      parts.push("type ", print("id"), print("typeParameters"));\n      const rightPropertyName = node.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";\n      return [printAssignment(path, options, print, parts, " =", rightPropertyName), semi];\n    }\n    function printIntersectionType(path, options, print) {\n      const node = path.getValue();\n      const types = path.map(print, "types");\n      const result = [];\n      let wasIndented = false;\n      for (let i = 0; i < types.length; ++i) {\n        if (i === 0) {\n          result.push(types[i]);\n        } else if (isObjectType(node.types[i - 1]) && isObjectType(node.types[i])) {\n          result.push([" & ", wasIndented ? indent(types[i]) : types[i]]);\n        } else if (!isObjectType(node.types[i - 1]) && !isObjectType(node.types[i])) {\n          result.push(indent([" &", line, types[i]]));\n        } else {\n          if (i > 1) {\n            wasIndented = true;\n          }\n          result.push(" & ", i > 1 ? indent(types[i]) : types[i]);\n        }\n      }\n      return group(result);\n    }\n    function printUnionType(path, options, print) {\n      const node = path.getValue();\n      const parent = path.getParentNode();\n      const shouldIndent = parent.type !== "TypeParameterInstantiation" && parent.type !== "TSTypeParameterInstantiation" && parent.type !== "GenericTypeAnnotation" && parent.type !== "TSTypeReference" && parent.type !== "TSTypeAssertion" && parent.type !== "TupleTypeAnnotation" && parent.type !== "TSTupleType" && !(parent.type === "FunctionTypeParam" && !parent.name && path.getParentNode(1).this !== parent) && !((parent.type === "TypeAlias" || parent.type === "VariableDeclarator" || parent.type === "TSTypeAliasDeclaration") && hasLeadingOwnLineComment(options.originalText, node));\n      const shouldHug = shouldHugType(node);\n      const printed = path.map((typePath) => {\n        let printedType = print();\n        if (!shouldHug) {\n          printedType = align(2, printedType);\n        }\n        return printComments(typePath, printedType, options);\n      }, "types");\n      if (shouldHug) {\n        return join(" | ", printed);\n      }\n      const shouldAddStartLine = shouldIndent && !hasLeadingOwnLineComment(options.originalText, node);\n      const code = [ifBreak([shouldAddStartLine ? line : "", "| "]), join([line, "| "], printed)];\n      if (pathNeedsParens(path, options)) {\n        return group([indent(code), softline]);\n      }\n      if (parent.type === "TupleTypeAnnotation" && parent.types.length > 1 || parent.type === "TSTupleType" && parent.elementTypes.length > 1) {\n        return group([indent([ifBreak(["(", softline]), code]), softline, ifBreak(")")]);\n      }\n      return group(shouldIndent ? indent(code) : code);\n    }\n    function printFunctionType(path, options, print) {\n      const node = path.getValue();\n      const parts = [];\n      const parent = path.getParentNode(0);\n      const parentParent = path.getParentNode(1);\n      const parentParentParent = path.getParentNode(2);\n      let isArrowFunctionTypeAnnotation = node.type === "TSFunctionType" || !((parent.type === "ObjectTypeProperty" || parent.type === "ObjectTypeInternalSlot") && !parent.variance && !parent.optional && locStart(parent) === locStart(node) || parent.type === "ObjectTypeCallProperty" || parentParentParent && parentParentParent.type === "DeclareFunction");\n      let needsColon = isArrowFunctionTypeAnnotation && (parent.type === "TypeAnnotation" || parent.type === "TSTypeAnnotation");\n      const needsParens = needsColon && isArrowFunctionTypeAnnotation && (parent.type === "TypeAnnotation" || parent.type === "TSTypeAnnotation") && parentParent.type === "ArrowFunctionExpression";\n      if (isObjectTypePropertyAFunction(parent)) {\n        isArrowFunctionTypeAnnotation = true;\n        needsColon = true;\n      }\n      if (needsParens) {\n        parts.push("(");\n      }\n      const parametersDoc = printFunctionParameters(path, print, options, false, true);\n      const returnTypeDoc = node.returnType || node.predicate || node.typeAnnotation ? [isArrowFunctionTypeAnnotation ? " => " : ": ", print("returnType"), print("predicate"), print("typeAnnotation")] : "";\n      const shouldGroupParameters = shouldGroupFunctionParameters(node, returnTypeDoc);\n      parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);\n      if (returnTypeDoc) {\n        parts.push(returnTypeDoc);\n      }\n      if (needsParens) {\n        parts.push(")");\n      }\n      return group(parts);\n    }\n    function printTupleType(path, options, print) {\n      const node = path.getValue();\n      const typesField = node.type === "TSTupleType" ? "elementTypes" : "types";\n      const types = node[typesField];\n      const isNonEmptyTuple = isNonEmptyArray(types);\n      const bracketsDelimiterLine = isNonEmptyTuple ? softline : "";\n      return group(["[", indent([bracketsDelimiterLine, printArrayItems(path, options, typesField, print)]), ifBreak(isNonEmptyTuple && shouldPrintComma(options, "all") ? "," : ""), printDanglingComments(path, options, true), bracketsDelimiterLine, "]"]);\n    }\n    function printIndexedAccessType(path, options, print) {\n      const node = path.getValue();\n      const leftDelimiter = node.type === "OptionalIndexedAccessType" && node.optional ? "?.[" : "[";\n      return [print("objectType"), leftDelimiter, print("indexType"), "]"];\n    }\n    function printJSDocType(path, print, token) {\n      const node = path.getValue();\n      return [node.postfix ? "" : token, print("typeAnnotation"), node.postfix ? token : ""];\n    }\n    module2.exports = {\n      printOpaqueType,\n      printTypeAlias,\n      printIntersectionType,\n      printUnionType,\n      printFunctionType,\n      printTupleType,\n      printIndexedAccessType,\n      shouldHugType,\n      printJSDocType\n    };\n  }\n});\nvar require_type_parameters = __commonJS2({\n  "src/language-js/print/type-parameters.js"(exports2, module2) {\n    "use strict";\n    var {\n      printDanglingComments\n    } = require_comments();\n    var {\n      builders: {\n        join,\n        line,\n        hardline,\n        softline,\n        group,\n        indent,\n        ifBreak\n      }\n    } = require("./doc.js");\n    var {\n      isTestCall,\n      hasComment,\n      CommentCheckFlags,\n      isTSXFile,\n      shouldPrintComma,\n      getFunctionParameters,\n      isObjectType,\n      getTypeScriptMappedTypeModifier\n    } = require_utils7();\n    var {\n      createGroupIdMapper\n    } = require_util();\n    var {\n      shouldHugType\n    } = require_type_annotation();\n    var {\n      isArrowFunctionVariableDeclarator\n    } = require_assignment();\n    var getTypeParametersGroupId = createGroupIdMapper("typeParameters");\n    function printTypeParameters(path, options, print, paramsKey) {\n      const node = path.getValue();\n      if (!node[paramsKey]) {\n        return "";\n      }\n      if (!Array.isArray(node[paramsKey])) {\n        return print(paramsKey);\n      }\n      const grandparent = path.getNode(2);\n      const isParameterInTestCall = grandparent && isTestCall(grandparent);\n      const isArrowFunctionVariable = path.match((node2) => !(node2[paramsKey].length === 1 && isObjectType(node2[paramsKey][0])), void 0, (node2, name) => name === "typeAnnotation", (node2) => node2.type === "Identifier", isArrowFunctionVariableDeclarator);\n      const shouldInline = node[paramsKey].length === 0 || !isArrowFunctionVariable && (isParameterInTestCall || node[paramsKey].length === 1 && (node[paramsKey][0].type === "NullableTypeAnnotation" || shouldHugType(node[paramsKey][0])));\n      if (shouldInline) {\n        return ["<", join(", ", path.map(print, paramsKey)), printDanglingCommentsForInline(path, options), ">"];\n      }\n      const trailingComma = node.type === "TSTypeParameterInstantiation" ? "" : getFunctionParameters(node).length === 1 && isTSXFile(options) && !node[paramsKey][0].constraint && path.getParentNode().type === "ArrowFunctionExpression" ? "," : shouldPrintComma(options, "all") ? ifBreak(",") : "";\n      return group(["<", indent([softline, join([",", line], path.map(print, paramsKey))]), trailingComma, softline, ">"], {\n        id: getTypeParametersGroupId(node)\n      });\n    }\n    function printDanglingCommentsForInline(path, options) {\n      const node = path.getValue();\n      if (!hasComment(node, CommentCheckFlags.Dangling)) {\n        return "";\n      }\n      const hasOnlyBlockComments = !hasComment(node, CommentCheckFlags.Line);\n      const printed = printDanglingComments(path, options, hasOnlyBlockComments);\n      if (hasOnlyBlockComments) {\n        return printed;\n      }\n      return [printed, hardline];\n    }\n    function printTypeParameter(path, options, print) {\n      const node = path.getValue();\n      const parts = [node.type === "TSTypeParameter" && node.const ? "const " : ""];\n      const parent = path.getParentNode();\n      if (parent.type === "TSMappedType") {\n        if (parent.readonly) {\n          parts.push(getTypeScriptMappedTypeModifier(parent.readonly, "readonly"), " ");\n        }\n        parts.push("[", print("name"));\n        if (node.constraint) {\n          parts.push(" in ", print("constraint"));\n        }\n        if (parent.nameType) {\n          parts.push(" as ", path.callParent(() => print("nameType")));\n        }\n        parts.push("]");\n        return parts;\n      }\n      if (node.variance) {\n        parts.push(print("variance"));\n      }\n      if (node.in) {\n        parts.push("in ");\n      }\n      if (node.out) {\n        parts.push("out ");\n      }\n      parts.push(print("name"));\n      if (node.bound) {\n        parts.push(": ", print("bound"));\n      }\n      if (node.constraint) {\n        parts.push(" extends ", print("constraint"));\n      }\n      if (node.default) {\n        parts.push(" = ", print("default"));\n      }\n      return parts;\n    }\n    module2.exports = {\n      printTypeParameter,\n      printTypeParameters,\n      getTypeParametersGroupId\n    };\n  }\n});\nvar require_property = __commonJS2({\n  "src/language-js/print/property.js"(exports2, module2) {\n    "use strict";\n    var {\n      printComments\n    } = require_comments();\n    var {\n      printString,\n      printNumber\n    } = require_util();\n    var {\n      isNumericLiteral,\n      isSimpleNumber,\n      isStringLiteral,\n      isStringPropSafeToUnquote,\n      rawText\n    } = require_utils7();\n    var {\n      printAssignment\n    } = require_assignment();\n    var needsQuoteProps = /* @__PURE__ */ new WeakMap();\n    function printPropertyKey(path, options, print) {\n      const node = path.getNode();\n      if (node.computed) {\n        return ["[", print("key"), "]"];\n      }\n      const parent = path.getParentNode();\n      const {\n        key\n      } = node;\n      if (options.quoteProps === "consistent" && !needsQuoteProps.has(parent)) {\n        const objectHasStringProp = (parent.properties || parent.body || parent.members).some((prop) => !prop.computed && prop.key && isStringLiteral(prop.key) && !isStringPropSafeToUnquote(prop, options));\n        needsQuoteProps.set(parent, objectHasStringProp);\n      }\n      if ((key.type === "Identifier" || isNumericLiteral(key) && isSimpleNumber(printNumber(rawText(key))) && String(key.value) === printNumber(rawText(key)) && !(options.parser === "typescript" || options.parser === "babel-ts")) && (options.parser === "json" || options.quoteProps === "consistent" && needsQuoteProps.get(parent))) {\n        const prop = printString(JSON.stringify(key.type === "Identifier" ? key.name : key.value.toString()), options);\n        return path.call((keyPath) => printComments(keyPath, prop, options), "key");\n      }\n      if (isStringPropSafeToUnquote(node, options) && (options.quoteProps === "as-needed" || options.quoteProps === "consistent" && !needsQuoteProps.get(parent))) {\n        return path.call((keyPath) => printComments(keyPath, /^\\d/.test(key.value) ? printNumber(key.value) : key.value, options), "key");\n      }\n      return print("key");\n    }\n    function printProperty(path, options, print) {\n      const node = path.getValue();\n      if (node.shorthand) {\n        return print("value");\n      }\n      return printAssignment(path, options, print, printPropertyKey(path, options, print), ":", "value");\n    }\n    module2.exports = {\n      printProperty,\n      printPropertyKey\n    };\n  }\n});\nvar require_function = __commonJS2({\n  "src/language-js/print/function.js"(exports2, module2) {\n    "use strict";\n    var assert = require("assert");\n    var {\n      printDanglingComments,\n      printCommentsSeparately\n    } = require_comments();\n    var getLast = require_get_last();\n    var {\n      getNextNonSpaceNonCommentCharacterIndex\n    } = require_util();\n    var {\n      builders: {\n        line,\n        softline,\n        group,\n        indent,\n        ifBreak,\n        hardline,\n        join,\n        indentIfBreak\n      },\n      utils: {\n        removeLines,\n        willBreak\n      }\n    } = require("./doc.js");\n    var {\n      ArgExpansionBailout\n    } = require_errors();\n    var {\n      getFunctionParameters,\n      hasLeadingOwnLineComment,\n      isFlowAnnotationComment,\n      isJsxNode,\n      isTemplateOnItsOwnLine,\n      shouldPrintComma,\n      startsWithNoLookaheadToken,\n      isBinaryish,\n      isLineComment,\n      hasComment,\n      getComments,\n      CommentCheckFlags,\n      isCallLikeExpression,\n      isCallExpression,\n      getCallArguments,\n      hasNakedLeftSide,\n      getLeftSide\n    } = require_utils7();\n    var {\n      locEnd\n    } = require_loc();\n    var {\n      printFunctionParameters,\n      shouldGroupFunctionParameters\n    } = require_function_parameters();\n    var {\n      printPropertyKey\n    } = require_property();\n    var {\n      printFunctionTypeParameters\n    } = require_misc();\n    function printFunction(path, print, options, args) {\n      const node = path.getValue();\n      let expandArg = false;\n      if ((node.type === "FunctionDeclaration" || node.type === "FunctionExpression") && args && args.expandLastArg) {\n        const parent = path.getParentNode();\n        if (isCallExpression(parent) && getCallArguments(parent).length > 1) {\n          expandArg = true;\n        }\n      }\n      const parts = [];\n      if (node.type === "TSDeclareFunction" && node.declare) {\n        parts.push("declare ");\n      }\n      if (node.async) {\n        parts.push("async ");\n      }\n      if (node.generator) {\n        parts.push("function* ");\n      } else {\n        parts.push("function ");\n      }\n      if (node.id) {\n        parts.push(print("id"));\n      }\n      const parametersDoc = printFunctionParameters(path, print, options, expandArg);\n      const returnTypeDoc = printReturnType(path, print, options);\n      const shouldGroupParameters = shouldGroupFunctionParameters(node, returnTypeDoc);\n      parts.push(printFunctionTypeParameters(path, options, print), group([shouldGroupParameters ? group(parametersDoc) : parametersDoc, returnTypeDoc]), node.body ? " " : "", print("body"));\n      if (options.semi && (node.declare || !node.body)) {\n        parts.push(";");\n      }\n      return parts;\n    }\n    function printMethod(path, options, print) {\n      const node = path.getNode();\n      const {\n        kind\n      } = node;\n      const value = node.value || node;\n      const parts = [];\n      if (!kind || kind === "init" || kind === "method" || kind === "constructor") {\n        if (value.async) {\n          parts.push("async ");\n        }\n      } else {\n        assert.ok(kind === "get" || kind === "set");\n        parts.push(kind, " ");\n      }\n      if (value.generator) {\n        parts.push("*");\n      }\n      parts.push(printPropertyKey(path, options, print), node.optional || node.key.optional ? "?" : "");\n      if (node === value) {\n        parts.push(printMethodInternal(path, options, print));\n      } else if (value.type === "FunctionExpression") {\n        parts.push(path.call((path2) => printMethodInternal(path2, options, print), "value"));\n      } else {\n        parts.push(print("value"));\n      }\n      return parts;\n    }\n    function printMethodInternal(path, options, print) {\n      const node = path.getNode();\n      const parametersDoc = printFunctionParameters(path, print, options);\n      const returnTypeDoc = printReturnType(path, print, options);\n      const shouldGroupParameters = shouldGroupFunctionParameters(node, returnTypeDoc);\n      const parts = [printFunctionTypeParameters(path, options, print), group([shouldGroupParameters ? group(parametersDoc) : parametersDoc, returnTypeDoc])];\n      if (node.body) {\n        parts.push(" ", print("body"));\n      } else {\n        parts.push(options.semi ? ";" : "");\n      }\n      return parts;\n    }\n    function printArrowFunctionSignature(path, options, print, args) {\n      const node = path.getValue();\n      const parts = [];\n      if (node.async) {\n        parts.push("async ");\n      }\n      if (shouldPrintParamsWithoutParens(path, options)) {\n        parts.push(print(["params", 0]));\n      } else {\n        const expandArg = args && (args.expandLastArg || args.expandFirstArg);\n        let returnTypeDoc = printReturnType(path, print, options);\n        if (expandArg) {\n          if (willBreak(returnTypeDoc)) {\n            throw new ArgExpansionBailout();\n          }\n          returnTypeDoc = group(removeLines(returnTypeDoc));\n        }\n        parts.push(group([printFunctionParameters(path, print, options, expandArg, true), returnTypeDoc]));\n      }\n      const dangling = printDanglingComments(path, options, true, (comment) => {\n        const nextCharacter = getNextNonSpaceNonCommentCharacterIndex(options.originalText, comment, locEnd);\n        return nextCharacter !== false && options.originalText.slice(nextCharacter, nextCharacter + 2) === "=>";\n      });\n      if (dangling) {\n        parts.push(" ", dangling);\n      }\n      return parts;\n    }\n    function printArrowChain(path, args, signatures, shouldBreak, bodyDoc, tailNode) {\n      const name = path.getName();\n      const parent = path.getParentNode();\n      const isCallee = isCallLikeExpression(parent) && name === "callee";\n      const isAssignmentRhs = Boolean(args && args.assignmentLayout);\n      const shouldPutBodyOnSeparateLine = tailNode.body.type !== "BlockStatement" && tailNode.body.type !== "ObjectExpression" && tailNode.body.type !== "SequenceExpression";\n      const shouldBreakBeforeChain = isCallee && shouldPutBodyOnSeparateLine || args && args.assignmentLayout === "chain-tail-arrow-chain";\n      const groupId = Symbol("arrow-chain");\n      if (tailNode.body.type === "SequenceExpression") {\n        bodyDoc = group(["(", indent([softline, bodyDoc]), softline, ")"]);\n      }\n      return group([group(indent([isCallee || isAssignmentRhs ? softline : "", group(join([" =>", line], signatures), {\n        shouldBreak\n      })]), {\n        id: groupId,\n        shouldBreak: shouldBreakBeforeChain\n      }), " =>", indentIfBreak(shouldPutBodyOnSeparateLine ? indent([line, bodyDoc]) : [" ", bodyDoc], {\n        groupId\n      }), isCallee ? ifBreak(softline, "", {\n        groupId\n      }) : ""]);\n    }\n    function printArrowFunction(path, options, print, args) {\n      let node = path.getValue();\n      const signatures = [];\n      const body = [];\n      let chainShouldBreak = false;\n      (function rec() {\n        const doc2 = printArrowFunctionSignature(path, options, print, args);\n        if (signatures.length === 0) {\n          signatures.push(doc2);\n        } else {\n          const {\n            leading,\n            trailing\n          } = printCommentsSeparately(path, options);\n          signatures.push([leading, doc2]);\n          body.unshift(trailing);\n        }\n        chainShouldBreak = chainShouldBreak || node.returnType && getFunctionParameters(node).length > 0 || node.typeParameters || getFunctionParameters(node).some((param) => param.type !== "Identifier");\n        if (node.body.type !== "ArrowFunctionExpression" || args && args.expandLastArg) {\n          body.unshift(print("body", args));\n        } else {\n          node = node.body;\n          path.call(rec, "body");\n        }\n      })();\n      if (signatures.length > 1) {\n        return printArrowChain(path, args, signatures, chainShouldBreak, body, node);\n      }\n      const parts = signatures;\n      parts.push(" =>");\n      if (!hasLeadingOwnLineComment(options.originalText, node.body) && (node.body.type === "ArrayExpression" || node.body.type === "ObjectExpression" || node.body.type === "BlockStatement" || isJsxNode(node.body) || isTemplateOnItsOwnLine(node.body, options.originalText) || node.body.type === "ArrowFunctionExpression" || node.body.type === "DoExpression")) {\n        return group([...parts, " ", body]);\n      }\n      if (node.body.type === "SequenceExpression") {\n        return group([...parts, group([" (", indent([softline, body]), softline, ")"])]);\n      }\n      const shouldAddSoftLine = (args && args.expandLastArg || path.getParentNode().type === "JSXExpressionContainer") && !hasComment(node);\n      const printTrailingComma = args && args.expandLastArg && shouldPrintComma(options, "all");\n      const shouldAddParens = node.body.type === "ConditionalExpression" && !startsWithNoLookaheadToken(node.body, (node2) => node2.type === "ObjectExpression");\n      return group([...parts, group([indent([line, shouldAddParens ? ifBreak("", "(") : "", body, shouldAddParens ? ifBreak("", ")") : ""]), shouldAddSoftLine ? [ifBreak(printTrailingComma ? "," : ""), softline] : ""])]);\n    }\n    function canPrintParamsWithoutParens(node) {\n      const parameters = getFunctionParameters(node);\n      return parameters.length === 1 && !node.typeParameters && !hasComment(node, CommentCheckFlags.Dangling) && parameters[0].type === "Identifier" && !parameters[0].typeAnnotation && !hasComment(parameters[0]) && !parameters[0].optional && !node.predicate && !node.returnType;\n    }\n    function shouldPrintParamsWithoutParens(path, options) {\n      if (options.arrowParens === "always") {\n        return false;\n      }\n      if (options.arrowParens === "avoid") {\n        const node = path.getValue();\n        return canPrintParamsWithoutParens(node);\n      }\n      return false;\n    }\n    function printReturnType(path, print, options) {\n      const node = path.getValue();\n      const returnType = print("returnType");\n      if (node.returnType && isFlowAnnotationComment(options.originalText, node.returnType)) {\n        return [" /*: ", returnType, " */"];\n      }\n      const parts = [returnType];\n      if (node.returnType && node.returnType.typeAnnotation) {\n        parts.unshift(": ");\n      }\n      if (node.predicate) {\n        parts.push(node.returnType ? " " : ": ", print("predicate"));\n      }\n      return parts;\n    }\n    function printReturnOrThrowArgument(path, options, print) {\n      const node = path.getValue();\n      const semi = options.semi ? ";" : "";\n      const parts = [];\n      if (node.argument) {\n        if (returnArgumentHasLeadingComment(options, node.argument)) {\n          parts.push([" (", indent([hardline, print("argument")]), hardline, ")"]);\n        } else if (isBinaryish(node.argument) || node.argument.type === "SequenceExpression") {\n          parts.push(group([ifBreak(" (", " "), indent([softline, print("argument")]), softline, ifBreak(")")]));\n        } else {\n          parts.push(" ", print("argument"));\n        }\n      }\n      const comments = getComments(node);\n      const lastComment = getLast(comments);\n      const isLastCommentLine = lastComment && isLineComment(lastComment);\n      if (isLastCommentLine) {\n        parts.push(semi);\n      }\n      if (hasComment(node, CommentCheckFlags.Dangling)) {\n        parts.push(" ", printDanglingComments(path, options, true));\n      }\n      if (!isLastCommentLine) {\n        parts.push(semi);\n      }\n      return parts;\n    }\n    function printReturnStatement(path, options, print) {\n      return ["return", printReturnOrThrowArgument(path, options, print)];\n    }\n    function printThrowStatement(path, options, print) {\n      return ["throw", printReturnOrThrowArgument(path, options, print)];\n    }\n    function returnArgumentHasLeadingComment(options, argument) {\n      if (hasLeadingOwnLineComment(options.originalText, argument)) {\n        return true;\n      }\n      if (hasNakedLeftSide(argument)) {\n        let leftMost = argument;\n        let newLeftMost;\n        while (newLeftMost = getLeftSide(leftMost)) {\n          leftMost = newLeftMost;\n          if (hasLeadingOwnLineComment(options.originalText, leftMost)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n    module2.exports = {\n      printFunction,\n      printArrowFunction,\n      printMethod,\n      printReturnStatement,\n      printThrowStatement,\n      printMethodInternal,\n      shouldPrintParamsWithoutParens\n    };\n  }\n});\nvar require_decorators = __commonJS2({\n  "src/language-js/print/decorators.js"(exports2, module2) {\n    "use strict";\n    var {\n      isNonEmptyArray,\n      hasNewline\n    } = require_util();\n    var {\n      builders: {\n        line,\n        hardline,\n        join,\n        breakParent,\n        group\n      }\n    } = require("./doc.js");\n    var {\n      locStart,\n      locEnd\n    } = require_loc();\n    var {\n      getParentExportDeclaration\n    } = require_utils7();\n    function printClassMemberDecorators(path, options, print) {\n      const node = path.getValue();\n      return group([join(line, path.map(print, "decorators")), hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line]);\n    }\n    function printDecoratorsBeforeExport(path, options, print) {\n      return [join(hardline, path.map(print, "declaration", "decorators")), hardline];\n    }\n    function printDecorators(path, options, print) {\n      const node = path.getValue();\n      const {\n        decorators\n      } = node;\n      if (!isNonEmptyArray(decorators) || hasDecoratorsBeforeExport(path.getParentNode())) {\n        return;\n      }\n      const shouldBreak = node.type === "ClassExpression" || node.type === "ClassDeclaration" || hasNewlineBetweenOrAfterDecorators(node, options);\n      return [getParentExportDeclaration(path) ? hardline : shouldBreak ? breakParent : "", join(line, path.map(print, "decorators")), line];\n    }\n    function hasNewlineBetweenOrAfterDecorators(node, options) {\n      return node.decorators.some((decorator) => hasNewline(options.originalText, locEnd(decorator)));\n    }\n    function hasDecoratorsBeforeExport(node) {\n      if (node.type !== "ExportDefaultDeclaration" && node.type !== "ExportNamedDeclaration" && node.type !== "DeclareExportDeclaration") {\n        return false;\n      }\n      const decorators = node.declaration && node.declaration.decorators;\n      return isNonEmptyArray(decorators) && locStart(node) === locStart(decorators[0]);\n    }\n    module2.exports = {\n      printDecorators,\n      printClassMemberDecorators,\n      printDecoratorsBeforeExport,\n      hasDecoratorsBeforeExport\n    };\n  }\n});\nvar require_class = __commonJS2({\n  "src/language-js/print/class.js"(exports2, module2) {\n    "use strict";\n    var {\n      isNonEmptyArray,\n      createGroupIdMapper\n    } = require_util();\n    var {\n      printComments,\n      printDanglingComments\n    } = require_comments();\n    var {\n      builders: {\n        join,\n        line,\n        hardline,\n        softline,\n        group,\n        indent,\n        ifBreak\n      }\n    } = require("./doc.js");\n    var {\n      hasComment,\n      CommentCheckFlags\n    } = require_utils7();\n    var {\n      getTypeParametersGroupId\n    } = require_type_parameters();\n    var {\n      printMethod\n    } = require_function();\n    var {\n      printOptionalToken,\n      printTypeAnnotation,\n      printDefiniteToken\n    } = require_misc();\n    var {\n      printPropertyKey\n    } = require_property();\n    var {\n      printAssignment\n    } = require_assignment();\n    var {\n      printClassMemberDecorators\n    } = require_decorators();\n    function printClass(path, options, print) {\n      const node = path.getValue();\n      const parts = [];\n      if (node.declare) {\n        parts.push("declare ");\n      }\n      if (node.abstract) {\n        parts.push("abstract ");\n      }\n      parts.push("class");\n      const groupMode = node.id && hasComment(node.id, CommentCheckFlags.Trailing) || node.typeParameters && hasComment(node.typeParameters, CommentCheckFlags.Trailing) || node.superClass && hasComment(node.superClass) || isNonEmptyArray(node.extends) || isNonEmptyArray(node.mixins) || isNonEmptyArray(node.implements);\n      const partsGroup = [];\n      const extendsParts = [];\n      if (node.id) {\n        partsGroup.push(" ", print("id"));\n      }\n      partsGroup.push(print("typeParameters"));\n      if (node.superClass) {\n        const printed = [printSuperClass(path, options, print), print("superTypeParameters")];\n        const printedWithComments = path.call((superClass) => ["extends ", printComments(superClass, printed, options)], "superClass");\n        if (groupMode) {\n          extendsParts.push(line, group(printedWithComments));\n        } else {\n          extendsParts.push(" ", printedWithComments);\n        }\n      } else {\n        extendsParts.push(printList(path, options, print, "extends"));\n      }\n      extendsParts.push(printList(path, options, print, "mixins"), printList(path, options, print, "implements"));\n      if (groupMode) {\n        let printedPartsGroup;\n        if (shouldIndentOnlyHeritageClauses(node)) {\n          printedPartsGroup = [...partsGroup, indent(extendsParts)];\n        } else {\n          printedPartsGroup = indent([...partsGroup, extendsParts]);\n        }\n        parts.push(group(printedPartsGroup, {\n          id: getHeritageGroupId(node)\n        }));\n      } else {\n        parts.push(...partsGroup, ...extendsParts);\n      }\n      parts.push(" ", print("body"));\n      return parts;\n    }\n    var getHeritageGroupId = createGroupIdMapper("heritageGroup");\n    function printHardlineAfterHeritage(node) {\n      return ifBreak(hardline, "", {\n        groupId: getHeritageGroupId(node)\n      });\n    }\n    function hasMultipleHeritage(node) {\n      return ["superClass", "extends", "mixins", "implements"].filter((key) => Boolean(node[key])).length > 1;\n    }\n    function shouldIndentOnlyHeritageClauses(node) {\n      return node.typeParameters && !hasComment(node.typeParameters, CommentCheckFlags.Trailing | CommentCheckFlags.Line) && !hasMultipleHeritage(node);\n    }\n    function printList(path, options, print, listName) {\n      const node = path.getValue();\n      if (!isNonEmptyArray(node[listName])) {\n        return "";\n      }\n      const printedLeadingComments = printDanglingComments(path, options, true, ({\n        marker\n      }) => marker === listName);\n      return [shouldIndentOnlyHeritageClauses(node) ? ifBreak(" ", line, {\n        groupId: getTypeParametersGroupId(node.typeParameters)\n      }) : line, printedLeadingComments, printedLeadingComments && hardline, listName, group(indent([line, join([",", line], path.map(print, listName))]))];\n    }\n    function printSuperClass(path, options, print) {\n      const printed = print("superClass");\n      const parent = path.getParentNode();\n      if (parent.type === "AssignmentExpression") {\n        return group(ifBreak(["(", indent([softline, printed]), softline, ")"], printed));\n      }\n      return printed;\n    }\n    function printClassMethod(path, options, print) {\n      const node = path.getValue();\n      const parts = [];\n      if (isNonEmptyArray(node.decorators)) {\n        parts.push(printClassMemberDecorators(path, options, print));\n      }\n      if (node.accessibility) {\n        parts.push(node.accessibility + " ");\n      }\n      if (node.readonly) {\n        parts.push("readonly ");\n      }\n      if (node.declare) {\n        parts.push("declare ");\n      }\n      if (node.static) {\n        parts.push("static ");\n      }\n      if (node.type === "TSAbstractMethodDefinition" || node.abstract) {\n        parts.push("abstract ");\n      }\n      if (node.override) {\n        parts.push("override ");\n      }\n      parts.push(printMethod(path, options, print));\n      return parts;\n    }\n    function printClassProperty(path, options, print) {\n      const node = path.getValue();\n      const parts = [];\n      const semi = options.semi ? ";" : "";\n      if (isNonEmptyArray(node.decorators)) {\n        parts.push(printClassMemberDecorators(path, options, print));\n      }\n      if (node.accessibility) {\n        parts.push(node.accessibility + " ");\n      }\n      if (node.declare) {\n        parts.push("declare ");\n      }\n      if (node.static) {\n        parts.push("static ");\n      }\n      if (node.type === "TSAbstractPropertyDefinition" || node.type === "TSAbstractAccessorProperty" || node.abstract) {\n        parts.push("abstract ");\n      }\n      if (node.override) {\n        parts.push("override ");\n      }\n      if (node.readonly) {\n        parts.push("readonly ");\n      }\n      if (node.variance) {\n        parts.push(print("variance"));\n      }\n      if (node.type === "ClassAccessorProperty" || node.type === "AccessorProperty" || node.type === "TSAbstractAccessorProperty") {\n        parts.push("accessor ");\n      }\n      parts.push(printPropertyKey(path, options, print), printOptionalToken(path), printDefiniteToken(path), printTypeAnnotation(path, options, print));\n      return [printAssignment(path, options, print, parts, " =", "value"), semi];\n    }\n    module2.exports = {\n      printClass,\n      printClassMethod,\n      printClassProperty,\n      printHardlineAfterHeritage\n    };\n  }\n});\nvar require_interface = __commonJS2({\n  "src/language-js/print/interface.js"(exports2, module2) {\n    "use strict";\n    var {\n      isNonEmptyArray\n    } = require_util();\n    var {\n      builders: {\n        join,\n        line,\n        group,\n        indent,\n        ifBreak\n      }\n    } = require("./doc.js");\n    var {\n      hasComment,\n      identity,\n      CommentCheckFlags\n    } = require_utils7();\n    var {\n      getTypeParametersGroupId\n    } = require_type_parameters();\n    var {\n      printTypeScriptModifiers\n    } = require_misc();\n    function printInterface(path, options, print) {\n      const node = path.getValue();\n      const parts = [];\n      if (node.declare) {\n        parts.push("declare ");\n      }\n      if (node.type === "TSInterfaceDeclaration") {\n        parts.push(node.abstract ? "abstract " : "", printTypeScriptModifiers(path, options, print));\n      }\n      parts.push("interface");\n      const partsGroup = [];\n      const extendsParts = [];\n      if (node.type !== "InterfaceTypeAnnotation") {\n        partsGroup.push(" ", print("id"), print("typeParameters"));\n      }\n      const shouldIndentOnlyHeritageClauses = node.typeParameters && !hasComment(node.typeParameters, CommentCheckFlags.Trailing | CommentCheckFlags.Line);\n      if (isNonEmptyArray(node.extends)) {\n        extendsParts.push(shouldIndentOnlyHeritageClauses ? ifBreak(" ", line, {\n          groupId: getTypeParametersGroupId(node.typeParameters)\n        }) : line, "extends ", (node.extends.length === 1 ? identity : indent)(join([",", line], path.map(print, "extends"))));\n      }\n      if (node.id && hasComment(node.id, CommentCheckFlags.Trailing) || isNonEmptyArray(node.extends)) {\n        if (shouldIndentOnlyHeritageClauses) {\n          parts.push(group([...partsGroup, indent(extendsParts)]));\n        } else {\n          parts.push(group(indent([...partsGroup, ...extendsParts])));\n        }\n      } else {\n        parts.push(...partsGroup, ...extendsParts);\n      }\n      parts.push(" ", print("body"));\n      return group(parts);\n    }\n    module2.exports = {\n      printInterface\n    };\n  }\n});\nvar require_module = __commonJS2({\n  "src/language-js/print/module.js"(exports2, module2) {\n    "use strict";\n    var {\n      isNonEmptyArray\n    } = require_util();\n    var {\n      builders: {\n        softline,\n        group,\n        indent,\n        join,\n        line,\n        ifBreak,\n        hardline\n      }\n    } = require("./doc.js");\n    var {\n      printDanglingComments\n    } = require_comments();\n    var {\n      hasComment,\n      CommentCheckFlags,\n      shouldPrintComma,\n      needsHardlineAfterDanglingComment,\n      isStringLiteral,\n      rawText\n    } = require_utils7();\n    var {\n      locStart,\n      hasSameLoc\n    } = require_loc();\n    var {\n      hasDecoratorsBeforeExport,\n      printDecoratorsBeforeExport\n    } = require_decorators();\n    function printImportDeclaration(path, options, print) {\n      const node = path.getValue();\n      const semi = options.semi ? ";" : "";\n      const parts = [];\n      const {\n        importKind\n      } = node;\n      parts.push("import");\n      if (importKind && importKind !== "value") {\n        parts.push(" ", importKind);\n      }\n      parts.push(printModuleSpecifiers(path, options, print), printModuleSource(path, options, print), printImportAssertions(path, options, print), semi);\n      return parts;\n    }\n    function printExportDeclaration(path, options, print) {\n      const node = path.getValue();\n      const parts = [];\n      if (hasDecoratorsBeforeExport(node)) {\n        parts.push(printDecoratorsBeforeExport(path, options, print));\n      }\n      const {\n        type,\n        exportKind,\n        declaration\n      } = node;\n      parts.push("export");\n      const isDefaultExport = node.default || type === "ExportDefaultDeclaration";\n      if (isDefaultExport) {\n        parts.push(" default");\n      }\n      if (hasComment(node, CommentCheckFlags.Dangling)) {\n        parts.push(" ", printDanglingComments(path, options, true));\n        if (needsHardlineAfterDanglingComment(node)) {\n          parts.push(hardline);\n        }\n      }\n      if (declaration) {\n        parts.push(" ", print("declaration"));\n      } else {\n        parts.push(exportKind === "type" ? " type" : "", printModuleSpecifiers(path, options, print), printModuleSource(path, options, print), printImportAssertions(path, options, print));\n      }\n      if (shouldExportDeclarationPrintSemi(node, options)) {\n        parts.push(";");\n      }\n      return parts;\n    }\n    function printExportAllDeclaration(path, options, print) {\n      const node = path.getValue();\n      const semi = options.semi ? ";" : "";\n      const parts = [];\n      const {\n        exportKind,\n        exported\n      } = node;\n      parts.push("export");\n      if (exportKind === "type") {\n        parts.push(" type");\n      }\n      parts.push(" *");\n      if (exported) {\n        parts.push(" as ", print("exported"));\n      }\n      parts.push(printModuleSource(path, options, print), printImportAssertions(path, options, print), semi);\n      return parts;\n    }\n    function shouldExportDeclarationPrintSemi(node, options) {\n      if (!options.semi) {\n        return false;\n      }\n      const {\n        type,\n        declaration\n      } = node;\n      const isDefaultExport = node.default || type === "ExportDefaultDeclaration";\n      if (!declaration) {\n        return true;\n      }\n      const {\n        type: declarationType\n      } = declaration;\n      if (isDefaultExport && declarationType !== "ClassDeclaration" && declarationType !== "FunctionDeclaration" && declarationType !== "TSInterfaceDeclaration" && declarationType !== "DeclareClass" && declarationType !== "DeclareFunction" && declarationType !== "TSDeclareFunction" && declarationType !== "EnumDeclaration") {\n        return true;\n      }\n      return false;\n    }\n    function printModuleSource(path, options, print) {\n      const node = path.getValue();\n      if (!node.source) {\n        return "";\n      }\n      const parts = [];\n      if (!shouldNotPrintSpecifiers(node, options)) {\n        parts.push(" from");\n      }\n      parts.push(" ", print("source"));\n      return parts;\n    }\n    function printModuleSpecifiers(path, options, print) {\n      const node = path.getValue();\n      if (shouldNotPrintSpecifiers(node, options)) {\n        return "";\n      }\n      const parts = [" "];\n      if (isNonEmptyArray(node.specifiers)) {\n        const standaloneSpecifiers = [];\n        const groupedSpecifiers = [];\n        path.each(() => {\n          const specifierType = path.getValue().type;\n          if (specifierType === "ExportNamespaceSpecifier" || specifierType === "ExportDefaultSpecifier" || specifierType === "ImportNamespaceSpecifier" || specifierType === "ImportDefaultSpecifier") {\n            standaloneSpecifiers.push(print());\n          } else if (specifierType === "ExportSpecifier" || specifierType === "ImportSpecifier") {\n            groupedSpecifiers.push(print());\n          } else {\n            throw new Error(`Unknown specifier type ${JSON.stringify(specifierType)}`);\n          }\n        }, "specifiers");\n        parts.push(join(", ", standaloneSpecifiers));\n        if (groupedSpecifiers.length > 0) {\n          if (standaloneSpecifiers.length > 0) {\n            parts.push(", ");\n          }\n          const canBreak = groupedSpecifiers.length > 1 || standaloneSpecifiers.length > 0 || node.specifiers.some((node2) => hasComment(node2));\n          if (canBreak) {\n            parts.push(group(["{", indent([options.bracketSpacing ? line : softline, join([",", line], groupedSpecifiers)]), ifBreak(shouldPrintComma(options) ? "," : ""), options.bracketSpacing ? line : softline, "}"]));\n          } else {\n            parts.push(["{", options.bracketSpacing ? " " : "", ...groupedSpecifiers, options.bracketSpacing ? " " : "", "}"]);\n          }\n        }\n      } else {\n        parts.push("{}");\n      }\n      return parts;\n    }\n    function shouldNotPrintSpecifiers(node, options) {\n      const {\n        type,\n        importKind,\n        source,\n        specifiers\n      } = node;\n      if (type !== "ImportDeclaration" || isNonEmptyArray(specifiers) || importKind === "type") {\n        return false;\n      }\n      return !/{\\s*}/.test(options.originalText.slice(locStart(node), locStart(source)));\n    }\n    function printImportAssertions(path, options, print) {\n      const node = path.getNode();\n      if (isNonEmptyArray(node.assertions)) {\n        return [" assert {", options.bracketSpacing ? " " : "", join(", ", path.map(print, "assertions")), options.bracketSpacing ? " " : "", "}"];\n      }\n      return "";\n    }\n    function printModuleSpecifier(path, options, print) {\n      const node = path.getNode();\n      const {\n        type\n      } = node;\n      const parts = [];\n      const kind = type === "ImportSpecifier" ? node.importKind : node.exportKind;\n      if (kind && kind !== "value") {\n        parts.push(kind, " ");\n      }\n      const isImport = type.startsWith("Import");\n      const leftSideProperty = isImport ? "imported" : "local";\n      const rightSideProperty = isImport ? "local" : "exported";\n      const leftSideNode = node[leftSideProperty];\n      const rightSideNode = node[rightSideProperty];\n      let left = "";\n      let right = "";\n      if (type === "ExportNamespaceSpecifier" || type === "ImportNamespaceSpecifier") {\n        left = "*";\n      } else if (leftSideNode) {\n        left = print(leftSideProperty);\n      }\n      if (rightSideNode && !isShorthandSpecifier(node)) {\n        right = print(rightSideProperty);\n      }\n      parts.push(left, left && right ? " as " : "", right);\n      return parts;\n    }\n    function isShorthandSpecifier(specifier) {\n      if (specifier.type !== "ImportSpecifier" && specifier.type !== "ExportSpecifier") {\n        return false;\n      }\n      const {\n        local,\n        [specifier.type === "ImportSpecifier" ? "imported" : "exported"]: importedOrExported\n      } = specifier;\n      if (local.type !== importedOrExported.type || !hasSameLoc(local, importedOrExported)) {\n        return false;\n      }\n      if (isStringLiteral(local)) {\n        return local.value === importedOrExported.value && rawText(local) === rawText(importedOrExported);\n      }\n      switch (local.type) {\n        case "Identifier":\n          return local.name === importedOrExported.name;\n        default:\n          return false;\n      }\n    }\n    module2.exports = {\n      printImportDeclaration,\n      printExportDeclaration,\n      printExportAllDeclaration,\n      printModuleSpecifier\n    };\n  }\n});\nvar require_object = __commonJS2({\n  "src/language-js/print/object.js"(exports2, module2) {\n    "use strict";\n    var {\n      printDanglingComments\n    } = require_comments();\n    var {\n      builders: {\n        line,\n        softline,\n        group,\n        indent,\n        ifBreak,\n        hardline\n      }\n    } = require("./doc.js");\n    var {\n      getLast,\n      hasNewlineInRange,\n      hasNewline,\n      isNonEmptyArray\n    } = require_util();\n    var {\n      shouldPrintComma,\n      hasComment,\n      getComments,\n      CommentCheckFlags,\n      isNextLineEmpty\n    } = require_utils7();\n    var {\n      locStart,\n      locEnd\n    } = require_loc();\n    var {\n      printOptionalToken,\n      printTypeAnnotation\n    } = require_misc();\n    var {\n      shouldHugFunctionParameters\n    } = require_function_parameters();\n    var {\n      shouldHugType\n    } = require_type_annotation();\n    var {\n      printHardlineAfterHeritage\n    } = require_class();\n    function printObject(path, options, print) {\n      const semi = options.semi ? ";" : "";\n      const node = path.getValue();\n      let propertiesField;\n      if (node.type === "TSTypeLiteral") {\n        propertiesField = "members";\n      } else if (node.type === "TSInterfaceBody") {\n        propertiesField = "body";\n      } else {\n        propertiesField = "properties";\n      }\n      const isTypeAnnotation = node.type === "ObjectTypeAnnotation";\n      const fields = [propertiesField];\n      if (isTypeAnnotation) {\n        fields.push("indexers", "callProperties", "internalSlots");\n      }\n      const firstProperty = fields.map((field) => node[field][0]).sort((a, b) => locStart(a) - locStart(b))[0];\n      const parent = path.getParentNode(0);\n      const isFlowInterfaceLikeBody = isTypeAnnotation && parent && (parent.type === "InterfaceDeclaration" || parent.type === "DeclareInterface" || parent.type === "DeclareClass") && path.getName() === "body";\n      const shouldBreak = node.type === "TSInterfaceBody" || isFlowInterfaceLikeBody || node.type === "ObjectPattern" && parent.type !== "FunctionDeclaration" && parent.type !== "FunctionExpression" && parent.type !== "ArrowFunctionExpression" && parent.type !== "ObjectMethod" && parent.type !== "ClassMethod" && parent.type !== "ClassPrivateMethod" && parent.type !== "AssignmentPattern" && parent.type !== "CatchClause" && node.properties.some((property) => property.value && (property.value.type === "ObjectPattern" || property.value.type === "ArrayPattern")) || node.type !== "ObjectPattern" && firstProperty && hasNewlineInRange(options.originalText, locStart(node), locStart(firstProperty));\n      const separator = isFlowInterfaceLikeBody ? ";" : node.type === "TSInterfaceBody" || node.type === "TSTypeLiteral" ? ifBreak(semi, ";") : ",";\n      const leftBrace = node.type === "RecordExpression" ? "#{" : node.exact ? "{|" : "{";\n      const rightBrace = node.exact ? "|}" : "}";\n      const propsAndLoc = [];\n      for (const field of fields) {\n        path.each((childPath) => {\n          const node2 = childPath.getValue();\n          propsAndLoc.push({\n            node: node2,\n            printed: print(),\n            loc: locStart(node2)\n          });\n        }, field);\n      }\n      if (fields.length > 1) {\n        propsAndLoc.sort((a, b) => a.loc - b.loc);\n      }\n      let separatorParts = [];\n      const props = propsAndLoc.map((prop) => {\n        const result = [...separatorParts, group(prop.printed)];\n        separatorParts = [separator, line];\n        if ((prop.node.type === "TSPropertySignature" || prop.node.type === "TSMethodSignature" || prop.node.type === "TSConstructSignatureDeclaration") && hasComment(prop.node, CommentCheckFlags.PrettierIgnore)) {\n          separatorParts.shift();\n        }\n        if (isNextLineEmpty(prop.node, options)) {\n          separatorParts.push(hardline);\n        }\n        return result;\n      });\n      if (node.inexact) {\n        let printed;\n        if (hasComment(node, CommentCheckFlags.Dangling)) {\n          const hasLineComments = hasComment(node, CommentCheckFlags.Line);\n          const printedDanglingComments = printDanglingComments(path, options, true);\n          printed = [printedDanglingComments, hasLineComments || hasNewline(options.originalText, locEnd(getLast(getComments(node)))) ? hardline : line, "..."];\n        } else {\n          printed = ["..."];\n        }\n        props.push([...separatorParts, ...printed]);\n      }\n      const lastElem = getLast(node[propertiesField]);\n      const canHaveTrailingSeparator = !(node.inexact || lastElem && lastElem.type === "RestElement" || lastElem && (lastElem.type === "TSPropertySignature" || lastElem.type === "TSCallSignatureDeclaration" || lastElem.type === "TSMethodSignature" || lastElem.type === "TSConstructSignatureDeclaration") && hasComment(lastElem, CommentCheckFlags.PrettierIgnore));\n      let content;\n      if (props.length === 0) {\n        if (!hasComment(node, CommentCheckFlags.Dangling)) {\n          return [leftBrace, rightBrace, printTypeAnnotation(path, options, print)];\n        }\n        content = group([leftBrace, printDanglingComments(path, options), softline, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)]);\n      } else {\n        content = [isFlowInterfaceLikeBody && isNonEmptyArray(node.properties) ? printHardlineAfterHeritage(parent) : "", leftBrace, indent([options.bracketSpacing ? line : softline, ...props]), ifBreak(canHaveTrailingSeparator && (separator !== "," || shouldPrintComma(options)) ? separator : ""), options.bracketSpacing ? line : softline, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)];\n      }\n      if (path.match((node2) => node2.type === "ObjectPattern" && !node2.decorators, (node2, name, number) => shouldHugFunctionParameters(node2) && (name === "params" || name === "parameters" || name === "this" || name === "rest") && number === 0) || path.match(shouldHugType, (node2, name) => name === "typeAnnotation", (node2, name) => name === "typeAnnotation", (node2, name, number) => shouldHugFunctionParameters(node2) && (name === "params" || name === "parameters" || name === "this" || name === "rest") && number === 0) || !shouldBreak && path.match((node2) => node2.type === "ObjectPattern", (node2) => node2.type === "AssignmentExpression" || node2.type === "VariableDeclarator")) {\n        return content;\n      }\n      return group(content, {\n        shouldBreak\n      });\n    }\n    module2.exports = {\n      printObject\n    };\n  }\n});\nvar require_flow = __commonJS2({\n  "src/language-js/print/flow.js"(exports2, module2) {\n    "use strict";\n    var assert = require("assert");\n    var {\n      printDanglingComments\n    } = require_comments();\n    var {\n      printString,\n      printNumber\n    } = require_util();\n    var {\n      builders: {\n        hardline,\n        softline,\n        group,\n        indent\n      }\n    } = require("./doc.js");\n    var {\n      getParentExportDeclaration,\n      isFunctionNotation,\n      isGetterOrSetter,\n      rawText,\n      shouldPrintComma\n    } = require_utils7();\n    var {\n      locStart,\n      locEnd\n    } = require_loc();\n    var {\n      replaceTextEndOfLine\n    } = require_doc_utils();\n    var {\n      printClass\n    } = require_class();\n    var {\n      printOpaqueType,\n      printTypeAlias,\n      printIntersectionType,\n      printUnionType,\n      printFunctionType,\n      printTupleType,\n      printIndexedAccessType\n    } = require_type_annotation();\n    var {\n      printInterface\n    } = require_interface();\n    var {\n      printTypeParameter,\n      printTypeParameters\n    } = require_type_parameters();\n    var {\n      printExportDeclaration,\n      printExportAllDeclaration\n    } = require_module();\n    var {\n      printArrayItems\n    } = require_array4();\n    var {\n      printObject\n    } = require_object();\n    var {\n      printPropertyKey\n    } = require_property();\n    var {\n      printOptionalToken,\n      printTypeAnnotation,\n      printRestSpread\n    } = require_misc();\n    function printFlow(path, options, print) {\n      const node = path.getValue();\n      const semi = options.semi ? ";" : "";\n      const parts = [];\n      switch (node.type) {\n        case "DeclareClass":\n          return printFlowDeclaration(path, printClass(path, options, print));\n        case "DeclareFunction":\n          return printFlowDeclaration(path, ["function ", print("id"), node.predicate ? " " : "", print("predicate"), semi]);\n        case "DeclareModule":\n          return printFlowDeclaration(path, ["module ", print("id"), " ", print("body")]);\n        case "DeclareModuleExports":\n          return printFlowDeclaration(path, ["module.exports", ": ", print("typeAnnotation"), semi]);\n        case "DeclareVariable":\n          return printFlowDeclaration(path, ["var ", print("id"), semi]);\n        case "DeclareOpaqueType":\n          return printFlowDeclaration(path, printOpaqueType(path, options, print));\n        case "DeclareInterface":\n          return printFlowDeclaration(path, printInterface(path, options, print));\n        case "DeclareTypeAlias":\n          return printFlowDeclaration(path, printTypeAlias(path, options, print));\n        case "DeclareExportDeclaration":\n          return printFlowDeclaration(path, printExportDeclaration(path, options, print));\n        case "DeclareExportAllDeclaration":\n          return printFlowDeclaration(path, printExportAllDeclaration(path, options, print));\n        case "OpaqueType":\n          return printOpaqueType(path, options, print);\n        case "TypeAlias":\n          return printTypeAlias(path, options, print);\n        case "IntersectionTypeAnnotation":\n          return printIntersectionType(path, options, print);\n        case "UnionTypeAnnotation":\n          return printUnionType(path, options, print);\n        case "FunctionTypeAnnotation":\n          return printFunctionType(path, options, print);\n        case "TupleTypeAnnotation":\n          return printTupleType(path, options, print);\n        case "GenericTypeAnnotation":\n          return [print("id"), printTypeParameters(path, options, print, "typeParameters")];\n        case "IndexedAccessType":\n        case "OptionalIndexedAccessType":\n          return printIndexedAccessType(path, options, print);\n        case "TypeAnnotation":\n          return print("typeAnnotation");\n        case "TypeParameter":\n          return printTypeParameter(path, options, print);\n        case "TypeofTypeAnnotation":\n          return ["typeof ", print("argument")];\n        case "ExistsTypeAnnotation":\n          return "*";\n        case "EmptyTypeAnnotation":\n          return "empty";\n        case "MixedTypeAnnotation":\n          return "mixed";\n        case "ArrayTypeAnnotation":\n          return [print("elementType"), "[]"];\n        case "BooleanLiteralTypeAnnotation":\n          return String(node.value);\n        case "EnumDeclaration":\n          return ["enum ", print("id"), " ", print("body")];\n        case "EnumBooleanBody":\n        case "EnumNumberBody":\n        case "EnumStringBody":\n        case "EnumSymbolBody": {\n          if (node.type === "EnumSymbolBody" || node.explicitType) {\n            let type = null;\n            switch (node.type) {\n              case "EnumBooleanBody":\n                type = "boolean";\n                break;\n              case "EnumNumberBody":\n                type = "number";\n                break;\n              case "EnumStringBody":\n                type = "string";\n                break;\n              case "EnumSymbolBody":\n                type = "symbol";\n                break;\n            }\n            parts.push("of ", type, " ");\n          }\n          if (node.members.length === 0 && !node.hasUnknownMembers) {\n            parts.push(group(["{", printDanglingComments(path, options), softline, "}"]));\n          } else {\n            const members = node.members.length > 0 ? [hardline, printArrayItems(path, options, "members", print), node.hasUnknownMembers || shouldPrintComma(options) ? "," : ""] : [];\n            parts.push(group(["{", indent([...members, ...node.hasUnknownMembers ? [hardline, "..."] : []]), printDanglingComments(path, options, true), hardline, "}"]));\n          }\n          return parts;\n        }\n        case "EnumBooleanMember":\n        case "EnumNumberMember":\n        case "EnumStringMember":\n          return [print("id"), " = ", typeof node.init === "object" ? print("init") : String(node.init)];\n        case "EnumDefaultedMember":\n          return print("id");\n        case "FunctionTypeParam": {\n          const name = node.name ? print("name") : path.getParentNode().this === node ? "this" : "";\n          return [name, printOptionalToken(path), name ? ": " : "", print("typeAnnotation")];\n        }\n        case "InterfaceDeclaration":\n        case "InterfaceTypeAnnotation":\n          return printInterface(path, options, print);\n        case "ClassImplements":\n        case "InterfaceExtends":\n          return [print("id"), print("typeParameters")];\n        case "NullableTypeAnnotation":\n          return ["?", print("typeAnnotation")];\n        case "Variance": {\n          const {\n            kind\n          } = node;\n          assert.ok(kind === "plus" || kind === "minus");\n          return kind === "plus" ? "+" : "-";\n        }\n        case "ObjectTypeCallProperty":\n          if (node.static) {\n            parts.push("static ");\n          }\n          parts.push(print("value"));\n          return parts;\n        case "ObjectTypeIndexer": {\n          return [node.static ? "static " : "", node.variance ? print("variance") : "", "[", print("id"), node.id ? ": " : "", print("key"), "]: ", print("value")];\n        }\n        case "ObjectTypeProperty": {\n          let modifier = "";\n          if (node.proto) {\n            modifier = "proto ";\n          } else if (node.static) {\n            modifier = "static ";\n          }\n          return [modifier, isGetterOrSetter(node) ? node.kind + " " : "", node.variance ? print("variance") : "", printPropertyKey(path, options, print), printOptionalToken(path), isFunctionNotation(node) ? "" : ": ", print("value")];\n        }\n        case "ObjectTypeAnnotation":\n          return printObject(path, options, print);\n        case "ObjectTypeInternalSlot":\n          return [node.static ? "static " : "", "[[", print("id"), "]]", printOptionalToken(path), node.method ? "" : ": ", print("value")];\n        case "ObjectTypeSpreadProperty":\n          return printRestSpread(path, options, print);\n        case "QualifiedTypeofIdentifier":\n        case "QualifiedTypeIdentifier":\n          return [print("qualification"), ".", print("id")];\n        case "StringLiteralTypeAnnotation":\n          return replaceTextEndOfLine(printString(rawText(node), options));\n        case "NumberLiteralTypeAnnotation":\n          assert.strictEqual(typeof node.value, "number");\n        case "BigIntLiteralTypeAnnotation":\n          if (node.extra) {\n            return printNumber(node.extra.raw);\n          }\n          return printNumber(node.raw);\n        case "TypeCastExpression": {\n          return ["(", print("expression"), printTypeAnnotation(path, options, print), ")"];\n        }\n        case "TypeParameterDeclaration":\n        case "TypeParameterInstantiation": {\n          const printed = printTypeParameters(path, options, print, "params");\n          if (options.parser === "flow") {\n            const start = locStart(node);\n            const end = locEnd(node);\n            const commentStartIndex = options.originalText.lastIndexOf("/*", start);\n            const commentEndIndex = options.originalText.indexOf("*/", end);\n            if (commentStartIndex !== -1 && commentEndIndex !== -1) {\n              const comment = options.originalText.slice(commentStartIndex + 2, commentEndIndex).trim();\n              if (comment.startsWith("::") && !comment.includes("/*") && !comment.includes("*/")) {\n                return ["/*:: ", printed, " */"];\n              }\n            }\n          }\n          return printed;\n        }\n        case "InferredPredicate":\n          return "%checks";\n        case "DeclaredPredicate":\n          return ["%checks(", print("value"), ")"];\n        case "AnyTypeAnnotation":\n          return "any";\n        case "BooleanTypeAnnotation":\n          return "boolean";\n        case "BigIntTypeAnnotation":\n          return "bigint";\n        case "NullLiteralTypeAnnotation":\n          return "null";\n        case "NumberTypeAnnotation":\n          return "number";\n        case "SymbolTypeAnnotation":\n          return "symbol";\n        case "StringTypeAnnotation":\n          return "string";\n        case "VoidTypeAnnotation":\n          return "void";\n        case "ThisTypeAnnotation":\n          return "this";\n        case "Node":\n        case "Printable":\n        case "SourceLocation":\n        case "Position":\n        case "Statement":\n        case "Function":\n        case "Pattern":\n        case "Expression":\n        case "Declaration":\n        case "Specifier":\n        case "NamedSpecifier":\n        case "Comment":\n        case "MemberTypeAnnotation":\n        case "Type":\n          throw new Error("unprintable type: " + JSON.stringify(node.type));\n      }\n    }\n    function printFlowDeclaration(path, printed) {\n      const parentExportDecl = getParentExportDeclaration(path);\n      if (parentExportDecl) {\n        assert.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");\n        return printed;\n      }\n      return ["declare ", printed];\n    }\n    module2.exports = {\n      printFlow\n    };\n  }\n});\nvar require_is_ts_keyword_type = __commonJS2({\n  "src/language-js/utils/is-ts-keyword-type.js"(exports2, module2) {\n    "use strict";\n    function isTsKeywordType({\n      type\n    }) {\n      return type.startsWith("TS") && type.endsWith("Keyword");\n    }\n    module2.exports = isTsKeywordType;\n  }\n});\nvar require_ternary = __commonJS2({\n  "src/language-js/print/ternary.js"(exports2, module2) {\n    "use strict";\n    var {\n      hasNewlineInRange\n    } = require_util();\n    var {\n      isJsxNode,\n      getComments,\n      isCallExpression,\n      isMemberExpression,\n      isTSTypeExpression\n    } = require_utils7();\n    var {\n      locStart,\n      locEnd\n    } = require_loc();\n    var isBlockComment = require_is_block_comment();\n    var {\n      builders: {\n        line,\n        softline,\n        group,\n        indent,\n        align,\n        ifBreak,\n        dedent,\n        breakParent\n      }\n    } = require("./doc.js");\n    function conditionalExpressionChainContainsJsx(node) {\n      const conditionalExpressions = [node];\n      for (let index = 0; index < conditionalExpressions.length; index++) {\n        const conditionalExpression = conditionalExpressions[index];\n        for (const property of ["test", "consequent", "alternate"]) {\n          const node2 = conditionalExpression[property];\n          if (isJsxNode(node2)) {\n            return true;\n          }\n          if (node2.type === "ConditionalExpression") {\n            conditionalExpressions.push(node2);\n          }\n        }\n      }\n      return false;\n    }\n    function printTernaryTest(path, options, print) {\n      const node = path.getValue();\n      const isConditionalExpression = node.type === "ConditionalExpression";\n      const alternateNodePropertyName = isConditionalExpression ? "alternate" : "falseType";\n      const parent = path.getParentNode();\n      const printed = isConditionalExpression ? print("test") : [print("checkType"), " ", "extends", " ", print("extendsType")];\n      if (parent.type === node.type && parent[alternateNodePropertyName] === node) {\n        return align(2, printed);\n      }\n      return printed;\n    }\n    var ancestorNameMap = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);\n    function shouldExtraIndentForConditionalExpression(path) {\n      const node = path.getValue();\n      if (node.type !== "ConditionalExpression") {\n        return false;\n      }\n      let parent;\n      let child = node;\n      for (let ancestorCount = 0; !parent; ancestorCount++) {\n        const node2 = path.getParentNode(ancestorCount);\n        if (isCallExpression(node2) && node2.callee === child || isMemberExpression(node2) && node2.object === child || node2.type === "TSNonNullExpression" && node2.expression === child) {\n          child = node2;\n          continue;\n        }\n        if (node2.type === "NewExpression" && node2.callee === child || isTSTypeExpression(node2) && node2.expression === child) {\n          parent = path.getParentNode(ancestorCount + 1);\n          child = node2;\n        } else {\n          parent = node2;\n        }\n      }\n      if (child === node) {\n        return false;\n      }\n      return parent[ancestorNameMap.get(parent.type)] === child;\n    }\n    function printTernary(path, options, print) {\n      const node = path.getValue();\n      const isConditionalExpression = node.type === "ConditionalExpression";\n      const consequentNodePropertyName = isConditionalExpression ? "consequent" : "trueType";\n      const alternateNodePropertyName = isConditionalExpression ? "alternate" : "falseType";\n      const testNodePropertyNames = isConditionalExpression ? ["test"] : ["checkType", "extendsType"];\n      const consequentNode = node[consequentNodePropertyName];\n      const alternateNode = node[alternateNodePropertyName];\n      const parts = [];\n      let jsxMode = false;\n      const parent = path.getParentNode();\n      const isParentTest = parent.type === node.type && testNodePropertyNames.some((prop) => parent[prop] === node);\n      let forceNoIndent = parent.type === node.type && !isParentTest;\n      let currentParent;\n      let previousParent;\n      let i = 0;\n      do {\n        previousParent = currentParent || node;\n        currentParent = path.getParentNode(i);\n        i++;\n      } while (currentParent && currentParent.type === node.type && testNodePropertyNames.every((prop) => currentParent[prop] !== previousParent));\n      const firstNonConditionalParent = currentParent || parent;\n      const lastConditionalParent = previousParent;\n      if (isConditionalExpression && (isJsxNode(node[testNodePropertyNames[0]]) || isJsxNode(consequentNode) || isJsxNode(alternateNode) || conditionalExpressionChainContainsJsx(lastConditionalParent))) {\n        jsxMode = true;\n        forceNoIndent = true;\n        const wrap = (doc2) => [ifBreak("("), indent([softline, doc2]), softline, ifBreak(")")];\n        const isNil = (node2) => node2.type === "NullLiteral" || node2.type === "Literal" && node2.value === null || node2.type === "Identifier" && node2.name === "undefined";\n        parts.push(" ? ", isNil(consequentNode) ? print(consequentNodePropertyName) : wrap(print(consequentNodePropertyName)), " : ", alternateNode.type === node.type || isNil(alternateNode) ? print(alternateNodePropertyName) : wrap(print(alternateNodePropertyName)));\n      } else {\n        const part = [line, "? ", consequentNode.type === node.type ? ifBreak("", "(") : "", align(2, print(consequentNodePropertyName)), consequentNode.type === node.type ? ifBreak("", ")") : "", line, ": ", alternateNode.type === node.type ? print(alternateNodePropertyName) : align(2, print(alternateNodePropertyName))];\n        parts.push(parent.type !== node.type || parent[alternateNodePropertyName] === node || isParentTest ? part : options.useTabs ? dedent(indent(part)) : align(Math.max(0, options.tabWidth - 2), part));\n      }\n      const comments = [...testNodePropertyNames.map((propertyName) => getComments(node[propertyName])), getComments(consequentNode), getComments(alternateNode)].flat();\n      const shouldBreak = comments.some((comment) => isBlockComment(comment) && hasNewlineInRange(options.originalText, locStart(comment), locEnd(comment)));\n      const maybeGroup = (doc2) => parent === firstNonConditionalParent ? group(doc2, {\n        shouldBreak\n      }) : shouldBreak ? [doc2, breakParent] : doc2;\n      const breakClosingParen = !jsxMode && (isMemberExpression(parent) || parent.type === "NGPipeExpression" && parent.left === node) && !parent.computed;\n      const shouldExtraIndent = shouldExtraIndentForConditionalExpression(path);\n      const result = maybeGroup([printTernaryTest(path, options, print), forceNoIndent ? parts : indent(parts), isConditionalExpression && breakClosingParen && !shouldExtraIndent ? softline : ""]);\n      return isParentTest || shouldExtraIndent ? group([indent([softline, result]), softline]) : result;\n    }\n    module2.exports = {\n      printTernary\n    };\n  }\n});\nvar require_statement = __commonJS2({\n  "src/language-js/print/statement.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        hardline\n      }\n    } = require("./doc.js");\n    var pathNeedsParens = require_needs_parens();\n    var {\n      getLeftSidePathName,\n      hasNakedLeftSide,\n      isJsxNode,\n      isTheOnlyJsxElementInMarkdown,\n      hasComment,\n      CommentCheckFlags,\n      isNextLineEmpty\n    } = require_utils7();\n    var {\n      shouldPrintParamsWithoutParens\n    } = require_function();\n    function printStatementSequence(path, options, print, property) {\n      const node = path.getValue();\n      const parts = [];\n      const isClassBody = node.type === "ClassBody";\n      const lastStatement = getLastStatement(node[property]);\n      path.each((path2, index, statements) => {\n        const node2 = path2.getValue();\n        if (node2.type === "EmptyStatement") {\n          return;\n        }\n        const printed = print();\n        if (!options.semi && !isClassBody && !isTheOnlyJsxElementInMarkdown(options, path2) && statementNeedsASIProtection(path2, options)) {\n          if (hasComment(node2, CommentCheckFlags.Leading)) {\n            parts.push(print([], {\n              needsSemi: true\n            }));\n          } else {\n            parts.push(";", printed);\n          }\n        } else {\n          parts.push(printed);\n        }\n        if (!options.semi && isClassBody && isClassProperty(node2) && shouldPrintSemicolonAfterClassProperty(node2, statements[index + 1])) {\n          parts.push(";");\n        }\n        if (node2 !== lastStatement) {\n          parts.push(hardline);\n          if (isNextLineEmpty(node2, options)) {\n            parts.push(hardline);\n          }\n        }\n      }, property);\n      return parts;\n    }\n    function getLastStatement(statements) {\n      for (let i = statements.length - 1; i >= 0; i--) {\n        const statement = statements[i];\n        if (statement.type !== "EmptyStatement") {\n          return statement;\n        }\n      }\n    }\n    function statementNeedsASIProtection(path, options) {\n      const node = path.getNode();\n      if (node.type !== "ExpressionStatement") {\n        return false;\n      }\n      return path.call((childPath) => expressionNeedsASIProtection(childPath, options), "expression");\n    }\n    function expressionNeedsASIProtection(path, options) {\n      const node = path.getValue();\n      switch (node.type) {\n        case "ParenthesizedExpression":\n        case "TypeCastExpression":\n        case "ArrayExpression":\n        case "ArrayPattern":\n        case "TemplateLiteral":\n        case "TemplateElement":\n        case "RegExpLiteral":\n          return true;\n        case "ArrowFunctionExpression": {\n          if (!shouldPrintParamsWithoutParens(path, options)) {\n            return true;\n          }\n          break;\n        }\n        case "UnaryExpression": {\n          const {\n            prefix,\n            operator\n          } = node;\n          if (prefix && (operator === "+" || operator === "-")) {\n            return true;\n          }\n          break;\n        }\n        case "BindExpression": {\n          if (!node.object) {\n            return true;\n          }\n          break;\n        }\n        case "Literal": {\n          if (node.regex) {\n            return true;\n          }\n          break;\n        }\n        default: {\n          if (isJsxNode(node)) {\n            return true;\n          }\n        }\n      }\n      if (pathNeedsParens(path, options)) {\n        return true;\n      }\n      if (!hasNakedLeftSide(node)) {\n        return false;\n      }\n      return path.call((childPath) => expressionNeedsASIProtection(childPath, options), ...getLeftSidePathName(path, node));\n    }\n    function printBody(path, options, print) {\n      return printStatementSequence(path, options, print, "body");\n    }\n    function printSwitchCaseConsequent(path, options, print) {\n      return printStatementSequence(path, options, print, "consequent");\n    }\n    var isClassProperty = ({\n      type\n    }) => type === "ClassProperty" || type === "PropertyDefinition" || type === "ClassPrivateProperty" || type === "ClassAccessorProperty" || type === "AccessorProperty" || type === "TSAbstractPropertyDefinition" || type === "TSAbstractAccessorProperty";\n    function shouldPrintSemicolonAfterClassProperty(node, nextNode) {\n      const {\n        type,\n        name\n      } = node.key;\n      if (!node.computed && type === "Identifier" && (name === "static" || name === "get" || name === "set" || name === "accessor") && !node.value && !node.typeAnnotation) {\n        return true;\n      }\n      if (!nextNode) {\n        return false;\n      }\n      if (nextNode.static || nextNode.accessibility) {\n        return false;\n      }\n      if (!nextNode.computed) {\n        const name2 = nextNode.key && nextNode.key.name;\n        if (name2 === "in" || name2 === "instanceof") {\n          return true;\n        }\n      }\n      if (isClassProperty(nextNode) && nextNode.variance && !nextNode.static && !nextNode.declare) {\n        return true;\n      }\n      switch (nextNode.type) {\n        case "ClassProperty":\n        case "PropertyDefinition":\n        case "TSAbstractPropertyDefinition":\n          return nextNode.computed;\n        case "MethodDefinition":\n        case "TSAbstractMethodDefinition":\n        case "ClassMethod":\n        case "ClassPrivateMethod": {\n          const isAsync = nextNode.value ? nextNode.value.async : nextNode.async;\n          if (isAsync || nextNode.kind === "get" || nextNode.kind === "set") {\n            return false;\n          }\n          const isGenerator = nextNode.value ? nextNode.value.generator : nextNode.generator;\n          if (nextNode.computed || isGenerator) {\n            return true;\n          }\n          return false;\n        }\n        case "TSIndexSignature":\n          return true;\n      }\n      return false;\n    }\n    module2.exports = {\n      printBody,\n      printSwitchCaseConsequent\n    };\n  }\n});\nvar require_block = __commonJS2({\n  "src/language-js/print/block.js"(exports2, module2) {\n    "use strict";\n    var {\n      printDanglingComments\n    } = require_comments();\n    var {\n      isNonEmptyArray\n    } = require_util();\n    var {\n      builders: {\n        hardline,\n        indent\n      }\n    } = require("./doc.js");\n    var {\n      hasComment,\n      CommentCheckFlags,\n      isNextLineEmpty\n    } = require_utils7();\n    var {\n      printHardlineAfterHeritage\n    } = require_class();\n    var {\n      printBody\n    } = require_statement();\n    function printBlock(path, options, print) {\n      const node = path.getValue();\n      const parts = [];\n      if (node.type === "StaticBlock") {\n        parts.push("static ");\n      }\n      if (node.type === "ClassBody" && isNonEmptyArray(node.body)) {\n        const parent = path.getParentNode();\n        parts.push(printHardlineAfterHeritage(parent));\n      }\n      parts.push("{");\n      const printed = printBlockBody(path, options, print);\n      if (printed) {\n        parts.push(indent([hardline, printed]), hardline);\n      } else {\n        const parent = path.getParentNode();\n        const parentParent = path.getParentNode(1);\n        if (!(parent.type === "ArrowFunctionExpression" || parent.type === "FunctionExpression" || parent.type === "FunctionDeclaration" || parent.type === "ObjectMethod" || parent.type === "ClassMethod" || parent.type === "ClassPrivateMethod" || parent.type === "ForStatement" || parent.type === "WhileStatement" || parent.type === "DoWhileStatement" || parent.type === "DoExpression" || parent.type === "CatchClause" && !parentParent.finalizer || parent.type === "TSModuleDeclaration" || parent.type === "TSDeclareFunction" || node.type === "StaticBlock" || node.type === "ClassBody")) {\n          parts.push(hardline);\n        }\n      }\n      parts.push("}");\n      return parts;\n    }\n    function printBlockBody(path, options, print) {\n      const node = path.getValue();\n      const nodeHasDirectives = isNonEmptyArray(node.directives);\n      const nodeHasBody = node.body.some((node2) => node2.type !== "EmptyStatement");\n      const nodeHasComment = hasComment(node, CommentCheckFlags.Dangling);\n      if (!nodeHasDirectives && !nodeHasBody && !nodeHasComment) {\n        return "";\n      }\n      const parts = [];\n      if (nodeHasDirectives) {\n        path.each((childPath, index, directives) => {\n          parts.push(print());\n          if (index < directives.length - 1 || nodeHasBody || nodeHasComment) {\n            parts.push(hardline);\n            if (isNextLineEmpty(childPath.getValue(), options)) {\n              parts.push(hardline);\n            }\n          }\n        }, "directives");\n      }\n      if (nodeHasBody) {\n        parts.push(printBody(path, options, print));\n      }\n      if (nodeHasComment) {\n        parts.push(printDanglingComments(path, options, true));\n      }\n      if (node.type === "Program") {\n        const parent = path.getParentNode();\n        if (!parent || parent.type !== "ModuleExpression") {\n          parts.push(hardline);\n        }\n      }\n      return parts;\n    }\n    module2.exports = {\n      printBlock,\n      printBlockBody\n    };\n  }\n});\nvar require_typescript = __commonJS2({\n  "src/language-js/print/typescript.js"(exports2, module2) {\n    "use strict";\n    var {\n      printDanglingComments\n    } = require_comments();\n    var {\n      hasNewlineInRange\n    } = require_util();\n    var {\n      builders: {\n        join,\n        line,\n        hardline,\n        softline,\n        group,\n        indent,\n        conditionalGroup,\n        ifBreak\n      }\n    } = require("./doc.js");\n    var {\n      isStringLiteral,\n      getTypeScriptMappedTypeModifier,\n      shouldPrintComma,\n      isCallExpression,\n      isMemberExpression\n    } = require_utils7();\n    var isTsKeywordType = require_is_ts_keyword_type();\n    var {\n      locStart,\n      locEnd\n    } = require_loc();\n    var {\n      printOptionalToken,\n      printTypeScriptModifiers\n    } = require_misc();\n    var {\n      printTernary\n    } = require_ternary();\n    var {\n      printFunctionParameters,\n      shouldGroupFunctionParameters\n    } = require_function_parameters();\n    var {\n      printTemplateLiteral\n    } = require_template_literal();\n    var {\n      printArrayItems\n    } = require_array4();\n    var {\n      printObject\n    } = require_object();\n    var {\n      printClassProperty,\n      printClassMethod\n    } = require_class();\n    var {\n      printTypeParameter,\n      printTypeParameters\n    } = require_type_parameters();\n    var {\n      printPropertyKey\n    } = require_property();\n    var {\n      printFunction,\n      printMethodInternal\n    } = require_function();\n    var {\n      printInterface\n    } = require_interface();\n    var {\n      printBlock\n    } = require_block();\n    var {\n      printTypeAlias,\n      printIntersectionType,\n      printUnionType,\n      printFunctionType,\n      printTupleType,\n      printIndexedAccessType,\n      printJSDocType\n    } = require_type_annotation();\n    function printTypescript(path, options, print) {\n      const node = path.getValue();\n      if (!node.type.startsWith("TS")) {\n        return;\n      }\n      if (isTsKeywordType(node)) {\n        return node.type.slice(2, -7).toLowerCase();\n      }\n      const semi = options.semi ? ";" : "";\n      const parts = [];\n      switch (node.type) {\n        case "TSThisType":\n          return "this";\n        case "TSTypeAssertion": {\n          const shouldBreakAfterCast = !(node.expression.type === "ArrayExpression" || node.expression.type === "ObjectExpression");\n          const castGroup = group(["<", indent([softline, print("typeAnnotation")]), softline, ">"]);\n          const exprContents = [ifBreak("("), indent([softline, print("expression")]), softline, ifBreak(")")];\n          if (shouldBreakAfterCast) {\n            return conditionalGroup([[castGroup, print("expression")], [castGroup, group(exprContents, {\n              shouldBreak: true\n            })], [castGroup, print("expression")]]);\n          }\n          return group([castGroup, print("expression")]);\n        }\n        case "TSDeclareFunction":\n          return printFunction(path, print, options);\n        case "TSExportAssignment":\n          return ["export = ", print("expression"), semi];\n        case "TSModuleBlock":\n          return printBlock(path, options, print);\n        case "TSInterfaceBody":\n        case "TSTypeLiteral":\n          return printObject(path, options, print);\n        case "TSTypeAliasDeclaration":\n          return printTypeAlias(path, options, print);\n        case "TSQualifiedName":\n          return join(".", [print("left"), print("right")]);\n        case "TSAbstractMethodDefinition":\n        case "TSDeclareMethod":\n          return printClassMethod(path, options, print);\n        case "TSAbstractAccessorProperty":\n        case "TSAbstractPropertyDefinition":\n          return printClassProperty(path, options, print);\n        case "TSInterfaceHeritage":\n        case "TSExpressionWithTypeArguments":\n          parts.push(print("expression"));\n          if (node.typeParameters) {\n            parts.push(print("typeParameters"));\n          }\n          return parts;\n        case "TSTemplateLiteralType":\n          return printTemplateLiteral(path, print, options);\n        case "TSNamedTupleMember":\n          return [print("label"), node.optional ? "?" : "", ": ", print("elementType")];\n        case "TSRestType":\n          return ["...", print("typeAnnotation")];\n        case "TSOptionalType":\n          return [print("typeAnnotation"), "?"];\n        case "TSInterfaceDeclaration":\n          return printInterface(path, options, print);\n        case "TSClassImplements":\n          return [print("expression"), print("typeParameters")];\n        case "TSTypeParameterDeclaration":\n        case "TSTypeParameterInstantiation":\n          return printTypeParameters(path, options, print, "params");\n        case "TSTypeParameter":\n          return printTypeParameter(path, options, print);\n        case "TSSatisfiesExpression":\n        case "TSAsExpression": {\n          const operator = node.type === "TSAsExpression" ? "as" : "satisfies";\n          parts.push(print("expression"), ` ${operator} `, print("typeAnnotation"));\n          const parent = path.getParentNode();\n          if (isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node) {\n            return group([indent([softline, ...parts]), softline]);\n          }\n          return parts;\n        }\n        case "TSArrayType":\n          return [print("elementType"), "[]"];\n        case "TSPropertySignature": {\n          if (node.readonly) {\n            parts.push("readonly ");\n          }\n          parts.push(printPropertyKey(path, options, print), printOptionalToken(path));\n          if (node.typeAnnotation) {\n            parts.push(": ", print("typeAnnotation"));\n          }\n          if (node.initializer) {\n            parts.push(" = ", print("initializer"));\n          }\n          return parts;\n        }\n        case "TSParameterProperty":\n          if (node.accessibility) {\n            parts.push(node.accessibility + " ");\n          }\n          if (node.export) {\n            parts.push("export ");\n          }\n          if (node.static) {\n            parts.push("static ");\n          }\n          if (node.override) {\n            parts.push("override ");\n          }\n          if (node.readonly) {\n            parts.push("readonly ");\n          }\n          parts.push(print("parameter"));\n          return parts;\n        case "TSTypeQuery":\n          return ["typeof ", print("exprName"), print("typeParameters")];\n        case "TSIndexSignature": {\n          const parent = path.getParentNode();\n          const trailingComma = node.parameters.length > 1 ? ifBreak(shouldPrintComma(options) ? "," : "") : "";\n          const parametersGroup = group([indent([softline, join([", ", softline], path.map(print, "parameters"))]), trailingComma, softline]);\n          return [node.export ? "export " : "", node.accessibility ? [node.accessibility, " "] : "", node.static ? "static " : "", node.readonly ? "readonly " : "", node.declare ? "declare " : "", "[", node.parameters ? parametersGroup : "", node.typeAnnotation ? "]: " : "]", node.typeAnnotation ? print("typeAnnotation") : "", parent.type === "ClassBody" ? semi : ""];\n        }\n        case "TSTypePredicate":\n          return [node.asserts ? "asserts " : "", print("parameterName"), node.typeAnnotation ? [" is ", print("typeAnnotation")] : ""];\n        case "TSNonNullExpression":\n          return [print("expression"), "!"];\n        case "TSImportType":\n          return [!node.isTypeOf ? "" : "typeof ", "import(", print(node.parameter ? "parameter" : "argument"), ")", !node.qualifier ? "" : [".", print("qualifier")], printTypeParameters(path, options, print, "typeParameters")];\n        case "TSLiteralType":\n          return print("literal");\n        case "TSIndexedAccessType":\n          return printIndexedAccessType(path, options, print);\n        case "TSConstructSignatureDeclaration":\n        case "TSCallSignatureDeclaration":\n        case "TSConstructorType": {\n          if (node.type === "TSConstructorType" && node.abstract) {\n            parts.push("abstract ");\n          }\n          if (node.type !== "TSCallSignatureDeclaration") {\n            parts.push("new ");\n          }\n          parts.push(group(printFunctionParameters(path, print, options, false, true)));\n          if (node.returnType || node.typeAnnotation) {\n            const isType = node.type === "TSConstructorType";\n            parts.push(isType ? " => " : ": ", print("returnType"), print("typeAnnotation"));\n          }\n          return parts;\n        }\n        case "TSTypeOperator":\n          return [node.operator, " ", print("typeAnnotation")];\n        case "TSMappedType": {\n          const shouldBreak = hasNewlineInRange(options.originalText, locStart(node), locEnd(node));\n          return group(["{", indent([options.bracketSpacing ? line : softline, print("typeParameter"), node.optional ? getTypeScriptMappedTypeModifier(node.optional, "?") : "", node.typeAnnotation ? ": " : "", print("typeAnnotation"), ifBreak(semi)]), printDanglingComments(path, options, true), options.bracketSpacing ? line : softline, "}"], {\n            shouldBreak\n          });\n        }\n        case "TSMethodSignature": {\n          const kind = node.kind && node.kind !== "method" ? `${node.kind} ` : "";\n          parts.push(node.accessibility ? [node.accessibility, " "] : "", kind, node.export ? "export " : "", node.static ? "static " : "", node.readonly ? "readonly " : "", node.abstract ? "abstract " : "", node.declare ? "declare " : "", node.computed ? "[" : "", print("key"), node.computed ? "]" : "", printOptionalToken(path));\n          const parametersDoc = printFunctionParameters(path, print, options, false, true);\n          const returnTypePropertyName = node.returnType ? "returnType" : "typeAnnotation";\n          const returnTypeNode = node[returnTypePropertyName];\n          const returnTypeDoc = returnTypeNode ? print(returnTypePropertyName) : "";\n          const shouldGroupParameters = shouldGroupFunctionParameters(node, returnTypeDoc);\n          parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);\n          if (returnTypeNode) {\n            parts.push(": ", group(returnTypeDoc));\n          }\n          return group(parts);\n        }\n        case "TSNamespaceExportDeclaration":\n          parts.push("export as namespace ", print("id"));\n          if (options.semi) {\n            parts.push(";");\n          }\n          return group(parts);\n        case "TSEnumDeclaration":\n          if (node.declare) {\n            parts.push("declare ");\n          }\n          if (node.modifiers) {\n            parts.push(printTypeScriptModifiers(path, options, print));\n          }\n          if (node.const) {\n            parts.push("const ");\n          }\n          parts.push("enum ", print("id"), " ");\n          if (node.members.length === 0) {\n            parts.push(group(["{", printDanglingComments(path, options), softline, "}"]));\n          } else {\n            parts.push(group(["{", indent([hardline, printArrayItems(path, options, "members", print), shouldPrintComma(options, "es5") ? "," : ""]), printDanglingComments(path, options, true), hardline, "}"]));\n          }\n          return parts;\n        case "TSEnumMember":\n          if (node.computed) {\n            parts.push("[", print("id"), "]");\n          } else {\n            parts.push(print("id"));\n          }\n          if (node.initializer) {\n            parts.push(" = ", print("initializer"));\n          }\n          return parts;\n        case "TSImportEqualsDeclaration":\n          if (node.isExport) {\n            parts.push("export ");\n          }\n          parts.push("import ");\n          if (node.importKind && node.importKind !== "value") {\n            parts.push(node.importKind, " ");\n          }\n          parts.push(print("id"), " = ", print("moduleReference"));\n          if (options.semi) {\n            parts.push(";");\n          }\n          return group(parts);\n        case "TSExternalModuleReference":\n          return ["require(", print("expression"), ")"];\n        case "TSModuleDeclaration": {\n          const parent = path.getParentNode();\n          const isExternalModule = isStringLiteral(node.id);\n          const parentIsDeclaration = parent.type === "TSModuleDeclaration";\n          const bodyIsDeclaration = node.body && node.body.type === "TSModuleDeclaration";\n          if (parentIsDeclaration) {\n            parts.push(".");\n          } else {\n            if (node.declare) {\n              parts.push("declare ");\n            }\n            parts.push(printTypeScriptModifiers(path, options, print));\n            const textBetweenNodeAndItsId = options.originalText.slice(locStart(node), locStart(node.id));\n            const isGlobalDeclaration = node.id.type === "Identifier" && node.id.name === "global" && !/namespace|module/.test(textBetweenNodeAndItsId);\n            if (!isGlobalDeclaration) {\n              parts.push(isExternalModule || /(?:^|\\s)module(?:\\s|$)/.test(textBetweenNodeAndItsId) ? "module " : "namespace ");\n            }\n          }\n          parts.push(print("id"));\n          if (bodyIsDeclaration) {\n            parts.push(print("body"));\n          } else if (node.body) {\n            parts.push(" ", group(print("body")));\n          } else {\n            parts.push(semi);\n          }\n          return parts;\n        }\n        case "TSConditionalType":\n          return printTernary(path, options, print);\n        case "TSInferType":\n          return ["infer", " ", print("typeParameter")];\n        case "TSIntersectionType":\n          return printIntersectionType(path, options, print);\n        case "TSUnionType":\n          return printUnionType(path, options, print);\n        case "TSFunctionType":\n          return printFunctionType(path, options, print);\n        case "TSTupleType":\n          return printTupleType(path, options, print);\n        case "TSTypeReference":\n          return [print("typeName"), printTypeParameters(path, options, print, "typeParameters")];\n        case "TSTypeAnnotation":\n          return print("typeAnnotation");\n        case "TSEmptyBodyFunctionExpression":\n          return printMethodInternal(path, options, print);\n        case "TSJSDocAllType":\n          return "*";\n        case "TSJSDocUnknownType":\n          return "?";\n        case "TSJSDocNullableType":\n          return printJSDocType(path, print, "?");\n        case "TSJSDocNonNullableType":\n          return printJSDocType(path, print, "!");\n        case "TSInstantiationExpression":\n          return [print("expression"), print("typeParameters")];\n        default:\n          throw new Error(`Unknown TypeScript node type: ${JSON.stringify(node.type)}.`);\n      }\n    }\n    module2.exports = {\n      printTypescript\n    };\n  }\n});\nvar require_comment = __commonJS2({\n  "src/language-js/print/comment.js"(exports2, module2) {\n    "use strict";\n    var {\n      hasNewline\n    } = require_util();\n    var {\n      builders: {\n        join,\n        hardline\n      },\n      utils: {\n        replaceTextEndOfLine\n      }\n    } = require("./doc.js");\n    var {\n      isLineComment\n    } = require_utils7();\n    var {\n      locStart,\n      locEnd\n    } = require_loc();\n    var isBlockComment = require_is_block_comment();\n    function printComment(commentPath, options) {\n      const comment = commentPath.getValue();\n      if (isLineComment(comment)) {\n        return options.originalText.slice(locStart(comment), locEnd(comment)).trimEnd();\n      }\n      if (isBlockComment(comment)) {\n        if (isIndentableBlockComment(comment)) {\n          const printed = printIndentableBlockComment(comment);\n          if (comment.trailing && !hasNewline(options.originalText, locStart(comment), {\n            backwards: true\n          })) {\n            return [hardline, printed];\n          }\n          return printed;\n        }\n        const commentEnd = locEnd(comment);\n        const isInsideFlowComment = options.originalText.slice(commentEnd - 3, commentEnd) === "*-/";\n        return ["/*", replaceTextEndOfLine(comment.value), isInsideFlowComment ? "*-/" : "*/"];\n      }\n      throw new Error("Not a comment: " + JSON.stringify(comment));\n    }\n    function isIndentableBlockComment(comment) {\n      const lines = `*${comment.value}*`.split("\\n");\n      return lines.length > 1 && lines.every((line) => line.trim()[0] === "*");\n    }\n    function printIndentableBlockComment(comment) {\n      const lines = comment.value.split("\\n");\n      return ["/*", join(hardline, lines.map((line, index) => index === 0 ? line.trimEnd() : " " + (index < lines.length - 1 ? line.trim() : line.trimStart()))), "*/"];\n    }\n    module2.exports = {\n      printComment\n    };\n  }\n});\nvar require_literal = __commonJS2({\n  "src/language-js/print/literal.js"(exports2, module2) {\n    "use strict";\n    var {\n      printString,\n      printNumber\n    } = require_util();\n    var {\n      replaceTextEndOfLine\n    } = require_doc_utils();\n    var {\n      printDirective\n    } = require_misc();\n    function printLiteral(path, options) {\n      const node = path.getNode();\n      switch (node.type) {\n        case "RegExpLiteral":\n          return printRegex(node);\n        case "BigIntLiteral":\n          return printBigInt(node.bigint || node.extra.raw);\n        case "NumericLiteral":\n          return printNumber(node.extra.raw);\n        case "StringLiteral":\n          return replaceTextEndOfLine(printString(node.extra.raw, options));\n        case "NullLiteral":\n          return "null";\n        case "BooleanLiteral":\n          return String(node.value);\n        case "DecimalLiteral":\n          return printNumber(node.value) + "m";\n        case "Literal": {\n          if (node.regex) {\n            return printRegex(node.regex);\n          }\n          if (node.bigint) {\n            return printBigInt(node.raw);\n          }\n          if (node.decimal) {\n            return printNumber(node.decimal) + "m";\n          }\n          const {\n            value\n          } = node;\n          if (typeof value === "number") {\n            return printNumber(node.raw);\n          }\n          if (typeof value === "string") {\n            return isDirective(path) ? printDirective(node.raw, options) : replaceTextEndOfLine(printString(node.raw, options));\n          }\n          return String(value);\n        }\n      }\n    }\n    function isDirective(path) {\n      if (path.getName() !== "expression") {\n        return;\n      }\n      const parent = path.getParentNode();\n      return parent.type === "ExpressionStatement" && parent.directive;\n    }\n    function printBigInt(raw) {\n      return raw.toLowerCase();\n    }\n    function printRegex({\n      pattern,\n      flags\n    }) {\n      flags = [...flags].sort().join("");\n      return `/${pattern}/${flags}`;\n    }\n    module2.exports = {\n      printLiteral\n    };\n  }\n});\nvar require_printer_estree = __commonJS2({\n  "src/language-js/printer-estree.js"(exports2, module2) {\n    "use strict";\n    var {\n      printDanglingComments\n    } = require_comments();\n    var {\n      hasNewline\n    } = require_util();\n    var {\n      builders: {\n        join,\n        line,\n        hardline,\n        softline,\n        group,\n        indent\n      },\n      utils: {\n        replaceTextEndOfLine\n      }\n    } = require("./doc.js");\n    var embed = require_embed();\n    var clean = require_clean();\n    var {\n      insertPragma\n    } = require_pragma();\n    var handleComments = require_comments2();\n    var pathNeedsParens = require_needs_parens();\n    var preprocess = require_print_preprocess();\n    var {\n      hasFlowShorthandAnnotationComment,\n      hasComment,\n      CommentCheckFlags,\n      isTheOnlyJsxElementInMarkdown,\n      isLineComment,\n      isNextLineEmpty,\n      needsHardlineAfterDanglingComment,\n      hasIgnoreComment,\n      isCallExpression,\n      isMemberExpression,\n      markerForIfWithoutBlockAndSameLineComment\n    } = require_utils7();\n    var {\n      locStart,\n      locEnd\n    } = require_loc();\n    var isBlockComment = require_is_block_comment();\n    var {\n      printHtmlBinding,\n      isVueEventBindingExpression\n    } = require_html_binding();\n    var {\n      printAngular\n    } = require_angular();\n    var {\n      printJsx,\n      hasJsxIgnoreComment\n    } = require_jsx();\n    var {\n      printFlow\n    } = require_flow();\n    var {\n      printTypescript\n    } = require_typescript();\n    var {\n      printOptionalToken,\n      printBindExpressionCallee,\n      printTypeAnnotation,\n      adjustClause,\n      printRestSpread,\n      printDefiniteToken,\n      printDirective\n    } = require_misc();\n    var {\n      printImportDeclaration,\n      printExportDeclaration,\n      printExportAllDeclaration,\n      printModuleSpecifier\n    } = require_module();\n    var {\n      printTernary\n    } = require_ternary();\n    var {\n      printTemplateLiteral\n    } = require_template_literal();\n    var {\n      printArray\n    } = require_array4();\n    var {\n      printObject\n    } = require_object();\n    var {\n      printClass,\n      printClassMethod,\n      printClassProperty\n    } = require_class();\n    var {\n      printProperty\n    } = require_property();\n    var {\n      printFunction,\n      printArrowFunction,\n      printMethod,\n      printReturnStatement,\n      printThrowStatement\n    } = require_function();\n    var {\n      printCallExpression\n    } = require_call_expression();\n    var {\n      printVariableDeclarator,\n      printAssignmentExpression\n    } = require_assignment();\n    var {\n      printBinaryishExpression\n    } = require_binaryish();\n    var {\n      printSwitchCaseConsequent\n    } = require_statement();\n    var {\n      printMemberExpression\n    } = require_member();\n    var {\n      printBlock,\n      printBlockBody\n    } = require_block();\n    var {\n      printComment\n    } = require_comment();\n    var {\n      printLiteral\n    } = require_literal();\n    var {\n      printDecorators\n    } = require_decorators();\n    function genericPrint(path, options, print, args) {\n      const printed = printPathNoParens(path, options, print, args);\n      if (!printed) {\n        return "";\n      }\n      const node = path.getValue();\n      const {\n        type\n      } = node;\n      if (type === "ClassMethod" || type === "ClassPrivateMethod" || type === "ClassProperty" || type === "ClassAccessorProperty" || type === "AccessorProperty" || type === "TSAbstractAccessorProperty" || type === "PropertyDefinition" || type === "TSAbstractPropertyDefinition" || type === "ClassPrivateProperty" || type === "MethodDefinition" || type === "TSAbstractMethodDefinition" || type === "TSDeclareMethod") {\n        return printed;\n      }\n      let parts = [printed];\n      const printedDecorators = printDecorators(path, options, print);\n      const isClassExpressionWithDecorators = node.type === "ClassExpression" && printedDecorators;\n      if (printedDecorators) {\n        parts = [...printedDecorators, printed];\n        if (!isClassExpressionWithDecorators) {\n          return group(parts);\n        }\n      }\n      const needsParens = pathNeedsParens(path, options);\n      if (!needsParens) {\n        if (args && args.needsSemi) {\n          parts.unshift(";");\n        }\n        if (parts.length === 1 && parts[0] === printed) {\n          return printed;\n        }\n        return parts;\n      }\n      if (isClassExpressionWithDecorators) {\n        parts = [indent([line, ...parts])];\n      }\n      parts.unshift("(");\n      if (args && args.needsSemi) {\n        parts.unshift(";");\n      }\n      if (hasFlowShorthandAnnotationComment(node)) {\n        const [comment] = node.trailingComments;\n        parts.push(" /*", comment.value.trimStart(), "*/");\n        comment.printed = true;\n      }\n      if (isClassExpressionWithDecorators) {\n        parts.push(line);\n      }\n      parts.push(")");\n      return parts;\n    }\n    function printPathNoParens(path, options, print, args) {\n      const node = path.getValue();\n      const semi = options.semi ? ";" : "";\n      if (!node) {\n        return "";\n      }\n      if (typeof node === "string") {\n        return node;\n      }\n      for (const printer of [printLiteral, printHtmlBinding, printAngular, printJsx, printFlow, printTypescript]) {\n        const printed = printer(path, options, print);\n        if (typeof printed !== "undefined") {\n          return printed;\n        }\n      }\n      let parts = [];\n      switch (node.type) {\n        case "JsExpressionRoot":\n          return print("node");\n        case "JsonRoot":\n          return [print("node"), hardline];\n        case "File":\n          if (node.program && node.program.interpreter) {\n            parts.push(print(["program", "interpreter"]));\n          }\n          parts.push(print("program"));\n          return parts;\n        case "Program":\n          return printBlockBody(path, options, print);\n        case "EmptyStatement":\n          return "";\n        case "ExpressionStatement": {\n          if (options.parser === "__vue_event_binding" || options.parser === "__vue_ts_event_binding") {\n            const parent = path.getParentNode();\n            if (parent.type === "Program" && parent.body.length === 1 && parent.body[0] === node) {\n              return [print("expression"), isVueEventBindingExpression(node.expression) ? ";" : ""];\n            }\n          }\n          const danglingComment = printDanglingComments(path, options, true, ({\n            marker\n          }) => marker === markerForIfWithoutBlockAndSameLineComment);\n          return [print("expression"), isTheOnlyJsxElementInMarkdown(options, path) ? "" : semi, danglingComment ? [" ", danglingComment] : ""];\n        }\n        case "ParenthesizedExpression": {\n          const shouldHug = !hasComment(node.expression) && (node.expression.type === "ObjectExpression" || node.expression.type === "ArrayExpression");\n          if (shouldHug) {\n            return ["(", print("expression"), ")"];\n          }\n          return group(["(", indent([softline, print("expression")]), softline, ")"]);\n        }\n        case "AssignmentExpression":\n          return printAssignmentExpression(path, options, print);\n        case "VariableDeclarator":\n          return printVariableDeclarator(path, options, print);\n        case "BinaryExpression":\n        case "LogicalExpression":\n          return printBinaryishExpression(path, options, print);\n        case "AssignmentPattern":\n          return [print("left"), " = ", print("right")];\n        case "OptionalMemberExpression":\n        case "MemberExpression": {\n          return printMemberExpression(path, options, print);\n        }\n        case "MetaProperty":\n          return [print("meta"), ".", print("property")];\n        case "BindExpression":\n          if (node.object) {\n            parts.push(print("object"));\n          }\n          parts.push(group(indent([softline, printBindExpressionCallee(path, options, print)])));\n          return parts;\n        case "Identifier": {\n          return [node.name, printOptionalToken(path), printDefiniteToken(path), printTypeAnnotation(path, options, print)];\n        }\n        case "V8IntrinsicIdentifier":\n          return ["%", node.name];\n        case "SpreadElement":\n        case "SpreadElementPattern":\n        case "SpreadProperty":\n        case "SpreadPropertyPattern":\n        case "RestElement":\n          return printRestSpread(path, options, print);\n        case "FunctionDeclaration":\n        case "FunctionExpression":\n          return printFunction(path, print, options, args);\n        case "ArrowFunctionExpression":\n          return printArrowFunction(path, options, print, args);\n        case "YieldExpression":\n          parts.push("yield");\n          if (node.delegate) {\n            parts.push("*");\n          }\n          if (node.argument) {\n            parts.push(" ", print("argument"));\n          }\n          return parts;\n        case "AwaitExpression": {\n          parts.push("await");\n          if (node.argument) {\n            parts.push(" ", print("argument"));\n            const parent = path.getParentNode();\n            if (isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node) {\n              parts = [indent([softline, ...parts]), softline];\n              const parentAwaitOrBlock = path.findAncestor((node2) => node2.type === "AwaitExpression" || node2.type === "BlockStatement");\n              if (!parentAwaitOrBlock || parentAwaitOrBlock.type !== "AwaitExpression") {\n                return group(parts);\n              }\n            }\n          }\n          return parts;\n        }\n        case "ExportDefaultDeclaration":\n        case "ExportNamedDeclaration":\n          return printExportDeclaration(path, options, print);\n        case "ExportAllDeclaration":\n          return printExportAllDeclaration(path, options, print);\n        case "ImportDeclaration":\n          return printImportDeclaration(path, options, print);\n        case "ImportSpecifier":\n        case "ExportSpecifier":\n        case "ImportNamespaceSpecifier":\n        case "ExportNamespaceSpecifier":\n        case "ImportDefaultSpecifier":\n        case "ExportDefaultSpecifier":\n          return printModuleSpecifier(path, options, print);\n        case "ImportAttribute":\n          return [print("key"), ": ", print("value")];\n        case "Import":\n          return "import";\n        case "BlockStatement":\n        case "StaticBlock":\n        case "ClassBody":\n          return printBlock(path, options, print);\n        case "ThrowStatement":\n          return printThrowStatement(path, options, print);\n        case "ReturnStatement":\n          return printReturnStatement(path, options, print);\n        case "NewExpression":\n        case "ImportExpression":\n        case "OptionalCallExpression":\n        case "CallExpression":\n          return printCallExpression(path, options, print);\n        case "ObjectExpression":\n        case "ObjectPattern":\n        case "RecordExpression":\n          return printObject(path, options, print);\n        case "ObjectProperty":\n        case "Property":\n          if (node.method || node.kind === "get" || node.kind === "set") {\n            return printMethod(path, options, print);\n          }\n          return printProperty(path, options, print);\n        case "ObjectMethod":\n          return printMethod(path, options, print);\n        case "Decorator":\n          return ["@", print("expression")];\n        case "ArrayExpression":\n        case "ArrayPattern":\n        case "TupleExpression":\n          return printArray(path, options, print);\n        case "SequenceExpression": {\n          const parent = path.getParentNode(0);\n          if (parent.type === "ExpressionStatement" || parent.type === "ForStatement") {\n            const parts2 = [];\n            path.each((expressionPath, index) => {\n              if (index === 0) {\n                parts2.push(print());\n              } else {\n                parts2.push(",", indent([line, print()]));\n              }\n            }, "expressions");\n            return group(parts2);\n          }\n          return group(join([",", line], path.map(print, "expressions")));\n        }\n        case "ThisExpression":\n          return "this";\n        case "Super":\n          return "super";\n        case "Directive":\n          return [print("value"), semi];\n        case "DirectiveLiteral":\n          return printDirective(node.extra.raw, options);\n        case "UnaryExpression":\n          parts.push(node.operator);\n          if (/[a-z]$/.test(node.operator)) {\n            parts.push(" ");\n          }\n          if (hasComment(node.argument)) {\n            parts.push(group(["(", indent([softline, print("argument")]), softline, ")"]));\n          } else {\n            parts.push(print("argument"));\n          }\n          return parts;\n        case "UpdateExpression":\n          parts.push(print("argument"), node.operator);\n          if (node.prefix) {\n            parts.reverse();\n          }\n          return parts;\n        case "ConditionalExpression":\n          return printTernary(path, options, print);\n        case "VariableDeclaration": {\n          const printed = path.map(print, "declarations");\n          const parentNode = path.getParentNode();\n          const isParentForLoop = parentNode.type === "ForStatement" || parentNode.type === "ForInStatement" || parentNode.type === "ForOfStatement";\n          const hasValue = node.declarations.some((decl) => decl.init);\n          let firstVariable;\n          if (printed.length === 1 && !hasComment(node.declarations[0])) {\n            firstVariable = printed[0];\n          } else if (printed.length > 0) {\n            firstVariable = indent(printed[0]);\n          }\n          parts = [node.declare ? "declare " : "", node.kind, firstVariable ? [" ", firstVariable] : "", indent(printed.slice(1).map((p) => [",", hasValue && !isParentForLoop ? hardline : line, p]))];\n          if (!(isParentForLoop && parentNode.body !== node)) {\n            parts.push(semi);\n          }\n          return group(parts);\n        }\n        case "WithStatement":\n          return group(["with (", print("object"), ")", adjustClause(node.body, print("body"))]);\n        case "IfStatement": {\n          const con = adjustClause(node.consequent, print("consequent"));\n          const opening = group(["if (", group([indent([softline, print("test")]), softline]), ")", con]);\n          parts.push(opening);\n          if (node.alternate) {\n            const commentOnOwnLine = hasComment(node.consequent, CommentCheckFlags.Trailing | CommentCheckFlags.Line) || needsHardlineAfterDanglingComment(node);\n            const elseOnSameLine = node.consequent.type === "BlockStatement" && !commentOnOwnLine;\n            parts.push(elseOnSameLine ? " " : hardline);\n            if (hasComment(node, CommentCheckFlags.Dangling)) {\n              parts.push(printDanglingComments(path, options, true), commentOnOwnLine ? hardline : " ");\n            }\n            parts.push("else", group(adjustClause(node.alternate, print("alternate"), node.alternate.type === "IfStatement")));\n          }\n          return parts;\n        }\n        case "ForStatement": {\n          const body = adjustClause(node.body, print("body"));\n          const dangling = printDanglingComments(path, options, true);\n          const printedComments = dangling ? [dangling, softline] : "";\n          if (!node.init && !node.test && !node.update) {\n            return [printedComments, group(["for (;;)", body])];\n          }\n          return [printedComments, group(["for (", group([indent([softline, print("init"), ";", line, print("test"), ";", line, print("update")]), softline]), ")", body])];\n        }\n        case "WhileStatement":\n          return group(["while (", group([indent([softline, print("test")]), softline]), ")", adjustClause(node.body, print("body"))]);\n        case "ForInStatement":\n          return group(["for (", print("left"), " in ", print("right"), ")", adjustClause(node.body, print("body"))]);\n        case "ForOfStatement":\n          return group(["for", node.await ? " await" : "", " (", print("left"), " of ", print("right"), ")", adjustClause(node.body, print("body"))]);\n        case "DoWhileStatement": {\n          const clause = adjustClause(node.body, print("body"));\n          const doBody = group(["do", clause]);\n          parts = [doBody];\n          if (node.body.type === "BlockStatement") {\n            parts.push(" ");\n          } else {\n            parts.push(hardline);\n          }\n          parts.push("while (", group([indent([softline, print("test")]), softline]), ")", semi);\n          return parts;\n        }\n        case "DoExpression":\n          return [node.async ? "async " : "", "do ", print("body")];\n        case "BreakStatement":\n          parts.push("break");\n          if (node.label) {\n            parts.push(" ", print("label"));\n          }\n          parts.push(semi);\n          return parts;\n        case "ContinueStatement":\n          parts.push("continue");\n          if (node.label) {\n            parts.push(" ", print("label"));\n          }\n          parts.push(semi);\n          return parts;\n        case "LabeledStatement":\n          if (node.body.type === "EmptyStatement") {\n            return [print("label"), ":;"];\n          }\n          return [print("label"), ": ", print("body")];\n        case "TryStatement":\n          return ["try ", print("block"), node.handler ? [" ", print("handler")] : "", node.finalizer ? [" finally ", print("finalizer")] : ""];\n        case "CatchClause":\n          if (node.param) {\n            const parameterHasComments = hasComment(node.param, (comment) => !isBlockComment(comment) || comment.leading && hasNewline(options.originalText, locEnd(comment)) || comment.trailing && hasNewline(options.originalText, locStart(comment), {\n              backwards: true\n            }));\n            const param = print("param");\n            return ["catch ", parameterHasComments ? ["(", indent([softline, param]), softline, ") "] : ["(", param, ") "], print("body")];\n          }\n          return ["catch ", print("body")];\n        case "SwitchStatement":\n          return [group(["switch (", indent([softline, print("discriminant")]), softline, ")"]), " {", node.cases.length > 0 ? indent([hardline, join(hardline, path.map((casePath, index, cases) => {\n            const caseNode = casePath.getValue();\n            return [print(), index !== cases.length - 1 && isNextLineEmpty(caseNode, options) ? hardline : ""];\n          }, "cases"))]) : "", hardline, "}"];\n        case "SwitchCase": {\n          if (node.test) {\n            parts.push("case ", print("test"), ":");\n          } else {\n            parts.push("default:");\n          }\n          if (hasComment(node, CommentCheckFlags.Dangling)) {\n            parts.push(" ", printDanglingComments(path, options, true));\n          }\n          const consequent = node.consequent.filter((node2) => node2.type !== "EmptyStatement");\n          if (consequent.length > 0) {\n            const cons = printSwitchCaseConsequent(path, options, print);\n            parts.push(consequent.length === 1 && consequent[0].type === "BlockStatement" ? [" ", cons] : indent([hardline, cons]));\n          }\n          return parts;\n        }\n        case "DebuggerStatement":\n          return ["debugger", semi];\n        case "ClassDeclaration":\n        case "ClassExpression":\n          return printClass(path, options, print);\n        case "ClassMethod":\n        case "ClassPrivateMethod":\n        case "MethodDefinition":\n          return printClassMethod(path, options, print);\n        case "ClassProperty":\n        case "PropertyDefinition":\n        case "ClassPrivateProperty":\n        case "ClassAccessorProperty":\n        case "AccessorProperty":\n          return printClassProperty(path, options, print);\n        case "TemplateElement":\n          return replaceTextEndOfLine(node.value.raw);\n        case "TemplateLiteral":\n          return printTemplateLiteral(path, print, options);\n        case "TaggedTemplateExpression":\n          return [print("tag"), print("typeParameters"), print("quasi")];\n        case "PrivateIdentifier":\n          return ["#", print("name")];\n        case "PrivateName":\n          return ["#", print("id")];\n        case "InterpreterDirective":\n          parts.push("#!", node.value, hardline);\n          if (isNextLineEmpty(node, options)) {\n            parts.push(hardline);\n          }\n          return parts;\n        case "TopicReference":\n          return "%";\n        case "ArgumentPlaceholder":\n          return "?";\n        case "ModuleExpression": {\n          parts.push("module {");\n          const printed = print("body");\n          if (printed) {\n            parts.push(indent([hardline, printed]), hardline);\n          }\n          parts.push("}");\n          return parts;\n        }\n        default:\n          throw new Error("unknown type: " + JSON.stringify(node.type));\n      }\n    }\n    function canAttachComment(node) {\n      return node.type && !isBlockComment(node) && !isLineComment(node) && node.type !== "EmptyStatement" && node.type !== "TemplateElement" && node.type !== "Import" && node.type !== "TSEmptyBodyFunctionExpression";\n    }\n    module2.exports = {\n      preprocess,\n      print: genericPrint,\n      embed,\n      insertPragma,\n      massageAstNode: clean,\n      hasPrettierIgnore(path) {\n        return hasIgnoreComment(path) || hasJsxIgnoreComment(path);\n      },\n      willPrintOwnComments: handleComments.willPrintOwnComments,\n      canAttachComment,\n      printComment,\n      isBlockComment,\n      handleComments: {\n        avoidAstMutation: true,\n        ownLine: handleComments.handleOwnLineComment,\n        endOfLine: handleComments.handleEndOfLineComment,\n        remaining: handleComments.handleRemainingComment\n      },\n      getCommentChildNodes: handleComments.getCommentChildNodes\n    };\n  }\n});\nvar require_printer_estree_json = __commonJS2({\n  "src/language-js/printer-estree-json.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        hardline,\n        indent,\n        join\n      }\n    } = require("./doc.js");\n    var preprocess = require_print_preprocess();\n    function genericPrint(path, options, print) {\n      const node = path.getValue();\n      switch (node.type) {\n        case "JsonRoot":\n          return [print("node"), hardline];\n        case "ArrayExpression": {\n          if (node.elements.length === 0) {\n            return "[]";\n          }\n          const printed = path.map(() => path.getValue() === null ? "null" : print(), "elements");\n          return ["[", indent([hardline, join([",", hardline], printed)]), hardline, "]"];\n        }\n        case "ObjectExpression":\n          return node.properties.length === 0 ? "{}" : ["{", indent([hardline, join([",", hardline], path.map(print, "properties"))]), hardline, "}"];\n        case "ObjectProperty":\n          return [print("key"), ": ", print("value")];\n        case "UnaryExpression":\n          return [node.operator === "+" ? "" : node.operator, print("argument")];\n        case "NullLiteral":\n          return "null";\n        case "BooleanLiteral":\n          return node.value ? "true" : "false";\n        case "StringLiteral":\n          return JSON.stringify(node.value);\n        case "NumericLiteral":\n          return isObjectKey(path) ? JSON.stringify(String(node.value)) : JSON.stringify(node.value);\n        case "Identifier":\n          return isObjectKey(path) ? JSON.stringify(node.name) : node.name;\n        case "TemplateLiteral":\n          return print(["quasis", 0]);\n        case "TemplateElement":\n          return JSON.stringify(node.value.cooked);\n        default:\n          throw new Error("unknown type: " + JSON.stringify(node.type));\n      }\n    }\n    function isObjectKey(path) {\n      return path.getName() === "key" && path.getParentNode().type === "ObjectProperty";\n    }\n    var ignoredProperties = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);\n    function clean(node, newNode) {\n      const {\n        type\n      } = node;\n      if (type === "ObjectProperty") {\n        const {\n          key\n        } = node;\n        if (key.type === "Identifier") {\n          newNode.key = {\n            type: "StringLiteral",\n            value: key.name\n          };\n        } else if (key.type === "NumericLiteral") {\n          newNode.key = {\n            type: "StringLiteral",\n            value: String(key.value)\n          };\n        }\n        return;\n      }\n      if (type === "UnaryExpression" && node.operator === "+") {\n        return newNode.argument;\n      }\n      if (type === "ArrayExpression") {\n        for (const [index, element] of node.elements.entries()) {\n          if (element === null) {\n            newNode.elements.splice(index, 0, {\n              type: "NullLiteral"\n            });\n          }\n        }\n        return;\n      }\n      if (type === "TemplateLiteral") {\n        return {\n          type: "StringLiteral",\n          value: node.quasis[0].value.cooked\n        };\n      }\n    }\n    clean.ignoredProperties = ignoredProperties;\n    module2.exports = {\n      preprocess,\n      print: genericPrint,\n      massageAstNode: clean\n    };\n  }\n});\nvar require_common_options = __commonJS2({\n  "src/common/common-options.js"(exports2, module2) {\n    "use strict";\n    var CATEGORY_COMMON = "Common";\n    module2.exports = {\n      bracketSpacing: {\n        since: "0.0.0",\n        category: CATEGORY_COMMON,\n        type: "boolean",\n        default: true,\n        description: "Print spaces between brackets.",\n        oppositeDescription: "Do not print spaces between brackets."\n      },\n      singleQuote: {\n        since: "0.0.0",\n        category: CATEGORY_COMMON,\n        type: "boolean",\n        default: false,\n        description: "Use single quotes instead of double quotes."\n      },\n      proseWrap: {\n        since: "1.8.2",\n        category: CATEGORY_COMMON,\n        type: "choice",\n        default: [{\n          since: "1.8.2",\n          value: true\n        }, {\n          since: "1.9.0",\n          value: "preserve"\n        }],\n        description: "How to wrap prose.",\n        choices: [{\n          since: "1.9.0",\n          value: "always",\n          description: "Wrap prose if it exceeds the print width."\n        }, {\n          since: "1.9.0",\n          value: "never",\n          description: "Do not wrap prose."\n        }, {\n          since: "1.9.0",\n          value: "preserve",\n          description: "Wrap prose as-is."\n        }]\n      },\n      bracketSameLine: {\n        since: "2.4.0",\n        category: CATEGORY_COMMON,\n        type: "boolean",\n        default: false,\n        description: "Put > of opening tags on the last line instead of on a new line."\n      },\n      singleAttributePerLine: {\n        since: "2.6.0",\n        category: CATEGORY_COMMON,\n        type: "boolean",\n        default: false,\n        description: "Enforce single attribute per line in HTML, Vue and JSX."\n      }\n    };\n  }\n});\nvar require_options2 = __commonJS2({\n  "src/language-js/options.js"(exports2, module2) {\n    "use strict";\n    var commonOptions = require_common_options();\n    var CATEGORY_JAVASCRIPT = "JavaScript";\n    module2.exports = {\n      arrowParens: {\n        since: "1.9.0",\n        category: CATEGORY_JAVASCRIPT,\n        type: "choice",\n        default: [{\n          since: "1.9.0",\n          value: "avoid"\n        }, {\n          since: "2.0.0",\n          value: "always"\n        }],\n        description: "Include parentheses around a sole arrow function parameter.",\n        choices: [{\n          value: "always",\n          description: "Always include parens. Example: `(x) => x`"\n        }, {\n          value: "avoid",\n          description: "Omit parens when possible. Example: `x => x`"\n        }]\n      },\n      bracketSameLine: commonOptions.bracketSameLine,\n      bracketSpacing: commonOptions.bracketSpacing,\n      jsxBracketSameLine: {\n        since: "0.17.0",\n        category: CATEGORY_JAVASCRIPT,\n        type: "boolean",\n        description: "Put > on the last line instead of at a new line.",\n        deprecated: "2.4.0"\n      },\n      semi: {\n        since: "1.0.0",\n        category: CATEGORY_JAVASCRIPT,\n        type: "boolean",\n        default: true,\n        description: "Print semicolons.",\n        oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."\n      },\n      singleQuote: commonOptions.singleQuote,\n      jsxSingleQuote: {\n        since: "1.15.0",\n        category: CATEGORY_JAVASCRIPT,\n        type: "boolean",\n        default: false,\n        description: "Use single quotes in JSX."\n      },\n      quoteProps: {\n        since: "1.17.0",\n        category: CATEGORY_JAVASCRIPT,\n        type: "choice",\n        default: "as-needed",\n        description: "Change when properties in objects are quoted.",\n        choices: [{\n          value: "as-needed",\n          description: "Only add quotes around object properties where required."\n        }, {\n          value: "consistent",\n          description: "If at least one property in an object requires quotes, quote all properties."\n        }, {\n          value: "preserve",\n          description: "Respect the input use of quotes in object properties."\n        }]\n      },\n      trailingComma: {\n        since: "0.0.0",\n        category: CATEGORY_JAVASCRIPT,\n        type: "choice",\n        default: [{\n          since: "0.0.0",\n          value: false\n        }, {\n          since: "0.19.0",\n          value: "none"\n        }, {\n          since: "2.0.0",\n          value: "es5"\n        }],\n        description: "Print trailing commas wherever possible when multi-line.",\n        choices: [{\n          value: "es5",\n          description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"\n        }, {\n          value: "none",\n          description: "No trailing commas."\n        }, {\n          value: "all",\n          description: "Trailing commas wherever possible (including function arguments)."\n        }]\n      },\n      singleAttributePerLine: commonOptions.singleAttributePerLine\n    };\n  }\n});\nvar require_parsers = __commonJS2({\n  "src/language-js/parse/parsers.js"(exports2, module2) {\n    "use strict";\n    module2.exports = {\n      get babel() {\n        return require("./parser-babel.js").parsers.babel;\n      },\n      get "babel-flow"() {\n        return require("./parser-babel.js").parsers["babel-flow"];\n      },\n      get "babel-ts"() {\n        return require("./parser-babel.js").parsers["babel-ts"];\n      },\n      get json() {\n        return require("./parser-babel.js").parsers.json;\n      },\n      get json5() {\n        return require("./parser-babel.js").parsers.json5;\n      },\n      get "json-stringify"() {\n        return require("./parser-babel.js").parsers["json-stringify"];\n      },\n      get __js_expression() {\n        return require("./parser-babel.js").parsers.__js_expression;\n      },\n      get __vue_expression() {\n        return require("./parser-babel.js").parsers.__vue_expression;\n      },\n      get __vue_ts_expression() {\n        return require("./parser-babel.js").parsers.__vue_ts_expression;\n      },\n      get __vue_event_binding() {\n        return require("./parser-babel.js").parsers.__vue_event_binding;\n      },\n      get __vue_ts_event_binding() {\n        return require("./parser-babel.js").parsers.__vue_ts_event_binding;\n      },\n      get flow() {\n        return require("./parser-flow.js").parsers.flow;\n      },\n      get typescript() {\n        return require("./parser-typescript.js").parsers.typescript;\n      },\n      get __ng_action() {\n        return require("./parser-angular.js").parsers.__ng_action;\n      },\n      get __ng_binding() {\n        return require("./parser-angular.js").parsers.__ng_binding;\n      },\n      get __ng_interpolation() {\n        return require("./parser-angular.js").parsers.__ng_interpolation;\n      },\n      get __ng_directive() {\n        return require("./parser-angular.js").parsers.__ng_directive;\n      },\n      get acorn() {\n        return require("./parser-espree.js").parsers.acorn;\n      },\n      get espree() {\n        return require("./parser-espree.js").parsers.espree;\n      },\n      get meriyah() {\n        return require("./parser-meriyah.js").parsers.meriyah;\n      },\n      get __babel_estree() {\n        return require("./parser-babel.js").parsers.__babel_estree;\n      }\n    };\n  }\n});\nvar require_JavaScript = __commonJS2({\n  "node_modules/linguist-languages/data/JavaScript.json"(exports2, module2) {\n    module2.exports = {\n      name: "JavaScript",\n      type: "programming",\n      tmScope: "source.js",\n      aceMode: "javascript",\n      codemirrorMode: "javascript",\n      codemirrorMimeType: "text/javascript",\n      color: "#f1e05a",\n      aliases: ["js", "node"],\n      extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"],\n      filenames: ["Jakefile"],\n      interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"],\n      languageId: 183\n    };\n  }\n});\nvar require_TypeScript = __commonJS2({\n  "node_modules/linguist-languages/data/TypeScript.json"(exports2, module2) {\n    module2.exports = {\n      name: "TypeScript",\n      type: "programming",\n      color: "#3178c6",\n      aliases: ["ts"],\n      interpreters: ["deno", "ts-node"],\n      extensions: [".ts", ".cts", ".mts"],\n      tmScope: "source.ts",\n      aceMode: "typescript",\n      codemirrorMode: "javascript",\n      codemirrorMimeType: "application/typescript",\n      languageId: 378\n    };\n  }\n});\nvar require_TSX = __commonJS2({\n  "node_modules/linguist-languages/data/TSX.json"(exports2, module2) {\n    module2.exports = {\n      name: "TSX",\n      type: "programming",\n      color: "#3178c6",\n      group: "TypeScript",\n      extensions: [".tsx"],\n      tmScope: "source.tsx",\n      aceMode: "javascript",\n      codemirrorMode: "jsx",\n      codemirrorMimeType: "text/jsx",\n      languageId: 94901924\n    };\n  }\n});\nvar require_JSON = __commonJS2({\n  "node_modules/linguist-languages/data/JSON.json"(exports2, module2) {\n    module2.exports = {\n      name: "JSON",\n      type: "data",\n      color: "#292929",\n      tmScope: "source.json",\n      aceMode: "json",\n      codemirrorMode: "javascript",\n      codemirrorMimeType: "application/json",\n      aliases: ["geojson", "jsonl", "topojson"],\n      extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"],\n      filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"],\n      languageId: 174\n    };\n  }\n});\nvar require_JSON_with_Comments = __commonJS2({\n  "node_modules/linguist-languages/data/JSON with Comments.json"(exports2, module2) {\n    module2.exports = {\n      name: "JSON with Comments",\n      type: "data",\n      color: "#292929",\n      group: "JSON",\n      tmScope: "source.js",\n      aceMode: "javascript",\n      codemirrorMode: "javascript",\n      codemirrorMimeType: "text/javascript",\n      aliases: ["jsonc"],\n      extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"],\n      filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"],\n      languageId: 423\n    };\n  }\n});\nvar require_JSON5 = __commonJS2({\n  "node_modules/linguist-languages/data/JSON5.json"(exports2, module2) {\n    module2.exports = {\n      name: "JSON5",\n      type: "data",\n      color: "#267CB9",\n      extensions: [".json5"],\n      tmScope: "source.js",\n      aceMode: "javascript",\n      codemirrorMode: "javascript",\n      codemirrorMimeType: "application/json",\n      languageId: 175\n    };\n  }\n});\nvar require_language_js = __commonJS2({\n  "src/language-js/index.js"(exports2, module2) {\n    "use strict";\n    var createLanguage = require_create_language();\n    var estreePrinter = require_printer_estree();\n    var estreeJsonPrinter = require_printer_estree_json();\n    var options = require_options2();\n    var parsers = require_parsers();\n    var languages = [createLanguage(require_JavaScript(), (data) => ({\n      since: "0.0.0",\n      parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"],\n      vscodeLanguageIds: ["javascript", "mongo"],\n      interpreters: [...data.interpreters, "zx"],\n      extensions: [...data.extensions.filter((extension) => extension !== ".jsx"), ".wxs"]\n    })), createLanguage(require_JavaScript(), () => ({\n      name: "Flow",\n      since: "0.0.0",\n      parsers: ["flow", "babel-flow"],\n      vscodeLanguageIds: ["javascript"],\n      aliases: [],\n      filenames: [],\n      extensions: [".js.flow"]\n    })), createLanguage(require_JavaScript(), () => ({\n      name: "JSX",\n      since: "0.0.0",\n      parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"],\n      vscodeLanguageIds: ["javascriptreact"],\n      aliases: void 0,\n      filenames: void 0,\n      extensions: [".jsx"],\n      group: "JavaScript",\n      interpreters: void 0,\n      tmScope: "source.js.jsx",\n      aceMode: "javascript",\n      codemirrorMode: "jsx",\n      codemirrorMimeType: "text/jsx",\n      color: void 0\n    })), createLanguage(require_TypeScript(), () => ({\n      since: "1.4.0",\n      parsers: ["typescript", "babel-ts"],\n      vscodeLanguageIds: ["typescript"]\n    })), createLanguage(require_TSX(), () => ({\n      since: "1.4.0",\n      parsers: ["typescript", "babel-ts"],\n      vscodeLanguageIds: ["typescriptreact"]\n    })), createLanguage(require_JSON(), () => ({\n      name: "JSON.stringify",\n      since: "1.13.0",\n      parsers: ["json-stringify"],\n      vscodeLanguageIds: ["json"],\n      extensions: [".importmap"],\n      filenames: ["package.json", "package-lock.json", "composer.json"]\n    })), createLanguage(require_JSON(), (data) => ({\n      since: "1.5.0",\n      parsers: ["json"],\n      vscodeLanguageIds: ["json"],\n      extensions: data.extensions.filter((extension) => extension !== ".jsonl")\n    })), createLanguage(require_JSON_with_Comments(), (data) => ({\n      since: "1.5.0",\n      parsers: ["json"],\n      vscodeLanguageIds: ["jsonc"],\n      filenames: [...data.filenames, ".eslintrc", ".swcrc"]\n    })), createLanguage(require_JSON5(), () => ({\n      since: "1.13.0",\n      parsers: ["json5"],\n      vscodeLanguageIds: ["json5"]\n    }))];\n    var printers = {\n      estree: estreePrinter,\n      "estree-json": estreeJsonPrinter\n    };\n    module2.exports = {\n      languages,\n      options,\n      printers,\n      parsers\n    };\n  }\n});\nvar require_clean2 = __commonJS2({\n  "src/language-css/clean.js"(exports2, module2) {\n    "use strict";\n    var {\n      isFrontMatterNode\n    } = require_util();\n    var getLast = require_get_last();\n    var ignoredProperties = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);\n    function clean(ast, newObj, parent) {\n      if (isFrontMatterNode(ast) && ast.lang === "yaml") {\n        delete newObj.value;\n      }\n      if (ast.type === "css-comment" && parent.type === "css-root" && parent.nodes.length > 0) {\n        if (parent.nodes[0] === ast || isFrontMatterNode(parent.nodes[0]) && parent.nodes[1] === ast) {\n          delete newObj.text;\n          if (/^\\*\\s*@(?:format|prettier)\\s*$/.test(ast.text)) {\n            return null;\n          }\n        }\n        if (parent.type === "css-root" && getLast(parent.nodes) === ast) {\n          return null;\n        }\n      }\n      if (ast.type === "value-root") {\n        delete newObj.text;\n      }\n      if (ast.type === "media-query" || ast.type === "media-query-list" || ast.type === "media-feature-expression") {\n        delete newObj.value;\n      }\n      if (ast.type === "css-rule") {\n        delete newObj.params;\n      }\n      if (ast.type === "selector-combinator") {\n        newObj.value = newObj.value.replace(/\\s+/g, " ");\n      }\n      if (ast.type === "media-feature") {\n        newObj.value = newObj.value.replace(/ /g, "");\n      }\n      if (ast.type === "value-word" && (ast.isColor && ast.isHex || ["initial", "inherit", "unset", "revert"].includes(newObj.value.replace().toLowerCase())) || ast.type === "media-feature" || ast.type === "selector-root-invalid" || ast.type === "selector-pseudo") {\n        newObj.value = newObj.value.toLowerCase();\n      }\n      if (ast.type === "css-decl") {\n        newObj.prop = newObj.prop.toLowerCase();\n      }\n      if (ast.type === "css-atrule" || ast.type === "css-import") {\n        newObj.name = newObj.name.toLowerCase();\n      }\n      if (ast.type === "value-number") {\n        newObj.unit = newObj.unit.toLowerCase();\n      }\n      if ((ast.type === "media-feature" || ast.type === "media-keyword" || ast.type === "media-type" || ast.type === "media-unknown" || ast.type === "media-url" || ast.type === "media-value" || ast.type === "selector-attribute" || ast.type === "selector-string" || ast.type === "selector-class" || ast.type === "selector-combinator" || ast.type === "value-string") && newObj.value) {\n        newObj.value = cleanCSSStrings(newObj.value);\n      }\n      if (ast.type === "selector-attribute") {\n        newObj.attribute = newObj.attribute.trim();\n        if (newObj.namespace) {\n          if (typeof newObj.namespace === "string") {\n            newObj.namespace = newObj.namespace.trim();\n            if (newObj.namespace.length === 0) {\n              newObj.namespace = true;\n            }\n          }\n        }\n        if (newObj.value) {\n          newObj.value = newObj.value.trim().replace(/^["\']|["\']$/g, "");\n          delete newObj.quoted;\n        }\n      }\n      if ((ast.type === "media-value" || ast.type === "media-type" || ast.type === "value-number" || ast.type === "selector-root-invalid" || ast.type === "selector-class" || ast.type === "selector-combinator" || ast.type === "selector-tag") && newObj.value) {\n        newObj.value = newObj.value.replace(/([\\d+.Ee-]+)([A-Za-z]*)/g, (match, numStr, unit) => {\n          const num = Number(numStr);\n          return Number.isNaN(num) ? match : num + unit.toLowerCase();\n        });\n      }\n      if (ast.type === "selector-tag") {\n        const lowercasedValue = ast.value.toLowerCase();\n        if (["from", "to"].includes(lowercasedValue)) {\n          newObj.value = lowercasedValue;\n        }\n      }\n      if (ast.type === "css-atrule" && ast.name.toLowerCase() === "supports") {\n        delete newObj.value;\n      }\n      if (ast.type === "selector-unknown") {\n        delete newObj.value;\n      }\n      if (ast.type === "value-comma_group") {\n        const index = ast.groups.findIndex((node) => node.type === "value-number" && node.unit === "...");\n        if (index !== -1) {\n          newObj.groups[index].unit = "";\n          newObj.groups.splice(index + 1, 0, {\n            type: "value-word",\n            value: "...",\n            isColor: false,\n            isHex: false\n          });\n        }\n      }\n      if (ast.type === "value-comma_group" && ast.groups.some((node) => node.type === "value-atword" && node.value.endsWith("[") || node.type === "value-word" && node.value.startsWith("]"))) {\n        return {\n          type: "value-atword",\n          value: ast.groups.map((node) => node.value).join(""),\n          group: {\n            open: null,\n            close: null,\n            groups: [],\n            type: "value-paren_group"\n          }\n        };\n      }\n    }\n    clean.ignoredProperties = ignoredProperties;\n    function cleanCSSStrings(value) {\n      return value.replace(/\'/g, \'"\').replace(/\\\\([^\\dA-Fa-f])/g, "$1");\n    }\n    module2.exports = clean;\n  }\n});\nvar require_print = __commonJS2({\n  "src/utils/front-matter/print.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        hardline,\n        markAsRoot\n      }\n    } = require("./doc.js");\n    function print(node, textToDoc) {\n      if (node.lang === "yaml") {\n        const value = node.value.trim();\n        const doc2 = value ? textToDoc(value, {\n          parser: "yaml"\n        }, {\n          stripTrailingHardline: true\n        }) : "";\n        return markAsRoot([node.startDelimiter, hardline, doc2, doc2 ? hardline : "", node.endDelimiter]);\n      }\n    }\n    module2.exports = print;\n  }\n});\nvar require_embed2 = __commonJS2({\n  "src/language-css/embed.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        hardline\n      }\n    } = require("./doc.js");\n    var printFrontMatter = require_print();\n    function embed(path, print, textToDoc) {\n      const node = path.getValue();\n      if (node.type === "front-matter") {\n        const doc2 = printFrontMatter(node, textToDoc);\n        return doc2 ? [doc2, hardline] : "";\n      }\n    }\n    module2.exports = embed;\n  }\n});\nvar require_parse4 = __commonJS2({\n  "src/utils/front-matter/parse.js"(exports2, module2) {\n    "use strict";\n    var frontMatterRegex = new RegExp("^(?<startDelimiter>-{3}|\\\\+{3})(?<language>[^\\\\n]*)\\\\n(?:|(?<value>.*?)\\\\n)(?<endDelimiter>\\\\k<startDelimiter>|\\\\.{3})[^\\\\S\\\\n]*(?:\\\\n|$)", "s");\n    function parse(text) {\n      const match = text.match(frontMatterRegex);\n      if (!match) {\n        return {\n          content: text\n        };\n      }\n      const {\n        startDelimiter,\n        language,\n        value = "",\n        endDelimiter\n      } = match.groups;\n      let lang = language.trim() || "yaml";\n      if (startDelimiter === "+++") {\n        lang = "toml";\n      }\n      if (lang !== "yaml" && startDelimiter !== endDelimiter) {\n        return {\n          content: text\n        };\n      }\n      const [raw] = match;\n      const frontMatter = {\n        type: "front-matter",\n        lang,\n        value,\n        startDelimiter,\n        endDelimiter,\n        raw: raw.replace(/\\n$/, "")\n      };\n      return {\n        frontMatter,\n        content: raw.replace(/[^\\n]/g, " ") + text.slice(raw.length)\n      };\n    }\n    module2.exports = parse;\n  }\n});\nvar require_pragma2 = __commonJS2({\n  "src/language-css/pragma.js"(exports2, module2) {\n    "use strict";\n    var jsPragma = require_pragma();\n    var parseFrontMatter = require_parse4();\n    function hasPragma(text) {\n      return jsPragma.hasPragma(parseFrontMatter(text).content);\n    }\n    function insertPragma(text) {\n      const {\n        frontMatter,\n        content\n      } = parseFrontMatter(text);\n      return (frontMatter ? frontMatter.raw + "\\n\\n" : "") + jsPragma.insertPragma(content);\n    }\n    module2.exports = {\n      hasPragma,\n      insertPragma\n    };\n  }\n});\nvar require_utils8 = __commonJS2({\n  "src/language-css/utils/index.js"(exports2, module2) {\n    "use strict";\n    var colorAdjusterFunctions = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);\n    function getAncestorCounter(path, typeOrTypes) {\n      const types = Array.isArray(typeOrTypes) ? typeOrTypes : [typeOrTypes];\n      let counter = -1;\n      let ancestorNode;\n      while (ancestorNode = path.getParentNode(++counter)) {\n        if (types.includes(ancestorNode.type)) {\n          return counter;\n        }\n      }\n      return -1;\n    }\n    function getAncestorNode(path, typeOrTypes) {\n      const counter = getAncestorCounter(path, typeOrTypes);\n      return counter === -1 ? null : path.getParentNode(counter);\n    }\n    function getPropOfDeclNode(path) {\n      var _declAncestorNode$pro;\n      const declAncestorNode = getAncestorNode(path, "css-decl");\n      return declAncestorNode === null || declAncestorNode === void 0 ? void 0 : (_declAncestorNode$pro = declAncestorNode.prop) === null || _declAncestorNode$pro === void 0 ? void 0 : _declAncestorNode$pro.toLowerCase();\n    }\n    var wideKeywords = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);\n    function isWideKeywords(value) {\n      return wideKeywords.has(value.toLowerCase());\n    }\n    function isKeyframeAtRuleKeywords(path, value) {\n      const atRuleAncestorNode = getAncestorNode(path, "css-atrule");\n      return (atRuleAncestorNode === null || atRuleAncestorNode === void 0 ? void 0 : atRuleAncestorNode.name) && atRuleAncestorNode.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(value.toLowerCase());\n    }\n    function maybeToLowerCase(value) {\n      return value.includes("$") || value.includes("@") || value.includes("#") || value.startsWith("%") || value.startsWith("--") || value.startsWith(":--") || value.includes("(") && value.includes(")") ? value : value.toLowerCase();\n    }\n    function insideValueFunctionNode(path, functionName) {\n      var _funcAncestorNode$val;\n      const funcAncestorNode = getAncestorNode(path, "value-func");\n      return (funcAncestorNode === null || funcAncestorNode === void 0 ? void 0 : (_funcAncestorNode$val = funcAncestorNode.value) === null || _funcAncestorNode$val === void 0 ? void 0 : _funcAncestorNode$val.toLowerCase()) === functionName;\n    }\n    function insideICSSRuleNode(path) {\n      var _ruleAncestorNode$raw;\n      const ruleAncestorNode = getAncestorNode(path, "css-rule");\n      const selector = ruleAncestorNode === null || ruleAncestorNode === void 0 ? void 0 : (_ruleAncestorNode$raw = ruleAncestorNode.raws) === null || _ruleAncestorNode$raw === void 0 ? void 0 : _ruleAncestorNode$raw.selector;\n      return selector && (selector.startsWith(":import") || selector.startsWith(":export"));\n    }\n    function insideAtRuleNode(path, atRuleNameOrAtRuleNames) {\n      const atRuleNames = Array.isArray(atRuleNameOrAtRuleNames) ? atRuleNameOrAtRuleNames : [atRuleNameOrAtRuleNames];\n      const atRuleAncestorNode = getAncestorNode(path, "css-atrule");\n      return atRuleAncestorNode && atRuleNames.includes(atRuleAncestorNode.name.toLowerCase());\n    }\n    function insideURLFunctionInImportAtRuleNode(path) {\n      const node = path.getValue();\n      const atRuleAncestorNode = getAncestorNode(path, "css-atrule");\n      return (atRuleAncestorNode === null || atRuleAncestorNode === void 0 ? void 0 : atRuleAncestorNode.name) === "import" && node.groups[0].value === "url" && node.groups.length === 2;\n    }\n    function isURLFunctionNode(node) {\n      return node.type === "value-func" && node.value.toLowerCase() === "url";\n    }\n    function isLastNode(path, node) {\n      var _path$getParentNode;\n      const nodes = (_path$getParentNode = path.getParentNode()) === null || _path$getParentNode === void 0 ? void 0 : _path$getParentNode.nodes;\n      return nodes && nodes.indexOf(node) === nodes.length - 1;\n    }\n    function isDetachedRulesetDeclarationNode(node) {\n      const {\n        selector\n      } = node;\n      if (!selector) {\n        return false;\n      }\n      return typeof selector === "string" && /^@.+:.*$/.test(selector) || selector.value && /^@.+:.*$/.test(selector.value);\n    }\n    function isForKeywordNode(node) {\n      return node.type === "value-word" && ["from", "through", "end"].includes(node.value);\n    }\n    function isIfElseKeywordNode(node) {\n      return node.type === "value-word" && ["and", "or", "not"].includes(node.value);\n    }\n    function isEachKeywordNode(node) {\n      return node.type === "value-word" && node.value === "in";\n    }\n    function isMultiplicationNode(node) {\n      return node.type === "value-operator" && node.value === "*";\n    }\n    function isDivisionNode(node) {\n      return node.type === "value-operator" && node.value === "/";\n    }\n    function isAdditionNode(node) {\n      return node.type === "value-operator" && node.value === "+";\n    }\n    function isSubtractionNode(node) {\n      return node.type === "value-operator" && node.value === "-";\n    }\n    function isModuloNode(node) {\n      return node.type === "value-operator" && node.value === "%";\n    }\n    function isMathOperatorNode(node) {\n      return isMultiplicationNode(node) || isDivisionNode(node) || isAdditionNode(node) || isSubtractionNode(node) || isModuloNode(node);\n    }\n    function isEqualityOperatorNode(node) {\n      return node.type === "value-word" && ["==", "!="].includes(node.value);\n    }\n    function isRelationalOperatorNode(node) {\n      return node.type === "value-word" && ["<", ">", "<=", ">="].includes(node.value);\n    }\n    function isSCSSControlDirectiveNode(node) {\n      return node.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(node.name);\n    }\n    function isDetachedRulesetCallNode(node) {\n      var _node$raws;\n      return ((_node$raws = node.raws) === null || _node$raws === void 0 ? void 0 : _node$raws.params) && /^\\(\\s*\\)$/.test(node.raws.params);\n    }\n    function isTemplatePlaceholderNode(node) {\n      return node.name.startsWith("prettier-placeholder");\n    }\n    function isTemplatePropNode(node) {\n      return node.prop.startsWith("@prettier-placeholder");\n    }\n    function isPostcssSimpleVarNode(currentNode, nextNode) {\n      return currentNode.value === "$$" && currentNode.type === "value-func" && (nextNode === null || nextNode === void 0 ? void 0 : nextNode.type) === "value-word" && !nextNode.raws.before;\n    }\n    function hasComposesNode(node) {\n      var _node$value, _node$value$group;\n      return ((_node$value = node.value) === null || _node$value === void 0 ? void 0 : _node$value.type) === "value-root" && ((_node$value$group = node.value.group) === null || _node$value$group === void 0 ? void 0 : _node$value$group.type) === "value-value" && node.prop.toLowerCase() === "composes";\n    }\n    function hasParensAroundNode(node) {\n      var _node$value2, _node$value2$group, _node$value2$group$gr;\n      return ((_node$value2 = node.value) === null || _node$value2 === void 0 ? void 0 : (_node$value2$group = _node$value2.group) === null || _node$value2$group === void 0 ? void 0 : (_node$value2$group$gr = _node$value2$group.group) === null || _node$value2$group$gr === void 0 ? void 0 : _node$value2$group$gr.type) === "value-paren_group" && node.value.group.group.open !== null && node.value.group.group.close !== null;\n    }\n    function hasEmptyRawBefore(node) {\n      var _node$raws2;\n      return ((_node$raws2 = node.raws) === null || _node$raws2 === void 0 ? void 0 : _node$raws2.before) === "";\n    }\n    function isKeyValuePairNode(node) {\n      var _node$groups, _node$groups$;\n      return node.type === "value-comma_group" && ((_node$groups = node.groups) === null || _node$groups === void 0 ? void 0 : (_node$groups$ = _node$groups[1]) === null || _node$groups$ === void 0 ? void 0 : _node$groups$.type) === "value-colon";\n    }\n    function isKeyValuePairInParenGroupNode(node) {\n      var _node$groups2;\n      return node.type === "value-paren_group" && ((_node$groups2 = node.groups) === null || _node$groups2 === void 0 ? void 0 : _node$groups2[0]) && isKeyValuePairNode(node.groups[0]);\n    }\n    function isSCSSMapItemNode(path) {\n      var _declNode$prop;\n      const node = path.getValue();\n      if (node.groups.length === 0) {\n        return false;\n      }\n      const parentParentNode = path.getParentNode(1);\n      if (!isKeyValuePairInParenGroupNode(node) && !(parentParentNode && isKeyValuePairInParenGroupNode(parentParentNode))) {\n        return false;\n      }\n      const declNode = getAncestorNode(path, "css-decl");\n      if (declNode !== null && declNode !== void 0 && (_declNode$prop = declNode.prop) !== null && _declNode$prop !== void 0 && _declNode$prop.startsWith("$")) {\n        return true;\n      }\n      if (isKeyValuePairInParenGroupNode(parentParentNode)) {\n        return true;\n      }\n      if (parentParentNode.type === "value-func") {\n        return true;\n      }\n      return false;\n    }\n    function isInlineValueCommentNode(node) {\n      return node.type === "value-comment" && node.inline;\n    }\n    function isHashNode(node) {\n      return node.type === "value-word" && node.value === "#";\n    }\n    function isLeftCurlyBraceNode(node) {\n      return node.type === "value-word" && node.value === "{";\n    }\n    function isRightCurlyBraceNode(node) {\n      return node.type === "value-word" && node.value === "}";\n    }\n    function isWordNode(node) {\n      return ["value-word", "value-atword"].includes(node.type);\n    }\n    function isColonNode(node) {\n      return (node === null || node === void 0 ? void 0 : node.type) === "value-colon";\n    }\n    function isKeyInValuePairNode(node, parentNode) {\n      if (!isKeyValuePairNode(parentNode)) {\n        return false;\n      }\n      const {\n        groups\n      } = parentNode;\n      const index = groups.indexOf(node);\n      if (index === -1) {\n        return false;\n      }\n      return isColonNode(groups[index + 1]);\n    }\n    function isMediaAndSupportsKeywords(node) {\n      return node.value && ["not", "and", "or"].includes(node.value.toLowerCase());\n    }\n    function isColorAdjusterFuncNode(node) {\n      if (node.type !== "value-func") {\n        return false;\n      }\n      return colorAdjusterFunctions.has(node.value.toLowerCase());\n    }\n    function lastLineHasInlineComment(text) {\n      return /\\/\\//.test(text.split(/[\\n\\r]/).pop());\n    }\n    function isAtWordPlaceholderNode(node) {\n      return (node === null || node === void 0 ? void 0 : node.type) === "value-atword" && node.value.startsWith("prettier-placeholder-");\n    }\n    function isConfigurationNode(node, parentNode) {\n      var _node$open, _node$close;\n      if (((_node$open = node.open) === null || _node$open === void 0 ? void 0 : _node$open.value) !== "(" || ((_node$close = node.close) === null || _node$close === void 0 ? void 0 : _node$close.value) !== ")" || node.groups.some((group) => group.type !== "value-comma_group")) {\n        return false;\n      }\n      if (parentNode.type === "value-comma_group") {\n        const prevIdx = parentNode.groups.indexOf(node) - 1;\n        const maybeWithNode = parentNode.groups[prevIdx];\n        if ((maybeWithNode === null || maybeWithNode === void 0 ? void 0 : maybeWithNode.type) === "value-word" && maybeWithNode.value === "with") {\n          return true;\n        }\n      }\n      return false;\n    }\n    function isParenGroupNode(node) {\n      var _node$open2, _node$close2;\n      return node.type === "value-paren_group" && ((_node$open2 = node.open) === null || _node$open2 === void 0 ? void 0 : _node$open2.value) === "(" && ((_node$close2 = node.close) === null || _node$close2 === void 0 ? void 0 : _node$close2.value) === ")";\n    }\n    module2.exports = {\n      getAncestorCounter,\n      getAncestorNode,\n      getPropOfDeclNode,\n      maybeToLowerCase,\n      insideValueFunctionNode,\n      insideICSSRuleNode,\n      insideAtRuleNode,\n      insideURLFunctionInImportAtRuleNode,\n      isKeyframeAtRuleKeywords,\n      isWideKeywords,\n      isLastNode,\n      isSCSSControlDirectiveNode,\n      isDetachedRulesetDeclarationNode,\n      isRelationalOperatorNode,\n      isEqualityOperatorNode,\n      isMultiplicationNode,\n      isDivisionNode,\n      isAdditionNode,\n      isSubtractionNode,\n      isModuloNode,\n      isMathOperatorNode,\n      isEachKeywordNode,\n      isForKeywordNode,\n      isURLFunctionNode,\n      isIfElseKeywordNode,\n      hasComposesNode,\n      hasParensAroundNode,\n      hasEmptyRawBefore,\n      isDetachedRulesetCallNode,\n      isTemplatePlaceholderNode,\n      isTemplatePropNode,\n      isPostcssSimpleVarNode,\n      isKeyValuePairNode,\n      isKeyValuePairInParenGroupNode,\n      isKeyInValuePairNode,\n      isSCSSMapItemNode,\n      isInlineValueCommentNode,\n      isHashNode,\n      isLeftCurlyBraceNode,\n      isRightCurlyBraceNode,\n      isWordNode,\n      isColonNode,\n      isMediaAndSupportsKeywords,\n      isColorAdjusterFuncNode,\n      lastLineHasInlineComment,\n      isAtWordPlaceholderNode,\n      isConfigurationNode,\n      isParenGroupNode\n    };\n  }\n});\nvar require_line_column_to_index = __commonJS2({\n  "src/utils/line-column-to-index.js"(exports2, module2) {\n    "use strict";\n    module2.exports = function(lineColumn, text) {\n      let index = 0;\n      for (let i = 0; i < lineColumn.line - 1; ++i) {\n        index = text.indexOf("\\n", index) + 1;\n      }\n      return index + lineColumn.column;\n    };\n  }\n});\nvar require_loc2 = __commonJS2({\n  "src/language-css/loc.js"(exports2, module2) {\n    "use strict";\n    var {\n      skipEverythingButNewLine\n    } = require_skip();\n    var getLast = require_get_last();\n    var lineColumnToIndex = require_line_column_to_index();\n    function calculateLocStart(node, text) {\n      if (typeof node.sourceIndex === "number") {\n        return node.sourceIndex;\n      }\n      return node.source ? lineColumnToIndex(node.source.start, text) - 1 : null;\n    }\n    function calculateLocEnd(node, text) {\n      if (node.type === "css-comment" && node.inline) {\n        return skipEverythingButNewLine(text, node.source.startOffset);\n      }\n      const endNode = node.nodes && getLast(node.nodes);\n      if (endNode && node.source && !node.source.end) {\n        node = endNode;\n      }\n      if (node.source && node.source.end) {\n        return lineColumnToIndex(node.source.end, text);\n      }\n      return null;\n    }\n    function calculateLoc(node, text) {\n      if (node.source) {\n        node.source.startOffset = calculateLocStart(node, text);\n        node.source.endOffset = calculateLocEnd(node, text);\n      }\n      for (const key in node) {\n        const child = node[key];\n        if (key === "source" || !child || typeof child !== "object") {\n          continue;\n        }\n        if (child.type === "value-root" || child.type === "value-unknown") {\n          calculateValueNodeLoc(child, getValueRootOffset(node), child.text || child.value);\n        } else {\n          calculateLoc(child, text);\n        }\n      }\n    }\n    function calculateValueNodeLoc(node, rootOffset, text) {\n      if (node.source) {\n        node.source.startOffset = calculateLocStart(node, text) + rootOffset;\n        node.source.endOffset = calculateLocEnd(node, text) + rootOffset;\n      }\n      for (const key in node) {\n        const child = node[key];\n        if (key === "source" || !child || typeof child !== "object") {\n          continue;\n        }\n        calculateValueNodeLoc(child, rootOffset, text);\n      }\n    }\n    function getValueRootOffset(node) {\n      let result = node.source.startOffset;\n      if (typeof node.prop === "string") {\n        result += node.prop.length;\n      }\n      if (node.type === "css-atrule" && typeof node.name === "string") {\n        result += 1 + node.name.length + node.raws.afterName.match(/^\\s*:?\\s*/)[0].length;\n      }\n      if (node.type !== "css-atrule" && node.raws && typeof node.raws.between === "string") {\n        result += node.raws.between.length;\n      }\n      return result;\n    }\n    function replaceQuotesInInlineComments(text) {\n      let state = "initial";\n      let stateToReturnFromQuotes = "initial";\n      let inlineCommentStartIndex;\n      let inlineCommentContainsQuotes = false;\n      const inlineCommentsToReplace = [];\n      for (let i = 0; i < text.length; i++) {\n        const c = text[i];\n        switch (state) {\n          case "initial":\n            if (c === "\'") {\n              state = "single-quotes";\n              continue;\n            }\n            if (c === \'"\') {\n              state = "double-quotes";\n              continue;\n            }\n            if ((c === "u" || c === "U") && text.slice(i, i + 4).toLowerCase() === "url(") {\n              state = "url";\n              i += 3;\n              continue;\n            }\n            if (c === "*" && text[i - 1] === "/") {\n              state = "comment-block";\n              continue;\n            }\n            if (c === "/" && text[i - 1] === "/") {\n              state = "comment-inline";\n              inlineCommentStartIndex = i - 1;\n              continue;\n            }\n            continue;\n          case "single-quotes":\n            if (c === "\'" && text[i - 1] !== "\\\\") {\n              state = stateToReturnFromQuotes;\n              stateToReturnFromQuotes = "initial";\n            }\n            if (c === "\\n" || c === "\\r") {\n              return text;\n            }\n            continue;\n          case "double-quotes":\n            if (c === \'"\' && text[i - 1] !== "\\\\") {\n              state = stateToReturnFromQuotes;\n              stateToReturnFromQuotes = "initial";\n            }\n            if (c === "\\n" || c === "\\r") {\n              return text;\n            }\n            continue;\n          case "url":\n            if (c === ")") {\n              state = "initial";\n            }\n            if (c === "\\n" || c === "\\r") {\n              return text;\n            }\n            if (c === "\'") {\n              state = "single-quotes";\n              stateToReturnFromQuotes = "url";\n              continue;\n            }\n            if (c === \'"\') {\n              state = "double-quotes";\n              stateToReturnFromQuotes = "url";\n              continue;\n            }\n            continue;\n          case "comment-block":\n            if (c === "/" && text[i - 1] === "*") {\n              state = "initial";\n            }\n            continue;\n          case "comment-inline":\n            if (c === \'"\' || c === "\'" || c === "*") {\n              inlineCommentContainsQuotes = true;\n            }\n            if (c === "\\n" || c === "\\r") {\n              if (inlineCommentContainsQuotes) {\n                inlineCommentsToReplace.push([inlineCommentStartIndex, i]);\n              }\n              state = "initial";\n              inlineCommentContainsQuotes = false;\n            }\n            continue;\n        }\n      }\n      for (const [start, end] of inlineCommentsToReplace) {\n        text = text.slice(0, start) + text.slice(start, end).replace(/["\'*]/g, " ") + text.slice(end);\n      }\n      return text;\n    }\n    function locStart(node) {\n      return node.source.startOffset;\n    }\n    function locEnd(node) {\n      return node.source.endOffset;\n    }\n    module2.exports = {\n      locStart,\n      locEnd,\n      calculateLoc,\n      replaceQuotesInInlineComments\n    };\n  }\n});\nvar require_is_less_parser = __commonJS2({\n  "src/language-css/utils/is-less-parser.js"(exports2, module2) {\n    "use strict";\n    function isLessParser(options) {\n      return options.parser === "css" || options.parser === "less";\n    }\n    module2.exports = isLessParser;\n  }\n});\nvar require_is_scss = __commonJS2({\n  "src/language-css/utils/is-scss.js"(exports2, module2) {\n    "use strict";\n    function isSCSS(parser, text) {\n      const hasExplicitParserChoice = parser === "less" || parser === "scss";\n      const IS_POSSIBLY_SCSS = /(?:\\w\\s*:\\s*[^:}]+|#){|@import[^\\n]+(?:url|,)/;\n      return hasExplicitParserChoice ? parser === "scss" : IS_POSSIBLY_SCSS.test(text);\n    }\n    module2.exports = isSCSS;\n  }\n});\nvar require_css_units_evaluate = __commonJS2({\n  "src/language-css/utils/css-units.evaluate.js"(exports2, module2) {\n    module2.exports = {\n      em: "em",\n      rem: "rem",\n      ex: "ex",\n      rex: "rex",\n      cap: "cap",\n      rcap: "rcap",\n      ch: "ch",\n      rch: "rch",\n      ic: "ic",\n      ric: "ric",\n      lh: "lh",\n      rlh: "rlh",\n      vw: "vw",\n      svw: "svw",\n      lvw: "lvw",\n      dvw: "dvw",\n      vh: "vh",\n      svh: "svh",\n      lvh: "lvh",\n      dvh: "dvh",\n      vi: "vi",\n      svi: "svi",\n      lvi: "lvi",\n      dvi: "dvi",\n      vb: "vb",\n      svb: "svb",\n      lvb: "lvb",\n      dvb: "dvb",\n      vmin: "vmin",\n      svmin: "svmin",\n      lvmin: "lvmin",\n      dvmin: "dvmin",\n      vmax: "vmax",\n      svmax: "svmax",\n      lvmax: "lvmax",\n      dvmax: "dvmax",\n      cm: "cm",\n      mm: "mm",\n      q: "Q",\n      in: "in",\n      pt: "pt",\n      pc: "pc",\n      px: "px",\n      deg: "deg",\n      grad: "grad",\n      rad: "rad",\n      turn: "turn",\n      s: "s",\n      ms: "ms",\n      hz: "Hz",\n      khz: "kHz",\n      dpi: "dpi",\n      dpcm: "dpcm",\n      dppx: "dppx",\n      x: "x"\n    };\n  }\n});\nvar require_print_unit = __commonJS2({\n  "src/language-css/utils/print-unit.js"(exports2, module2) {\n    "use strict";\n    var CSS_UNITS = require_css_units_evaluate();\n    function printUnit(unit) {\n      const lowercased = unit.toLowerCase();\n      return Object.prototype.hasOwnProperty.call(CSS_UNITS, lowercased) ? CSS_UNITS[lowercased] : unit;\n    }\n    module2.exports = printUnit;\n  }\n});\nvar require_printer_postcss = __commonJS2({\n  "src/language-css/printer-postcss.js"(exports2, module2) {\n    "use strict";\n    var getLast = require_get_last();\n    var {\n      printNumber,\n      printString,\n      hasNewline,\n      isFrontMatterNode,\n      isNextLineEmpty,\n      isNonEmptyArray\n    } = require_util();\n    var {\n      builders: {\n        join,\n        line,\n        hardline,\n        softline,\n        group,\n        fill,\n        indent,\n        dedent,\n        ifBreak,\n        breakParent\n      },\n      utils: {\n        removeLines,\n        getDocParts\n      }\n    } = require("./doc.js");\n    var clean = require_clean2();\n    var embed = require_embed2();\n    var {\n      insertPragma\n    } = require_pragma2();\n    var {\n      getAncestorNode,\n      getPropOfDeclNode,\n      maybeToLowerCase,\n      insideValueFunctionNode,\n      insideICSSRuleNode,\n      insideAtRuleNode,\n      insideURLFunctionInImportAtRuleNode,\n      isKeyframeAtRuleKeywords,\n      isWideKeywords,\n      isLastNode,\n      isSCSSControlDirectiveNode,\n      isDetachedRulesetDeclarationNode,\n      isRelationalOperatorNode,\n      isEqualityOperatorNode,\n      isMultiplicationNode,\n      isDivisionNode,\n      isAdditionNode,\n      isSubtractionNode,\n      isMathOperatorNode,\n      isEachKeywordNode,\n      isForKeywordNode,\n      isURLFunctionNode,\n      isIfElseKeywordNode,\n      hasComposesNode,\n      hasParensAroundNode,\n      hasEmptyRawBefore,\n      isKeyValuePairNode,\n      isKeyInValuePairNode,\n      isDetachedRulesetCallNode,\n      isTemplatePlaceholderNode,\n      isTemplatePropNode,\n      isPostcssSimpleVarNode,\n      isSCSSMapItemNode,\n      isInlineValueCommentNode,\n      isHashNode,\n      isLeftCurlyBraceNode,\n      isRightCurlyBraceNode,\n      isWordNode,\n      isColonNode,\n      isMediaAndSupportsKeywords,\n      isColorAdjusterFuncNode,\n      lastLineHasInlineComment,\n      isAtWordPlaceholderNode,\n      isConfigurationNode,\n      isParenGroupNode\n    } = require_utils8();\n    var {\n      locStart,\n      locEnd\n    } = require_loc2();\n    var isLessParser = require_is_less_parser();\n    var isSCSS = require_is_scss();\n    var printUnit = require_print_unit();\n    function shouldPrintComma(options) {\n      return options.trailingComma === "es5" || options.trailingComma === "all";\n    }\n    function genericPrint(path, options, print) {\n      const node = path.getValue();\n      if (!node) {\n        return "";\n      }\n      if (typeof node === "string") {\n        return node;\n      }\n      switch (node.type) {\n        case "front-matter":\n          return [node.raw, hardline];\n        case "css-root": {\n          const nodes = printNodeSequence(path, options, print);\n          let after = node.raws.after.trim();\n          if (after.startsWith(";")) {\n            after = after.slice(1).trim();\n          }\n          return [nodes, after ? ` ${after}` : "", getDocParts(nodes).length > 0 ? hardline : ""];\n        }\n        case "css-comment": {\n          const isInlineComment = node.inline || node.raws.inline;\n          const text = options.originalText.slice(locStart(node), locEnd(node));\n          return isInlineComment ? text.trimEnd() : text;\n        }\n        case "css-rule": {\n          return [print("selector"), node.important ? " !important" : "", node.nodes ? [node.selector && node.selector.type === "selector-unknown" && lastLineHasInlineComment(node.selector.value) ? line : " ", "{", node.nodes.length > 0 ? indent([hardline, printNodeSequence(path, options, print)]) : "", hardline, "}", isDetachedRulesetDeclarationNode(node) ? ";" : ""] : ";"];\n        }\n        case "css-decl": {\n          const parentNode = path.getParentNode();\n          const {\n            between: rawBetween\n          } = node.raws;\n          const trimmedBetween = rawBetween.trim();\n          const isColon = trimmedBetween === ":";\n          let value = hasComposesNode(node) ? removeLines(print("value")) : print("value");\n          if (!isColon && lastLineHasInlineComment(trimmedBetween)) {\n            value = indent([hardline, dedent(value)]);\n          }\n          return [node.raws.before.replace(/[\\s;]/g, ""), parentNode.type === "css-atrule" && parentNode.variable || insideICSSRuleNode(path) ? node.prop : maybeToLowerCase(node.prop), trimmedBetween.startsWith("//") ? " " : "", trimmedBetween, node.extend ? "" : " ", isLessParser(options) && node.extend && node.selector ? ["extend(", print("selector"), ")"] : "", value, node.raws.important ? node.raws.important.replace(/\\s*!\\s*important/i, " !important") : node.important ? " !important" : "", node.raws.scssDefault ? node.raws.scssDefault.replace(/\\s*!default/i, " !default") : node.scssDefault ? " !default" : "", node.raws.scssGlobal ? node.raws.scssGlobal.replace(/\\s*!global/i, " !global") : node.scssGlobal ? " !global" : "", node.nodes ? [" {", indent([softline, printNodeSequence(path, options, print)]), softline, "}"] : isTemplatePropNode(node) && !parentNode.raws.semicolon && options.originalText[locEnd(node) - 1] !== ";" ? "" : options.__isHTMLStyleAttribute && isLastNode(path, node) ? ifBreak(";") : ";"];\n        }\n        case "css-atrule": {\n          const parentNode = path.getParentNode();\n          const isTemplatePlaceholderNodeWithoutSemiColon = isTemplatePlaceholderNode(node) && !parentNode.raws.semicolon && options.originalText[locEnd(node) - 1] !== ";";\n          if (isLessParser(options)) {\n            if (node.mixin) {\n              return [print("selector"), node.important ? " !important" : "", isTemplatePlaceholderNodeWithoutSemiColon ? "" : ";"];\n            }\n            if (node.function) {\n              return [node.name, print("params"), isTemplatePlaceholderNodeWithoutSemiColon ? "" : ";"];\n            }\n            if (node.variable) {\n              return ["@", node.name, ": ", node.value ? print("value") : "", node.raws.between.trim() ? node.raws.between.trim() + " " : "", node.nodes ? ["{", indent([node.nodes.length > 0 ? softline : "", printNodeSequence(path, options, print)]), softline, "}"] : "", isTemplatePlaceholderNodeWithoutSemiColon ? "" : ";"];\n            }\n          }\n          return ["@", isDetachedRulesetCallNode(node) || node.name.endsWith(":") ? node.name : maybeToLowerCase(node.name), node.params ? [isDetachedRulesetCallNode(node) ? "" : isTemplatePlaceholderNode(node) ? node.raws.afterName === "" ? "" : node.name.endsWith(":") ? " " : /^\\s*\\n\\s*\\n/.test(node.raws.afterName) ? [hardline, hardline] : /^\\s*\\n/.test(node.raws.afterName) ? hardline : " " : " ", print("params")] : "", node.selector ? indent([" ", print("selector")]) : "", node.value ? group([" ", print("value"), isSCSSControlDirectiveNode(node) ? hasParensAroundNode(node) ? " " : line : ""]) : node.name === "else" ? " " : "", node.nodes ? [isSCSSControlDirectiveNode(node) ? "" : node.selector && !node.selector.nodes && typeof node.selector.value === "string" && lastLineHasInlineComment(node.selector.value) || !node.selector && typeof node.params === "string" && lastLineHasInlineComment(node.params) ? line : " ", "{", indent([node.nodes.length > 0 ? softline : "", printNodeSequence(path, options, print)]), softline, "}"] : isTemplatePlaceholderNodeWithoutSemiColon ? "" : ";"];\n        }\n        case "media-query-list": {\n          const parts = [];\n          path.each((childPath) => {\n            const node2 = childPath.getValue();\n            if (node2.type === "media-query" && node2.value === "") {\n              return;\n            }\n            parts.push(print());\n          }, "nodes");\n          return group(indent(join(line, parts)));\n        }\n        case "media-query": {\n          return [join(" ", path.map(print, "nodes")), isLastNode(path, node) ? "" : ","];\n        }\n        case "media-type": {\n          return adjustNumbers(adjustStrings(node.value, options));\n        }\n        case "media-feature-expression": {\n          if (!node.nodes) {\n            return node.value;\n          }\n          return ["(", ...path.map(print, "nodes"), ")"];\n        }\n        case "media-feature": {\n          return maybeToLowerCase(adjustStrings(node.value.replace(/ +/g, " "), options));\n        }\n        case "media-colon": {\n          return [node.value, " "];\n        }\n        case "media-value": {\n          return adjustNumbers(adjustStrings(node.value, options));\n        }\n        case "media-keyword": {\n          return adjustStrings(node.value, options);\n        }\n        case "media-url": {\n          return adjustStrings(node.value.replace(/^url\\(\\s+/gi, "url(").replace(/\\s+\\)$/g, ")"), options);\n        }\n        case "media-unknown": {\n          return node.value;\n        }\n        case "selector-root": {\n          return group([insideAtRuleNode(path, "custom-selector") ? [getAncestorNode(path, "css-atrule").customSelector, line] : "", join([",", insideAtRuleNode(path, ["extend", "custom-selector", "nest"]) ? line : hardline], path.map(print, "nodes"))]);\n        }\n        case "selector-selector": {\n          return group(indent(path.map(print, "nodes")));\n        }\n        case "selector-comment": {\n          return node.value;\n        }\n        case "selector-string": {\n          return adjustStrings(node.value, options);\n        }\n        case "selector-tag": {\n          const parentNode = path.getParentNode();\n          const index = parentNode && parentNode.nodes.indexOf(node);\n          const prevNode = index && parentNode.nodes[index - 1];\n          return [node.namespace ? [node.namespace === true ? "" : node.namespace.trim(), "|"] : "", prevNode.type === "selector-nesting" ? node.value : adjustNumbers(isKeyframeAtRuleKeywords(path, node.value) ? node.value.toLowerCase() : node.value)];\n        }\n        case "selector-id": {\n          return ["#", node.value];\n        }\n        case "selector-class": {\n          return [".", adjustNumbers(adjustStrings(node.value, options))];\n        }\n        case "selector-attribute": {\n          var _node$operator;\n          return ["[", node.namespace ? [node.namespace === true ? "" : node.namespace.trim(), "|"] : "", node.attribute.trim(), (_node$operator = node.operator) !== null && _node$operator !== void 0 ? _node$operator : "", node.value ? quoteAttributeValue(adjustStrings(node.value.trim(), options), options) : "", node.insensitive ? " i" : "", "]"];\n        }\n        case "selector-combinator": {\n          if (node.value === "+" || node.value === ">" || node.value === "~" || node.value === ">>>") {\n            const parentNode = path.getParentNode();\n            const leading2 = parentNode.type === "selector-selector" && parentNode.nodes[0] === node ? "" : line;\n            return [leading2, node.value, isLastNode(path, node) ? "" : " "];\n          }\n          const leading = node.value.trim().startsWith("(") ? line : "";\n          const value = adjustNumbers(adjustStrings(node.value.trim(), options)) || line;\n          return [leading, value];\n        }\n        case "selector-universal": {\n          return [node.namespace ? [node.namespace === true ? "" : node.namespace.trim(), "|"] : "", node.value];\n        }\n        case "selector-pseudo": {\n          return [maybeToLowerCase(node.value), isNonEmptyArray(node.nodes) ? group(["(", indent([softline, join([",", line], path.map(print, "nodes"))]), softline, ")"]) : ""];\n        }\n        case "selector-nesting": {\n          return node.value;\n        }\n        case "selector-unknown": {\n          const ruleAncestorNode = getAncestorNode(path, "css-rule");\n          if (ruleAncestorNode && ruleAncestorNode.isSCSSNesterProperty) {\n            return adjustNumbers(adjustStrings(maybeToLowerCase(node.value), options));\n          }\n          const parentNode = path.getParentNode();\n          if (parentNode.raws && parentNode.raws.selector) {\n            const start = locStart(parentNode);\n            const end = start + parentNode.raws.selector.length;\n            return options.originalText.slice(start, end).trim();\n          }\n          const grandParent = path.getParentNode(1);\n          if (parentNode.type === "value-paren_group" && grandParent && grandParent.type === "value-func" && grandParent.value === "selector") {\n            const start = locEnd(parentNode.open) + 1;\n            const end = locStart(parentNode.close);\n            const selector = options.originalText.slice(start, end).trim();\n            return lastLineHasInlineComment(selector) ? [breakParent, selector] : selector;\n          }\n          return node.value;\n        }\n        case "value-value":\n        case "value-root": {\n          return print("group");\n        }\n        case "value-comment": {\n          return options.originalText.slice(locStart(node), locEnd(node));\n        }\n        case "value-comma_group": {\n          const parentNode = path.getParentNode();\n          const parentParentNode = path.getParentNode(1);\n          const declAncestorProp = getPropOfDeclNode(path);\n          const isGridValue = declAncestorProp && parentNode.type === "value-value" && (declAncestorProp === "grid" || declAncestorProp.startsWith("grid-template"));\n          const atRuleAncestorNode = getAncestorNode(path, "css-atrule");\n          const isControlDirective = atRuleAncestorNode && isSCSSControlDirectiveNode(atRuleAncestorNode);\n          const hasInlineComment = node.groups.some((node2) => isInlineValueCommentNode(node2));\n          const printed = path.map(print, "groups");\n          const parts = [];\n          const insideURLFunction = insideValueFunctionNode(path, "url");\n          let insideSCSSInterpolationInString = false;\n          let didBreak = false;\n          for (let i = 0; i < node.groups.length; ++i) {\n            var _iNode$value;\n            parts.push(printed[i]);\n            const iPrevNode = node.groups[i - 1];\n            const iNode = node.groups[i];\n            const iNextNode = node.groups[i + 1];\n            const iNextNextNode = node.groups[i + 2];\n            if (insideURLFunction) {\n              if (iNextNode && isAdditionNode(iNextNode) || isAdditionNode(iNode)) {\n                parts.push(" ");\n              }\n              continue;\n            }\n            if (insideAtRuleNode(path, "forward") && iNode.type === "value-word" && iNode.value && iPrevNode !== void 0 && iPrevNode.type === "value-word" && iPrevNode.value === "as" && iNextNode.type === "value-operator" && iNextNode.value === "*") {\n              continue;\n            }\n            if (!iNextNode) {\n              continue;\n            }\n            if (iNode.type === "value-word" && iNode.value.endsWith("-") && isAtWordPlaceholderNode(iNextNode)) {\n              continue;\n            }\n            if (iNode.type === "value-string" && iNode.quoted) {\n              const positionOfOpeningInterpolation = iNode.value.lastIndexOf("#{");\n              const positionOfClosingInterpolation = iNode.value.lastIndexOf("}");\n              if (positionOfOpeningInterpolation !== -1 && positionOfClosingInterpolation !== -1) {\n                insideSCSSInterpolationInString = positionOfOpeningInterpolation > positionOfClosingInterpolation;\n              } else if (positionOfOpeningInterpolation !== -1) {\n                insideSCSSInterpolationInString = true;\n              } else if (positionOfClosingInterpolation !== -1) {\n                insideSCSSInterpolationInString = false;\n              }\n            }\n            if (insideSCSSInterpolationInString) {\n              continue;\n            }\n            if (isColonNode(iNode) || isColonNode(iNextNode)) {\n              continue;\n            }\n            if (iNode.type === "value-atword" && (iNode.value === "" || iNode.value.endsWith("["))) {\n              continue;\n            }\n            if (iNextNode.type === "value-word" && iNextNode.value.startsWith("]")) {\n              continue;\n            }\n            if (iNode.value === "~") {\n              continue;\n            }\n            if (iNode.value && iNode.value.includes("\\\\") && iNextNode && iNextNode.type !== "value-comment") {\n              continue;\n            }\n            if (iPrevNode && iPrevNode.value && iPrevNode.value.indexOf("\\\\") === iPrevNode.value.length - 1 && iNode.type === "value-operator" && iNode.value === "/") {\n              continue;\n            }\n            if (iNode.value === "\\\\") {\n              continue;\n            }\n            if (isPostcssSimpleVarNode(iNode, iNextNode)) {\n              continue;\n            }\n            if (isHashNode(iNode) || isLeftCurlyBraceNode(iNode) || isRightCurlyBraceNode(iNextNode) || isLeftCurlyBraceNode(iNextNode) && hasEmptyRawBefore(iNextNode) || isRightCurlyBraceNode(iNode) && hasEmptyRawBefore(iNextNode)) {\n              continue;\n            }\n            if (iNode.value === "--" && isHashNode(iNextNode)) {\n              continue;\n            }\n            const isMathOperator = isMathOperatorNode(iNode);\n            const isNextMathOperator = isMathOperatorNode(iNextNode);\n            if ((isMathOperator && isHashNode(iNextNode) || isNextMathOperator && isRightCurlyBraceNode(iNode)) && hasEmptyRawBefore(iNextNode)) {\n              continue;\n            }\n            if (!iPrevNode && isDivisionNode(iNode)) {\n              continue;\n            }\n            if (insideValueFunctionNode(path, "calc") && (isAdditionNode(iNode) || isAdditionNode(iNextNode) || isSubtractionNode(iNode) || isSubtractionNode(iNextNode)) && hasEmptyRawBefore(iNextNode)) {\n              continue;\n            }\n            const isColorAdjusterNode = (isAdditionNode(iNode) || isSubtractionNode(iNode)) && i === 0 && (iNextNode.type === "value-number" || iNextNode.isHex) && parentParentNode && isColorAdjusterFuncNode(parentParentNode) && !hasEmptyRawBefore(iNextNode);\n            const requireSpaceBeforeOperator = iNextNextNode && iNextNextNode.type === "value-func" || iNextNextNode && isWordNode(iNextNextNode) || iNode.type === "value-func" || isWordNode(iNode);\n            const requireSpaceAfterOperator = iNextNode.type === "value-func" || isWordNode(iNextNode) || iPrevNode && iPrevNode.type === "value-func" || iPrevNode && isWordNode(iPrevNode);\n            if (!(isMultiplicationNode(iNextNode) || isMultiplicationNode(iNode)) && !insideValueFunctionNode(path, "calc") && !isColorAdjusterNode && (isDivisionNode(iNextNode) && !requireSpaceBeforeOperator || isDivisionNode(iNode) && !requireSpaceAfterOperator || isAdditionNode(iNextNode) && !requireSpaceBeforeOperator || isAdditionNode(iNode) && !requireSpaceAfterOperator || isSubtractionNode(iNextNode) || isSubtractionNode(iNode)) && (hasEmptyRawBefore(iNextNode) || isMathOperator && (!iPrevNode || iPrevNode && isMathOperatorNode(iPrevNode)))) {\n              continue;\n            }\n            if ((options.parser === "scss" || options.parser === "less") && isMathOperator && iNode.value === "-" && isParenGroupNode(iNextNode) && locEnd(iNode) === locStart(iNextNode.open) && iNextNode.open.value === "(") {\n              continue;\n            }\n            if (isInlineValueCommentNode(iNode)) {\n              if (parentNode.type === "value-paren_group") {\n                parts.push(dedent(hardline));\n                continue;\n              }\n              parts.push(hardline);\n              continue;\n            }\n            if (isControlDirective && (isEqualityOperatorNode(iNextNode) || isRelationalOperatorNode(iNextNode) || isIfElseKeywordNode(iNextNode) || isEachKeywordNode(iNode) || isForKeywordNode(iNode))) {\n              parts.push(" ");\n              continue;\n            }\n            if (atRuleAncestorNode && atRuleAncestorNode.name.toLowerCase() === "namespace") {\n              parts.push(" ");\n              continue;\n            }\n            if (isGridValue) {\n              if (iNode.source && iNextNode.source && iNode.source.start.line !== iNextNode.source.start.line) {\n                parts.push(hardline);\n                didBreak = true;\n              } else {\n                parts.push(" ");\n              }\n              continue;\n            }\n            if (isNextMathOperator) {\n              parts.push(" ");\n              continue;\n            }\n            if (iNextNode && iNextNode.value === "...") {\n              continue;\n            }\n            if (isAtWordPlaceholderNode(iNode) && isAtWordPlaceholderNode(iNextNode) && locEnd(iNode) === locStart(iNextNode)) {\n              continue;\n            }\n            if (isAtWordPlaceholderNode(iNode) && isParenGroupNode(iNextNode) && locEnd(iNode) === locStart(iNextNode.open)) {\n              parts.push(softline);\n              continue;\n            }\n            if (iNode.value === "with" && isParenGroupNode(iNextNode)) {\n              parts.push(" ");\n              continue;\n            }\n            if ((_iNode$value = iNode.value) !== null && _iNode$value !== void 0 && _iNode$value.endsWith("#") && iNextNode.value === "{" && isParenGroupNode(iNextNode.group)) {\n              continue;\n            }\n            parts.push(line);\n          }\n          if (hasInlineComment) {\n            parts.push(breakParent);\n          }\n          if (didBreak) {\n            parts.unshift(hardline);\n          }\n          if (isControlDirective) {\n            return group(indent(parts));\n          }\n          if (insideURLFunctionInImportAtRuleNode(path)) {\n            return group(fill(parts));\n          }\n          return group(indent(fill(parts)));\n        }\n        case "value-paren_group": {\n          const parentNode = path.getParentNode();\n          if (parentNode && isURLFunctionNode(parentNode) && (node.groups.length === 1 || node.groups.length > 0 && node.groups[0].type === "value-comma_group" && node.groups[0].groups.length > 0 && node.groups[0].groups[0].type === "value-word" && node.groups[0].groups[0].value.startsWith("data:"))) {\n            return [node.open ? print("open") : "", join(",", path.map(print, "groups")), node.close ? print("close") : ""];\n          }\n          if (!node.open) {\n            const printed2 = path.map(print, "groups");\n            const res = [];\n            for (let i = 0; i < printed2.length; i++) {\n              if (i !== 0) {\n                res.push([",", line]);\n              }\n              res.push(printed2[i]);\n            }\n            return group(indent(fill(res)));\n          }\n          const isSCSSMapItem = isSCSSMapItemNode(path);\n          const lastItem = getLast(node.groups);\n          const isLastItemComment = lastItem && lastItem.type === "value-comment";\n          const isKey = isKeyInValuePairNode(node, parentNode);\n          const isConfiguration = isConfigurationNode(node, parentNode);\n          const shouldBreak = isConfiguration || isSCSSMapItem && !isKey;\n          const shouldDedent = isConfiguration || isKey;\n          const printed = group([node.open ? print("open") : "", indent([softline, join([line], path.map((childPath, index) => {\n            const child = childPath.getValue();\n            const isLast = index === node.groups.length - 1;\n            let printed2 = [print(), isLast ? "" : ","];\n            if (isKeyValuePairNode(child) && child.type === "value-comma_group" && child.groups && child.groups[0].type !== "value-paren_group" && child.groups[2] && child.groups[2].type === "value-paren_group") {\n              const parts = getDocParts(printed2[0].contents.contents);\n              parts[1] = group(parts[1]);\n              printed2 = [group(dedent(printed2))];\n            }\n            if (!isLast && child.type === "value-comma_group" && isNonEmptyArray(child.groups)) {\n              let last = getLast(child.groups);\n              if (!last.source && last.close) {\n                last = last.close;\n              }\n              if (last.source && isNextLineEmpty(options.originalText, last, locEnd)) {\n                printed2.push(hardline);\n              }\n            }\n            return printed2;\n          }, "groups"))]), ifBreak(!isLastItemComment && isSCSS(options.parser, options.originalText) && isSCSSMapItem && shouldPrintComma(options) ? "," : ""), softline, node.close ? print("close") : ""], {\n            shouldBreak\n          });\n          return shouldDedent ? dedent(printed) : printed;\n        }\n        case "value-func": {\n          return [node.value, insideAtRuleNode(path, "supports") && isMediaAndSupportsKeywords(node) ? " " : "", print("group")];\n        }\n        case "value-paren": {\n          return node.value;\n        }\n        case "value-number": {\n          return [printCssNumber(node.value), printUnit(node.unit)];\n        }\n        case "value-operator": {\n          return node.value;\n        }\n        case "value-word": {\n          if (node.isColor && node.isHex || isWideKeywords(node.value)) {\n            return node.value.toLowerCase();\n          }\n          return node.value;\n        }\n        case "value-colon": {\n          const parentNode = path.getParentNode();\n          const index = parentNode && parentNode.groups.indexOf(node);\n          const prevNode = index && parentNode.groups[index - 1];\n          return [node.value, prevNode && typeof prevNode.value === "string" && getLast(prevNode.value) === "\\\\" || insideValueFunctionNode(path, "url") ? "" : line];\n        }\n        case "value-comma": {\n          return [node.value, " "];\n        }\n        case "value-string": {\n          return printString(node.raws.quote + node.value + node.raws.quote, options);\n        }\n        case "value-atword": {\n          return ["@", node.value];\n        }\n        case "value-unicode-range": {\n          return node.value;\n        }\n        case "value-unknown": {\n          return node.value;\n        }\n        default:\n          throw new Error(`Unknown postcss type ${JSON.stringify(node.type)}`);\n      }\n    }\n    function printNodeSequence(path, options, print) {\n      const parts = [];\n      path.each((pathChild, i, nodes) => {\n        const prevNode = nodes[i - 1];\n        if (prevNode && prevNode.type === "css-comment" && prevNode.text.trim() === "prettier-ignore") {\n          const childNode = pathChild.getValue();\n          parts.push(options.originalText.slice(locStart(childNode), locEnd(childNode)));\n        } else {\n          parts.push(print());\n        }\n        if (i !== nodes.length - 1) {\n          if (nodes[i + 1].type === "css-comment" && !hasNewline(options.originalText, locStart(nodes[i + 1]), {\n            backwards: true\n          }) && !isFrontMatterNode(nodes[i]) || nodes[i + 1].type === "css-atrule" && nodes[i + 1].name === "else" && nodes[i].type !== "css-comment") {\n            parts.push(" ");\n          } else {\n            parts.push(options.__isHTMLStyleAttribute ? line : hardline);\n            if (isNextLineEmpty(options.originalText, pathChild.getValue(), locEnd) && !isFrontMatterNode(nodes[i])) {\n              parts.push(hardline);\n            }\n          }\n        }\n      }, "nodes");\n      return parts;\n    }\n    var STRING_REGEX = /(["\'])(?:(?!\\1)[^\\\\]|\\\\.)*\\1/gs;\n    var NUMBER_REGEX = /(?:\\d*\\.\\d+|\\d+\\.?)(?:[Ee][+-]?\\d+)?/g;\n    var STANDARD_UNIT_REGEX = /[A-Za-z]+/g;\n    var WORD_PART_REGEX = /[$@]?[A-Z_a-z\\u0080-\\uFFFF][\\w\\u0080-\\uFFFF-]*/g;\n    var ADJUST_NUMBERS_REGEX = new RegExp(STRING_REGEX.source + `|(${WORD_PART_REGEX.source})?(${NUMBER_REGEX.source})(${STANDARD_UNIT_REGEX.source})?`, "g");\n    function adjustStrings(value, options) {\n      return value.replace(STRING_REGEX, (match) => printString(match, options));\n    }\n    function quoteAttributeValue(value, options) {\n      const quote = options.singleQuote ? "\'" : \'"\';\n      return value.includes(\'"\') || value.includes("\'") ? value : quote + value + quote;\n    }\n    function adjustNumbers(value) {\n      return value.replace(ADJUST_NUMBERS_REGEX, (match, quote, wordPart, number, unit) => !wordPart && number ? printCssNumber(number) + maybeToLowerCase(unit || "") : match);\n    }\n    function printCssNumber(rawNumber) {\n      return printNumber(rawNumber).replace(/\\.0(?=$|e)/, "");\n    }\n    module2.exports = {\n      print: genericPrint,\n      embed,\n      insertPragma,\n      massageAstNode: clean\n    };\n  }\n});\nvar require_options3 = __commonJS2({\n  "src/language-css/options.js"(exports2, module2) {\n    "use strict";\n    var commonOptions = require_common_options();\n    module2.exports = {\n      singleQuote: commonOptions.singleQuote\n    };\n  }\n});\nvar require_parsers2 = __commonJS2({\n  "src/language-css/parsers.js"(exports2, module2) {\n    "use strict";\n    module2.exports = {\n      get css() {\n        return require("./parser-postcss.js").parsers.css;\n      },\n      get less() {\n        return require("./parser-postcss.js").parsers.less;\n      },\n      get scss() {\n        return require("./parser-postcss.js").parsers.scss;\n      }\n    };\n  }\n});\nvar require_CSS = __commonJS2({\n  "node_modules/linguist-languages/data/CSS.json"(exports2, module2) {\n    module2.exports = {\n      name: "CSS",\n      type: "markup",\n      tmScope: "source.css",\n      aceMode: "css",\n      codemirrorMode: "css",\n      codemirrorMimeType: "text/css",\n      color: "#563d7c",\n      extensions: [".css"],\n      languageId: 50\n    };\n  }\n});\nvar require_PostCSS = __commonJS2({\n  "node_modules/linguist-languages/data/PostCSS.json"(exports2, module2) {\n    module2.exports = {\n      name: "PostCSS",\n      type: "markup",\n      color: "#dc3a0c",\n      tmScope: "source.postcss",\n      group: "CSS",\n      extensions: [".pcss", ".postcss"],\n      aceMode: "text",\n      languageId: 262764437\n    };\n  }\n});\nvar require_Less = __commonJS2({\n  "node_modules/linguist-languages/data/Less.json"(exports2, module2) {\n    module2.exports = {\n      name: "Less",\n      type: "markup",\n      color: "#1d365d",\n      aliases: ["less-css"],\n      extensions: [".less"],\n      tmScope: "source.css.less",\n      aceMode: "less",\n      codemirrorMode: "css",\n      codemirrorMimeType: "text/css",\n      languageId: 198\n    };\n  }\n});\nvar require_SCSS = __commonJS2({\n  "node_modules/linguist-languages/data/SCSS.json"(exports2, module2) {\n    module2.exports = {\n      name: "SCSS",\n      type: "markup",\n      color: "#c6538c",\n      tmScope: "source.css.scss",\n      aceMode: "scss",\n      codemirrorMode: "css",\n      codemirrorMimeType: "text/x-scss",\n      extensions: [".scss"],\n      languageId: 329\n    };\n  }\n});\nvar require_language_css = __commonJS2({\n  "src/language-css/index.js"(exports2, module2) {\n    "use strict";\n    var createLanguage = require_create_language();\n    var printer = require_printer_postcss();\n    var options = require_options3();\n    var parsers = require_parsers2();\n    var languages = [createLanguage(require_CSS(), (data) => ({\n      since: "1.4.0",\n      parsers: ["css"],\n      vscodeLanguageIds: ["css"],\n      extensions: [...data.extensions, ".wxss"]\n    })), createLanguage(require_PostCSS(), () => ({\n      since: "1.4.0",\n      parsers: ["css"],\n      vscodeLanguageIds: ["postcss"]\n    })), createLanguage(require_Less(), () => ({\n      since: "1.4.0",\n      parsers: ["less"],\n      vscodeLanguageIds: ["less"]\n    })), createLanguage(require_SCSS(), () => ({\n      since: "1.4.0",\n      parsers: ["scss"],\n      vscodeLanguageIds: ["scss"]\n    }))];\n    var printers = {\n      postcss: printer\n    };\n    module2.exports = {\n      languages,\n      options,\n      printers,\n      parsers\n    };\n  }\n});\nvar require_loc3 = __commonJS2({\n  "src/language-handlebars/loc.js"(exports2, module2) {\n    "use strict";\n    function locStart(node) {\n      return node.loc.start.offset;\n    }\n    function locEnd(node) {\n      return node.loc.end.offset;\n    }\n    module2.exports = {\n      locStart,\n      locEnd\n    };\n  }\n});\nvar require_clean3 = __commonJS2({\n  "src/language-handlebars/clean.js"(exports2, module2) {\n    "use strict";\n    function clean(ast, newNode) {\n      if (ast.type === "TextNode") {\n        const trimmed = ast.chars.trim();\n        if (!trimmed) {\n          return null;\n        }\n        newNode.chars = trimmed.replace(/[\\t\\n\\f\\r ]+/g, " ");\n      }\n      if (ast.type === "AttrNode" && ast.name.toLowerCase() === "class") {\n        delete newNode.value;\n      }\n    }\n    clean.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]);\n    module2.exports = clean;\n  }\n});\nvar require_html_void_elements_evaluate = __commonJS2({\n  "src/language-handlebars/html-void-elements.evaluate.js"(exports2, module2) {\n    module2.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];\n  }\n});\nvar require_utils9 = __commonJS2({\n  "src/language-handlebars/utils.js"(exports2, module2) {\n    "use strict";\n    var getLast = require_get_last();\n    var htmlVoidElements = require_html_void_elements_evaluate();\n    function isLastNodeOfSiblings(path) {\n      const node = path.getValue();\n      const parentNode = path.getParentNode(0);\n      if (isParentOfSomeType(path, ["ElementNode"]) && getLast(parentNode.children) === node) {\n        return true;\n      }\n      if (isParentOfSomeType(path, ["Block"]) && getLast(parentNode.body) === node) {\n        return true;\n      }\n      return false;\n    }\n    function isUppercase(string) {\n      return string.toUpperCase() === string;\n    }\n    function isGlimmerComponent(node) {\n      return isNodeOfSomeType(node, ["ElementNode"]) && typeof node.tag === "string" && !node.tag.startsWith(":") && (isUppercase(node.tag[0]) || node.tag.includes("."));\n    }\n    var voidTags = new Set(htmlVoidElements);\n    function isVoidTag(tag) {\n      return voidTags.has(tag.toLowerCase()) && !isUppercase(tag[0]);\n    }\n    function isVoid(node) {\n      return node.selfClosing === true || isVoidTag(node.tag) || isGlimmerComponent(node) && node.children.every((node2) => isWhitespaceNode(node2));\n    }\n    function isWhitespaceNode(node) {\n      return isNodeOfSomeType(node, ["TextNode"]) && !/\\S/.test(node.chars);\n    }\n    function isNodeOfSomeType(node, types) {\n      return node && types.includes(node.type);\n    }\n    function isParentOfSomeType(path, types) {\n      const parentNode = path.getParentNode(0);\n      return isNodeOfSomeType(parentNode, types);\n    }\n    function isPreviousNodeOfSomeType(path, types) {\n      const previousNode = getPreviousNode(path);\n      return isNodeOfSomeType(previousNode, types);\n    }\n    function isNextNodeOfSomeType(path, types) {\n      const nextNode = getNextNode(path);\n      return isNodeOfSomeType(nextNode, types);\n    }\n    function getSiblingNode(path, offset) {\n      var _path$getParentNode2, _ref7, _ref8, _parentNode$children;\n      const node = path.getValue();\n      const parentNode = (_path$getParentNode2 = path.getParentNode(0)) !== null && _path$getParentNode2 !== void 0 ? _path$getParentNode2 : {};\n      const children = (_ref7 = (_ref8 = (_parentNode$children = parentNode.children) !== null && _parentNode$children !== void 0 ? _parentNode$children : parentNode.body) !== null && _ref8 !== void 0 ? _ref8 : parentNode.parts) !== null && _ref7 !== void 0 ? _ref7 : [];\n      const index = children.indexOf(node);\n      return index !== -1 && children[index + offset];\n    }\n    function getPreviousNode(path, lookBack = 1) {\n      return getSiblingNode(path, -lookBack);\n    }\n    function getNextNode(path) {\n      return getSiblingNode(path, 1);\n    }\n    function isPrettierIgnoreNode(node) {\n      return isNodeOfSomeType(node, ["MustacheCommentStatement"]) && typeof node.value === "string" && node.value.trim() === "prettier-ignore";\n    }\n    function hasPrettierIgnore(path) {\n      const node = path.getValue();\n      const previousPreviousNode = getPreviousNode(path, 2);\n      return isPrettierIgnoreNode(node) || isPrettierIgnoreNode(previousPreviousNode);\n    }\n    module2.exports = {\n      getNextNode,\n      getPreviousNode,\n      hasPrettierIgnore,\n      isLastNodeOfSiblings,\n      isNextNodeOfSomeType,\n      isNodeOfSomeType,\n      isParentOfSomeType,\n      isPreviousNodeOfSomeType,\n      isVoid,\n      isWhitespaceNode\n    };\n  }\n});\nvar require_printer_glimmer = __commonJS2({\n  "src/language-handlebars/printer-glimmer.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        dedent,\n        fill,\n        group,\n        hardline,\n        ifBreak,\n        indent,\n        join,\n        line,\n        softline\n      },\n      utils: {\n        getDocParts,\n        replaceTextEndOfLine\n      }\n    } = require("./doc.js");\n    var {\n      getPreferredQuote,\n      isNonEmptyArray\n    } = require_util();\n    var {\n      locStart,\n      locEnd\n    } = require_loc3();\n    var clean = require_clean3();\n    var {\n      getNextNode,\n      getPreviousNode,\n      hasPrettierIgnore,\n      isLastNodeOfSiblings,\n      isNextNodeOfSomeType,\n      isNodeOfSomeType,\n      isParentOfSomeType,\n      isPreviousNodeOfSomeType,\n      isVoid,\n      isWhitespaceNode\n    } = require_utils9();\n    var NEWLINES_TO_PRESERVE_MAX = 2;\n    function print(path, options, print2) {\n      const node = path.getValue();\n      if (!node) {\n        return "";\n      }\n      if (hasPrettierIgnore(path)) {\n        return options.originalText.slice(locStart(node), locEnd(node));\n      }\n      const favoriteQuote = options.singleQuote ? "\'" : \'"\';\n      switch (node.type) {\n        case "Block":\n        case "Program":\n        case "Template": {\n          return group(path.map(print2, "body"));\n        }\n        case "ElementNode": {\n          const startingTag = group(printStartingTag(path, print2));\n          const escapeNextElementNode = options.htmlWhitespaceSensitivity === "ignore" && isNextNodeOfSomeType(path, ["ElementNode"]) ? softline : "";\n          if (isVoid(node)) {\n            return [startingTag, escapeNextElementNode];\n          }\n          const endingTag = ["</", node.tag, ">"];\n          if (node.children.length === 0) {\n            return [startingTag, indent(endingTag), escapeNextElementNode];\n          }\n          if (options.htmlWhitespaceSensitivity === "ignore") {\n            return [startingTag, indent(printChildren(path, options, print2)), hardline, indent(endingTag), escapeNextElementNode];\n          }\n          return [startingTag, indent(group(printChildren(path, options, print2))), indent(endingTag), escapeNextElementNode];\n        }\n        case "BlockStatement": {\n          const pp = path.getParentNode(1);\n          const isElseIfLike = pp && pp.inverse && pp.inverse.body.length === 1 && pp.inverse.body[0] === node && pp.inverse.body[0].path.parts[0] === pp.path.parts[0];\n          if (isElseIfLike) {\n            return [printElseIfLikeBlock(path, print2, pp.inverse.body[0].path.parts[0]), printProgram(path, print2, options), printInverse(path, print2, options)];\n          }\n          return [printOpenBlock(path, print2), group([printProgram(path, print2, options), printInverse(path, print2, options), printCloseBlock(path, print2, options)])];\n        }\n        case "ElementModifierStatement": {\n          return group(["{{", printPathAndParams(path, print2), "}}"]);\n        }\n        case "MustacheStatement": {\n          return group([printOpeningMustache(node), printPathAndParams(path, print2), printClosingMustache(node)]);\n        }\n        case "SubExpression": {\n          return group(["(", printSubExpressionPathAndParams(path, print2), softline, ")"]);\n        }\n        case "AttrNode": {\n          const isText = node.value.type === "TextNode";\n          const isEmptyText = isText && node.value.chars === "";\n          if (isEmptyText && locStart(node.value) === locEnd(node.value)) {\n            return node.name;\n          }\n          const quote = isText ? getPreferredQuote(node.value.chars, favoriteQuote).quote : node.value.type === "ConcatStatement" ? getPreferredQuote(node.value.parts.filter((part) => part.type === "TextNode").map((part) => part.chars).join(""), favoriteQuote).quote : "";\n          const valueDoc = print2("value");\n          return [node.name, "=", quote, node.name === "class" && quote ? group(indent(valueDoc)) : valueDoc, quote];\n        }\n        case "ConcatStatement": {\n          return path.map(print2, "parts");\n        }\n        case "Hash": {\n          return join(line, path.map(print2, "pairs"));\n        }\n        case "HashPair": {\n          return [node.key, "=", print2("value")];\n        }\n        case "TextNode": {\n          let text = node.chars.replace(/{{/g, "\\\\{{");\n          const attrName = getCurrentAttributeName(path);\n          if (attrName) {\n            if (attrName === "class") {\n              const formattedClasses = text.trim().split(/\\s+/).join(" ");\n              let leadingSpace2 = false;\n              let trailingSpace2 = false;\n              if (isParentOfSomeType(path, ["ConcatStatement"])) {\n                if (isPreviousNodeOfSomeType(path, ["MustacheStatement"]) && /^\\s/.test(text)) {\n                  leadingSpace2 = true;\n                }\n                if (isNextNodeOfSomeType(path, ["MustacheStatement"]) && /\\s$/.test(text) && formattedClasses !== "") {\n                  trailingSpace2 = true;\n                }\n              }\n              return [leadingSpace2 ? line : "", formattedClasses, trailingSpace2 ? line : ""];\n            }\n            return replaceTextEndOfLine(text);\n          }\n          const whitespacesOnlyRE = /^[\\t\\n\\f\\r ]*$/;\n          const isWhitespaceOnly = whitespacesOnlyRE.test(text);\n          const isFirstElement = !getPreviousNode(path);\n          const isLastElement = !getNextNode(path);\n          if (options.htmlWhitespaceSensitivity !== "ignore") {\n            const leadingWhitespacesRE = /^[\\t\\n\\f\\r ]*/;\n            const trailingWhitespacesRE = /[\\t\\n\\f\\r ]*$/;\n            const shouldTrimTrailingNewlines = isLastElement && isParentOfSomeType(path, ["Template"]);\n            const shouldTrimLeadingNewlines = isFirstElement && isParentOfSomeType(path, ["Template"]);\n            if (isWhitespaceOnly) {\n              if (shouldTrimLeadingNewlines || shouldTrimTrailingNewlines) {\n                return "";\n              }\n              let breaks = [line];\n              const newlines = countNewLines(text);\n              if (newlines) {\n                breaks = generateHardlines(newlines);\n              }\n              if (isLastNodeOfSiblings(path)) {\n                breaks = breaks.map((newline) => dedent(newline));\n              }\n              return breaks;\n            }\n            const [lead] = text.match(leadingWhitespacesRE);\n            const [tail] = text.match(trailingWhitespacesRE);\n            let leadBreaks = [];\n            if (lead) {\n              leadBreaks = [line];\n              const leadingNewlines = countNewLines(lead);\n              if (leadingNewlines) {\n                leadBreaks = generateHardlines(leadingNewlines);\n              }\n              text = text.replace(leadingWhitespacesRE, "");\n            }\n            let trailBreaks = [];\n            if (tail) {\n              if (!shouldTrimTrailingNewlines) {\n                trailBreaks = [line];\n                const trailingNewlines = countNewLines(tail);\n                if (trailingNewlines) {\n                  trailBreaks = generateHardlines(trailingNewlines);\n                }\n                if (isLastNodeOfSiblings(path)) {\n                  trailBreaks = trailBreaks.map((hardline2) => dedent(hardline2));\n                }\n              }\n              text = text.replace(trailingWhitespacesRE, "");\n            }\n            return [...leadBreaks, fill(getTextValueParts(text)), ...trailBreaks];\n          }\n          const lineBreaksCount = countNewLines(text);\n          let leadingLineBreaksCount = countLeadingNewLines(text);\n          let trailingLineBreaksCount = countTrailingNewLines(text);\n          if ((isFirstElement || isLastElement) && isWhitespaceOnly && isParentOfSomeType(path, ["Block", "ElementNode", "Template"])) {\n            return "";\n          }\n          if (isWhitespaceOnly && lineBreaksCount) {\n            leadingLineBreaksCount = Math.min(lineBreaksCount, NEWLINES_TO_PRESERVE_MAX);\n            trailingLineBreaksCount = 0;\n          } else {\n            if (isNextNodeOfSomeType(path, ["BlockStatement", "ElementNode"])) {\n              trailingLineBreaksCount = Math.max(trailingLineBreaksCount, 1);\n            }\n            if (isPreviousNodeOfSomeType(path, ["BlockStatement", "ElementNode"])) {\n              leadingLineBreaksCount = Math.max(leadingLineBreaksCount, 1);\n            }\n          }\n          let leadingSpace = "";\n          let trailingSpace = "";\n          if (trailingLineBreaksCount === 0 && isNextNodeOfSomeType(path, ["MustacheStatement"])) {\n            trailingSpace = " ";\n          }\n          if (leadingLineBreaksCount === 0 && isPreviousNodeOfSomeType(path, ["MustacheStatement"])) {\n            leadingSpace = " ";\n          }\n          if (isFirstElement) {\n            leadingLineBreaksCount = 0;\n            leadingSpace = "";\n          }\n          if (isLastElement) {\n            trailingLineBreaksCount = 0;\n            trailingSpace = "";\n          }\n          text = text.replace(/^[\\t\\n\\f\\r ]+/g, leadingSpace).replace(/[\\t\\n\\f\\r ]+$/, trailingSpace);\n          return [...generateHardlines(leadingLineBreaksCount), fill(getTextValueParts(text)), ...generateHardlines(trailingLineBreaksCount)];\n        }\n        case "MustacheCommentStatement": {\n          const start = locStart(node);\n          const end = locEnd(node);\n          const isLeftWhiteSpaceSensitive = options.originalText.charAt(start + 2) === "~";\n          const isRightWhitespaceSensitive = options.originalText.charAt(end - 3) === "~";\n          const dashes = node.value.includes("}}") ? "--" : "";\n          return ["{{", isLeftWhiteSpaceSensitive ? "~" : "", "!", dashes, node.value, dashes, isRightWhitespaceSensitive ? "~" : "", "}}"];\n        }\n        case "PathExpression": {\n          return node.original;\n        }\n        case "BooleanLiteral": {\n          return String(node.value);\n        }\n        case "CommentStatement": {\n          return ["\x3c!--", node.value, "--\x3e"];\n        }\n        case "StringLiteral": {\n          if (needsOppositeQuote(path)) {\n            const printFavoriteQuote = !options.singleQuote ? "\'" : \'"\';\n            return printStringLiteral(node.value, printFavoriteQuote);\n          }\n          return printStringLiteral(node.value, favoriteQuote);\n        }\n        case "NumberLiteral": {\n          return String(node.value);\n        }\n        case "UndefinedLiteral": {\n          return "undefined";\n        }\n        case "NullLiteral": {\n          return "null";\n        }\n        default:\n          throw new Error("unknown glimmer type: " + JSON.stringify(node.type));\n      }\n    }\n    function sortByLoc(a, b) {\n      return locStart(a) - locStart(b);\n    }\n    function printStartingTag(path, print2) {\n      const node = path.getValue();\n      const types = ["attributes", "modifiers", "comments"].filter((property) => isNonEmptyArray(node[property]));\n      const attributes = types.flatMap((type) => node[type]).sort(sortByLoc);\n      for (const attributeType of types) {\n        path.each((attributePath) => {\n          const index = attributes.indexOf(attributePath.getValue());\n          attributes.splice(index, 1, [line, print2()]);\n        }, attributeType);\n      }\n      if (isNonEmptyArray(node.blockParams)) {\n        attributes.push(line, printBlockParams(node));\n      }\n      return ["<", node.tag, indent(attributes), printStartingTagEndMarker(node)];\n    }\n    function printChildren(path, options, print2) {\n      const node = path.getValue();\n      const isEmpty = node.children.every((node2) => isWhitespaceNode(node2));\n      if (options.htmlWhitespaceSensitivity === "ignore" && isEmpty) {\n        return "";\n      }\n      return path.map((childPath, childIndex) => {\n        const printedChild = print2();\n        if (childIndex === 0 && options.htmlWhitespaceSensitivity === "ignore") {\n          return [softline, printedChild];\n        }\n        return printedChild;\n      }, "children");\n    }\n    function printStartingTagEndMarker(node) {\n      if (isVoid(node)) {\n        return ifBreak([softline, "/>"], [" />", softline]);\n      }\n      return ifBreak([softline, ">"], ">");\n    }\n    function printOpeningMustache(node) {\n      const mustache = node.escaped === false ? "{{{" : "{{";\n      const strip = node.strip && node.strip.open ? "~" : "";\n      return [mustache, strip];\n    }\n    function printClosingMustache(node) {\n      const mustache = node.escaped === false ? "}}}" : "}}";\n      const strip = node.strip && node.strip.close ? "~" : "";\n      return [strip, mustache];\n    }\n    function printOpeningBlockOpeningMustache(node) {\n      const opening = printOpeningMustache(node);\n      const strip = node.openStrip.open ? "~" : "";\n      return [opening, strip, "#"];\n    }\n    function printOpeningBlockClosingMustache(node) {\n      const closing = printClosingMustache(node);\n      const strip = node.openStrip.close ? "~" : "";\n      return [strip, closing];\n    }\n    function printClosingBlockOpeningMustache(node) {\n      const opening = printOpeningMustache(node);\n      const strip = node.closeStrip.open ? "~" : "";\n      return [opening, strip, "/"];\n    }\n    function printClosingBlockClosingMustache(node) {\n      const closing = printClosingMustache(node);\n      const strip = node.closeStrip.close ? "~" : "";\n      return [strip, closing];\n    }\n    function printInverseBlockOpeningMustache(node) {\n      const opening = printOpeningMustache(node);\n      const strip = node.inverseStrip.open ? "~" : "";\n      return [opening, strip];\n    }\n    function printInverseBlockClosingMustache(node) {\n      const closing = printClosingMustache(node);\n      const strip = node.inverseStrip.close ? "~" : "";\n      return [strip, closing];\n    }\n    function printOpenBlock(path, print2) {\n      const node = path.getValue();\n      const parts = [];\n      const paramsDoc = printParams(path, print2);\n      if (paramsDoc) {\n        parts.push(group(paramsDoc));\n      }\n      if (isNonEmptyArray(node.program.blockParams)) {\n        parts.push(printBlockParams(node.program));\n      }\n      return group([printOpeningBlockOpeningMustache(node), printPath(path, print2), parts.length > 0 ? indent([line, join(line, parts)]) : "", softline, printOpeningBlockClosingMustache(node)]);\n    }\n    function printElseBlock(node, options) {\n      return [options.htmlWhitespaceSensitivity === "ignore" ? hardline : "", printInverseBlockOpeningMustache(node), "else", printInverseBlockClosingMustache(node)];\n    }\n    function printElseIfLikeBlock(path, print2, ifLikeKeyword) {\n      const node = path.getValue();\n      const parentNode = path.getParentNode(1);\n      return group([printInverseBlockOpeningMustache(parentNode), ["else", " ", ifLikeKeyword], indent([line, group(printParams(path, print2)), ...isNonEmptyArray(node.program.blockParams) ? [line, printBlockParams(node.program)] : []]), softline, printInverseBlockClosingMustache(parentNode)]);\n    }\n    function printCloseBlock(path, print2, options) {\n      const node = path.getValue();\n      if (options.htmlWhitespaceSensitivity === "ignore") {\n        const escape = blockStatementHasOnlyWhitespaceInProgram(node) ? softline : hardline;\n        return [escape, printClosingBlockOpeningMustache(node), print2("path"), printClosingBlockClosingMustache(node)];\n      }\n      return [printClosingBlockOpeningMustache(node), print2("path"), printClosingBlockClosingMustache(node)];\n    }\n    function blockStatementHasOnlyWhitespaceInProgram(node) {\n      return isNodeOfSomeType(node, ["BlockStatement"]) && node.program.body.every((node2) => isWhitespaceNode(node2));\n    }\n    function blockStatementHasElseIfLike(node) {\n      return blockStatementHasElse(node) && node.inverse.body.length === 1 && isNodeOfSomeType(node.inverse.body[0], ["BlockStatement"]) && node.inverse.body[0].path.parts[0] === node.path.parts[0];\n    }\n    function blockStatementHasElse(node) {\n      return isNodeOfSomeType(node, ["BlockStatement"]) && node.inverse;\n    }\n    function printProgram(path, print2, options) {\n      const node = path.getValue();\n      if (blockStatementHasOnlyWhitespaceInProgram(node)) {\n        return "";\n      }\n      const program = print2("program");\n      if (options.htmlWhitespaceSensitivity === "ignore") {\n        return indent([hardline, program]);\n      }\n      return indent(program);\n    }\n    function printInverse(path, print2, options) {\n      const node = path.getValue();\n      const inverse = print2("inverse");\n      const printed = options.htmlWhitespaceSensitivity === "ignore" ? [hardline, inverse] : inverse;\n      if (blockStatementHasElseIfLike(node)) {\n        return printed;\n      }\n      if (blockStatementHasElse(node)) {\n        return [printElseBlock(node, options), indent(printed)];\n      }\n      return "";\n    }\n    function getTextValueParts(value) {\n      return getDocParts(join(line, splitByHtmlWhitespace(value)));\n    }\n    function splitByHtmlWhitespace(string) {\n      return string.split(/[\\t\\n\\f\\r ]+/);\n    }\n    function getCurrentAttributeName(path) {\n      for (let depth = 0; depth < 2; depth++) {\n        const parentNode = path.getParentNode(depth);\n        if (parentNode && parentNode.type === "AttrNode") {\n          return parentNode.name.toLowerCase();\n        }\n      }\n    }\n    function countNewLines(string) {\n      string = typeof string === "string" ? string : "";\n      return string.split("\\n").length - 1;\n    }\n    function countLeadingNewLines(string) {\n      string = typeof string === "string" ? string : "";\n      const newLines = (string.match(/^([^\\S\\n\\r]*[\\n\\r])+/g) || [])[0] || "";\n      return countNewLines(newLines);\n    }\n    function countTrailingNewLines(string) {\n      string = typeof string === "string" ? string : "";\n      const newLines = (string.match(/([\\n\\r][^\\S\\n\\r]*)+$/g) || [])[0] || "";\n      return countNewLines(newLines);\n    }\n    function generateHardlines(number = 0) {\n      return Array.from({\n        length: Math.min(number, NEWLINES_TO_PRESERVE_MAX)\n      }).fill(hardline);\n    }\n    function printStringLiteral(stringLiteral, favoriteQuote) {\n      const {\n        quote,\n        regex\n      } = getPreferredQuote(stringLiteral, favoriteQuote);\n      return [quote, stringLiteral.replace(regex, `\\\\${quote}`), quote];\n    }\n    function needsOppositeQuote(path) {\n      let index = 0;\n      let parentNode = path.getParentNode(index);\n      while (parentNode && isNodeOfSomeType(parentNode, ["SubExpression"])) {\n        index++;\n        parentNode = path.getParentNode(index);\n      }\n      if (parentNode && isNodeOfSomeType(path.getParentNode(index + 1), ["ConcatStatement"]) && isNodeOfSomeType(path.getParentNode(index + 2), ["AttrNode"])) {\n        return true;\n      }\n      return false;\n    }\n    function printSubExpressionPathAndParams(path, print2) {\n      const printed = printPath(path, print2);\n      const params = printParams(path, print2);\n      if (!params) {\n        return printed;\n      }\n      return indent([printed, line, group(params)]);\n    }\n    function printPathAndParams(path, print2) {\n      const p = printPath(path, print2);\n      const params = printParams(path, print2);\n      if (!params) {\n        return p;\n      }\n      return [indent([p, line, params]), softline];\n    }\n    function printPath(path, print2) {\n      return print2("path");\n    }\n    function printParams(path, print2) {\n      const node = path.getValue();\n      const parts = [];\n      if (node.params.length > 0) {\n        const params = path.map(print2, "params");\n        parts.push(...params);\n      }\n      if (node.hash && node.hash.pairs.length > 0) {\n        const hash = print2("hash");\n        parts.push(hash);\n      }\n      if (parts.length === 0) {\n        return "";\n      }\n      return join(line, parts);\n    }\n    function printBlockParams(node) {\n      return ["as |", node.blockParams.join(" "), "|"];\n    }\n    module2.exports = {\n      print,\n      massageAstNode: clean\n    };\n  }\n});\nvar require_parsers3 = __commonJS2({\n  "src/language-handlebars/parsers.js"(exports2, module2) {\n    "use strict";\n    module2.exports = {\n      get glimmer() {\n        return require("./parser-glimmer.js").parsers.glimmer;\n      }\n    };\n  }\n});\nvar require_Handlebars = __commonJS2({\n  "node_modules/linguist-languages/data/Handlebars.json"(exports2, module2) {\n    module2.exports = {\n      name: "Handlebars",\n      type: "markup",\n      color: "#f7931e",\n      aliases: ["hbs", "htmlbars"],\n      extensions: [".handlebars", ".hbs"],\n      tmScope: "text.html.handlebars",\n      aceMode: "handlebars",\n      languageId: 155\n    };\n  }\n});\nvar require_language_handlebars = __commonJS2({\n  "src/language-handlebars/index.js"(exports2, module2) {\n    "use strict";\n    var createLanguage = require_create_language();\n    var printer = require_printer_glimmer();\n    var parsers = require_parsers3();\n    var languages = [createLanguage(require_Handlebars(), () => ({\n      since: "2.3.0",\n      parsers: ["glimmer"],\n      vscodeLanguageIds: ["handlebars"]\n    }))];\n    var printers = {\n      glimmer: printer\n    };\n    module2.exports = {\n      languages,\n      printers,\n      parsers\n    };\n  }\n});\nvar require_pragma3 = __commonJS2({\n  "src/language-graphql/pragma.js"(exports2, module2) {\n    "use strict";\n    function hasPragma(text) {\n      return /^\\s*#[^\\S\\n]*@(?:format|prettier)\\s*(?:\\n|$)/.test(text);\n    }\n    function insertPragma(text) {\n      return "# @format\\n\\n" + text;\n    }\n    module2.exports = {\n      hasPragma,\n      insertPragma\n    };\n  }\n});\nvar require_loc4 = __commonJS2({\n  "src/language-graphql/loc.js"(exports2, module2) {\n    "use strict";\n    function locStart(node) {\n      if (typeof node.start === "number") {\n        return node.start;\n      }\n      return node.loc && node.loc.start;\n    }\n    function locEnd(node) {\n      if (typeof node.end === "number") {\n        return node.end;\n      }\n      return node.loc && node.loc.end;\n    }\n    module2.exports = {\n      locStart,\n      locEnd\n    };\n  }\n});\nvar require_printer_graphql = __commonJS2({\n  "src/language-graphql/printer-graphql.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        join,\n        hardline,\n        line,\n        softline,\n        group,\n        indent,\n        ifBreak\n      }\n    } = require("./doc.js");\n    var {\n      isNextLineEmpty,\n      isNonEmptyArray\n    } = require_util();\n    var {\n      insertPragma\n    } = require_pragma3();\n    var {\n      locStart,\n      locEnd\n    } = require_loc4();\n    function genericPrint(path, options, print) {\n      const node = path.getValue();\n      if (!node) {\n        return "";\n      }\n      if (typeof node === "string") {\n        return node;\n      }\n      switch (node.kind) {\n        case "Document": {\n          const parts = [];\n          path.each((pathChild, index, definitions) => {\n            parts.push(print());\n            if (index !== definitions.length - 1) {\n              parts.push(hardline);\n              if (isNextLineEmpty(options.originalText, pathChild.getValue(), locEnd)) {\n                parts.push(hardline);\n              }\n            }\n          }, "definitions");\n          return [...parts, hardline];\n        }\n        case "OperationDefinition": {\n          const hasOperation = options.originalText[locStart(node)] !== "{";\n          const hasName = Boolean(node.name);\n          return [hasOperation ? node.operation : "", hasOperation && hasName ? [" ", print("name")] : "", hasOperation && !hasName && isNonEmptyArray(node.variableDefinitions) ? " " : "", isNonEmptyArray(node.variableDefinitions) ? group(["(", indent([softline, join([ifBreak("", ", "), softline], path.map(print, "variableDefinitions"))]), softline, ")"]) : "", printDirectives(path, print, node), node.selectionSet ? !hasOperation && !hasName ? "" : " " : "", print("selectionSet")];\n        }\n        case "FragmentDefinition": {\n          return ["fragment ", print("name"), isNonEmptyArray(node.variableDefinitions) ? group(["(", indent([softline, join([ifBreak("", ", "), softline], path.map(print, "variableDefinitions"))]), softline, ")"]) : "", " on ", print("typeCondition"), printDirectives(path, print, node), " ", print("selectionSet")];\n        }\n        case "SelectionSet": {\n          return ["{", indent([hardline, join(hardline, printSequence(path, options, print, "selections"))]), hardline, "}"];\n        }\n        case "Field": {\n          return group([node.alias ? [print("alias"), ": "] : "", print("name"), node.arguments.length > 0 ? group(["(", indent([softline, join([ifBreak("", ", "), softline], printSequence(path, options, print, "arguments"))]), softline, ")"]) : "", printDirectives(path, print, node), node.selectionSet ? " " : "", print("selectionSet")]);\n        }\n        case "Name": {\n          return node.value;\n        }\n        case "StringValue": {\n          if (node.block) {\n            const lines = node.value.replace(/"""/g, "\\\\$&").split("\\n");\n            if (lines.length === 1) {\n              lines[0] = lines[0].trim();\n            }\n            if (lines.every((line2) => line2 === "")) {\n              lines.length = 0;\n            }\n            return join(hardline, [\'"""\', ...lines, \'"""\']);\n          }\n          return [\'"\', node.value.replace(/["\\\\]/g, "\\\\$&").replace(/\\n/g, "\\\\n"), \'"\'];\n        }\n        case "IntValue":\n        case "FloatValue":\n        case "EnumValue": {\n          return node.value;\n        }\n        case "BooleanValue": {\n          return node.value ? "true" : "false";\n        }\n        case "NullValue": {\n          return "null";\n        }\n        case "Variable": {\n          return ["$", print("name")];\n        }\n        case "ListValue": {\n          return group(["[", indent([softline, join([ifBreak("", ", "), softline], path.map(print, "values"))]), softline, "]"]);\n        }\n        case "ObjectValue": {\n          return group(["{", options.bracketSpacing && node.fields.length > 0 ? " " : "", indent([softline, join([ifBreak("", ", "), softline], path.map(print, "fields"))]), softline, ifBreak("", options.bracketSpacing && node.fields.length > 0 ? " " : ""), "}"]);\n        }\n        case "ObjectField":\n        case "Argument": {\n          return [print("name"), ": ", print("value")];\n        }\n        case "Directive": {\n          return ["@", print("name"), node.arguments.length > 0 ? group(["(", indent([softline, join([ifBreak("", ", "), softline], printSequence(path, options, print, "arguments"))]), softline, ")"]) : ""];\n        }\n        case "NamedType": {\n          return print("name");\n        }\n        case "VariableDefinition": {\n          return [print("variable"), ": ", print("type"), node.defaultValue ? [" = ", print("defaultValue")] : "", printDirectives(path, print, node)];\n        }\n        case "ObjectTypeExtension":\n        case "ObjectTypeDefinition": {\n          return [print("description"), node.description ? hardline : "", node.kind === "ObjectTypeExtension" ? "extend " : "", "type ", print("name"), node.interfaces.length > 0 ? [" implements ", ...printInterfaces(path, options, print)] : "", printDirectives(path, print, node), node.fields.length > 0 ? [" {", indent([hardline, join(hardline, printSequence(path, options, print, "fields"))]), hardline, "}"] : ""];\n        }\n        case "FieldDefinition": {\n          return [print("description"), node.description ? hardline : "", print("name"), node.arguments.length > 0 ? group(["(", indent([softline, join([ifBreak("", ", "), softline], printSequence(path, options, print, "arguments"))]), softline, ")"]) : "", ": ", print("type"), printDirectives(path, print, node)];\n        }\n        case "DirectiveDefinition": {\n          return [print("description"), node.description ? hardline : "", "directive ", "@", print("name"), node.arguments.length > 0 ? group(["(", indent([softline, join([ifBreak("", ", "), softline], printSequence(path, options, print, "arguments"))]), softline, ")"]) : "", node.repeatable ? " repeatable" : "", " on ", join(" | ", path.map(print, "locations"))];\n        }\n        case "EnumTypeExtension":\n        case "EnumTypeDefinition": {\n          return [print("description"), node.description ? hardline : "", node.kind === "EnumTypeExtension" ? "extend " : "", "enum ", print("name"), printDirectives(path, print, node), node.values.length > 0 ? [" {", indent([hardline, join(hardline, printSequence(path, options, print, "values"))]), hardline, "}"] : ""];\n        }\n        case "EnumValueDefinition": {\n          return [print("description"), node.description ? hardline : "", print("name"), printDirectives(path, print, node)];\n        }\n        case "InputValueDefinition": {\n          return [print("description"), node.description ? node.description.block ? hardline : line : "", print("name"), ": ", print("type"), node.defaultValue ? [" = ", print("defaultValue")] : "", printDirectives(path, print, node)];\n        }\n        case "InputObjectTypeExtension":\n        case "InputObjectTypeDefinition": {\n          return [print("description"), node.description ? hardline : "", node.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", print("name"), printDirectives(path, print, node), node.fields.length > 0 ? [" {", indent([hardline, join(hardline, printSequence(path, options, print, "fields"))]), hardline, "}"] : ""];\n        }\n        case "SchemaExtension": {\n          return ["extend schema", printDirectives(path, print, node), ...node.operationTypes.length > 0 ? [" {", indent([hardline, join(hardline, printSequence(path, options, print, "operationTypes"))]), hardline, "}"] : []];\n        }\n        case "SchemaDefinition": {\n          return [print("description"), node.description ? hardline : "", "schema", printDirectives(path, print, node), " {", node.operationTypes.length > 0 ? indent([hardline, join(hardline, printSequence(path, options, print, "operationTypes"))]) : "", hardline, "}"];\n        }\n        case "OperationTypeDefinition": {\n          return [print("operation"), ": ", print("type")];\n        }\n        case "InterfaceTypeExtension":\n        case "InterfaceTypeDefinition": {\n          return [print("description"), node.description ? hardline : "", node.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", print("name"), node.interfaces.length > 0 ? [" implements ", ...printInterfaces(path, options, print)] : "", printDirectives(path, print, node), node.fields.length > 0 ? [" {", indent([hardline, join(hardline, printSequence(path, options, print, "fields"))]), hardline, "}"] : ""];\n        }\n        case "FragmentSpread": {\n          return ["...", print("name"), printDirectives(path, print, node)];\n        }\n        case "InlineFragment": {\n          return ["...", node.typeCondition ? [" on ", print("typeCondition")] : "", printDirectives(path, print, node), " ", print("selectionSet")];\n        }\n        case "UnionTypeExtension":\n        case "UnionTypeDefinition": {\n          return group([print("description"), node.description ? hardline : "", group([node.kind === "UnionTypeExtension" ? "extend " : "", "union ", print("name"), printDirectives(path, print, node), node.types.length > 0 ? [" =", ifBreak("", " "), indent([ifBreak([line, "  "]), join([line, "| "], path.map(print, "types"))])] : ""])]);\n        }\n        case "ScalarTypeExtension":\n        case "ScalarTypeDefinition": {\n          return [print("description"), node.description ? hardline : "", node.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", print("name"), printDirectives(path, print, node)];\n        }\n        case "NonNullType": {\n          return [print("type"), "!"];\n        }\n        case "ListType": {\n          return ["[", print("type"), "]"];\n        }\n        default:\n          throw new Error("unknown graphql type: " + JSON.stringify(node.kind));\n      }\n    }\n    function printDirectives(path, print, node) {\n      if (node.directives.length === 0) {\n        return "";\n      }\n      const printed = join(line, path.map(print, "directives"));\n      if (node.kind === "FragmentDefinition" || node.kind === "OperationDefinition") {\n        return group([line, printed]);\n      }\n      return [" ", group(indent([softline, printed]))];\n    }\n    function printSequence(path, options, print, property) {\n      return path.map((path2, index, sequence) => {\n        const printed = print();\n        if (index < sequence.length - 1 && isNextLineEmpty(options.originalText, path2.getValue(), locEnd)) {\n          return [printed, hardline];\n        }\n        return printed;\n      }, property);\n    }\n    function canAttachComment(node) {\n      return node.kind && node.kind !== "Comment";\n    }\n    function printComment(commentPath) {\n      const comment = commentPath.getValue();\n      if (comment.kind === "Comment") {\n        return "#" + comment.value.trimEnd();\n      }\n      throw new Error("Not a comment: " + JSON.stringify(comment));\n    }\n    function printInterfaces(path, options, print) {\n      const node = path.getNode();\n      const parts = [];\n      const {\n        interfaces\n      } = node;\n      const printed = path.map((node2) => print(node2), "interfaces");\n      for (let index = 0; index < interfaces.length; index++) {\n        const interfaceNode = interfaces[index];\n        parts.push(printed[index]);\n        const nextInterfaceNode = interfaces[index + 1];\n        if (nextInterfaceNode) {\n          const textBetween = options.originalText.slice(interfaceNode.loc.end, nextInterfaceNode.loc.start);\n          const hasComment = textBetween.includes("#");\n          const separator = textBetween.replace(/#.*/g, "").trim();\n          parts.push(separator === "," ? "," : " &", hasComment ? line : " ");\n        }\n      }\n      return parts;\n    }\n    function clean(node, newNode) {\n      if (node.kind === "StringValue" && node.block && !node.value.includes("\\n")) {\n        newNode.value = newNode.value.trim();\n      }\n    }\n    clean.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);\n    function hasPrettierIgnore(path) {\n      var _node$comments;\n      const node = path.getValue();\n      return node === null || node === void 0 ? void 0 : (_node$comments = node.comments) === null || _node$comments === void 0 ? void 0 : _node$comments.some((comment) => comment.value.trim() === "prettier-ignore");\n    }\n    module2.exports = {\n      print: genericPrint,\n      massageAstNode: clean,\n      hasPrettierIgnore,\n      insertPragma,\n      printComment,\n      canAttachComment\n    };\n  }\n});\nvar require_options4 = __commonJS2({\n  "src/language-graphql/options.js"(exports2, module2) {\n    "use strict";\n    var commonOptions = require_common_options();\n    module2.exports = {\n      bracketSpacing: commonOptions.bracketSpacing\n    };\n  }\n});\nvar require_parsers4 = __commonJS2({\n  "src/language-graphql/parsers.js"(exports2, module2) {\n    "use strict";\n    module2.exports = {\n      get graphql() {\n        return require("./parser-graphql.js").parsers.graphql;\n      }\n    };\n  }\n});\nvar require_GraphQL = __commonJS2({\n  "node_modules/linguist-languages/data/GraphQL.json"(exports2, module2) {\n    module2.exports = {\n      name: "GraphQL",\n      type: "data",\n      color: "#e10098",\n      extensions: [".graphql", ".gql", ".graphqls"],\n      tmScope: "source.graphql",\n      aceMode: "text",\n      languageId: 139\n    };\n  }\n});\nvar require_language_graphql = __commonJS2({\n  "src/language-graphql/index.js"(exports2, module2) {\n    "use strict";\n    var createLanguage = require_create_language();\n    var printer = require_printer_graphql();\n    var options = require_options4();\n    var parsers = require_parsers4();\n    var languages = [createLanguage(require_GraphQL(), () => ({\n      since: "1.5.0",\n      parsers: ["graphql"],\n      vscodeLanguageIds: ["graphql"]\n    }))];\n    var printers = {\n      graphql: printer\n    };\n    module2.exports = {\n      languages,\n      options,\n      printers,\n      parsers\n    };\n  }\n});\nvar require_collapse_white_space = __commonJS2({\n  "node_modules/collapse-white-space/index.js"(exports2, module2) {\n    "use strict";\n    module2.exports = collapse;\n    function collapse(value) {\n      return String(value).replace(/\\s+/g, " ");\n    }\n  }\n});\nvar require_loc5 = __commonJS2({\n  "src/language-markdown/loc.js"(exports2, module2) {\n    "use strict";\n    function locStart(node) {\n      return node.position.start.offset;\n    }\n    function locEnd(node) {\n      return node.position.end.offset;\n    }\n    module2.exports = {\n      locStart,\n      locEnd\n    };\n  }\n});\nvar require_constants_evaluate = __commonJS2({\n  "src/language-markdown/constants.evaluate.js"(exports2, module2) {\n    module2.exports = {\n      cjkPattern: "(?:[\\\\u02ea-\\\\u02eb\\\\u1100-\\\\u11ff\\\\u2e80-\\\\u2e99\\\\u2e9b-\\\\u2ef3\\\\u2f00-\\\\u2fd5\\\\u2ff0-\\\\u303f\\\\u3041-\\\\u3096\\\\u3099-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312f\\\\u3131-\\\\u318e\\\\u3190-\\\\u3191\\\\u3196-\\\\u31ba\\\\u31c0-\\\\u31e3\\\\u31f0-\\\\u321e\\\\u322a-\\\\u3247\\\\u3260-\\\\u327e\\\\u328a-\\\\u32b0\\\\u32c0-\\\\u32cb\\\\u32d0-\\\\u3370\\\\u337b-\\\\u337f\\\\u33e0-\\\\u33fe\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fef\\\\ua960-\\\\ua97c\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufe10-\\\\ufe1f\\\\ufe30-\\\\ufe6f\\\\uff00-\\\\uffef]|[\\\\ud840-\\\\ud868\\\\ud86a-\\\\ud86c\\\\ud86f-\\\\ud872\\\\ud874-\\\\ud879][\\\\udc00-\\\\udfff]|\\\\ud82c[\\\\udc00-\\\\udd1e\\\\udd50-\\\\udd52\\\\udd64-\\\\udd67]|\\\\ud83c[\\\\ude00\\\\ude50-\\\\ude51]|\\\\ud869[\\\\udc00-\\\\uded6\\\\udf00-\\\\udfff]|\\\\ud86d[\\\\udc00-\\\\udf34\\\\udf40-\\\\udfff]|\\\\ud86e[\\\\udc00-\\\\udc1d\\\\udc20-\\\\udfff]|\\\\ud873[\\\\udc00-\\\\udea1\\\\udeb0-\\\\udfff]|\\\\ud87a[\\\\udc00-\\\\udfe0]|\\\\ud87e[\\\\udc00-\\\\ude1d])(?:[\\\\ufe00-\\\\ufe0f]|\\\\udb40[\\\\udd00-\\\\uddef])?",\n      kPattern: "[\\\\u1100-\\\\u11ff\\\\u3001-\\\\u3003\\\\u3008-\\\\u3011\\\\u3013-\\\\u301f\\\\u302e-\\\\u3030\\\\u3037\\\\u30fb\\\\u3131-\\\\u318e\\\\u3200-\\\\u321e\\\\u3260-\\\\u327e\\\\ua960-\\\\ua97c\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\ufe45-\\\\ufe46\\\\uff61-\\\\uff65\\\\uffa0-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc]",\n      punctuationPattern: "[\\\\u0021-\\\\u002f\\\\u003a-\\\\u0040\\\\u005b-\\\\u0060\\\\u007b-\\\\u007e\\\\u00a1\\\\u00a7\\\\u00ab\\\\u00b6-\\\\u00b7\\\\u00bb\\\\u00bf\\\\u037e\\\\u0387\\\\u055a-\\\\u055f\\\\u0589-\\\\u058a\\\\u05be\\\\u05c0\\\\u05c3\\\\u05c6\\\\u05f3-\\\\u05f4\\\\u0609-\\\\u060a\\\\u060c-\\\\u060d\\\\u061b\\\\u061e-\\\\u061f\\\\u066a-\\\\u066d\\\\u06d4\\\\u0700-\\\\u070d\\\\u07f7-\\\\u07f9\\\\u0830-\\\\u083e\\\\u085e\\\\u0964-\\\\u0965\\\\u0970\\\\u09fd\\\\u0a76\\\\u0af0\\\\u0c77\\\\u0c84\\\\u0df4\\\\u0e4f\\\\u0e5a-\\\\u0e5b\\\\u0f04-\\\\u0f12\\\\u0f14\\\\u0f3a-\\\\u0f3d\\\\u0f85\\\\u0fd0-\\\\u0fd4\\\\u0fd9-\\\\u0fda\\\\u104a-\\\\u104f\\\\u10fb\\\\u1360-\\\\u1368\\\\u1400\\\\u166e\\\\u169b-\\\\u169c\\\\u16eb-\\\\u16ed\\\\u1735-\\\\u1736\\\\u17d4-\\\\u17d6\\\\u17d8-\\\\u17da\\\\u1800-\\\\u180a\\\\u1944-\\\\u1945\\\\u1a1e-\\\\u1a1f\\\\u1aa0-\\\\u1aa6\\\\u1aa8-\\\\u1aad\\\\u1b5a-\\\\u1b60\\\\u1bfc-\\\\u1bff\\\\u1c3b-\\\\u1c3f\\\\u1c7e-\\\\u1c7f\\\\u1cc0-\\\\u1cc7\\\\u1cd3\\\\u2010-\\\\u2027\\\\u2030-\\\\u2043\\\\u2045-\\\\u2051\\\\u2053-\\\\u205e\\\\u207d-\\\\u207e\\\\u208d-\\\\u208e\\\\u2308-\\\\u230b\\\\u2329-\\\\u232a\\\\u2768-\\\\u2775\\\\u27c5-\\\\u27c6\\\\u27e6-\\\\u27ef\\\\u2983-\\\\u2998\\\\u29d8-\\\\u29db\\\\u29fc-\\\\u29fd\\\\u2cf9-\\\\u2cfc\\\\u2cfe-\\\\u2cff\\\\u2d70\\\\u2e00-\\\\u2e2e\\\\u2e30-\\\\u2e4f\\\\u3001-\\\\u3003\\\\u3008-\\\\u3011\\\\u3014-\\\\u301f\\\\u3030\\\\u303d\\\\u30a0\\\\u30fb\\\\ua4fe-\\\\ua4ff\\\\ua60d-\\\\ua60f\\\\ua673\\\\ua67e\\\\ua6f2-\\\\ua6f7\\\\ua874-\\\\ua877\\\\ua8ce-\\\\ua8cf\\\\ua8f8-\\\\ua8fa\\\\ua8fc\\\\ua92e-\\\\ua92f\\\\ua95f\\\\ua9c1-\\\\ua9cd\\\\ua9de-\\\\ua9df\\\\uaa5c-\\\\uaa5f\\\\uaade-\\\\uaadf\\\\uaaf0-\\\\uaaf1\\\\uabeb\\\\ufd3e-\\\\ufd3f\\\\ufe10-\\\\ufe19\\\\ufe30-\\\\ufe52\\\\ufe54-\\\\ufe61\\\\ufe63\\\\ufe68\\\\ufe6a-\\\\ufe6b\\\\uff01-\\\\uff03\\\\uff05-\\\\uff0a\\\\uff0c-\\\\uff0f\\\\uff1a-\\\\uff1b\\\\uff1f-\\\\uff20\\\\uff3b-\\\\uff3d\\\\uff3f\\\\uff5b\\\\uff5d\\\\uff5f-\\\\uff65]|\\\\ud800[\\\\udd00-\\\\udd02\\\\udf9f\\\\udfd0]|\\\\ud801[\\\\udd6f]|\\\\ud802[\\\\udc57\\\\udd1f\\\\udd3f\\\\ude50-\\\\ude58\\\\ude7f\\\\udef0-\\\\udef6\\\\udf39-\\\\udf3f\\\\udf99-\\\\udf9c]|\\\\ud803[\\\\udf55-\\\\udf59]|\\\\ud804[\\\\udc47-\\\\udc4d\\\\udcbb-\\\\udcbc\\\\udcbe-\\\\udcc1\\\\udd40-\\\\udd43\\\\udd74-\\\\udd75\\\\uddc5-\\\\uddc8\\\\uddcd\\\\udddb\\\\udddd-\\\\udddf\\\\ude38-\\\\ude3d\\\\udea9]|\\\\ud805[\\\\udc4b-\\\\udc4f\\\\udc5b\\\\udc5d\\\\udcc6\\\\uddc1-\\\\uddd7\\\\ude41-\\\\ude43\\\\ude60-\\\\ude6c\\\\udf3c-\\\\udf3e]|\\\\ud806[\\\\udc3b\\\\udde2\\\\ude3f-\\\\ude46\\\\ude9a-\\\\ude9c\\\\ude9e-\\\\udea2]|\\\\ud807[\\\\udc41-\\\\udc45\\\\udc70-\\\\udc71\\\\udef7-\\\\udef8\\\\udfff]|\\\\ud809[\\\\udc70-\\\\udc74]|\\\\ud81a[\\\\ude6e-\\\\ude6f\\\\udef5\\\\udf37-\\\\udf3b\\\\udf44]|\\\\ud81b[\\\\ude97-\\\\ude9a\\\\udfe2]|\\\\ud82f[\\\\udc9f]|\\\\ud836[\\\\ude87-\\\\ude8b]|\\\\ud83a[\\\\udd5e-\\\\udd5f]"\n    };\n  }\n});\nvar require_utils10 = __commonJS2({\n  "src/language-markdown/utils.js"(exports2, module2) {\n    "use strict";\n    var {\n      getLast\n    } = require_util();\n    var {\n      locStart,\n      locEnd\n    } = require_loc5();\n    var {\n      cjkPattern,\n      kPattern,\n      punctuationPattern\n    } = require_constants_evaluate();\n    var INLINE_NODE_TYPES = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"];\n    var INLINE_NODE_WRAPPER_TYPES = [...INLINE_NODE_TYPES, "tableCell", "paragraph", "heading"];\n    var kRegex = new RegExp(kPattern);\n    var punctuationRegex = new RegExp(punctuationPattern);\n    function splitText(text, options) {\n      const KIND_NON_CJK = "non-cjk";\n      const KIND_CJ_LETTER = "cj-letter";\n      const KIND_K_LETTER = "k-letter";\n      const KIND_CJK_PUNCTUATION = "cjk-punctuation";\n      const nodes = [];\n      const tokens = (options.proseWrap === "preserve" ? text : text.replace(new RegExp(`(${cjkPattern})\n(${cjkPattern})`, "g"), "$1$2")).split(/([\\t\\n ]+)/);\n      for (const [index, token] of tokens.entries()) {\n        if (index % 2 === 1) {\n          nodes.push({\n            type: "whitespace",\n            value: /\\n/.test(token) ? "\\n" : " "\n          });\n          continue;\n        }\n        if ((index === 0 || index === tokens.length - 1) && token === "") {\n          continue;\n        }\n        const innerTokens = token.split(new RegExp(`(${cjkPattern})`));\n        for (const [innerIndex, innerToken] of innerTokens.entries()) {\n          if ((innerIndex === 0 || innerIndex === innerTokens.length - 1) && innerToken === "") {\n            continue;\n          }\n          if (innerIndex % 2 === 0) {\n            if (innerToken !== "") {\n              appendNode({\n                type: "word",\n                value: innerToken,\n                kind: KIND_NON_CJK,\n                hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),\n                hasTrailingPunctuation: punctuationRegex.test(getLast(innerToken))\n              });\n            }\n            continue;\n          }\n          appendNode(punctuationRegex.test(innerToken) ? {\n            type: "word",\n            value: innerToken,\n            kind: KIND_CJK_PUNCTUATION,\n            hasLeadingPunctuation: true,\n            hasTrailingPunctuation: true\n          } : {\n            type: "word",\n            value: innerToken,\n            kind: kRegex.test(innerToken) ? KIND_K_LETTER : KIND_CJ_LETTER,\n            hasLeadingPunctuation: false,\n            hasTrailingPunctuation: false\n          });\n        }\n      }\n      return nodes;\n      function appendNode(node) {\n        const lastNode = getLast(nodes);\n        if (lastNode && lastNode.type === "word") {\n          if (lastNode.kind === KIND_NON_CJK && node.kind === KIND_CJ_LETTER && !lastNode.hasTrailingPunctuation || lastNode.kind === KIND_CJ_LETTER && node.kind === KIND_NON_CJK && !node.hasLeadingPunctuation) {\n            nodes.push({\n              type: "whitespace",\n              value: " "\n            });\n          } else if (!isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) && ![lastNode.value, node.value].some((value) => /\\u3000/.test(value))) {\n            nodes.push({\n              type: "whitespace",\n              value: ""\n            });\n          }\n        }\n        nodes.push(node);\n        function isBetween(kind1, kind2) {\n          return lastNode.kind === kind1 && node.kind === kind2 || lastNode.kind === kind2 && node.kind === kind1;\n        }\n      }\n    }\n    function getOrderedListItemInfo(orderListItem, originalText) {\n      const [, numberText, marker, leadingSpaces] = originalText.slice(orderListItem.position.start.offset, orderListItem.position.end.offset).match(/^\\s*(\\d+)(\\.|\\))(\\s*)/);\n      return {\n        numberText,\n        marker,\n        leadingSpaces\n      };\n    }\n    function hasGitDiffFriendlyOrderedList(node, options) {\n      if (!node.ordered) {\n        return false;\n      }\n      if (node.children.length < 2) {\n        return false;\n      }\n      const firstNumber = Number(getOrderedListItemInfo(node.children[0], options.originalText).numberText);\n      const secondNumber = Number(getOrderedListItemInfo(node.children[1], options.originalText).numberText);\n      if (firstNumber === 0 && node.children.length > 2) {\n        const thirdNumber = Number(getOrderedListItemInfo(node.children[2], options.originalText).numberText);\n        return secondNumber === 1 && thirdNumber === 1;\n      }\n      return secondNumber === 1;\n    }\n    function getFencedCodeBlockValue(node, originalText) {\n      const {\n        value\n      } = node;\n      if (node.position.end.offset === originalText.length && value.endsWith("\\n") && originalText.endsWith("\\n")) {\n        return value.slice(0, -1);\n      }\n      return value;\n    }\n    function mapAst(ast, handler) {\n      return function preorder(node, index, parentStack) {\n        const newNode = Object.assign({}, handler(node, index, parentStack));\n        if (newNode.children) {\n          newNode.children = newNode.children.map((child, index2) => preorder(child, index2, [newNode, ...parentStack]));\n        }\n        return newNode;\n      }(ast, null, []);\n    }\n    function isAutolink(node) {\n      if ((node === null || node === void 0 ? void 0 : node.type) !== "link" || node.children.length !== 1) {\n        return false;\n      }\n      const [child] = node.children;\n      return locStart(node) === locStart(child) && locEnd(node) === locEnd(child);\n    }\n    module2.exports = {\n      mapAst,\n      splitText,\n      punctuationPattern,\n      getFencedCodeBlockValue,\n      getOrderedListItemInfo,\n      hasGitDiffFriendlyOrderedList,\n      INLINE_NODE_TYPES,\n      INLINE_NODE_WRAPPER_TYPES,\n      isAutolink\n    };\n  }\n});\nvar require_embed3 = __commonJS2({\n  "src/language-markdown/embed.js"(exports2, module2) {\n    "use strict";\n    var {\n      inferParserByLanguage,\n      getMaxContinuousCount\n    } = require_util();\n    var {\n      builders: {\n        hardline,\n        markAsRoot\n      },\n      utils: {\n        replaceEndOfLine\n      }\n    } = require("./doc.js");\n    var printFrontMatter = require_print();\n    var {\n      getFencedCodeBlockValue\n    } = require_utils10();\n    function embed(path, print, textToDoc, options) {\n      const node = path.getValue();\n      if (node.type === "code" && node.lang !== null) {\n        const parser = inferParserByLanguage(node.lang, options);\n        if (parser) {\n          const styleUnit = options.__inJsTemplate ? "~" : "`";\n          const style = styleUnit.repeat(Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1));\n          const newOptions = {\n            parser\n          };\n          if (node.lang === "tsx") {\n            newOptions.filepath = "dummy.tsx";\n          }\n          const doc2 = textToDoc(getFencedCodeBlockValue(node, options.originalText), newOptions, {\n            stripTrailingHardline: true\n          });\n          return markAsRoot([style, node.lang, node.meta ? " " + node.meta : "", hardline, replaceEndOfLine(doc2), hardline, style]);\n        }\n      }\n      switch (node.type) {\n        case "front-matter":\n          return printFrontMatter(node, textToDoc);\n        case "importExport":\n          return [textToDoc(node.value, {\n            parser: "babel"\n          }, {\n            stripTrailingHardline: true\n          }), hardline];\n        case "jsx":\n          return textToDoc(`<$>${node.value}</$>`, {\n            parser: "__js_expression",\n            rootMarker: "mdx"\n          }, {\n            stripTrailingHardline: true\n          });\n      }\n      return null;\n    }\n    module2.exports = embed;\n  }\n});\nvar require_pragma4 = __commonJS2({\n  "src/language-markdown/pragma.js"(exports2, module2) {\n    "use strict";\n    var parseFrontMatter = require_parse4();\n    var pragmas = ["format", "prettier"];\n    function startWithPragma(text) {\n      const pragma = `@(${pragmas.join("|")})`;\n      const regex = new RegExp([`\x3c!--\\\\s*${pragma}\\\\s*--\x3e`, `{\\\\s*\\\\/\\\\*\\\\s*${pragma}\\\\s*\\\\*\\\\/\\\\s*}`, `\x3c!--.*\\r?\n[\\\\s\\\\S]*(^|\n)[^\\\\S\n]*${pragma}[^\\\\S\n]*($|\n)[\\\\s\\\\S]*\n.*--\x3e`].join("|"), "m");\n      const matched = text.match(regex);\n      return (matched === null || matched === void 0 ? void 0 : matched.index) === 0;\n    }\n    module2.exports = {\n      startWithPragma,\n      hasPragma: (text) => startWithPragma(parseFrontMatter(text).content.trimStart()),\n      insertPragma: (text) => {\n        const extracted = parseFrontMatter(text);\n        const pragma = `\x3c!-- @${pragmas[0]} --\x3e`;\n        return extracted.frontMatter ? `${extracted.frontMatter.raw}\n\n${pragma}\n\n${extracted.content}` : `${pragma}\n\n${extracted.content}`;\n      }\n    };\n  }\n});\nvar require_print_preprocess2 = __commonJS2({\n  "src/language-markdown/print-preprocess.js"(exports2, module2) {\n    "use strict";\n    var getLast = require_get_last();\n    var {\n      getOrderedListItemInfo,\n      mapAst,\n      splitText\n    } = require_utils10();\n    var isSingleCharRegex = /^.$/su;\n    function preprocess(ast, options) {\n      ast = restoreUnescapedCharacter(ast, options);\n      ast = mergeContinuousTexts(ast);\n      ast = transformInlineCode(ast, options);\n      ast = transformIndentedCodeblockAndMarkItsParentList(ast, options);\n      ast = markAlignedList(ast, options);\n      ast = splitTextIntoSentences(ast, options);\n      ast = transformImportExport(ast);\n      ast = mergeContinuousImportExport(ast);\n      return ast;\n    }\n    function transformImportExport(ast) {\n      return mapAst(ast, (node) => {\n        if (node.type !== "import" && node.type !== "export") {\n          return node;\n        }\n        return Object.assign(Object.assign({}, node), {}, {\n          type: "importExport"\n        });\n      });\n    }\n    function transformInlineCode(ast, options) {\n      return mapAst(ast, (node) => {\n        if (node.type !== "inlineCode" || options.proseWrap === "preserve") {\n          return node;\n        }\n        return Object.assign(Object.assign({}, node), {}, {\n          value: node.value.replace(/\\s+/g, " ")\n        });\n      });\n    }\n    function restoreUnescapedCharacter(ast, options) {\n      return mapAst(ast, (node) => node.type !== "text" || node.value === "*" || node.value === "_" || !isSingleCharRegex.test(node.value) || node.position.end.offset - node.position.start.offset === node.value.length ? node : Object.assign(Object.assign({}, node), {}, {\n        value: options.originalText.slice(node.position.start.offset, node.position.end.offset)\n      }));\n    }\n    function mergeContinuousImportExport(ast) {\n      return mergeChildren(ast, (prevNode, node) => prevNode.type === "importExport" && node.type === "importExport", (prevNode, node) => ({\n        type: "importExport",\n        value: prevNode.value + "\\n\\n" + node.value,\n        position: {\n          start: prevNode.position.start,\n          end: node.position.end\n        }\n      }));\n    }\n    function mergeChildren(ast, shouldMerge, mergeNode) {\n      return mapAst(ast, (node) => {\n        if (!node.children) {\n          return node;\n        }\n        const children = node.children.reduce((current, child) => {\n          const lastChild = getLast(current);\n          if (lastChild && shouldMerge(lastChild, child)) {\n            current.splice(-1, 1, mergeNode(lastChild, child));\n          } else {\n            current.push(child);\n          }\n          return current;\n        }, []);\n        return Object.assign(Object.assign({}, node), {}, {\n          children\n        });\n      });\n    }\n    function mergeContinuousTexts(ast) {\n      return mergeChildren(ast, (prevNode, node) => prevNode.type === "text" && node.type === "text", (prevNode, node) => ({\n        type: "text",\n        value: prevNode.value + node.value,\n        position: {\n          start: prevNode.position.start,\n          end: node.position.end\n        }\n      }));\n    }\n    function splitTextIntoSentences(ast, options) {\n      return mapAst(ast, (node, index, [parentNode]) => {\n        if (node.type !== "text") {\n          return node;\n        }\n        let {\n          value\n        } = node;\n        if (parentNode.type === "paragraph") {\n          if (index === 0) {\n            value = value.trimStart();\n          }\n          if (index === parentNode.children.length - 1) {\n            value = value.trimEnd();\n          }\n        }\n        return {\n          type: "sentence",\n          position: node.position,\n          children: splitText(value, options)\n        };\n      });\n    }\n    function transformIndentedCodeblockAndMarkItsParentList(ast, options) {\n      return mapAst(ast, (node, index, parentStack) => {\n        if (node.type === "code") {\n          const isIndented = /^\\n?(?: {4,}|\\t)/.test(options.originalText.slice(node.position.start.offset, node.position.end.offset));\n          node.isIndented = isIndented;\n          if (isIndented) {\n            for (let i = 0; i < parentStack.length; i++) {\n              const parent = parentStack[i];\n              if (parent.hasIndentedCodeblock) {\n                break;\n              }\n              if (parent.type === "list") {\n                parent.hasIndentedCodeblock = true;\n              }\n            }\n          }\n        }\n        return node;\n      });\n    }\n    function markAlignedList(ast, options) {\n      return mapAst(ast, (node, index, parentStack) => {\n        if (node.type === "list" && node.children.length > 0) {\n          for (let i = 0; i < parentStack.length; i++) {\n            const parent = parentStack[i];\n            if (parent.type === "list" && !parent.isAligned) {\n              node.isAligned = false;\n              return node;\n            }\n          }\n          node.isAligned = isAligned(node);\n        }\n        return node;\n      });\n      function getListItemStart(listItem) {\n        return listItem.children.length === 0 ? -1 : listItem.children[0].position.start.column - 1;\n      }\n      function isAligned(list) {\n        if (!list.ordered) {\n          return true;\n        }\n        const [firstItem, secondItem] = list.children;\n        const firstInfo = getOrderedListItemInfo(firstItem, options.originalText);\n        if (firstInfo.leadingSpaces.length > 1) {\n          return true;\n        }\n        const firstStart = getListItemStart(firstItem);\n        if (firstStart === -1) {\n          return false;\n        }\n        if (list.children.length === 1) {\n          return firstStart % options.tabWidth === 0;\n        }\n        const secondStart = getListItemStart(secondItem);\n        if (firstStart !== secondStart) {\n          return false;\n        }\n        if (firstStart % options.tabWidth === 0) {\n          return true;\n        }\n        const secondInfo = getOrderedListItemInfo(secondItem, options.originalText);\n        return secondInfo.leadingSpaces.length > 1;\n      }\n    }\n    module2.exports = preprocess;\n  }\n});\nvar require_clean4 = __commonJS2({\n  "src/language-markdown/clean.js"(exports2, module2) {\n    "use strict";\n    var collapseWhiteSpace = require_collapse_white_space();\n    var {\n      isFrontMatterNode\n    } = require_util();\n    var {\n      startWithPragma\n    } = require_pragma4();\n    var ignoredProperties = /* @__PURE__ */ new Set(["position", "raw"]);\n    function clean(ast, newObj, parent) {\n      if (ast.type === "front-matter" || ast.type === "code" || ast.type === "yaml" || ast.type === "import" || ast.type === "export" || ast.type === "jsx") {\n        delete newObj.value;\n      }\n      if (ast.type === "list") {\n        delete newObj.isAligned;\n      }\n      if (ast.type === "list" || ast.type === "listItem") {\n        delete newObj.spread;\n        delete newObj.loose;\n      }\n      if (ast.type === "text") {\n        return null;\n      }\n      if (ast.type === "inlineCode") {\n        newObj.value = ast.value.replace(/[\\t\\n ]+/g, " ");\n      }\n      if (ast.type === "wikiLink") {\n        newObj.value = ast.value.trim().replace(/[\\t\\n]+/g, " ");\n      }\n      if (ast.type === "definition" || ast.type === "linkReference" || ast.type === "imageReference") {\n        newObj.label = collapseWhiteSpace(ast.label);\n      }\n      if ((ast.type === "definition" || ast.type === "link" || ast.type === "image") && ast.title) {\n        newObj.title = ast.title.replace(/\\\\(["\')])/g, "$1");\n      }\n      if (parent && parent.type === "root" && parent.children.length > 0 && (parent.children[0] === ast || isFrontMatterNode(parent.children[0]) && parent.children[1] === ast) && ast.type === "html" && startWithPragma(ast.value)) {\n        return null;\n      }\n    }\n    clean.ignoredProperties = ignoredProperties;\n    module2.exports = clean;\n  }\n});\nvar require_printer_markdown = __commonJS2({\n  "src/language-markdown/printer-markdown.js"(exports2, module2) {\n    "use strict";\n    var collapseWhiteSpace = require_collapse_white_space();\n    var {\n      getLast,\n      getMinNotPresentContinuousCount,\n      getMaxContinuousCount,\n      getStringWidth,\n      isNonEmptyArray\n    } = require_util();\n    var {\n      builders: {\n        breakParent,\n        join,\n        line,\n        literalline,\n        markAsRoot,\n        hardline,\n        softline,\n        ifBreak,\n        fill,\n        align,\n        indent,\n        group,\n        hardlineWithoutBreakParent\n      },\n      utils: {\n        normalizeDoc,\n        replaceTextEndOfLine\n      },\n      printer: {\n        printDocToString\n      }\n    } = require("./doc.js");\n    var embed = require_embed3();\n    var {\n      insertPragma\n    } = require_pragma4();\n    var {\n      locStart,\n      locEnd\n    } = require_loc5();\n    var preprocess = require_print_preprocess2();\n    var clean = require_clean4();\n    var {\n      getFencedCodeBlockValue,\n      hasGitDiffFriendlyOrderedList,\n      splitText,\n      punctuationPattern,\n      INLINE_NODE_TYPES,\n      INLINE_NODE_WRAPPER_TYPES,\n      isAutolink\n    } = require_utils10();\n    var TRAILING_HARDLINE_NODES = /* @__PURE__ */ new Set(["importExport"]);\n    var SINGLE_LINE_NODE_TYPES = ["heading", "tableCell", "link", "wikiLink"];\n    var SIBLING_NODE_TYPES = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);\n    function genericPrint(path, options, print) {\n      const node = path.getValue();\n      if (shouldRemainTheSameContent(path)) {\n        return splitText(options.originalText.slice(node.position.start.offset, node.position.end.offset), options).map((node2) => node2.type === "word" ? node2.value : node2.value === "" ? "" : printLine(path, node2.value, options));\n      }\n      switch (node.type) {\n        case "front-matter":\n          return options.originalText.slice(node.position.start.offset, node.position.end.offset);\n        case "root":\n          if (node.children.length === 0) {\n            return "";\n          }\n          return [normalizeDoc(printRoot(path, options, print)), !TRAILING_HARDLINE_NODES.has(getLastDescendantNode(node).type) ? hardline : ""];\n        case "paragraph":\n          return printChildren(path, options, print, {\n            postprocessor: fill\n          });\n        case "sentence":\n          return printChildren(path, options, print);\n        case "word": {\n          let escapedValue = node.value.replace(/\\*/g, "\\\\$&").replace(new RegExp([`(^|${punctuationPattern})(_+)`, `(_+)(${punctuationPattern}|$)`].join("|"), "g"), (_, text1, underscore1, underscore2, text2) => (underscore1 ? `${text1}${underscore1}` : `${underscore2}${text2}`).replace(/_/g, "\\\\_"));\n          const isFirstSentence = (node2, name, index) => node2.type === "sentence" && index === 0;\n          const isLastChildAutolink = (node2, name, index) => isAutolink(node2.children[index - 1]);\n          if (escapedValue !== node.value && (path.match(void 0, isFirstSentence, isLastChildAutolink) || path.match(void 0, isFirstSentence, (node2, name, index) => node2.type === "emphasis" && index === 0, isLastChildAutolink))) {\n            escapedValue = escapedValue.replace(/^(\\\\?[*_])+/, (prefix) => prefix.replace(/\\\\/g, ""));\n          }\n          return escapedValue;\n        }\n        case "whitespace": {\n          const parentNode = path.getParentNode();\n          const index = parentNode.children.indexOf(node);\n          const nextNode = parentNode.children[index + 1];\n          const proseWrap = nextNode && /^>|^(?:[*+-]|#{1,6}|\\d+[).])$/.test(nextNode.value) ? "never" : options.proseWrap;\n          return printLine(path, node.value, {\n            proseWrap\n          });\n        }\n        case "emphasis": {\n          let style;\n          if (isAutolink(node.children[0])) {\n            style = options.originalText[node.position.start.offset];\n          } else {\n            const parentNode = path.getParentNode();\n            const index = parentNode.children.indexOf(node);\n            const prevNode = parentNode.children[index - 1];\n            const nextNode = parentNode.children[index + 1];\n            const hasPrevOrNextWord = prevNode && prevNode.type === "sentence" && prevNode.children.length > 0 && getLast(prevNode.children).type === "word" && !getLast(prevNode.children).hasTrailingPunctuation || nextNode && nextNode.type === "sentence" && nextNode.children.length > 0 && nextNode.children[0].type === "word" && !nextNode.children[0].hasLeadingPunctuation;\n            style = hasPrevOrNextWord || getAncestorNode(path, "emphasis") ? "*" : "_";\n          }\n          return [style, printChildren(path, options, print), style];\n        }\n        case "strong":\n          return ["**", printChildren(path, options, print), "**"];\n        case "delete":\n          return ["~~", printChildren(path, options, print), "~~"];\n        case "inlineCode": {\n          const backtickCount = getMinNotPresentContinuousCount(node.value, "`");\n          const style = "`".repeat(backtickCount || 1);\n          const gap = backtickCount && !/^\\s/.test(node.value) ? " " : "";\n          return [style, gap, node.value, gap, style];\n        }\n        case "wikiLink": {\n          let contents = "";\n          if (options.proseWrap === "preserve") {\n            contents = node.value;\n          } else {\n            contents = node.value.replace(/[\\t\\n]+/g, " ");\n          }\n          return ["[[", contents, "]]"];\n        }\n        case "link":\n          switch (options.originalText[node.position.start.offset]) {\n            case "<": {\n              const mailto = "mailto:";\n              const url = node.url.startsWith(mailto) && options.originalText.slice(node.position.start.offset + 1, node.position.start.offset + 1 + mailto.length) !== mailto ? node.url.slice(mailto.length) : node.url;\n              return ["<", url, ">"];\n            }\n            case "[":\n              return ["[", printChildren(path, options, print), "](", printUrl(node.url, ")"), printTitle(node.title, options), ")"];\n            default:\n              return options.originalText.slice(node.position.start.offset, node.position.end.offset);\n          }\n        case "image":\n          return ["![", node.alt || "", "](", printUrl(node.url, ")"), printTitle(node.title, options), ")"];\n        case "blockquote":\n          return ["> ", align("> ", printChildren(path, options, print))];\n        case "heading":\n          return ["#".repeat(node.depth) + " ", printChildren(path, options, print)];\n        case "code": {\n          if (node.isIndented) {\n            const alignment = " ".repeat(4);\n            return align(alignment, [alignment, ...replaceTextEndOfLine(node.value, hardline)]);\n          }\n          const styleUnit = options.__inJsTemplate ? "~" : "`";\n          const style = styleUnit.repeat(Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1));\n          return [style, node.lang || "", node.meta ? " " + node.meta : "", hardline, ...replaceTextEndOfLine(getFencedCodeBlockValue(node, options.originalText), hardline), hardline, style];\n        }\n        case "html": {\n          const parentNode = path.getParentNode();\n          const value = parentNode.type === "root" && getLast(parentNode.children) === node ? node.value.trimEnd() : node.value;\n          const isHtmlComment = /^\x3c!--.*--\x3e$/s.test(value);\n          return replaceTextEndOfLine(value, isHtmlComment ? hardline : markAsRoot(literalline));\n        }\n        case "list": {\n          const nthSiblingIndex = getNthListSiblingIndex(node, path.getParentNode());\n          const isGitDiffFriendlyOrderedList = hasGitDiffFriendlyOrderedList(node, options);\n          return printChildren(path, options, print, {\n            processor: (childPath, index) => {\n              const prefix = getPrefix();\n              const childNode = childPath.getValue();\n              if (childNode.children.length === 2 && childNode.children[1].type === "html" && childNode.children[0].position.start.column !== childNode.children[1].position.start.column) {\n                return [prefix, printListItem(childPath, options, print, prefix)];\n              }\n              return [prefix, align(" ".repeat(prefix.length), printListItem(childPath, options, print, prefix))];\n              function getPrefix() {\n                const rawPrefix = node.ordered ? (index === 0 ? node.start : isGitDiffFriendlyOrderedList ? 1 : node.start + index) + (nthSiblingIndex % 2 === 0 ? ". " : ") ") : nthSiblingIndex % 2 === 0 ? "- " : "* ";\n                return node.isAligned || node.hasIndentedCodeblock ? alignListPrefix(rawPrefix, options) : rawPrefix;\n              }\n            }\n          });\n        }\n        case "thematicBreak": {\n          const counter = getAncestorCounter(path, "list");\n          if (counter === -1) {\n            return "---";\n          }\n          const nthSiblingIndex = getNthListSiblingIndex(path.getParentNode(counter), path.getParentNode(counter + 1));\n          return nthSiblingIndex % 2 === 0 ? "***" : "---";\n        }\n        case "linkReference":\n          return ["[", printChildren(path, options, print), "]", node.referenceType === "full" ? printLinkReference(node) : node.referenceType === "collapsed" ? "[]" : ""];\n        case "imageReference":\n          switch (node.referenceType) {\n            case "full":\n              return ["![", node.alt || "", "]", printLinkReference(node)];\n            default:\n              return ["![", node.alt, "]", node.referenceType === "collapsed" ? "[]" : ""];\n          }\n        case "definition": {\n          const lineOrSpace = options.proseWrap === "always" ? line : " ";\n          return group([printLinkReference(node), ":", indent([lineOrSpace, printUrl(node.url), node.title === null ? "" : [lineOrSpace, printTitle(node.title, options, false)]])]);\n        }\n        case "footnote":\n          return ["[^", printChildren(path, options, print), "]"];\n        case "footnoteReference":\n          return printFootnoteReference(node);\n        case "footnoteDefinition": {\n          const nextNode = path.getParentNode().children[path.getName() + 1];\n          const shouldInlineFootnote = node.children.length === 1 && node.children[0].type === "paragraph" && (options.proseWrap === "never" || options.proseWrap === "preserve" && node.children[0].position.start.line === node.children[0].position.end.line);\n          return [printFootnoteReference(node), ": ", shouldInlineFootnote ? printChildren(path, options, print) : group([align(" ".repeat(4), printChildren(path, options, print, {\n            processor: (childPath, index) => index === 0 ? group([softline, print()]) : print()\n          })), nextNode && nextNode.type === "footnoteDefinition" ? softline : ""])];\n        }\n        case "table":\n          return printTable(path, options, print);\n        case "tableCell":\n          return printChildren(path, options, print);\n        case "break":\n          return /\\s/.test(options.originalText[node.position.start.offset]) ? ["  ", markAsRoot(literalline)] : ["\\\\", hardline];\n        case "liquidNode":\n          return replaceTextEndOfLine(node.value, hardline);\n        case "importExport":\n          return [node.value, hardline];\n        case "esComment":\n          return ["{/* ", node.value, " */}"];\n        case "jsx":\n          return node.value;\n        case "math":\n          return ["$$", hardline, node.value ? [...replaceTextEndOfLine(node.value, hardline), hardline] : "", "$$"];\n        case "inlineMath": {\n          return options.originalText.slice(locStart(node), locEnd(node));\n        }\n        case "tableRow":\n        case "listItem":\n        default:\n          throw new Error(`Unknown markdown type ${JSON.stringify(node.type)}`);\n      }\n    }\n    function printListItem(path, options, print, listPrefix) {\n      const node = path.getValue();\n      const prefix = node.checked === null ? "" : node.checked ? "[x] " : "[ ] ";\n      return [prefix, printChildren(path, options, print, {\n        processor: (childPath, index) => {\n          if (index === 0 && childPath.getValue().type !== "list") {\n            return align(" ".repeat(prefix.length), print());\n          }\n          const alignment = " ".repeat(clamp(options.tabWidth - listPrefix.length, 0, 3));\n          return [alignment, align(alignment, print())];\n        }\n      })];\n    }\n    function alignListPrefix(prefix, options) {\n      const additionalSpaces = getAdditionalSpaces();\n      return prefix + " ".repeat(additionalSpaces >= 4 ? 0 : additionalSpaces);\n      function getAdditionalSpaces() {\n        const restSpaces = prefix.length % options.tabWidth;\n        return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;\n      }\n    }\n    function getNthListSiblingIndex(node, parentNode) {\n      return getNthSiblingIndex(node, parentNode, (siblingNode) => siblingNode.ordered === node.ordered);\n    }\n    function getNthSiblingIndex(node, parentNode, condition) {\n      let index = -1;\n      for (const childNode of parentNode.children) {\n        if (childNode.type === node.type && condition(childNode)) {\n          index++;\n        } else {\n          index = -1;\n        }\n        if (childNode === node) {\n          return index;\n        }\n      }\n    }\n    function getAncestorCounter(path, typeOrTypes) {\n      const types = Array.isArray(typeOrTypes) ? typeOrTypes : [typeOrTypes];\n      let counter = -1;\n      let ancestorNode;\n      while (ancestorNode = path.getParentNode(++counter)) {\n        if (types.includes(ancestorNode.type)) {\n          return counter;\n        }\n      }\n      return -1;\n    }\n    function getAncestorNode(path, typeOrTypes) {\n      const counter = getAncestorCounter(path, typeOrTypes);\n      return counter === -1 ? null : path.getParentNode(counter);\n    }\n    function printLine(path, value, options) {\n      if (options.proseWrap === "preserve" && value === "\\n") {\n        return hardline;\n      }\n      const isBreakable = options.proseWrap === "always" && !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);\n      return value !== "" ? isBreakable ? line : " " : isBreakable ? softline : "";\n    }\n    function printTable(path, options, print) {\n      const node = path.getValue();\n      const columnMaxWidths = [];\n      const contents = path.map((rowPath) => rowPath.map((cellPath, columnIndex) => {\n        const text = printDocToString(print(), options).formatted;\n        const width = getStringWidth(text);\n        columnMaxWidths[columnIndex] = Math.max(columnMaxWidths[columnIndex] || 3, width);\n        return {\n          text,\n          width\n        };\n      }, "children"), "children");\n      const alignedTable = printTableContents(false);\n      if (options.proseWrap !== "never") {\n        return [breakParent, alignedTable];\n      }\n      const compactTable = printTableContents(true);\n      return [breakParent, group(ifBreak(compactTable, alignedTable))];\n      function printTableContents(isCompact) {\n        const parts = [printRow(contents[0], isCompact), printAlign(isCompact)];\n        if (contents.length > 1) {\n          parts.push(join(hardlineWithoutBreakParent, contents.slice(1).map((rowContents) => printRow(rowContents, isCompact))));\n        }\n        return join(hardlineWithoutBreakParent, parts);\n      }\n      function printAlign(isCompact) {\n        const align2 = columnMaxWidths.map((width, index) => {\n          const align3 = node.align[index];\n          const first = align3 === "center" || align3 === "left" ? ":" : "-";\n          const last = align3 === "center" || align3 === "right" ? ":" : "-";\n          const middle = isCompact ? "-" : "-".repeat(width - 2);\n          return `${first}${middle}${last}`;\n        });\n        return `| ${align2.join(" | ")} |`;\n      }\n      function printRow(rowContents, isCompact) {\n        const columns = rowContents.map(({\n          text,\n          width\n        }, columnIndex) => {\n          if (isCompact) {\n            return text;\n          }\n          const spaces = columnMaxWidths[columnIndex] - width;\n          const align2 = node.align[columnIndex];\n          let before = 0;\n          if (align2 === "right") {\n            before = spaces;\n          } else if (align2 === "center") {\n            before = Math.floor(spaces / 2);\n          }\n          const after = spaces - before;\n          return `${" ".repeat(before)}${text}${" ".repeat(after)}`;\n        });\n        return `| ${columns.join(" | ")} |`;\n      }\n    }\n    function printRoot(path, options, print) {\n      const ignoreRanges = [];\n      let ignoreStart = null;\n      const {\n        children\n      } = path.getValue();\n      for (const [index, childNode] of children.entries()) {\n        switch (isPrettierIgnore(childNode)) {\n          case "start":\n            if (ignoreStart === null) {\n              ignoreStart = {\n                index,\n                offset: childNode.position.end.offset\n              };\n            }\n            break;\n          case "end":\n            if (ignoreStart !== null) {\n              ignoreRanges.push({\n                start: ignoreStart,\n                end: {\n                  index,\n                  offset: childNode.position.start.offset\n                }\n              });\n              ignoreStart = null;\n            }\n            break;\n          default:\n            break;\n        }\n      }\n      return printChildren(path, options, print, {\n        processor: (childPath, index) => {\n          if (ignoreRanges.length > 0) {\n            const ignoreRange = ignoreRanges[0];\n            if (index === ignoreRange.start.index) {\n              return [printIgnoreComment(children[ignoreRange.start.index]), options.originalText.slice(ignoreRange.start.offset, ignoreRange.end.offset), printIgnoreComment(children[ignoreRange.end.index])];\n            }\n            if (ignoreRange.start.index < index && index < ignoreRange.end.index) {\n              return false;\n            }\n            if (index === ignoreRange.end.index) {\n              ignoreRanges.shift();\n              return false;\n            }\n          }\n          return print();\n        }\n      });\n    }\n    function printChildren(path, options, print, events = {}) {\n      const {\n        postprocessor\n      } = events;\n      const processor = events.processor || (() => print());\n      const node = path.getValue();\n      const parts = [];\n      let lastChildNode;\n      path.each((childPath, index) => {\n        const childNode = childPath.getValue();\n        const result = processor(childPath, index);\n        if (result !== false) {\n          const data = {\n            parts,\n            prevNode: lastChildNode,\n            parentNode: node,\n            options\n          };\n          if (shouldPrePrintHardline(childNode, data)) {\n            parts.push(hardline);\n            if (lastChildNode && TRAILING_HARDLINE_NODES.has(lastChildNode.type)) {\n              if (shouldPrePrintTripleHardline(childNode, data)) {\n                parts.push(hardline);\n              }\n            } else {\n              if (shouldPrePrintDoubleHardline(childNode, data) || shouldPrePrintTripleHardline(childNode, data)) {\n                parts.push(hardline);\n              }\n              if (shouldPrePrintTripleHardline(childNode, data)) {\n                parts.push(hardline);\n              }\n            }\n          }\n          parts.push(result);\n          lastChildNode = childNode;\n        }\n      }, "children");\n      return postprocessor ? postprocessor(parts) : parts;\n    }\n    function printIgnoreComment(node) {\n      if (node.type === "html") {\n        return node.value;\n      }\n      if (node.type === "paragraph" && Array.isArray(node.children) && node.children.length === 1 && node.children[0].type === "esComment") {\n        return ["{/* ", node.children[0].value, " */}"];\n      }\n    }\n    function getLastDescendantNode(node) {\n      let current = node;\n      while (isNonEmptyArray(current.children)) {\n        current = getLast(current.children);\n      }\n      return current;\n    }\n    function isPrettierIgnore(node) {\n      let match;\n      if (node.type === "html") {\n        match = node.value.match(/^\x3c!--\\s*prettier-ignore(?:-(start|end))?\\s*--\x3e$/);\n      } else {\n        let comment;\n        if (node.type === "esComment") {\n          comment = node;\n        } else if (node.type === "paragraph" && node.children.length === 1 && node.children[0].type === "esComment") {\n          comment = node.children[0];\n        }\n        if (comment) {\n          match = comment.value.match(/^prettier-ignore(?:-(start|end))?$/);\n        }\n      }\n      return match ? match[1] || "next" : false;\n    }\n    function shouldPrePrintHardline(node, data) {\n      const isFirstNode = data.parts.length === 0;\n      const isInlineNode = INLINE_NODE_TYPES.includes(node.type);\n      const isInlineHTML = node.type === "html" && INLINE_NODE_WRAPPER_TYPES.includes(data.parentNode.type);\n      return !isFirstNode && !isInlineNode && !isInlineHTML;\n    }\n    function shouldPrePrintDoubleHardline(node, data) {\n      var _data$prevNode, _data$prevNode2, _data$prevNode3;\n      const isSequence = (data.prevNode && data.prevNode.type) === node.type;\n      const isSiblingNode = isSequence && SIBLING_NODE_TYPES.has(node.type);\n      const isInTightListItem = data.parentNode.type === "listItem" && !data.parentNode.loose;\n      const isPrevNodeLooseListItem = ((_data$prevNode = data.prevNode) === null || _data$prevNode === void 0 ? void 0 : _data$prevNode.type) === "listItem" && data.prevNode.loose;\n      const isPrevNodePrettierIgnore = isPrettierIgnore(data.prevNode) === "next";\n      const isBlockHtmlWithoutBlankLineBetweenPrevHtml = node.type === "html" && ((_data$prevNode2 = data.prevNode) === null || _data$prevNode2 === void 0 ? void 0 : _data$prevNode2.type) === "html" && data.prevNode.position.end.line + 1 === node.position.start.line;\n      const isHtmlDirectAfterListItem = node.type === "html" && data.parentNode.type === "listItem" && ((_data$prevNode3 = data.prevNode) === null || _data$prevNode3 === void 0 ? void 0 : _data$prevNode3.type) === "paragraph" && data.prevNode.position.end.line + 1 === node.position.start.line;\n      return isPrevNodeLooseListItem || !(isSiblingNode || isInTightListItem || isPrevNodePrettierIgnore || isBlockHtmlWithoutBlankLineBetweenPrevHtml || isHtmlDirectAfterListItem);\n    }\n    function shouldPrePrintTripleHardline(node, data) {\n      const isPrevNodeList = data.prevNode && data.prevNode.type === "list";\n      const isIndentedCode = node.type === "code" && node.isIndented;\n      return isPrevNodeList && isIndentedCode;\n    }\n    function shouldRemainTheSameContent(path) {\n      const ancestorNode = getAncestorNode(path, ["linkReference", "imageReference"]);\n      return ancestorNode && (ancestorNode.type !== "linkReference" || ancestorNode.referenceType !== "full");\n    }\n    function printUrl(url, dangerousCharOrChars = []) {\n      const dangerousChars = [" ", ...Array.isArray(dangerousCharOrChars) ? dangerousCharOrChars : [dangerousCharOrChars]];\n      return new RegExp(dangerousChars.map((x) => `\\\\${x}`).join("|")).test(url) ? `<${url}>` : url;\n    }\n    function printTitle(title, options, printSpace = true) {\n      if (!title) {\n        return "";\n      }\n      if (printSpace) {\n        return " " + printTitle(title, options, false);\n      }\n      title = title.replace(/\\\\(["\')])/g, "$1");\n      if (title.includes(\'"\') && title.includes("\'") && !title.includes(")")) {\n        return `(${title})`;\n      }\n      const singleCount = title.split("\'").length - 1;\n      const doubleCount = title.split(\'"\').length - 1;\n      const quote = singleCount > doubleCount ? \'"\' : doubleCount > singleCount ? "\'" : options.singleQuote ? "\'" : \'"\';\n      title = title.replace(/\\\\/, "\\\\\\\\");\n      title = title.replace(new RegExp(`(${quote})`, "g"), "\\\\$1");\n      return `${quote}${title}${quote}`;\n    }\n    function clamp(value, min, max) {\n      return value < min ? min : value > max ? max : value;\n    }\n    function hasPrettierIgnore(path) {\n      const index = Number(path.getName());\n      if (index === 0) {\n        return false;\n      }\n      const prevNode = path.getParentNode().children[index - 1];\n      return isPrettierIgnore(prevNode) === "next";\n    }\n    function printLinkReference(node) {\n      return `[${collapseWhiteSpace(node.label)}]`;\n    }\n    function printFootnoteReference(node) {\n      return `[^${node.label}]`;\n    }\n    module2.exports = {\n      preprocess,\n      print: genericPrint,\n      embed,\n      massageAstNode: clean,\n      hasPrettierIgnore,\n      insertPragma\n    };\n  }\n});\nvar require_options5 = __commonJS2({\n  "src/language-markdown/options.js"(exports2, module2) {\n    "use strict";\n    var commonOptions = require_common_options();\n    module2.exports = {\n      proseWrap: commonOptions.proseWrap,\n      singleQuote: commonOptions.singleQuote\n    };\n  }\n});\nvar require_parsers5 = __commonJS2({\n  "src/language-markdown/parsers.js"(exports2, module2) {\n    "use strict";\n    module2.exports = {\n      get remark() {\n        return require("./parser-markdown.js").parsers.remark;\n      },\n      get markdown() {\n        return require("./parser-markdown.js").parsers.remark;\n      },\n      get mdx() {\n        return require("./parser-markdown.js").parsers.mdx;\n      }\n    };\n  }\n});\nvar require_Markdown = __commonJS2({\n  "node_modules/linguist-languages/data/Markdown.json"(exports2, module2) {\n    module2.exports = {\n      name: "Markdown",\n      type: "prose",\n      color: "#083fa1",\n      aliases: ["pandoc"],\n      aceMode: "markdown",\n      codemirrorMode: "gfm",\n      codemirrorMimeType: "text/x-gfm",\n      wrap: true,\n      extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"],\n      filenames: ["contents.lr"],\n      tmScope: "source.gfm",\n      languageId: 222\n    };\n  }\n});\nvar require_language_markdown = __commonJS2({\n  "src/language-markdown/index.js"(exports2, module2) {\n    "use strict";\n    var createLanguage = require_create_language();\n    var printer = require_printer_markdown();\n    var options = require_options5();\n    var parsers = require_parsers5();\n    var languages = [createLanguage(require_Markdown(), (data) => ({\n      since: "1.8.0",\n      parsers: ["markdown"],\n      vscodeLanguageIds: ["markdown"],\n      filenames: [...data.filenames, "README"],\n      extensions: data.extensions.filter((extension) => extension !== ".mdx")\n    })), createLanguage(require_Markdown(), () => ({\n      name: "MDX",\n      since: "1.15.0",\n      parsers: ["mdx"],\n      vscodeLanguageIds: ["mdx"],\n      filenames: [],\n      extensions: [".mdx"]\n    }))];\n    var printers = {\n      mdast: printer\n    };\n    module2.exports = {\n      languages,\n      options,\n      printers,\n      parsers\n    };\n  }\n});\nvar require_clean5 = __commonJS2({\n  "src/language-html/clean.js"(exports2, module2) {\n    "use strict";\n    var {\n      isFrontMatterNode\n    } = require_util();\n    var ignoredProperties = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);\n    function clean(ast, newNode) {\n      if (ast.type === "text" || ast.type === "comment") {\n        return null;\n      }\n      if (isFrontMatterNode(ast) || ast.type === "yaml" || ast.type === "toml") {\n        return null;\n      }\n      if (ast.type === "attribute") {\n        delete newNode.value;\n      }\n      if (ast.type === "docType") {\n        delete newNode.value;\n      }\n    }\n    clean.ignoredProperties = ignoredProperties;\n    module2.exports = clean;\n  }\n});\nvar require_constants_evaluate2 = __commonJS2({\n  "src/language-html/constants.evaluate.js"(exports2, module2) {\n    module2.exports = {\n      CSS_DISPLAY_TAGS: {\n        area: "none",\n        base: "none",\n        basefont: "none",\n        datalist: "none",\n        head: "none",\n        link: "none",\n        meta: "none",\n        noembed: "none",\n        noframes: "none",\n        param: "block",\n        rp: "none",\n        script: "block",\n        source: "block",\n        style: "none",\n        template: "inline",\n        track: "block",\n        title: "none",\n        html: "block",\n        body: "block",\n        address: "block",\n        blockquote: "block",\n        center: "block",\n        div: "block",\n        figure: "block",\n        figcaption: "block",\n        footer: "block",\n        form: "block",\n        header: "block",\n        hr: "block",\n        legend: "block",\n        listing: "block",\n        main: "block",\n        p: "block",\n        plaintext: "block",\n        pre: "block",\n        xmp: "block",\n        slot: "contents",\n        ruby: "ruby",\n        rt: "ruby-text",\n        article: "block",\n        aside: "block",\n        h1: "block",\n        h2: "block",\n        h3: "block",\n        h4: "block",\n        h5: "block",\n        h6: "block",\n        hgroup: "block",\n        nav: "block",\n        section: "block",\n        dir: "block",\n        dd: "block",\n        dl: "block",\n        dt: "block",\n        ol: "block",\n        ul: "block",\n        li: "list-item",\n        table: "table",\n        caption: "table-caption",\n        colgroup: "table-column-group",\n        col: "table-column",\n        thead: "table-header-group",\n        tbody: "table-row-group",\n        tfoot: "table-footer-group",\n        tr: "table-row",\n        td: "table-cell",\n        th: "table-cell",\n        fieldset: "block",\n        button: "inline-block",\n        details: "block",\n        summary: "block",\n        dialog: "block",\n        meter: "inline-block",\n        progress: "inline-block",\n        object: "inline-block",\n        video: "inline-block",\n        audio: "inline-block",\n        select: "inline-block",\n        option: "block",\n        optgroup: "block"\n      },\n      CSS_DISPLAY_DEFAULT: "inline",\n      CSS_WHITE_SPACE_TAGS: {\n        listing: "pre",\n        plaintext: "pre",\n        pre: "pre",\n        xmp: "pre",\n        nobr: "nowrap",\n        table: "initial",\n        textarea: "pre-wrap"\n      },\n      CSS_WHITE_SPACE_DEFAULT: "normal"\n    };\n  }\n});\nvar require_is_unknown_namespace = __commonJS2({\n  "src/language-html/utils/is-unknown-namespace.js"(exports2, module2) {\n    "use strict";\n    function isUnknownNamespace(node) {\n      return node.type === "element" && !node.hasExplicitNamespace && !["html", "svg"].includes(node.namespace);\n    }\n    module2.exports = isUnknownNamespace;\n  }\n});\nvar require_utils11 = __commonJS2({\n  "src/language-html/utils/index.js"(exports2, module2) {\n    "use strict";\n    var {\n      inferParserByLanguage,\n      isFrontMatterNode\n    } = require_util();\n    var {\n      builders: {\n        line,\n        hardline,\n        join\n      },\n      utils: {\n        getDocParts,\n        replaceTextEndOfLine\n      }\n    } = require("./doc.js");\n    var {\n      CSS_DISPLAY_TAGS,\n      CSS_DISPLAY_DEFAULT,\n      CSS_WHITE_SPACE_TAGS,\n      CSS_WHITE_SPACE_DEFAULT\n    } = require_constants_evaluate2();\n    var isUnknownNamespace = require_is_unknown_namespace();\n    var HTML_WHITESPACE = /* @__PURE__ */ new Set(["\t", "\\n", "\\f", "\\r", " "]);\n    var htmlTrimStart = (string) => string.replace(/^[\\t\\n\\f\\r ]+/, "");\n    var htmlTrimEnd = (string) => string.replace(/[\\t\\n\\f\\r ]+$/, "");\n    var htmlTrim = (string) => htmlTrimStart(htmlTrimEnd(string));\n    var htmlTrimLeadingBlankLines = (string) => string.replace(/^[\\t\\f\\r ]*\\n/g, "");\n    var htmlTrimPreserveIndentation = (string) => htmlTrimLeadingBlankLines(htmlTrimEnd(string));\n    var splitByHtmlWhitespace = (string) => string.split(/[\\t\\n\\f\\r ]+/);\n    var getLeadingHtmlWhitespace = (string) => string.match(/^[\\t\\n\\f\\r ]*/)[0];\n    var getLeadingAndTrailingHtmlWhitespace = (string) => {\n      const [, leadingWhitespace, text, trailingWhitespace] = string.match(/^([\\t\\n\\f\\r ]*)(.*?)([\\t\\n\\f\\r ]*)$/s);\n      return {\n        leadingWhitespace,\n        trailingWhitespace,\n        text\n      };\n    };\n    var hasHtmlWhitespace = (string) => /[\\t\\n\\f\\r ]/.test(string);\n    function shouldPreserveContent(node, options) {\n      if (node.type === "ieConditionalComment" && node.lastChild && !node.lastChild.isSelfClosing && !node.lastChild.endSourceSpan) {\n        return true;\n      }\n      if (node.type === "ieConditionalComment" && !node.complete) {\n        return true;\n      }\n      if (isPreLikeNode(node) && node.children.some((child) => child.type !== "text" && child.type !== "interpolation")) {\n        return true;\n      }\n      if (isVueNonHtmlBlock(node, options) && !isScriptLikeTag(node) && node.type !== "interpolation") {\n        return true;\n      }\n      return false;\n    }\n    function hasPrettierIgnore(node) {\n      if (node.type === "attribute") {\n        return false;\n      }\n      if (!node.parent) {\n        return false;\n      }\n      if (!node.prev) {\n        return false;\n      }\n      return isPrettierIgnore(node.prev);\n    }\n    function isPrettierIgnore(node) {\n      return node.type === "comment" && node.value.trim() === "prettier-ignore";\n    }\n    function isTextLikeNode(node) {\n      return node.type === "text" || node.type === "comment";\n    }\n    function isScriptLikeTag(node) {\n      return node.type === "element" && (node.fullName === "script" || node.fullName === "style" || node.fullName === "svg:style" || isUnknownNamespace(node) && (node.name === "script" || node.name === "style"));\n    }\n    function canHaveInterpolation(node) {\n      return node.children && !isScriptLikeTag(node);\n    }\n    function isWhitespaceSensitiveNode(node) {\n      return isScriptLikeTag(node) || node.type === "interpolation" || isIndentationSensitiveNode(node);\n    }\n    function isIndentationSensitiveNode(node) {\n      return getNodeCssStyleWhiteSpace(node).startsWith("pre");\n    }\n    function isLeadingSpaceSensitiveNode(node, options) {\n      const isLeadingSpaceSensitive = _isLeadingSpaceSensitiveNode();\n      if (isLeadingSpaceSensitive && !node.prev && node.parent && node.parent.tagDefinition && node.parent.tagDefinition.ignoreFirstLf) {\n        return node.type === "interpolation";\n      }\n      return isLeadingSpaceSensitive;\n      function _isLeadingSpaceSensitiveNode() {\n        if (isFrontMatterNode(node)) {\n          return false;\n        }\n        if ((node.type === "text" || node.type === "interpolation") && node.prev && (node.prev.type === "text" || node.prev.type === "interpolation")) {\n          return true;\n        }\n        if (!node.parent || node.parent.cssDisplay === "none") {\n          return false;\n        }\n        if (isPreLikeNode(node.parent)) {\n          return true;\n        }\n        if (!node.prev && (node.parent.type === "root" || isPreLikeNode(node) && node.parent || isScriptLikeTag(node.parent) || isVueCustomBlock(node.parent, options) || !isFirstChildLeadingSpaceSensitiveCssDisplay(node.parent.cssDisplay))) {\n          return false;\n        }\n        if (node.prev && !isNextLeadingSpaceSensitiveCssDisplay(node.prev.cssDisplay)) {\n          return false;\n        }\n        return true;\n      }\n    }\n    function isTrailingSpaceSensitiveNode(node, options) {\n      if (isFrontMatterNode(node)) {\n        return false;\n      }\n      if ((node.type === "text" || node.type === "interpolation") && node.next && (node.next.type === "text" || node.next.type === "interpolation")) {\n        return true;\n      }\n      if (!node.parent || node.parent.cssDisplay === "none") {\n        return false;\n      }\n      if (isPreLikeNode(node.parent)) {\n        return true;\n      }\n      if (!node.next && (node.parent.type === "root" || isPreLikeNode(node) && node.parent || isScriptLikeTag(node.parent) || isVueCustomBlock(node.parent, options) || !isLastChildTrailingSpaceSensitiveCssDisplay(node.parent.cssDisplay))) {\n        return false;\n      }\n      if (node.next && !isPrevTrailingSpaceSensitiveCssDisplay(node.next.cssDisplay)) {\n        return false;\n      }\n      return true;\n    }\n    function isDanglingSpaceSensitiveNode(node) {\n      return isDanglingSpaceSensitiveCssDisplay(node.cssDisplay) && !isScriptLikeTag(node);\n    }\n    function forceNextEmptyLine(node) {\n      return isFrontMatterNode(node) || node.next && node.sourceSpan.end && node.sourceSpan.end.line + 1 < node.next.sourceSpan.start.line;\n    }\n    function forceBreakContent(node) {\n      return forceBreakChildren(node) || node.type === "element" && node.children.length > 0 && (["body", "script", "style"].includes(node.name) || node.children.some((child) => hasNonTextChild(child))) || node.firstChild && node.firstChild === node.lastChild && node.firstChild.type !== "text" && hasLeadingLineBreak(node.firstChild) && (!node.lastChild.isTrailingSpaceSensitive || hasTrailingLineBreak(node.lastChild));\n    }\n    function forceBreakChildren(node) {\n      return node.type === "element" && node.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(node.name) || node.cssDisplay.startsWith("table") && node.cssDisplay !== "table-cell");\n    }\n    function preferHardlineAsLeadingSpaces(node) {\n      return preferHardlineAsSurroundingSpaces(node) || node.prev && preferHardlineAsTrailingSpaces(node.prev) || hasSurroundingLineBreak(node);\n    }\n    function preferHardlineAsTrailingSpaces(node) {\n      return preferHardlineAsSurroundingSpaces(node) || node.type === "element" && node.fullName === "br" || hasSurroundingLineBreak(node);\n    }\n    function hasSurroundingLineBreak(node) {\n      return hasLeadingLineBreak(node) && hasTrailingLineBreak(node);\n    }\n    function hasLeadingLineBreak(node) {\n      return node.hasLeadingSpaces && (node.prev ? node.prev.sourceSpan.end.line < node.sourceSpan.start.line : node.parent.type === "root" || node.parent.startSourceSpan.end.line < node.sourceSpan.start.line);\n    }\n    function hasTrailingLineBreak(node) {\n      return node.hasTrailingSpaces && (node.next ? node.next.sourceSpan.start.line > node.sourceSpan.end.line : node.parent.type === "root" || node.parent.endSourceSpan && node.parent.endSourceSpan.start.line > node.sourceSpan.end.line);\n    }\n    function preferHardlineAsSurroundingSpaces(node) {\n      switch (node.type) {\n        case "ieConditionalComment":\n        case "comment":\n        case "directive":\n          return true;\n        case "element":\n          return ["script", "select"].includes(node.name);\n      }\n      return false;\n    }\n    function getLastDescendant(node) {\n      return node.lastChild ? getLastDescendant(node.lastChild) : node;\n    }\n    function hasNonTextChild(node) {\n      return node.children && node.children.some((child) => child.type !== "text");\n    }\n    function _inferScriptParser(node) {\n      const {\n        type,\n        lang\n      } = node.attrMap;\n      if (type === "module" || type === "text/javascript" || type === "text/babel" || type === "application/javascript" || lang === "jsx") {\n        return "babel";\n      }\n      if (type === "application/x-typescript" || lang === "ts" || lang === "tsx") {\n        return "typescript";\n      }\n      if (type === "text/markdown") {\n        return "markdown";\n      }\n      if (type === "text/html") {\n        return "html";\n      }\n      if (type && (type.endsWith("json") || type.endsWith("importmap")) || type === "speculationrules") {\n        return "json";\n      }\n      if (type === "text/x-handlebars-template") {\n        return "glimmer";\n      }\n    }\n    function inferStyleParser(node, options) {\n      const {\n        lang\n      } = node.attrMap;\n      if (!lang || lang === "postcss" || lang === "css") {\n        return "css";\n      }\n      if (lang === "scss") {\n        return "scss";\n      }\n      if (lang === "less") {\n        return "less";\n      }\n      if (lang === "stylus") {\n        return inferParserByLanguage("stylus", options);\n      }\n    }\n    function inferScriptParser(node, options) {\n      if (node.name === "script" && !node.attrMap.src) {\n        if (!node.attrMap.lang && !node.attrMap.type) {\n          return "babel";\n        }\n        return _inferScriptParser(node);\n      }\n      if (node.name === "style") {\n        return inferStyleParser(node, options);\n      }\n      if (options && isVueNonHtmlBlock(node, options)) {\n        return _inferScriptParser(node) || !("src" in node.attrMap) && inferParserByLanguage(node.attrMap.lang, options);\n      }\n    }\n    function isBlockLikeCssDisplay(cssDisplay) {\n      return cssDisplay === "block" || cssDisplay === "list-item" || cssDisplay.startsWith("table");\n    }\n    function isFirstChildLeadingSpaceSensitiveCssDisplay(cssDisplay) {\n      return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";\n    }\n    function isLastChildTrailingSpaceSensitiveCssDisplay(cssDisplay) {\n      return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";\n    }\n    function isPrevTrailingSpaceSensitiveCssDisplay(cssDisplay) {\n      return !isBlockLikeCssDisplay(cssDisplay);\n    }\n    function isNextLeadingSpaceSensitiveCssDisplay(cssDisplay) {\n      return !isBlockLikeCssDisplay(cssDisplay);\n    }\n    function isDanglingSpaceSensitiveCssDisplay(cssDisplay) {\n      return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";\n    }\n    function isPreLikeNode(node) {\n      return getNodeCssStyleWhiteSpace(node).startsWith("pre");\n    }\n    function countParents(path, predicate) {\n      let counter = 0;\n      for (let i = path.stack.length - 1; i >= 0; i--) {\n        const value = path.stack[i];\n        if (value && typeof value === "object" && !Array.isArray(value) && predicate(value)) {\n          counter++;\n        }\n      }\n      return counter;\n    }\n    function hasParent(node, fn) {\n      let current = node;\n      while (current) {\n        if (fn(current)) {\n          return true;\n        }\n        current = current.parent;\n      }\n      return false;\n    }\n    function getNodeCssStyleDisplay(node, options) {\n      if (node.prev && node.prev.type === "comment") {\n        const match = node.prev.value.match(/^\\s*display:\\s*([a-z]+)\\s*$/);\n        if (match) {\n          return match[1];\n        }\n      }\n      let isInSvgForeignObject = false;\n      if (node.type === "element" && node.namespace === "svg") {\n        if (hasParent(node, (parent) => parent.fullName === "svg:foreignObject")) {\n          isInSvgForeignObject = true;\n        } else {\n          return node.name === "svg" ? "inline-block" : "block";\n        }\n      }\n      switch (options.htmlWhitespaceSensitivity) {\n        case "strict":\n          return "inline";\n        case "ignore":\n          return "block";\n        default: {\n          if (options.parser === "vue" && node.parent && node.parent.type === "root") {\n            return "block";\n          }\n          return node.type === "element" && (!node.namespace || isInSvgForeignObject || isUnknownNamespace(node)) && CSS_DISPLAY_TAGS[node.name] || CSS_DISPLAY_DEFAULT;\n        }\n      }\n    }\n    function getNodeCssStyleWhiteSpace(node) {\n      return node.type === "element" && (!node.namespace || isUnknownNamespace(node)) && CSS_WHITE_SPACE_TAGS[node.name] || CSS_WHITE_SPACE_DEFAULT;\n    }\n    function getMinIndentation(text) {\n      let minIndentation = Number.POSITIVE_INFINITY;\n      for (const lineText of text.split("\\n")) {\n        if (lineText.length === 0) {\n          continue;\n        }\n        if (!HTML_WHITESPACE.has(lineText[0])) {\n          return 0;\n        }\n        const indentation = getLeadingHtmlWhitespace(lineText).length;\n        if (lineText.length === indentation) {\n          continue;\n        }\n        if (indentation < minIndentation) {\n          minIndentation = indentation;\n        }\n      }\n      return minIndentation === Number.POSITIVE_INFINITY ? 0 : minIndentation;\n    }\n    function dedentString(text, minIndent = getMinIndentation(text)) {\n      return minIndent === 0 ? text : text.split("\\n").map((lineText) => lineText.slice(minIndent)).join("\\n");\n    }\n    function countChars(text, char) {\n      let counter = 0;\n      for (let i = 0; i < text.length; i++) {\n        if (text[i] === char) {\n          counter++;\n        }\n      }\n      return counter;\n    }\n    function unescapeQuoteEntities(text) {\n      return text.replace(/&apos;/g, "\'").replace(/&quot;/g, \'"\');\n    }\n    var vueRootElementsSet = /* @__PURE__ */ new Set(["template", "style", "script"]);\n    function isVueCustomBlock(node, options) {\n      return isVueSfcBlock(node, options) && !vueRootElementsSet.has(node.fullName);\n    }\n    function isVueSfcBlock(node, options) {\n      return options.parser === "vue" && node.type === "element" && node.parent.type === "root" && node.fullName.toLowerCase() !== "html";\n    }\n    function isVueNonHtmlBlock(node, options) {\n      return isVueSfcBlock(node, options) && (isVueCustomBlock(node, options) || node.attrMap.lang && node.attrMap.lang !== "html");\n    }\n    function isVueSlotAttribute(attribute) {\n      const attributeName = attribute.fullName;\n      return attributeName.charAt(0) === "#" || attributeName === "slot-scope" || attributeName === "v-slot" || attributeName.startsWith("v-slot:");\n    }\n    function isVueSfcBindingsAttribute(attribute, options) {\n      const element = attribute.parent;\n      if (!isVueSfcBlock(element, options)) {\n        return false;\n      }\n      const tagName = element.fullName;\n      const attributeName = attribute.fullName;\n      return tagName === "script" && attributeName === "setup" || tagName === "style" && attributeName === "vars";\n    }\n    function getTextValueParts(node, value = node.value) {\n      return node.parent.isWhitespaceSensitive ? node.parent.isIndentationSensitive ? replaceTextEndOfLine(value) : replaceTextEndOfLine(dedentString(htmlTrimPreserveIndentation(value)), hardline) : getDocParts(join(line, splitByHtmlWhitespace(value)));\n    }\n    function isVueScriptTag(node, options) {\n      return isVueSfcBlock(node, options) && node.name === "script";\n    }\n    module2.exports = {\n      htmlTrim,\n      htmlTrimPreserveIndentation,\n      hasHtmlWhitespace,\n      getLeadingAndTrailingHtmlWhitespace,\n      canHaveInterpolation,\n      countChars,\n      countParents,\n      dedentString,\n      forceBreakChildren,\n      forceBreakContent,\n      forceNextEmptyLine,\n      getLastDescendant,\n      getNodeCssStyleDisplay,\n      getNodeCssStyleWhiteSpace,\n      hasPrettierIgnore,\n      inferScriptParser,\n      isVueCustomBlock,\n      isVueNonHtmlBlock,\n      isVueScriptTag,\n      isVueSlotAttribute,\n      isVueSfcBindingsAttribute,\n      isVueSfcBlock,\n      isDanglingSpaceSensitiveNode,\n      isIndentationSensitiveNode,\n      isLeadingSpaceSensitiveNode,\n      isPreLikeNode,\n      isScriptLikeTag,\n      isTextLikeNode,\n      isTrailingSpaceSensitiveNode,\n      isWhitespaceSensitiveNode,\n      isUnknownNamespace,\n      preferHardlineAsLeadingSpaces,\n      preferHardlineAsTrailingSpaces,\n      shouldPreserveContent,\n      unescapeQuoteEntities,\n      getTextValueParts\n    };\n  }\n});\nvar require_chars = __commonJS2({\n  "node_modules/angular-html-parser/lib/compiler/src/chars.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    exports2.$EOF = 0;\n    exports2.$BSPACE = 8;\n    exports2.$TAB = 9;\n    exports2.$LF = 10;\n    exports2.$VTAB = 11;\n    exports2.$FF = 12;\n    exports2.$CR = 13;\n    exports2.$SPACE = 32;\n    exports2.$BANG = 33;\n    exports2.$DQ = 34;\n    exports2.$HASH = 35;\n    exports2.$$ = 36;\n    exports2.$PERCENT = 37;\n    exports2.$AMPERSAND = 38;\n    exports2.$SQ = 39;\n    exports2.$LPAREN = 40;\n    exports2.$RPAREN = 41;\n    exports2.$STAR = 42;\n    exports2.$PLUS = 43;\n    exports2.$COMMA = 44;\n    exports2.$MINUS = 45;\n    exports2.$PERIOD = 46;\n    exports2.$SLASH = 47;\n    exports2.$COLON = 58;\n    exports2.$SEMICOLON = 59;\n    exports2.$LT = 60;\n    exports2.$EQ = 61;\n    exports2.$GT = 62;\n    exports2.$QUESTION = 63;\n    exports2.$0 = 48;\n    exports2.$7 = 55;\n    exports2.$9 = 57;\n    exports2.$A = 65;\n    exports2.$E = 69;\n    exports2.$F = 70;\n    exports2.$X = 88;\n    exports2.$Z = 90;\n    exports2.$LBRACKET = 91;\n    exports2.$BACKSLASH = 92;\n    exports2.$RBRACKET = 93;\n    exports2.$CARET = 94;\n    exports2.$_ = 95;\n    exports2.$a = 97;\n    exports2.$b = 98;\n    exports2.$e = 101;\n    exports2.$f = 102;\n    exports2.$n = 110;\n    exports2.$r = 114;\n    exports2.$t = 116;\n    exports2.$u = 117;\n    exports2.$v = 118;\n    exports2.$x = 120;\n    exports2.$z = 122;\n    exports2.$LBRACE = 123;\n    exports2.$BAR = 124;\n    exports2.$RBRACE = 125;\n    exports2.$NBSP = 160;\n    exports2.$PIPE = 124;\n    exports2.$TILDA = 126;\n    exports2.$AT = 64;\n    exports2.$BT = 96;\n    function isWhitespace(code) {\n      return code >= exports2.$TAB && code <= exports2.$SPACE || code == exports2.$NBSP;\n    }\n    exports2.isWhitespace = isWhitespace;\n    function isDigit(code) {\n      return exports2.$0 <= code && code <= exports2.$9;\n    }\n    exports2.isDigit = isDigit;\n    function isAsciiLetter(code) {\n      return code >= exports2.$a && code <= exports2.$z || code >= exports2.$A && code <= exports2.$Z;\n    }\n    exports2.isAsciiLetter = isAsciiLetter;\n    function isAsciiHexDigit(code) {\n      return code >= exports2.$a && code <= exports2.$f || code >= exports2.$A && code <= exports2.$F || isDigit(code);\n    }\n    exports2.isAsciiHexDigit = isAsciiHexDigit;\n    function isNewLine(code) {\n      return code === exports2.$LF || code === exports2.$CR;\n    }\n    exports2.isNewLine = isNewLine;\n    function isOctalDigit(code) {\n      return exports2.$0 <= code && code <= exports2.$7;\n    }\n    exports2.isOctalDigit = isOctalDigit;\n  }\n});\nvar require_static_symbol = __commonJS2({\n  "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var StaticSymbol = class {\n      constructor(filePath, name, members) {\n        this.filePath = filePath;\n        this.name = name;\n        this.members = members;\n      }\n      assertNoMembers() {\n        if (this.members.length) {\n          throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);\n        }\n      }\n    };\n    exports2.StaticSymbol = StaticSymbol;\n    var StaticSymbolCache = class {\n      constructor() {\n        this.cache = /* @__PURE__ */ new Map();\n      }\n      get(declarationFile, name, members) {\n        members = members || [];\n        const memberSuffix = members.length ? `.${members.join(".")}` : "";\n        const key = `"${declarationFile}".${name}${memberSuffix}`;\n        let result = this.cache.get(key);\n        if (!result) {\n          result = new StaticSymbol(declarationFile, name, members);\n          this.cache.set(key, result);\n        }\n        return result;\n      }\n    };\n    exports2.StaticSymbolCache = StaticSymbolCache;\n  }\n});\nvar require_util3 = __commonJS2({\n  "node_modules/angular-html-parser/lib/compiler/src/util.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n    function dashCaseToCamelCase(input) {\n      return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());\n    }\n    exports2.dashCaseToCamelCase = dashCaseToCamelCase;\n    function splitAtColon(input, defaultValues) {\n      return _splitAt(input, ":", defaultValues);\n    }\n    exports2.splitAtColon = splitAtColon;\n    function splitAtPeriod(input, defaultValues) {\n      return _splitAt(input, ".", defaultValues);\n    }\n    exports2.splitAtPeriod = splitAtPeriod;\n    function _splitAt(input, character, defaultValues) {\n      const characterIndex = input.indexOf(character);\n      if (characterIndex == -1)\n        return defaultValues;\n      return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n    }\n    function visitValue(value, visitor, context) {\n      if (Array.isArray(value)) {\n        return visitor.visitArray(value, context);\n      }\n      if (isStrictStringMap(value)) {\n        return visitor.visitStringMap(value, context);\n      }\n      if (value == null || typeof value == "string" || typeof value == "number" || typeof value == "boolean") {\n        return visitor.visitPrimitive(value, context);\n      }\n      return visitor.visitOther(value, context);\n    }\n    exports2.visitValue = visitValue;\n    function isDefined(val) {\n      return val !== null && val !== void 0;\n    }\n    exports2.isDefined = isDefined;\n    function noUndefined(val) {\n      return val === void 0 ? null : val;\n    }\n    exports2.noUndefined = noUndefined;\n    var ValueTransformer = class {\n      visitArray(arr, context) {\n        return arr.map((value) => visitValue(value, this, context));\n      }\n      visitStringMap(map, context) {\n        const result = {};\n        Object.keys(map).forEach((key) => {\n          result[key] = visitValue(map[key], this, context);\n        });\n        return result;\n      }\n      visitPrimitive(value, context) {\n        return value;\n      }\n      visitOther(value, context) {\n        return value;\n      }\n    };\n    exports2.ValueTransformer = ValueTransformer;\n    exports2.SyncAsync = {\n      assertSync: (value) => {\n        if (isPromise(value)) {\n          throw new Error(`Illegal state: value cannot be a promise`);\n        }\n        return value;\n      },\n      then: (value, cb) => {\n        return isPromise(value) ? value.then(cb) : cb(value);\n      },\n      all: (syncAsyncValues) => {\n        return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues;\n      }\n    };\n    function error(msg) {\n      throw new Error(`Internal Error: ${msg}`);\n    }\n    exports2.error = error;\n    function syntaxError(msg, parseErrors) {\n      const error2 = Error(msg);\n      error2[ERROR_SYNTAX_ERROR] = true;\n      if (parseErrors)\n        error2[ERROR_PARSE_ERRORS] = parseErrors;\n      return error2;\n    }\n    exports2.syntaxError = syntaxError;\n    var ERROR_SYNTAX_ERROR = "ngSyntaxError";\n    var ERROR_PARSE_ERRORS = "ngParseErrors";\n    function isSyntaxError(error2) {\n      return error2[ERROR_SYNTAX_ERROR];\n    }\n    exports2.isSyntaxError = isSyntaxError;\n    function getParseErrors(error2) {\n      return error2[ERROR_PARSE_ERRORS] || [];\n    }\n    exports2.getParseErrors = getParseErrors;\n    function escapeRegExp(s) {\n      return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, "\\\\$1");\n    }\n    exports2.escapeRegExp = escapeRegExp;\n    var STRING_MAP_PROTO = Object.getPrototypeOf({});\n    function isStrictStringMap(obj) {\n      return typeof obj === "object" && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n    }\n    function utf8Encode(str) {\n      let encoded = "";\n      for (let index = 0; index < str.length; index++) {\n        let codePoint = str.charCodeAt(index);\n        if (codePoint >= 55296 && codePoint <= 56319 && str.length > index + 1) {\n          const low = str.charCodeAt(index + 1);\n          if (low >= 56320 && low <= 57343) {\n            index++;\n            codePoint = (codePoint - 55296 << 10) + low - 56320 + 65536;\n          }\n        }\n        if (codePoint <= 127) {\n          encoded += String.fromCharCode(codePoint);\n        } else if (codePoint <= 2047) {\n          encoded += String.fromCharCode(codePoint >> 6 & 31 | 192, codePoint & 63 | 128);\n        } else if (codePoint <= 65535) {\n          encoded += String.fromCharCode(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else if (codePoint <= 2097151) {\n          encoded += String.fromCharCode(codePoint >> 18 & 7 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        }\n      }\n      return encoded;\n    }\n    exports2.utf8Encode = utf8Encode;\n    function stringify(token) {\n      if (typeof token === "string") {\n        return token;\n      }\n      if (token instanceof Array) {\n        return "[" + token.map(stringify).join(", ") + "]";\n      }\n      if (token == null) {\n        return "" + token;\n      }\n      if (token.overriddenName) {\n        return `${token.overriddenName}`;\n      }\n      if (token.name) {\n        return `${token.name}`;\n      }\n      if (!token.toString) {\n        return "object";\n      }\n      const res = token.toString();\n      if (res == null) {\n        return "" + res;\n      }\n      const newLineIndex = res.indexOf("\\n");\n      return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n    }\n    exports2.stringify = stringify;\n    function resolveForwardRef(type) {\n      if (typeof type === "function" && type.hasOwnProperty("__forward_ref__")) {\n        return type();\n      } else {\n        return type;\n      }\n    }\n    exports2.resolveForwardRef = resolveForwardRef;\n    function isPromise(obj) {\n      return !!obj && typeof obj.then === "function";\n    }\n    exports2.isPromise = isPromise;\n    var Version = class {\n      constructor(full) {\n        this.full = full;\n        const splits = full.split(".");\n        this.major = splits[0];\n        this.minor = splits[1];\n        this.patch = splits.slice(2).join(".");\n      }\n    };\n    exports2.Version = Version;\n    var __window = typeof window !== "undefined" && window;\n    var __self = typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && self;\n    var __global = typeof global !== "undefined" && global;\n    var _global = __global || __window || __self;\n    exports2.global = _global;\n  }\n});\nvar require_compile_metadata = __commonJS2({\n  "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var static_symbol_1 = require_static_symbol();\n    var util_1 = require_util3();\n    var HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\n    function sanitizeIdentifier(name) {\n      return name.replace(/\\W/g, "_");\n    }\n    exports2.sanitizeIdentifier = sanitizeIdentifier;\n    var _anonymousTypeIndex = 0;\n    function identifierName(compileIdentifier) {\n      if (!compileIdentifier || !compileIdentifier.reference) {\n        return null;\n      }\n      const ref = compileIdentifier.reference;\n      if (ref instanceof static_symbol_1.StaticSymbol) {\n        return ref.name;\n      }\n      if (ref["__anonymousType"]) {\n        return ref["__anonymousType"];\n      }\n      let identifier = util_1.stringify(ref);\n      if (identifier.indexOf("(") >= 0) {\n        identifier = `anonymous_${_anonymousTypeIndex++}`;\n        ref["__anonymousType"] = identifier;\n      } else {\n        identifier = sanitizeIdentifier(identifier);\n      }\n      return identifier;\n    }\n    exports2.identifierName = identifierName;\n    function identifierModuleUrl(compileIdentifier) {\n      const ref = compileIdentifier.reference;\n      if (ref instanceof static_symbol_1.StaticSymbol) {\n        return ref.filePath;\n      }\n      return `./${util_1.stringify(ref)}`;\n    }\n    exports2.identifierModuleUrl = identifierModuleUrl;\n    function viewClassName(compType, embeddedTemplateIndex) {\n      return `View_${identifierName({\n        reference: compType\n      })}_${embeddedTemplateIndex}`;\n    }\n    exports2.viewClassName = viewClassName;\n    function rendererTypeName(compType) {\n      return `RenderType_${identifierName({\n        reference: compType\n      })}`;\n    }\n    exports2.rendererTypeName = rendererTypeName;\n    function hostViewClassName(compType) {\n      return `HostView_${identifierName({\n        reference: compType\n      })}`;\n    }\n    exports2.hostViewClassName = hostViewClassName;\n    function componentFactoryName(compType) {\n      return `${identifierName({\n        reference: compType\n      })}NgFactory`;\n    }\n    exports2.componentFactoryName = componentFactoryName;\n    var CompileSummaryKind;\n    (function(CompileSummaryKind2) {\n      CompileSummaryKind2[CompileSummaryKind2["Pipe"] = 0] = "Pipe";\n      CompileSummaryKind2[CompileSummaryKind2["Directive"] = 1] = "Directive";\n      CompileSummaryKind2[CompileSummaryKind2["NgModule"] = 2] = "NgModule";\n      CompileSummaryKind2[CompileSummaryKind2["Injectable"] = 3] = "Injectable";\n    })(CompileSummaryKind = exports2.CompileSummaryKind || (exports2.CompileSummaryKind = {}));\n    function tokenName(token) {\n      return token.value != null ? sanitizeIdentifier(token.value) : identifierName(token.identifier);\n    }\n    exports2.tokenName = tokenName;\n    function tokenReference(token) {\n      if (token.identifier != null) {\n        return token.identifier.reference;\n      } else {\n        return token.value;\n      }\n    }\n    exports2.tokenReference = tokenReference;\n    var CompileStylesheetMetadata = class {\n      constructor({\n        moduleUrl,\n        styles,\n        styleUrls\n      } = {}) {\n        this.moduleUrl = moduleUrl || null;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n      }\n    };\n    exports2.CompileStylesheetMetadata = CompileStylesheetMetadata;\n    var CompileTemplateMetadata = class {\n      constructor({\n        encapsulation,\n        template,\n        templateUrl,\n        htmlAst,\n        styles,\n        styleUrls,\n        externalStylesheets,\n        animations,\n        ngContentSelectors,\n        interpolation,\n        isInline,\n        preserveWhitespaces\n      }) {\n        this.encapsulation = encapsulation;\n        this.template = template;\n        this.templateUrl = templateUrl;\n        this.htmlAst = htmlAst;\n        this.styles = _normalizeArray(styles);\n        this.styleUrls = _normalizeArray(styleUrls);\n        this.externalStylesheets = _normalizeArray(externalStylesheets);\n        this.animations = animations ? flatten(animations) : [];\n        this.ngContentSelectors = ngContentSelectors || [];\n        if (interpolation && interpolation.length != 2) {\n          throw new Error(`\'interpolation\' should have a start and an end symbol.`);\n        }\n        this.interpolation = interpolation;\n        this.isInline = isInline;\n        this.preserveWhitespaces = preserveWhitespaces;\n      }\n      toSummary() {\n        return {\n          ngContentSelectors: this.ngContentSelectors,\n          encapsulation: this.encapsulation,\n          styles: this.styles,\n          animations: this.animations\n        };\n      }\n    };\n    exports2.CompileTemplateMetadata = CompileTemplateMetadata;\n    var CompileDirectiveMetadata = class {\n      static create({\n        isHost,\n        type,\n        isComponent,\n        selector,\n        exportAs,\n        changeDetection,\n        inputs,\n        outputs,\n        host,\n        providers,\n        viewProviders,\n        queries,\n        guards,\n        viewQueries,\n        entryComponents,\n        template,\n        componentViewType,\n        rendererType,\n        componentFactory\n      }) {\n        const hostListeners = {};\n        const hostProperties = {};\n        const hostAttributes = {};\n        if (host != null) {\n          Object.keys(host).forEach((key) => {\n            const value = host[key];\n            const matches = key.match(HOST_REG_EXP);\n            if (matches === null) {\n              hostAttributes[key] = value;\n            } else if (matches[1] != null) {\n              hostProperties[matches[1]] = value;\n            } else if (matches[2] != null) {\n              hostListeners[matches[2]] = value;\n            }\n          });\n        }\n        const inputsMap = {};\n        if (inputs != null) {\n          inputs.forEach((bindConfig) => {\n            const parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);\n            inputsMap[parts[0]] = parts[1];\n          });\n        }\n        const outputsMap = {};\n        if (outputs != null) {\n          outputs.forEach((bindConfig) => {\n            const parts = util_1.splitAtColon(bindConfig, [bindConfig, bindConfig]);\n            outputsMap[parts[0]] = parts[1];\n          });\n        }\n        return new CompileDirectiveMetadata({\n          isHost,\n          type,\n          isComponent: !!isComponent,\n          selector,\n          exportAs,\n          changeDetection,\n          inputs: inputsMap,\n          outputs: outputsMap,\n          hostListeners,\n          hostProperties,\n          hostAttributes,\n          providers,\n          viewProviders,\n          queries,\n          guards,\n          viewQueries,\n          entryComponents,\n          template,\n          componentViewType,\n          rendererType,\n          componentFactory\n        });\n      }\n      constructor({\n        isHost,\n        type,\n        isComponent,\n        selector,\n        exportAs,\n        changeDetection,\n        inputs,\n        outputs,\n        hostListeners,\n        hostProperties,\n        hostAttributes,\n        providers,\n        viewProviders,\n        queries,\n        guards,\n        viewQueries,\n        entryComponents,\n        template,\n        componentViewType,\n        rendererType,\n        componentFactory\n      }) {\n        this.isHost = !!isHost;\n        this.type = type;\n        this.isComponent = isComponent;\n        this.selector = selector;\n        this.exportAs = exportAs;\n        this.changeDetection = changeDetection;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.hostListeners = hostListeners;\n        this.hostProperties = hostProperties;\n        this.hostAttributes = hostAttributes;\n        this.providers = _normalizeArray(providers);\n        this.viewProviders = _normalizeArray(viewProviders);\n        this.queries = _normalizeArray(queries);\n        this.guards = guards;\n        this.viewQueries = _normalizeArray(viewQueries);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.template = template;\n        this.componentViewType = componentViewType;\n        this.rendererType = rendererType;\n        this.componentFactory = componentFactory;\n      }\n      toSummary() {\n        return {\n          summaryKind: CompileSummaryKind.Directive,\n          type: this.type,\n          isComponent: this.isComponent,\n          selector: this.selector,\n          exportAs: this.exportAs,\n          inputs: this.inputs,\n          outputs: this.outputs,\n          hostListeners: this.hostListeners,\n          hostProperties: this.hostProperties,\n          hostAttributes: this.hostAttributes,\n          providers: this.providers,\n          viewProviders: this.viewProviders,\n          queries: this.queries,\n          guards: this.guards,\n          viewQueries: this.viewQueries,\n          entryComponents: this.entryComponents,\n          changeDetection: this.changeDetection,\n          template: this.template && this.template.toSummary(),\n          componentViewType: this.componentViewType,\n          rendererType: this.rendererType,\n          componentFactory: this.componentFactory\n        };\n      }\n    };\n    exports2.CompileDirectiveMetadata = CompileDirectiveMetadata;\n    var CompilePipeMetadata = class {\n      constructor({\n        type,\n        name,\n        pure\n      }) {\n        this.type = type;\n        this.name = name;\n        this.pure = !!pure;\n      }\n      toSummary() {\n        return {\n          summaryKind: CompileSummaryKind.Pipe,\n          type: this.type,\n          name: this.name,\n          pure: this.pure\n        };\n      }\n    };\n    exports2.CompilePipeMetadata = CompilePipeMetadata;\n    var CompileShallowModuleMetadata = class {\n    };\n    exports2.CompileShallowModuleMetadata = CompileShallowModuleMetadata;\n    var CompileNgModuleMetadata = class {\n      constructor({\n        type,\n        providers,\n        declaredDirectives,\n        exportedDirectives,\n        declaredPipes,\n        exportedPipes,\n        entryComponents,\n        bootstrapComponents,\n        importedModules,\n        exportedModules,\n        schemas,\n        transitiveModule,\n        id\n      }) {\n        this.type = type || null;\n        this.declaredDirectives = _normalizeArray(declaredDirectives);\n        this.exportedDirectives = _normalizeArray(exportedDirectives);\n        this.declaredPipes = _normalizeArray(declaredPipes);\n        this.exportedPipes = _normalizeArray(exportedPipes);\n        this.providers = _normalizeArray(providers);\n        this.entryComponents = _normalizeArray(entryComponents);\n        this.bootstrapComponents = _normalizeArray(bootstrapComponents);\n        this.importedModules = _normalizeArray(importedModules);\n        this.exportedModules = _normalizeArray(exportedModules);\n        this.schemas = _normalizeArray(schemas);\n        this.id = id || null;\n        this.transitiveModule = transitiveModule || null;\n      }\n      toSummary() {\n        const module3 = this.transitiveModule;\n        return {\n          summaryKind: CompileSummaryKind.NgModule,\n          type: this.type,\n          entryComponents: module3.entryComponents,\n          providers: module3.providers,\n          modules: module3.modules,\n          exportedDirectives: module3.exportedDirectives,\n          exportedPipes: module3.exportedPipes\n        };\n      }\n    };\n    exports2.CompileNgModuleMetadata = CompileNgModuleMetadata;\n    var TransitiveCompileNgModuleMetadata = class {\n      constructor() {\n        this.directivesSet = /* @__PURE__ */ new Set();\n        this.directives = [];\n        this.exportedDirectivesSet = /* @__PURE__ */ new Set();\n        this.exportedDirectives = [];\n        this.pipesSet = /* @__PURE__ */ new Set();\n        this.pipes = [];\n        this.exportedPipesSet = /* @__PURE__ */ new Set();\n        this.exportedPipes = [];\n        this.modulesSet = /* @__PURE__ */ new Set();\n        this.modules = [];\n        this.entryComponentsSet = /* @__PURE__ */ new Set();\n        this.entryComponents = [];\n        this.providers = [];\n      }\n      addProvider(provider, module3) {\n        this.providers.push({\n          provider,\n          module: module3\n        });\n      }\n      addDirective(id) {\n        if (!this.directivesSet.has(id.reference)) {\n          this.directivesSet.add(id.reference);\n          this.directives.push(id);\n        }\n      }\n      addExportedDirective(id) {\n        if (!this.exportedDirectivesSet.has(id.reference)) {\n          this.exportedDirectivesSet.add(id.reference);\n          this.exportedDirectives.push(id);\n        }\n      }\n      addPipe(id) {\n        if (!this.pipesSet.has(id.reference)) {\n          this.pipesSet.add(id.reference);\n          this.pipes.push(id);\n        }\n      }\n      addExportedPipe(id) {\n        if (!this.exportedPipesSet.has(id.reference)) {\n          this.exportedPipesSet.add(id.reference);\n          this.exportedPipes.push(id);\n        }\n      }\n      addModule(id) {\n        if (!this.modulesSet.has(id.reference)) {\n          this.modulesSet.add(id.reference);\n          this.modules.push(id);\n        }\n      }\n      addEntryComponent(ec) {\n        if (!this.entryComponentsSet.has(ec.componentType)) {\n          this.entryComponentsSet.add(ec.componentType);\n          this.entryComponents.push(ec);\n        }\n      }\n    };\n    exports2.TransitiveCompileNgModuleMetadata = TransitiveCompileNgModuleMetadata;\n    function _normalizeArray(obj) {\n      return obj || [];\n    }\n    var ProviderMeta = class {\n      constructor(token, {\n        useClass,\n        useValue,\n        useExisting,\n        useFactory,\n        deps,\n        multi\n      }) {\n        this.token = token;\n        this.useClass = useClass || null;\n        this.useValue = useValue;\n        this.useExisting = useExisting;\n        this.useFactory = useFactory || null;\n        this.dependencies = deps || null;\n        this.multi = !!multi;\n      }\n    };\n    exports2.ProviderMeta = ProviderMeta;\n    function flatten(list) {\n      return list.reduce((flat, item) => {\n        const flatItem = Array.isArray(item) ? flatten(item) : item;\n        return flat.concat(flatItem);\n      }, []);\n    }\n    exports2.flatten = flatten;\n    function jitSourceUrl(url) {\n      return url.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, "ng:///");\n    }\n    function templateSourceUrl(ngModuleType, compMeta, templateMeta) {\n      let url;\n      if (templateMeta.isInline) {\n        if (compMeta.type.reference instanceof static_symbol_1.StaticSymbol) {\n          url = `${compMeta.type.reference.filePath}.${compMeta.type.reference.name}.html`;\n        } else {\n          url = `${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.html`;\n        }\n      } else {\n        url = templateMeta.templateUrl;\n      }\n      return compMeta.type.reference instanceof static_symbol_1.StaticSymbol ? url : jitSourceUrl(url);\n    }\n    exports2.templateSourceUrl = templateSourceUrl;\n    function sharedStylesheetJitUrl(meta, id) {\n      const pathParts = meta.moduleUrl.split(/\\/\\\\/g);\n      const baseName = pathParts[pathParts.length - 1];\n      return jitSourceUrl(`css/${id}${baseName}.ngstyle.js`);\n    }\n    exports2.sharedStylesheetJitUrl = sharedStylesheetJitUrl;\n    function ngModuleJitUrl(moduleMeta) {\n      return jitSourceUrl(`${identifierName(moduleMeta.type)}/module.ngfactory.js`);\n    }\n    exports2.ngModuleJitUrl = ngModuleJitUrl;\n    function templateJitUrl(ngModuleType, compMeta) {\n      return jitSourceUrl(`${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.ngfactory.js`);\n    }\n    exports2.templateJitUrl = templateJitUrl;\n  }\n});\nvar require_parse_util = __commonJS2({\n  "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(exports2) {\n    "use strict";\n    Object.defineProperty(exports2, "__esModule", {\n      value: true\n    });\n    var chars = require_chars();\n    var compile_metadata_1 = require_compile_metadata();\n    var ParseLocation = class {\n      constructor(file, offset, line, col) {\n        this.file = file;\n        this.offset = offset;\n        this.line = line;\n        this.col = col;\n      }\n      toString() {\n        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n      }\n      moveBy(delta) {\n        const source = this.file.content;\n        const len = source.length;\n        let offset = this.offset;\n        let line = this.line;\n        let col = this.col;\n        while (offset > 0 && delta < 0) {\n          offset--;\n          delta++;\n          const ch = source.charCodeAt(offset);\n          if (ch == chars.$LF) {\n            line--;\n            const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode(chars.$LF));\n            col = priorLine > 0 ? offset - priorLine : offset;\n          } else {\n            col--;\n          }\n        }\n        while (offset < len && delta > 0) {\n          const ch = source.charCodeAt(offset);\n          offset++;\n          delta--;\n          if (ch == chars.$LF) {\n            line++;\n            col = 0;\n          } else {\n            col++;\n          }\n        }\n        return new ParseLocation(this.file, offset, line, col);\n      }\n      getContext(maxChars, maxLines) {\n        const content = this.file.content;\n        let startOffset = this.offset;\n        if (startOffset != null) {\n          if (startOffset > content.length - 1) {\n            startOffset = content.length - 1;\n          }\n          let endOffset = startOffset;\n          let ctxChars = 0;\n          let ctxLines = 0;\n          while (ctxChars < maxChars && startOffset > 0) {\n            startOffset--;\n            ctxChars++;\n            if (content[startOffset] == "\\n") {\n              if (++ctxLines == maxLines) {\n                break;\n              }\n            }\n          }\n          ctxChars = 0;\n          ctxLines = 0;\n          while (ctxChars < maxChars && endOffset < content.length - 1) {\n            endOffset++;\n            ctxChars++;\n            if (content[endOffset] == "\\n") {\n              if (++ctxLines == maxLines) {\n                break;\n              }\n            }\n          }\n          return {\n            before: content.substring(startOffset, this.offset),\n            after: content.substring(this.offset, endOffset + 1)\n          };\n        }\n        return null;\n      }\n    };\n    exports2.ParseLocation = ParseLocation;\n    var ParseSourceFile = class {\n      constructor(content, url) {\n        this.content = content;\n        this.url = url;\n      }\n    };\n    exports2.ParseSourceFile = ParseSourceFile;\n    var ParseSourceSpan = class {\n      constructor(start, end, details = null) {\n        this.start = start;\n        this.end = end;\n        this.details = details;\n      }\n      toString() {\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\n      }\n    };\n    exports2.ParseSourceSpan = ParseSourceSpan;\n    exports2.EMPTY_PARSE_LOCATION = new ParseLocation(new ParseSourceFile("", ""), 0, 0, 0);\n    exports2.EMPTY_SOURCE_SPAN = new ParseSourceSpan(exports2.EMPTY_PARSE_LOCATION, exports2.EMPTY_PARSE_LOCATION);\n    var ParseErrorLevel;\n    (function(ParseErrorLevel2) {\n      ParseErrorLevel2[ParseErrorLevel2["WARNING"] = 0] = "WARNING";\n      ParseErrorLevel2[ParseErrorLevel2["ERROR"] = 1] = "ERROR";\n    })(ParseErrorLevel = exports2.ParseErrorLevel || (exports2.ParseErrorLevel = {}));\n    var ParseError = class {\n      constructor(span, msg, level = ParseErrorLevel.ERROR) {\n        this.span = span;\n        this.msg = msg;\n        this.level = level;\n      }\n      contextualMessage() {\n        const ctx = this.span.start.getContext(100, 3);\n        return ctx ? `${this.msg} ("${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}")` : this.msg;\n      }\n      toString() {\n        const details = this.span.details ? `, ${this.span.details}` : "";\n        return `${this.contextualMessage()}: ${this.span.start}${details}`;\n      }\n    };\n    exports2.ParseError = ParseError;\n    function typeSourceSpan(kind, type) {\n      const moduleUrl = compile_metadata_1.identifierModuleUrl(type);\n      const sourceFileName = moduleUrl != null ? `in ${kind} ${compile_metadata_1.identifierName(type)} in ${moduleUrl}` : `in ${kind} ${compile_metadata_1.identifierName(type)}`;\n      const sourceFile = new ParseSourceFile("", sourceFileName);\n      return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n    }\n    exports2.typeSourceSpan = typeSourceSpan;\n    function r3JitTypeSourceSpan(kind, typeName, sourceUrl) {\n      const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n      const sourceFile = new ParseSourceFile("", sourceFileName);\n      return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n    }\n    exports2.r3JitTypeSourceSpan = r3JitTypeSourceSpan;\n  }\n});\nvar require_print_preprocess3 = __commonJS2({\n  "src/language-html/print-preprocess.js"(exports2, module2) {\n    "use strict";\n    var {\n      ParseSourceSpan\n    } = require_parse_util();\n    var {\n      htmlTrim,\n      getLeadingAndTrailingHtmlWhitespace,\n      hasHtmlWhitespace,\n      canHaveInterpolation,\n      getNodeCssStyleDisplay,\n      isDanglingSpaceSensitiveNode,\n      isIndentationSensitiveNode,\n      isLeadingSpaceSensitiveNode,\n      isTrailingSpaceSensitiveNode,\n      isWhitespaceSensitiveNode,\n      isVueScriptTag\n    } = require_utils11();\n    var PREPROCESS_PIPELINE = [removeIgnorableFirstLf, mergeIfConditionalStartEndCommentIntoElementOpeningTag, mergeCdataIntoText, extractInterpolation, extractWhitespaces, addCssDisplay, addIsSelfClosing, addHasHtmComponentClosingTag, addIsSpaceSensitive, mergeSimpleElementIntoText, markTsScript];\n    function preprocess(ast, options) {\n      for (const fn of PREPROCESS_PIPELINE) {\n        fn(ast, options);\n      }\n      return ast;\n    }\n    function removeIgnorableFirstLf(ast) {\n      ast.walk((node) => {\n        if (node.type === "element" && node.tagDefinition.ignoreFirstLf && node.children.length > 0 && node.children[0].type === "text" && node.children[0].value[0] === "\\n") {\n          const text = node.children[0];\n          if (text.value.length === 1) {\n            node.removeChild(text);\n          } else {\n            text.value = text.value.slice(1);\n          }\n        }\n      });\n    }\n    function mergeIfConditionalStartEndCommentIntoElementOpeningTag(ast) {\n      const isTarget = (node) => node.type === "element" && node.prev && node.prev.type === "ieConditionalStartComment" && node.prev.sourceSpan.end.offset === node.startSourceSpan.start.offset && node.firstChild && node.firstChild.type === "ieConditionalEndComment" && node.firstChild.sourceSpan.start.offset === node.startSourceSpan.end.offset;\n      ast.walk((node) => {\n        if (node.children) {\n          for (let i = 0; i < node.children.length; i++) {\n            const child = node.children[i];\n            if (!isTarget(child)) {\n              continue;\n            }\n            const ieConditionalStartComment = child.prev;\n            const ieConditionalEndComment = child.firstChild;\n            node.removeChild(ieConditionalStartComment);\n            i--;\n            const startSourceSpan = new ParseSourceSpan(ieConditionalStartComment.sourceSpan.start, ieConditionalEndComment.sourceSpan.end);\n            const sourceSpan = new ParseSourceSpan(startSourceSpan.start, child.sourceSpan.end);\n            child.condition = ieConditionalStartComment.condition;\n            child.sourceSpan = sourceSpan;\n            child.startSourceSpan = startSourceSpan;\n            child.removeChild(ieConditionalEndComment);\n          }\n        }\n      });\n    }\n    function mergeNodeIntoText(ast, shouldMerge, getValue) {\n      ast.walk((node) => {\n        if (node.children) {\n          for (let i = 0; i < node.children.length; i++) {\n            const child = node.children[i];\n            if (child.type !== "text" && !shouldMerge(child)) {\n              continue;\n            }\n            if (child.type !== "text") {\n              child.type = "text";\n              child.value = getValue(child);\n            }\n            const prevChild = child.prev;\n            if (!prevChild || prevChild.type !== "text") {\n              continue;\n            }\n            prevChild.value += child.value;\n            prevChild.sourceSpan = new ParseSourceSpan(prevChild.sourceSpan.start, child.sourceSpan.end);\n            node.removeChild(child);\n            i--;\n          }\n        }\n      });\n    }\n    function mergeCdataIntoText(ast) {\n      return mergeNodeIntoText(ast, (node) => node.type === "cdata", (node) => `<![CDATA[${node.value}]]>`);\n    }\n    function mergeSimpleElementIntoText(ast) {\n      const isSimpleElement = (node) => node.type === "element" && node.attrs.length === 0 && node.children.length === 1 && node.firstChild.type === "text" && !hasHtmlWhitespace(node.children[0].value) && !node.firstChild.hasLeadingSpaces && !node.firstChild.hasTrailingSpaces && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces && node.prev && node.prev.type === "text" && node.next && node.next.type === "text";\n      ast.walk((node) => {\n        if (node.children) {\n          for (let i = 0; i < node.children.length; i++) {\n            const child = node.children[i];\n            if (!isSimpleElement(child)) {\n              continue;\n            }\n            const prevChild = child.prev;\n            const nextChild = child.next;\n            prevChild.value += `<${child.rawName}>` + child.firstChild.value + `</${child.rawName}>` + nextChild.value;\n            prevChild.sourceSpan = new ParseSourceSpan(prevChild.sourceSpan.start, nextChild.sourceSpan.end);\n            prevChild.isTrailingSpaceSensitive = nextChild.isTrailingSpaceSensitive;\n            prevChild.hasTrailingSpaces = nextChild.hasTrailingSpaces;\n            node.removeChild(child);\n            i--;\n            node.removeChild(nextChild);\n          }\n        }\n      });\n    }\n    function extractInterpolation(ast, options) {\n      if (options.parser === "html") {\n        return;\n      }\n      const interpolationRegex = /{{(.+?)}}/s;\n      ast.walk((node) => {\n        if (!canHaveInterpolation(node)) {\n          return;\n        }\n        for (const child of node.children) {\n          if (child.type !== "text") {\n            continue;\n          }\n          let startSourceSpan = child.sourceSpan.start;\n          let endSourceSpan = null;\n          const components = child.value.split(interpolationRegex);\n          for (let i = 0; i < components.length; i++, startSourceSpan = endSourceSpan) {\n            const value = components[i];\n            if (i % 2 === 0) {\n              endSourceSpan = startSourceSpan.moveBy(value.length);\n              if (value.length > 0) {\n                node.insertChildBefore(child, {\n                  type: "text",\n                  value,\n                  sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan)\n                });\n              }\n              continue;\n            }\n            endSourceSpan = startSourceSpan.moveBy(value.length + 4);\n            node.insertChildBefore(child, {\n              type: "interpolation",\n              sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),\n              children: value.length === 0 ? [] : [{\n                type: "text",\n                value,\n                sourceSpan: new ParseSourceSpan(startSourceSpan.moveBy(2), endSourceSpan.moveBy(-2))\n              }]\n            });\n          }\n          node.removeChild(child);\n        }\n      });\n    }\n    function extractWhitespaces(ast) {\n      ast.walk((node) => {\n        if (!node.children) {\n          return;\n        }\n        if (node.children.length === 0 || node.children.length === 1 && node.children[0].type === "text" && htmlTrim(node.children[0].value).length === 0) {\n          node.hasDanglingSpaces = node.children.length > 0;\n          node.children = [];\n          return;\n        }\n        const isWhitespaceSensitive = isWhitespaceSensitiveNode(node);\n        const isIndentationSensitive = isIndentationSensitiveNode(node);\n        if (!isWhitespaceSensitive) {\n          for (let i = 0; i < node.children.length; i++) {\n            const child = node.children[i];\n            if (child.type !== "text") {\n              continue;\n            }\n            const {\n              leadingWhitespace,\n              text,\n              trailingWhitespace\n            } = getLeadingAndTrailingHtmlWhitespace(child.value);\n            const prevChild = child.prev;\n            const nextChild = child.next;\n            if (!text) {\n              node.removeChild(child);\n              i--;\n              if (leadingWhitespace || trailingWhitespace) {\n                if (prevChild) {\n                  prevChild.hasTrailingSpaces = true;\n                }\n                if (nextChild) {\n                  nextChild.hasLeadingSpaces = true;\n                }\n              }\n            } else {\n              child.value = text;\n              child.sourceSpan = new ParseSourceSpan(child.sourceSpan.start.moveBy(leadingWhitespace.length), child.sourceSpan.end.moveBy(-trailingWhitespace.length));\n              if (leadingWhitespace) {\n                if (prevChild) {\n                  prevChild.hasTrailingSpaces = true;\n                }\n                child.hasLeadingSpaces = true;\n              }\n              if (trailingWhitespace) {\n                child.hasTrailingSpaces = true;\n                if (nextChild) {\n                  nextChild.hasLeadingSpaces = true;\n                }\n              }\n            }\n          }\n        }\n        node.isWhitespaceSensitive = isWhitespaceSensitive;\n        node.isIndentationSensitive = isIndentationSensitive;\n      });\n    }\n    function addIsSelfClosing(ast) {\n      ast.walk((node) => {\n        node.isSelfClosing = !node.children || node.type === "element" && (node.tagDefinition.isVoid || node.startSourceSpan === node.endSourceSpan);\n      });\n    }\n    function addHasHtmComponentClosingTag(ast, options) {\n      ast.walk((node) => {\n        if (node.type !== "element") {\n          return;\n        }\n        node.hasHtmComponentClosingTag = node.endSourceSpan && /^<\\s*\\/\\s*\\/\\s*>$/.test(options.originalText.slice(node.endSourceSpan.start.offset, node.endSourceSpan.end.offset));\n      });\n    }\n    function addCssDisplay(ast, options) {\n      ast.walk((node) => {\n        node.cssDisplay = getNodeCssStyleDisplay(node, options);\n      });\n    }\n    function addIsSpaceSensitive(ast, options) {\n      ast.walk((node) => {\n        const {\n          children\n        } = node;\n        if (!children) {\n          return;\n        }\n        if (children.length === 0) {\n          node.isDanglingSpaceSensitive = isDanglingSpaceSensitiveNode(node);\n          return;\n        }\n        for (const child of children) {\n          child.isLeadingSpaceSensitive = isLeadingSpaceSensitiveNode(child, options);\n          child.isTrailingSpaceSensitive = isTrailingSpaceSensitiveNode(child, options);\n        }\n        for (let index = 0; index < children.length; index++) {\n          const child = children[index];\n          child.isLeadingSpaceSensitive = index === 0 ? child.isLeadingSpaceSensitive : child.prev.isTrailingSpaceSensitive && child.isLeadingSpaceSensitive;\n          child.isTrailingSpaceSensitive = index === children.length - 1 ? child.isTrailingSpaceSensitive : child.next.isLeadingSpaceSensitive && child.isTrailingSpaceSensitive;\n        }\n      });\n    }\n    function markTsScript(ast, options) {\n      if (options.parser === "vue") {\n        const vueScriptTag = ast.children.find((child) => isVueScriptTag(child, options));\n        if (!vueScriptTag) {\n          return;\n        }\n        const {\n          lang\n        } = vueScriptTag.attrMap;\n        if (lang === "ts" || lang === "typescript") {\n          options.__should_parse_vue_template_with_ts = true;\n        }\n      }\n    }\n    module2.exports = preprocess;\n  }\n});\nvar require_pragma5 = __commonJS2({\n  "src/language-html/pragma.js"(exports2, module2) {\n    "use strict";\n    function hasPragma(text) {\n      return /^\\s*\x3c!--\\s*@(?:format|prettier)\\s*--\x3e/.test(text);\n    }\n    function insertPragma(text) {\n      return "\x3c!-- @format --\x3e\\n\\n" + text.replace(/^\\s*\\n/, "");\n    }\n    module2.exports = {\n      hasPragma,\n      insertPragma\n    };\n  }\n});\nvar require_loc6 = __commonJS2({\n  "src/language-html/loc.js"(exports2, module2) {\n    "use strict";\n    function locStart(node) {\n      return node.sourceSpan.start.offset;\n    }\n    function locEnd(node) {\n      return node.sourceSpan.end.offset;\n    }\n    module2.exports = {\n      locStart,\n      locEnd\n    };\n  }\n});\nvar require_tag = __commonJS2({\n  "src/language-html/print/tag.js"(exports2, module2) {\n    "use strict";\n    var assert = require("assert");\n    var {\n      isNonEmptyArray\n    } = require_util();\n    var {\n      builders: {\n        indent,\n        join,\n        line,\n        softline,\n        hardline\n      },\n      utils: {\n        replaceTextEndOfLine\n      }\n    } = require("./doc.js");\n    var {\n      locStart,\n      locEnd\n    } = require_loc6();\n    var {\n      isTextLikeNode,\n      getLastDescendant,\n      isPreLikeNode,\n      hasPrettierIgnore,\n      shouldPreserveContent,\n      isVueSfcBlock\n    } = require_utils11();\n    function printClosingTag(node, options) {\n      return [node.isSelfClosing ? "" : printClosingTagStart(node, options), printClosingTagEnd(node, options)];\n    }\n    function printClosingTagStart(node, options) {\n      return node.lastChild && needsToBorrowParentClosingTagStartMarker(node.lastChild) ? "" : [printClosingTagPrefix(node, options), printClosingTagStartMarker(node, options)];\n    }\n    function printClosingTagEnd(node, options) {\n      return (node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : needsToBorrowLastChildClosingTagEndMarker(node.parent)) ? "" : [printClosingTagEndMarker(node, options), printClosingTagSuffix(node, options)];\n    }\n    function printClosingTagPrefix(node, options) {\n      return needsToBorrowLastChildClosingTagEndMarker(node) ? printClosingTagEndMarker(node.lastChild, options) : "";\n    }\n    function printClosingTagSuffix(node, options) {\n      return needsToBorrowParentClosingTagStartMarker(node) ? printClosingTagStartMarker(node.parent, options) : needsToBorrowNextOpeningTagStartMarker(node) ? printOpeningTagStartMarker(node.next) : "";\n    }\n    function printClosingTagStartMarker(node, options) {\n      assert(!node.isSelfClosing);\n      if (shouldNotPrintClosingTag(node, options)) {\n        return "";\n      }\n      switch (node.type) {\n        case "ieConditionalComment":\n          return "<!";\n        case "element":\n          if (node.hasHtmComponentClosingTag) {\n            return "<//";\n          }\n        default:\n          return `</${node.rawName}`;\n      }\n    }\n    function printClosingTagEndMarker(node, options) {\n      if (shouldNotPrintClosingTag(node, options)) {\n        return "";\n      }\n      switch (node.type) {\n        case "ieConditionalComment":\n        case "ieConditionalEndComment":\n          return "[endif]--\x3e";\n        case "ieConditionalStartComment":\n          return "]>\x3c!--\x3e";\n        case "interpolation":\n          return "}}";\n        case "element":\n          if (node.isSelfClosing) {\n            return "/>";\n          }\n        default:\n          return ">";\n      }\n    }\n    function shouldNotPrintClosingTag(node, options) {\n      return !node.isSelfClosing && !node.endSourceSpan && (hasPrettierIgnore(node) || shouldPreserveContent(node.parent, options));\n    }\n    function needsToBorrowPrevClosingTagEndMarker(node) {\n      return node.prev && node.prev.type !== "docType" && !isTextLikeNode(node.prev) && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;\n    }\n    function needsToBorrowLastChildClosingTagEndMarker(node) {\n      return node.lastChild && node.lastChild.isTrailingSpaceSensitive && !node.lastChild.hasTrailingSpaces && !isTextLikeNode(getLastDescendant(node.lastChild)) && !isPreLikeNode(node);\n    }\n    function needsToBorrowParentClosingTagStartMarker(node) {\n      return !node.next && !node.hasTrailingSpaces && node.isTrailingSpaceSensitive && isTextLikeNode(getLastDescendant(node));\n    }\n    function needsToBorrowNextOpeningTagStartMarker(node) {\n      return node.next && !isTextLikeNode(node.next) && isTextLikeNode(node) && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces;\n    }\n    function getPrettierIgnoreAttributeCommentData(value) {\n      const match = value.trim().match(/^prettier-ignore-attribute(?:\\s+(.+))?$/s);\n      if (!match) {\n        return false;\n      }\n      if (!match[1]) {\n        return true;\n      }\n      return match[1].split(/\\s+/);\n    }\n    function needsToBorrowParentOpeningTagEndMarker(node) {\n      return !node.prev && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;\n    }\n    function printAttributes(path, options, print) {\n      const node = path.getValue();\n      if (!isNonEmptyArray(node.attrs)) {\n        return node.isSelfClosing ? " " : "";\n      }\n      const ignoreAttributeData = node.prev && node.prev.type === "comment" && getPrettierIgnoreAttributeCommentData(node.prev.value);\n      const hasPrettierIgnoreAttribute = typeof ignoreAttributeData === "boolean" ? () => ignoreAttributeData : Array.isArray(ignoreAttributeData) ? (attribute) => ignoreAttributeData.includes(attribute.rawName) : () => false;\n      const printedAttributes = path.map((attributePath) => {\n        const attribute = attributePath.getValue();\n        return hasPrettierIgnoreAttribute(attribute) ? replaceTextEndOfLine(options.originalText.slice(locStart(attribute), locEnd(attribute))) : print();\n      }, "attrs");\n      const forceNotToBreakAttrContent = node.type === "element" && node.fullName === "script" && node.attrs.length === 1 && node.attrs[0].fullName === "src" && node.children.length === 0;\n      const shouldPrintAttributePerLine = options.singleAttributePerLine && node.attrs.length > 1 && !isVueSfcBlock(node, options);\n      const attributeLine = shouldPrintAttributePerLine ? hardline : line;\n      const parts = [indent([forceNotToBreakAttrContent ? " " : line, join(attributeLine, printedAttributes)])];\n      if (node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) || node.isSelfClosing && needsToBorrowLastChildClosingTagEndMarker(node.parent) || forceNotToBreakAttrContent) {\n        parts.push(node.isSelfClosing ? " " : "");\n      } else {\n        parts.push(options.bracketSameLine ? node.isSelfClosing ? " " : "" : node.isSelfClosing ? line : softline);\n      }\n      return parts;\n    }\n    function printOpeningTagEnd(node) {\n      return node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) ? "" : printOpeningTagEndMarker(node);\n    }\n    function printOpeningTag(path, options, print) {\n      const node = path.getValue();\n      return [printOpeningTagStart(node, options), printAttributes(path, options, print), node.isSelfClosing ? "" : printOpeningTagEnd(node)];\n    }\n    function printOpeningTagStart(node, options) {\n      return node.prev && needsToBorrowNextOpeningTagStartMarker(node.prev) ? "" : [printOpeningTagPrefix(node, options), printOpeningTagStartMarker(node)];\n    }\n    function printOpeningTagPrefix(node, options) {\n      return needsToBorrowParentOpeningTagEndMarker(node) ? printOpeningTagEndMarker(node.parent) : needsToBorrowPrevClosingTagEndMarker(node) ? printClosingTagEndMarker(node.prev, options) : "";\n    }\n    function printOpeningTagStartMarker(node) {\n      switch (node.type) {\n        case "ieConditionalComment":\n        case "ieConditionalStartComment":\n          return `\x3c!--[if ${node.condition}`;\n        case "ieConditionalEndComment":\n          return "\x3c!--<!";\n        case "interpolation":\n          return "{{";\n        case "docType":\n          return "<!DOCTYPE";\n        case "element":\n          if (node.condition) {\n            return `\x3c!--[if ${node.condition}]>\x3c!--\x3e<${node.rawName}`;\n          }\n        default:\n          return `<${node.rawName}`;\n      }\n    }\n    function printOpeningTagEndMarker(node) {\n      assert(!node.isSelfClosing);\n      switch (node.type) {\n        case "ieConditionalComment":\n          return "]>";\n        case "element":\n          if (node.condition) {\n            return ">\x3c!--<![endif]--\x3e";\n          }\n        default:\n          return ">";\n      }\n    }\n    module2.exports = {\n      printClosingTag,\n      printClosingTagStart,\n      printClosingTagStartMarker,\n      printClosingTagEndMarker,\n      printClosingTagSuffix,\n      printClosingTagEnd,\n      needsToBorrowLastChildClosingTagEndMarker,\n      needsToBorrowParentClosingTagStartMarker,\n      needsToBorrowPrevClosingTagEndMarker,\n      printOpeningTag,\n      printOpeningTagStart,\n      printOpeningTagPrefix,\n      printOpeningTagStartMarker,\n      printOpeningTagEndMarker,\n      needsToBorrowNextOpeningTagStartMarker,\n      needsToBorrowParentOpeningTagEndMarker\n    };\n  }\n});\nvar require_parse_srcset = __commonJS2({\n  "node_modules/parse-srcset/src/parse-srcset.js"(exports2, module2) {\n    (function(root, factory) {\n      if (typeof define === "function" && define.amd) {\n        define([], factory);\n      } else if (typeof module2 === "object" && module2.exports) {\n        module2.exports = factory();\n      } else {\n        root.parseSrcset = factory();\n      }\n    })(exports2, function() {\n      return function(input, options) {\n        var logger = options && options.logger || console;\n        function isSpace(c2) {\n          return c2 === " " || c2 === "\t" || c2 === "\\n" || c2 === "\\f" || c2 === "\\r";\n        }\n        function collectCharacters(regEx) {\n          var chars, match = regEx.exec(input.substring(pos));\n          if (match) {\n            chars = match[0];\n            pos += chars.length;\n            return chars;\n          }\n        }\n        var inputLength = input.length, regexLeadingSpaces = /^[ \\t\\n\\r\\u000c]+/, regexLeadingCommasOrSpaces = /^[, \\t\\n\\r\\u000c]+/, regexLeadingNotSpaces = /^[^ \\t\\n\\r\\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\\d+$/, regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url, descriptors, currentDescriptor, state, c, pos = 0, candidates = [];\n        while (true) {\n          collectCharacters(regexLeadingCommasOrSpaces);\n          if (pos >= inputLength) {\n            return candidates;\n          }\n          url = collectCharacters(regexLeadingNotSpaces);\n          descriptors = [];\n          if (url.slice(-1) === ",") {\n            url = url.replace(regexTrailingCommas, "");\n            parseDescriptors();\n          } else {\n            tokenize();\n          }\n        }\n        function tokenize() {\n          collectCharacters(regexLeadingSpaces);\n          currentDescriptor = "";\n          state = "in descriptor";\n          while (true) {\n            c = input.charAt(pos);\n            if (state === "in descriptor") {\n              if (isSpace(c)) {\n                if (currentDescriptor) {\n                  descriptors.push(currentDescriptor);\n                  currentDescriptor = "";\n                  state = "after descriptor";\n                }\n              } else if (c === ",") {\n                pos += 1;\n                if (currentDescriptor) {\n                  descriptors.push(currentDescriptor);\n                }\n                parseDescriptors();\n                return;\n              } else if (c === "(") {\n                currentDescriptor = currentDescriptor + c;\n                state = "in parens";\n              } else if (c === "") {\n                if (currentDescriptor) {\n                  descriptors.push(currentDescriptor);\n                }\n                parseDescriptors();\n                return;\n              } else {\n                currentDescriptor = currentDescriptor + c;\n              }\n            } else if (state === "in parens") {\n              if (c === ")") {\n                currentDescriptor = currentDescriptor + c;\n                state = "in descriptor";\n              } else if (c === "") {\n                descriptors.push(currentDescriptor);\n                parseDescriptors();\n                return;\n              } else {\n                currentDescriptor = currentDescriptor + c;\n              }\n            } else if (state === "after descriptor") {\n              if (isSpace(c)) {\n              } else if (c === "") {\n                parseDescriptors();\n                return;\n              } else {\n                state = "in descriptor";\n                pos -= 1;\n              }\n            }\n            pos += 1;\n          }\n        }\n        function parseDescriptors() {\n          var pError = false, w, d, h, i, candidate = {}, desc, lastChar, value, intVal, floatVal;\n          for (i = 0; i < descriptors.length; i++) {\n            desc = descriptors[i];\n            lastChar = desc[desc.length - 1];\n            value = desc.substring(0, desc.length - 1);\n            intVal = parseInt(value, 10);\n            floatVal = parseFloat(value);\n            if (regexNonNegativeInteger.test(value) && lastChar === "w") {\n              if (w || d) {\n                pError = true;\n              }\n              if (intVal === 0) {\n                pError = true;\n              } else {\n                w = intVal;\n              }\n            } else if (regexFloatingPoint.test(value) && lastChar === "x") {\n              if (w || d || h) {\n                pError = true;\n              }\n              if (floatVal < 0) {\n                pError = true;\n              } else {\n                d = floatVal;\n              }\n            } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {\n              if (h || d) {\n                pError = true;\n              }\n              if (intVal === 0) {\n                pError = true;\n              } else {\n                h = intVal;\n              }\n            } else {\n              pError = true;\n            }\n          }\n          if (!pError) {\n            candidate.url = url;\n            if (w) {\n              candidate.w = w;\n            }\n            if (d) {\n              candidate.d = d;\n            }\n            if (h) {\n              candidate.h = h;\n            }\n            candidates.push(candidate);\n          } else if (logger && logger.error) {\n            logger.error("Invalid srcset descriptor found in \'" + input + "\' at \'" + desc + "\'.");\n          }\n        }\n      };\n    });\n  }\n});\nvar require_syntax_attribute = __commonJS2({\n  "src/language-html/syntax-attribute.js"(exports2, module2) {\n    "use strict";\n    var parseSrcset = require_parse_srcset();\n    var {\n      builders: {\n        ifBreak,\n        join,\n        line\n      }\n    } = require("./doc.js");\n    function printImgSrcset(value) {\n      const srcset = parseSrcset(value, {\n        logger: {\n          error(message) {\n            throw new Error(message);\n          }\n        }\n      });\n      const hasW = srcset.some(({\n        w\n      }) => w);\n      const hasH = srcset.some(({\n        h\n      }) => h);\n      const hasX = srcset.some(({\n        d\n      }) => d);\n      if (hasW + hasH + hasX > 1) {\n        throw new Error("Mixed descriptor in srcset is not supported");\n      }\n      const key = hasW ? "w" : hasH ? "h" : "d";\n      const unit = hasW ? "w" : hasH ? "h" : "x";\n      const getMax = (values) => Math.max(...values);\n      const urls = srcset.map((src) => src.url);\n      const maxUrlLength = getMax(urls.map((url) => url.length));\n      const descriptors = srcset.map((src) => src[key]).map((descriptor) => descriptor ? descriptor.toString() : "");\n      const descriptorLeftLengths = descriptors.map((descriptor) => {\n        const index = descriptor.indexOf(".");\n        return index === -1 ? descriptor.length : index;\n      });\n      const maxDescriptorLeftLength = getMax(descriptorLeftLengths);\n      return join([",", line], urls.map((url, index) => {\n        const parts = [url];\n        const descriptor = descriptors[index];\n        if (descriptor) {\n          const urlPadding = maxUrlLength - url.length + 1;\n          const descriptorPadding = maxDescriptorLeftLength - descriptorLeftLengths[index];\n          const alignment = " ".repeat(urlPadding + descriptorPadding);\n          parts.push(ifBreak(alignment, " "), descriptor + unit);\n        }\n        return parts;\n      }));\n    }\n    function printClassNames(value) {\n      return value.trim().split(/\\s+/).join(" ");\n    }\n    module2.exports = {\n      printImgSrcset,\n      printClassNames\n    };\n  }\n});\nvar require_syntax_vue = __commonJS2({\n  "src/language-html/syntax-vue.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        group\n      }\n    } = require("./doc.js");\n    function printVueFor(value, textToDoc) {\n      const {\n        left,\n        operator,\n        right\n      } = parseVueFor(value);\n      return [group(textToDoc(`function _(${left}) {}`, {\n        parser: "babel",\n        __isVueForBindingLeft: true\n      })), " ", operator, " ", textToDoc(right, {\n        parser: "__js_expression"\n      }, {\n        stripTrailingHardline: true\n      })];\n    }\n    function parseVueFor(value) {\n      const forAliasRE = /(.*?)\\s+(in|of)\\s+(.*)/s;\n      const forIteratorRE = /,([^,\\]}]*)(?:,([^,\\]}]*))?$/;\n      const stripParensRE = /^\\(|\\)$/g;\n      const inMatch = value.match(forAliasRE);\n      if (!inMatch) {\n        return;\n      }\n      const res = {};\n      res.for = inMatch[3].trim();\n      if (!res.for) {\n        return;\n      }\n      const alias = inMatch[1].trim().replace(stripParensRE, "");\n      const iteratorMatch = alias.match(forIteratorRE);\n      if (iteratorMatch) {\n        res.alias = alias.replace(forIteratorRE, "");\n        res.iterator1 = iteratorMatch[1].trim();\n        if (iteratorMatch[2]) {\n          res.iterator2 = iteratorMatch[2].trim();\n        }\n      } else {\n        res.alias = alias;\n      }\n      const left = [res.alias, res.iterator1, res.iterator2];\n      if (left.some((part, index) => !part && (index === 0 || left.slice(index + 1).some(Boolean)))) {\n        return;\n      }\n      return {\n        left: left.filter(Boolean).join(","),\n        operator: inMatch[2],\n        right: res.for\n      };\n    }\n    function printVueBindings(value, textToDoc) {\n      return textToDoc(`function _(${value}) {}`, {\n        parser: "babel",\n        __isVueBindings: true\n      });\n    }\n    function isVueEventBindingExpression(eventBindingValue) {\n      const fnExpRE = /^(?:[\\w$]+|\\([^)]*\\))\\s*=>|^function\\s*\\(/;\n      const simplePathRE = /^[$A-Z_a-z][\\w$]*(?:\\.[$A-Z_a-z][\\w$]*|\\[\'[^\']*\']|\\["[^"]*"]|\\[\\d+]|\\[[$A-Z_a-z][\\w$]*])*$/;\n      const value = eventBindingValue.trim();\n      return fnExpRE.test(value) || simplePathRE.test(value);\n    }\n    module2.exports = {\n      isVueEventBindingExpression,\n      printVueFor,\n      printVueBindings\n    };\n  }\n});\nvar require_get_node_content = __commonJS2({\n  "src/language-html/get-node-content.js"(exports2, module2) {\n    "use strict";\n    var {\n      needsToBorrowParentClosingTagStartMarker,\n      printClosingTagStartMarker,\n      needsToBorrowLastChildClosingTagEndMarker,\n      printClosingTagEndMarker,\n      needsToBorrowParentOpeningTagEndMarker,\n      printOpeningTagEndMarker\n    } = require_tag();\n    function getNodeContent(node, options) {\n      let start = node.startSourceSpan.end.offset;\n      if (node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild)) {\n        start -= printOpeningTagEndMarker(node).length;\n      }\n      let end = node.endSourceSpan.start.offset;\n      if (node.lastChild && needsToBorrowParentClosingTagStartMarker(node.lastChild)) {\n        end += printClosingTagStartMarker(node, options).length;\n      } else if (needsToBorrowLastChildClosingTagEndMarker(node)) {\n        end -= printClosingTagEndMarker(node.lastChild, options).length;\n      }\n      return options.originalText.slice(start, end);\n    }\n    module2.exports = getNodeContent;\n  }\n});\nvar require_embed4 = __commonJS2({\n  "src/language-html/embed.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        breakParent,\n        group,\n        hardline,\n        indent,\n        line,\n        fill,\n        softline\n      },\n      utils: {\n        mapDoc,\n        replaceTextEndOfLine\n      }\n    } = require("./doc.js");\n    var printFrontMatter = require_print();\n    var {\n      printClosingTag,\n      printClosingTagSuffix,\n      needsToBorrowPrevClosingTagEndMarker,\n      printOpeningTagPrefix,\n      printOpeningTag\n    } = require_tag();\n    var {\n      printImgSrcset,\n      printClassNames\n    } = require_syntax_attribute();\n    var {\n      printVueFor,\n      printVueBindings,\n      isVueEventBindingExpression\n    } = require_syntax_vue();\n    var {\n      isScriptLikeTag,\n      isVueNonHtmlBlock,\n      inferScriptParser,\n      htmlTrimPreserveIndentation,\n      dedentString,\n      unescapeQuoteEntities,\n      isVueSlotAttribute,\n      isVueSfcBindingsAttribute,\n      getTextValueParts\n    } = require_utils11();\n    var getNodeContent = require_get_node_content();\n    function printEmbeddedAttributeValue(node, htmlTextToDoc, options) {\n      const isKeyMatched = (patterns) => new RegExp(patterns.join("|")).test(node.fullName);\n      const getValue = () => unescapeQuoteEntities(node.value);\n      let shouldHug = false;\n      const __onHtmlBindingRoot = (root, options2) => {\n        const rootNode = root.type === "NGRoot" ? root.node.type === "NGMicrosyntax" && root.node.body.length === 1 && root.node.body[0].type === "NGMicrosyntaxExpression" ? root.node.body[0].expression : root.node : root.type === "JsExpressionRoot" ? root.node : root;\n        if (rootNode && (rootNode.type === "ObjectExpression" || rootNode.type === "ArrayExpression" || options2.parser === "__vue_expression" && (rootNode.type === "TemplateLiteral" || rootNode.type === "StringLiteral"))) {\n          shouldHug = true;\n        }\n      };\n      const printHug = (doc2) => group(doc2);\n      const printExpand = (doc2, canHaveTrailingWhitespace = true) => group([indent([softline, doc2]), canHaveTrailingWhitespace ? softline : ""]);\n      const printMaybeHug = (doc2) => shouldHug ? printHug(doc2) : printExpand(doc2);\n      const attributeTextToDoc = (code, opts) => htmlTextToDoc(code, Object.assign({\n        __onHtmlBindingRoot,\n        __embeddedInHtml: true\n      }, opts));\n      if (node.fullName === "srcset" && (node.parent.fullName === "img" || node.parent.fullName === "source")) {\n        return printExpand(printImgSrcset(getValue()));\n      }\n      if (node.fullName === "class" && !options.parentParser) {\n        const value = getValue();\n        if (!value.includes("{{")) {\n          return printClassNames(value);\n        }\n      }\n      if (node.fullName === "style" && !options.parentParser) {\n        const value = getValue();\n        if (!value.includes("{{")) {\n          return printExpand(attributeTextToDoc(value, {\n            parser: "css",\n            __isHTMLStyleAttribute: true\n          }));\n        }\n      }\n      if (options.parser === "vue") {\n        if (node.fullName === "v-for") {\n          return printVueFor(getValue(), attributeTextToDoc);\n        }\n        if (isVueSlotAttribute(node) || isVueSfcBindingsAttribute(node, options)) {\n          return printVueBindings(getValue(), attributeTextToDoc);\n        }\n        const vueEventBindingPatterns = ["^@", "^v-on:"];\n        const vueExpressionBindingPatterns = ["^:", "^v-bind:"];\n        const jsExpressionBindingPatterns = ["^v-"];\n        if (isKeyMatched(vueEventBindingPatterns)) {\n          const value = getValue();\n          const parser = isVueEventBindingExpression(value) ? "__js_expression" : options.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";\n          return printMaybeHug(attributeTextToDoc(value, {\n            parser\n          }));\n        }\n        if (isKeyMatched(vueExpressionBindingPatterns)) {\n          return printMaybeHug(attributeTextToDoc(getValue(), {\n            parser: "__vue_expression"\n          }));\n        }\n        if (isKeyMatched(jsExpressionBindingPatterns)) {\n          return printMaybeHug(attributeTextToDoc(getValue(), {\n            parser: "__js_expression"\n          }));\n        }\n      }\n      if (options.parser === "angular") {\n        const ngTextToDoc = (code, opts) => attributeTextToDoc(code, Object.assign(Object.assign({}, opts), {}, {\n          trailingComma: "none"\n        }));\n        const ngDirectiveBindingPatterns = ["^\\\\*"];\n        const ngStatementBindingPatterns = ["^\\\\(.+\\\\)$", "^on-"];\n        const ngExpressionBindingPatterns = ["^\\\\[.+\\\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"];\n        const ngI18nPatterns = ["^i18n(-.+)?$"];\n        if (isKeyMatched(ngStatementBindingPatterns)) {\n          return printMaybeHug(ngTextToDoc(getValue(), {\n            parser: "__ng_action"\n          }));\n        }\n        if (isKeyMatched(ngExpressionBindingPatterns)) {\n          return printMaybeHug(ngTextToDoc(getValue(), {\n            parser: "__ng_binding"\n          }));\n        }\n        if (isKeyMatched(ngI18nPatterns)) {\n          const value2 = getValue().trim();\n          return printExpand(fill(getTextValueParts(node, value2)), !value2.includes("@@"));\n        }\n        if (isKeyMatched(ngDirectiveBindingPatterns)) {\n          return printMaybeHug(ngTextToDoc(getValue(), {\n            parser: "__ng_directive"\n          }));\n        }\n        const interpolationRegex = /{{(.+?)}}/s;\n        const value = getValue();\n        if (interpolationRegex.test(value)) {\n          const parts = [];\n          for (const [index, part] of value.split(interpolationRegex).entries()) {\n            if (index % 2 === 0) {\n              parts.push(replaceTextEndOfLine(part));\n            } else {\n              try {\n                parts.push(group(["{{", indent([line, ngTextToDoc(part, {\n                  parser: "__ng_interpolation",\n                  __isInHtmlInterpolation: true\n                })]), line, "}}"]));\n              } catch {\n                parts.push("{{", replaceTextEndOfLine(part), "}}");\n              }\n            }\n          }\n          return group(parts);\n        }\n      }\n      return null;\n    }\n    function embed(path, print, textToDoc, options) {\n      const node = path.getValue();\n      switch (node.type) {\n        case "element": {\n          if (isScriptLikeTag(node) || node.type === "interpolation") {\n            return;\n          }\n          if (!node.isSelfClosing && isVueNonHtmlBlock(node, options)) {\n            const parser = inferScriptParser(node, options);\n            if (!parser) {\n              return;\n            }\n            const content = getNodeContent(node, options);\n            let isEmpty = /^\\s*$/.test(content);\n            let doc2 = "";\n            if (!isEmpty) {\n              doc2 = textToDoc(htmlTrimPreserveIndentation(content), {\n                parser,\n                __embeddedInHtml: true\n              }, {\n                stripTrailingHardline: true\n              });\n              isEmpty = doc2 === "";\n            }\n            return [printOpeningTagPrefix(node, options), group(printOpeningTag(path, options, print)), isEmpty ? "" : hardline, doc2, isEmpty ? "" : hardline, printClosingTag(node, options), printClosingTagSuffix(node, options)];\n          }\n          break;\n        }\n        case "text": {\n          if (isScriptLikeTag(node.parent)) {\n            const parser = inferScriptParser(node.parent, options);\n            if (parser) {\n              const value = parser === "markdown" ? dedentString(node.value.replace(/^[^\\S\\n]*\\n/, "")) : node.value;\n              const textToDocOptions = {\n                parser,\n                __embeddedInHtml: true\n              };\n              if (options.parser === "html" && parser === "babel") {\n                let sourceType = "script";\n                const {\n                  attrMap\n                } = node.parent;\n                if (attrMap && (attrMap.type === "module" || attrMap.type === "text/babel" && attrMap["data-type"] === "module")) {\n                  sourceType = "module";\n                }\n                textToDocOptions.__babelSourceType = sourceType;\n              }\n              return [breakParent, printOpeningTagPrefix(node, options), textToDoc(value, textToDocOptions, {\n                stripTrailingHardline: true\n              }), printClosingTagSuffix(node, options)];\n            }\n          } else if (node.parent.type === "interpolation") {\n            const textToDocOptions = {\n              __isInHtmlInterpolation: true,\n              __embeddedInHtml: true\n            };\n            if (options.parser === "angular") {\n              textToDocOptions.parser = "__ng_interpolation";\n              textToDocOptions.trailingComma = "none";\n            } else if (options.parser === "vue") {\n              textToDocOptions.parser = options.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression";\n            } else {\n              textToDocOptions.parser = "__js_expression";\n            }\n            return [indent([line, textToDoc(node.value, textToDocOptions, {\n              stripTrailingHardline: true\n            })]), node.parent.next && needsToBorrowPrevClosingTagEndMarker(node.parent.next) ? " " : line];\n          }\n          break;\n        }\n        case "attribute": {\n          if (!node.value) {\n            break;\n          }\n          if (/^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(options.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {\n            return [node.rawName, "=", node.value];\n          }\n          if (options.parser === "lwc") {\n            const interpolationRegex = /^{.*}$/s;\n            if (interpolationRegex.test(options.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {\n              return [node.rawName, "=", node.value];\n            }\n          }\n          const embeddedAttributeValueDoc = printEmbeddedAttributeValue(node, (code, opts) => textToDoc(code, Object.assign({\n            __isInHtmlAttribute: true,\n            __embeddedInHtml: true\n          }, opts), {\n            stripTrailingHardline: true\n          }), options);\n          if (embeddedAttributeValueDoc) {\n            return [node.rawName, \'="\', group(mapDoc(embeddedAttributeValueDoc, (doc2) => typeof doc2 === "string" ? doc2.replace(/"/g, "&quot;") : doc2)), \'"\'];\n          }\n          break;\n        }\n        case "front-matter":\n          return printFrontMatter(node, textToDoc);\n      }\n    }\n    module2.exports = embed;\n  }\n});\nvar require_children = __commonJS2({\n  "src/language-html/print/children.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        breakParent,\n        group,\n        ifBreak,\n        line,\n        softline,\n        hardline\n      },\n      utils: {\n        replaceTextEndOfLine\n      }\n    } = require("./doc.js");\n    var {\n      locStart,\n      locEnd\n    } = require_loc6();\n    var {\n      forceBreakChildren,\n      forceNextEmptyLine,\n      isTextLikeNode,\n      hasPrettierIgnore,\n      preferHardlineAsLeadingSpaces\n    } = require_utils11();\n    var {\n      printOpeningTagPrefix,\n      needsToBorrowNextOpeningTagStartMarker,\n      printOpeningTagStartMarker,\n      needsToBorrowPrevClosingTagEndMarker,\n      printClosingTagEndMarker,\n      printClosingTagSuffix,\n      needsToBorrowParentClosingTagStartMarker\n    } = require_tag();\n    function printChild(childPath, options, print) {\n      const child = childPath.getValue();\n      if (hasPrettierIgnore(child)) {\n        return [printOpeningTagPrefix(child, options), ...replaceTextEndOfLine(options.originalText.slice(locStart(child) + (child.prev && needsToBorrowNextOpeningTagStartMarker(child.prev) ? printOpeningTagStartMarker(child).length : 0), locEnd(child) - (child.next && needsToBorrowPrevClosingTagEndMarker(child.next) ? printClosingTagEndMarker(child, options).length : 0))), printClosingTagSuffix(child, options)];\n      }\n      return print();\n    }\n    function printBetweenLine(prevNode, nextNode) {\n      return isTextLikeNode(prevNode) && isTextLikeNode(nextNode) ? prevNode.isTrailingSpaceSensitive ? prevNode.hasTrailingSpaces ? preferHardlineAsLeadingSpaces(nextNode) ? hardline : line : "" : preferHardlineAsLeadingSpaces(nextNode) ? hardline : softline : needsToBorrowNextOpeningTagStartMarker(prevNode) && (hasPrettierIgnore(nextNode) || nextNode.firstChild || nextNode.isSelfClosing || nextNode.type === "element" && nextNode.attrs.length > 0) || prevNode.type === "element" && prevNode.isSelfClosing && needsToBorrowPrevClosingTagEndMarker(nextNode) ? "" : !nextNode.isLeadingSpaceSensitive || preferHardlineAsLeadingSpaces(nextNode) || needsToBorrowPrevClosingTagEndMarker(nextNode) && prevNode.lastChild && needsToBorrowParentClosingTagStartMarker(prevNode.lastChild) && prevNode.lastChild.lastChild && needsToBorrowParentClosingTagStartMarker(prevNode.lastChild.lastChild) ? hardline : nextNode.hasLeadingSpaces ? line : softline;\n    }\n    function printChildren(path, options, print) {\n      const node = path.getValue();\n      if (forceBreakChildren(node)) {\n        return [breakParent, ...path.map((childPath) => {\n          const childNode = childPath.getValue();\n          const prevBetweenLine = !childNode.prev ? "" : printBetweenLine(childNode.prev, childNode);\n          return [!prevBetweenLine ? "" : [prevBetweenLine, forceNextEmptyLine(childNode.prev) ? hardline : ""], printChild(childPath, options, print)];\n        }, "children")];\n      }\n      const groupIds = node.children.map(() => Symbol(""));\n      return path.map((childPath, childIndex) => {\n        const childNode = childPath.getValue();\n        if (isTextLikeNode(childNode)) {\n          if (childNode.prev && isTextLikeNode(childNode.prev)) {\n            const prevBetweenLine2 = printBetweenLine(childNode.prev, childNode);\n            if (prevBetweenLine2) {\n              if (forceNextEmptyLine(childNode.prev)) {\n                return [hardline, hardline, printChild(childPath, options, print)];\n              }\n              return [prevBetweenLine2, printChild(childPath, options, print)];\n            }\n          }\n          return printChild(childPath, options, print);\n        }\n        const prevParts = [];\n        const leadingParts = [];\n        const trailingParts = [];\n        const nextParts = [];\n        const prevBetweenLine = childNode.prev ? printBetweenLine(childNode.prev, childNode) : "";\n        const nextBetweenLine = childNode.next ? printBetweenLine(childNode, childNode.next) : "";\n        if (prevBetweenLine) {\n          if (forceNextEmptyLine(childNode.prev)) {\n            prevParts.push(hardline, hardline);\n          } else if (prevBetweenLine === hardline) {\n            prevParts.push(hardline);\n          } else {\n            if (isTextLikeNode(childNode.prev)) {\n              leadingParts.push(prevBetweenLine);\n            } else {\n              leadingParts.push(ifBreak("", softline, {\n                groupId: groupIds[childIndex - 1]\n              }));\n            }\n          }\n        }\n        if (nextBetweenLine) {\n          if (forceNextEmptyLine(childNode)) {\n            if (isTextLikeNode(childNode.next)) {\n              nextParts.push(hardline, hardline);\n            }\n          } else if (nextBetweenLine === hardline) {\n            if (isTextLikeNode(childNode.next)) {\n              nextParts.push(hardline);\n            }\n          } else {\n            trailingParts.push(nextBetweenLine);\n          }\n        }\n        return [...prevParts, group([...leadingParts, group([printChild(childPath, options, print), ...trailingParts], {\n          id: groupIds[childIndex]\n        })]), ...nextParts];\n      }, "children");\n    }\n    module2.exports = {\n      printChildren\n    };\n  }\n});\nvar require_element = __commonJS2({\n  "src/language-html/print/element.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        breakParent,\n        dedentToRoot,\n        group,\n        ifBreak,\n        indentIfBreak,\n        indent,\n        line,\n        softline\n      },\n      utils: {\n        replaceTextEndOfLine\n      }\n    } = require("./doc.js");\n    var getNodeContent = require_get_node_content();\n    var {\n      shouldPreserveContent,\n      isScriptLikeTag,\n      isVueCustomBlock,\n      countParents,\n      forceBreakContent\n    } = require_utils11();\n    var {\n      printOpeningTagPrefix,\n      printOpeningTag,\n      printClosingTagSuffix,\n      printClosingTag,\n      needsToBorrowPrevClosingTagEndMarker,\n      needsToBorrowLastChildClosingTagEndMarker\n    } = require_tag();\n    var {\n      printChildren\n    } = require_children();\n    function printElement(path, options, print) {\n      const node = path.getValue();\n      if (shouldPreserveContent(node, options)) {\n        return [printOpeningTagPrefix(node, options), group(printOpeningTag(path, options, print)), ...replaceTextEndOfLine(getNodeContent(node, options)), ...printClosingTag(node, options), printClosingTagSuffix(node, options)];\n      }\n      const shouldHugContent = node.children.length === 1 && node.firstChild.type === "interpolation" && node.firstChild.isLeadingSpaceSensitive && !node.firstChild.hasLeadingSpaces && node.lastChild.isTrailingSpaceSensitive && !node.lastChild.hasTrailingSpaces;\n      const attrGroupId = Symbol("element-attr-group-id");\n      const printTag = (doc2) => group([group(printOpeningTag(path, options, print), {\n        id: attrGroupId\n      }), doc2, printClosingTag(node, options)]);\n      const printChildrenDoc = (childrenDoc) => {\n        if (shouldHugContent) {\n          return indentIfBreak(childrenDoc, {\n            groupId: attrGroupId\n          });\n        }\n        if ((isScriptLikeTag(node) || isVueCustomBlock(node, options)) && node.parent.type === "root" && options.parser === "vue" && !options.vueIndentScriptAndStyle) {\n          return childrenDoc;\n        }\n        return indent(childrenDoc);\n      };\n      const printLineBeforeChildren = () => {\n        if (shouldHugContent) {\n          return ifBreak(softline, "", {\n            groupId: attrGroupId\n          });\n        }\n        if (node.firstChild.hasLeadingSpaces && node.firstChild.isLeadingSpaceSensitive) {\n          return line;\n        }\n        if (node.firstChild.type === "text" && node.isWhitespaceSensitive && node.isIndentationSensitive) {\n          return dedentToRoot(softline);\n        }\n        return softline;\n      };\n      const printLineAfterChildren = () => {\n        const needsToBorrow = node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : needsToBorrowLastChildClosingTagEndMarker(node.parent);\n        if (needsToBorrow) {\n          if (node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive) {\n            return " ";\n          }\n          return "";\n        }\n        if (shouldHugContent) {\n          return ifBreak(softline, "", {\n            groupId: attrGroupId\n          });\n        }\n        if (node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive) {\n          return line;\n        }\n        if ((node.lastChild.type === "comment" || node.lastChild.type === "text" && node.isWhitespaceSensitive && node.isIndentationSensitive) && new RegExp(`\\\\n[\\\\t ]{${options.tabWidth * countParents(path, (node2) => node2.parent && node2.parent.type !== "root")}}$`).test(node.lastChild.value)) {\n          return "";\n        }\n        return softline;\n      };\n      if (node.children.length === 0) {\n        return printTag(node.hasDanglingSpaces && node.isDanglingSpaceSensitive ? line : "");\n      }\n      return printTag([forceBreakContent(node) ? breakParent : "", printChildrenDoc([printLineBeforeChildren(), printChildren(path, options, print)]), printLineAfterChildren()]);\n    }\n    module2.exports = {\n      printElement\n    };\n  }\n});\nvar require_printer_html = __commonJS2({\n  "src/language-html/printer-html.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        fill,\n        group,\n        hardline,\n        literalline\n      },\n      utils: {\n        cleanDoc,\n        getDocParts,\n        isConcat,\n        replaceTextEndOfLine\n      }\n    } = require("./doc.js");\n    var clean = require_clean5();\n    var {\n      countChars,\n      unescapeQuoteEntities,\n      getTextValueParts\n    } = require_utils11();\n    var preprocess = require_print_preprocess3();\n    var {\n      insertPragma\n    } = require_pragma5();\n    var {\n      locStart,\n      locEnd\n    } = require_loc6();\n    var embed = require_embed4();\n    var {\n      printClosingTagSuffix,\n      printClosingTagEnd,\n      printOpeningTagPrefix,\n      printOpeningTagStart\n    } = require_tag();\n    var {\n      printElement\n    } = require_element();\n    var {\n      printChildren\n    } = require_children();\n    function genericPrint(path, options, print) {\n      const node = path.getValue();\n      switch (node.type) {\n        case "front-matter":\n          return replaceTextEndOfLine(node.raw);\n        case "root":\n          if (options.__onHtmlRoot) {\n            options.__onHtmlRoot(node);\n          }\n          return [group(printChildren(path, options, print)), hardline];\n        case "element":\n        case "ieConditionalComment": {\n          return printElement(path, options, print);\n        }\n        case "ieConditionalStartComment":\n        case "ieConditionalEndComment":\n          return [printOpeningTagStart(node), printClosingTagEnd(node)];\n        case "interpolation":\n          return [printOpeningTagStart(node, options), ...path.map(print, "children"), printClosingTagEnd(node, options)];\n        case "text": {\n          if (node.parent.type === "interpolation") {\n            const trailingNewlineRegex = /\\n[^\\S\\n]*$/;\n            const hasTrailingNewline = trailingNewlineRegex.test(node.value);\n            const value = hasTrailingNewline ? node.value.replace(trailingNewlineRegex, "") : node.value;\n            return [...replaceTextEndOfLine(value), hasTrailingNewline ? hardline : ""];\n          }\n          const printed = cleanDoc([printOpeningTagPrefix(node, options), ...getTextValueParts(node), printClosingTagSuffix(node, options)]);\n          if (isConcat(printed) || printed.type === "fill") {\n            return fill(getDocParts(printed));\n          }\n          return printed;\n        }\n        case "docType":\n          return [group([printOpeningTagStart(node, options), " ", node.value.replace(/^html\\b/i, "html").replace(/\\s+/g, " ")]), printClosingTagEnd(node, options)];\n        case "comment": {\n          return [printOpeningTagPrefix(node, options), ...replaceTextEndOfLine(options.originalText.slice(locStart(node), locEnd(node)), literalline), printClosingTagSuffix(node, options)];\n        }\n        case "attribute": {\n          if (node.value === null) {\n            return node.rawName;\n          }\n          const value = unescapeQuoteEntities(node.value);\n          const singleQuoteCount = countChars(value, "\'");\n          const doubleQuoteCount = countChars(value, \'"\');\n          const quote = singleQuoteCount < doubleQuoteCount ? "\'" : \'"\';\n          return [node.rawName, "=", quote, ...replaceTextEndOfLine(quote === \'"\' ? value.replace(/"/g, "&quot;") : value.replace(/\'/g, "&apos;")), quote];\n        }\n        default:\n          throw new Error(`Unexpected node type ${node.type}`);\n      }\n    }\n    module2.exports = {\n      preprocess,\n      print: genericPrint,\n      insertPragma,\n      massageAstNode: clean,\n      embed\n    };\n  }\n});\nvar require_options6 = __commonJS2({\n  "src/language-html/options.js"(exports2, module2) {\n    "use strict";\n    var commonOptions = require_common_options();\n    var CATEGORY_HTML = "HTML";\n    module2.exports = {\n      bracketSameLine: commonOptions.bracketSameLine,\n      htmlWhitespaceSensitivity: {\n        since: "1.15.0",\n        category: CATEGORY_HTML,\n        type: "choice",\n        default: "css",\n        description: "How to handle whitespaces in HTML.",\n        choices: [{\n          value: "css",\n          description: "Respect the default value of CSS display property."\n        }, {\n          value: "strict",\n          description: "Whitespaces are considered sensitive."\n        }, {\n          value: "ignore",\n          description: "Whitespaces are considered insensitive."\n        }]\n      },\n      singleAttributePerLine: commonOptions.singleAttributePerLine,\n      vueIndentScriptAndStyle: {\n        since: "1.19.0",\n        category: CATEGORY_HTML,\n        type: "boolean",\n        default: false,\n        description: "Indent script and style tags in Vue files."\n      }\n    };\n  }\n});\nvar require_parsers6 = __commonJS2({\n  "src/language-html/parsers.js"(exports2, module2) {\n    "use strict";\n    module2.exports = {\n      get html() {\n        return require("./parser-html.js").parsers.html;\n      },\n      get vue() {\n        return require("./parser-html.js").parsers.vue;\n      },\n      get angular() {\n        return require("./parser-html.js").parsers.angular;\n      },\n      get lwc() {\n        return require("./parser-html.js").parsers.lwc;\n      }\n    };\n  }\n});\nvar require_HTML = __commonJS2({\n  "node_modules/linguist-languages/data/HTML.json"(exports2, module2) {\n    module2.exports = {\n      name: "HTML",\n      type: "markup",\n      tmScope: "text.html.basic",\n      aceMode: "html",\n      codemirrorMode: "htmlmixed",\n      codemirrorMimeType: "text/html",\n      color: "#e34c26",\n      aliases: ["xhtml"],\n      extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"],\n      languageId: 146\n    };\n  }\n});\nvar require_Vue = __commonJS2({\n  "node_modules/linguist-languages/data/Vue.json"(exports2, module2) {\n    module2.exports = {\n      name: "Vue",\n      type: "markup",\n      color: "#41b883",\n      extensions: [".vue"],\n      tmScope: "text.html.vue",\n      aceMode: "html",\n      languageId: 391\n    };\n  }\n});\nvar require_language_html = __commonJS2({\n  "src/language-html/index.js"(exports2, module2) {\n    "use strict";\n    var createLanguage = require_create_language();\n    var printer = require_printer_html();\n    var options = require_options6();\n    var parsers = require_parsers6();\n    var languages = [createLanguage(require_HTML(), () => ({\n      name: "Angular",\n      since: "1.15.0",\n      parsers: ["angular"],\n      vscodeLanguageIds: ["html"],\n      extensions: [".component.html"],\n      filenames: []\n    })), createLanguage(require_HTML(), (data) => ({\n      since: "1.15.0",\n      parsers: ["html"],\n      vscodeLanguageIds: ["html"],\n      extensions: [...data.extensions, ".mjml"]\n    })), createLanguage(require_HTML(), () => ({\n      name: "Lightning Web Components",\n      since: "1.17.0",\n      parsers: ["lwc"],\n      vscodeLanguageIds: ["html"],\n      extensions: [],\n      filenames: []\n    })), createLanguage(require_Vue(), () => ({\n      since: "1.10.0",\n      parsers: ["vue"],\n      vscodeLanguageIds: ["vue"]\n    }))];\n    var printers = {\n      html: printer\n    };\n    module2.exports = {\n      languages,\n      printers,\n      options,\n      parsers\n    };\n  }\n});\nvar require_pragma6 = __commonJS2({\n  "src/language-yaml/pragma.js"(exports2, module2) {\n    "use strict";\n    function isPragma(text) {\n      return /^\\s*@(?:prettier|format)\\s*$/.test(text);\n    }\n    function hasPragma(text) {\n      return /^\\s*#[^\\S\\n]*@(?:prettier|format)\\s*?(?:\\n|$)/.test(text);\n    }\n    function insertPragma(text) {\n      return `# @format\n\n${text}`;\n    }\n    module2.exports = {\n      isPragma,\n      hasPragma,\n      insertPragma\n    };\n  }\n});\nvar require_loc7 = __commonJS2({\n  "src/language-yaml/loc.js"(exports2, module2) {\n    "use strict";\n    function locStart(node) {\n      return node.position.start.offset;\n    }\n    function locEnd(node) {\n      return node.position.end.offset;\n    }\n    module2.exports = {\n      locStart,\n      locEnd\n    };\n  }\n});\nvar require_embed5 = __commonJS2({\n  "src/language-yaml/embed.js"(exports2, module2) {\n    "use strict";\n    function embed(path, print, textToDoc, options) {\n      const node = path.getValue();\n      if (node.type === "root" && options.filepath && /(?:[/\\\\]|^)\\.(?:prettier|stylelint|lintstaged)rc$/.test(options.filepath)) {\n        return textToDoc(options.originalText, Object.assign(Object.assign({}, options), {}, {\n          parser: "json"\n        }));\n      }\n    }\n    module2.exports = embed;\n  }\n});\nvar require_utils12 = __commonJS2({\n  "src/language-yaml/utils.js"(exports2, module2) {\n    "use strict";\n    var {\n      getLast,\n      isNonEmptyArray\n    } = require_util();\n    function getAncestorCount(path, filter) {\n      let counter = 0;\n      const pathStackLength = path.stack.length - 1;\n      for (let i = 0; i < pathStackLength; i++) {\n        const value = path.stack[i];\n        if (isNode(value) && filter(value)) {\n          counter++;\n        }\n      }\n      return counter;\n    }\n    function isNode(value, types) {\n      return value && typeof value.type === "string" && (!types || types.includes(value.type));\n    }\n    function mapNode(node, callback, parent) {\n      return callback("children" in node ? Object.assign(Object.assign({}, node), {}, {\n        children: node.children.map((childNode) => mapNode(childNode, callback, node))\n      }) : node, parent);\n    }\n    function defineShortcut(x, key, getter) {\n      Object.defineProperty(x, key, {\n        get: getter,\n        enumerable: false\n      });\n    }\n    function isNextLineEmpty(node, text) {\n      let newlineCount = 0;\n      const textLength = text.length;\n      for (let i = node.position.end.offset - 1; i < textLength; i++) {\n        const char = text[i];\n        if (char === "\\n") {\n          newlineCount++;\n        }\n        if (newlineCount === 1 && /\\S/.test(char)) {\n          return false;\n        }\n        if (newlineCount === 2) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function isLastDescendantNode(path) {\n      const node = path.getValue();\n      switch (node.type) {\n        case "tag":\n        case "anchor":\n        case "comment":\n          return false;\n      }\n      const pathStackLength = path.stack.length;\n      for (let i = 1; i < pathStackLength; i++) {\n        const item = path.stack[i];\n        const parentItem = path.stack[i - 1];\n        if (Array.isArray(parentItem) && typeof item === "number" && item !== parentItem.length - 1) {\n          return false;\n        }\n      }\n      return true;\n    }\n    function getLastDescendantNode(node) {\n      return isNonEmptyArray(node.children) ? getLastDescendantNode(getLast(node.children)) : node;\n    }\n    function isPrettierIgnore(comment) {\n      return comment.value.trim() === "prettier-ignore";\n    }\n    function hasPrettierIgnore(path) {\n      const node = path.getValue();\n      if (node.type === "documentBody") {\n        const document2 = path.getParentNode();\n        return hasEndComments(document2.head) && isPrettierIgnore(getLast(document2.head.endComments));\n      }\n      return hasLeadingComments(node) && isPrettierIgnore(getLast(node.leadingComments));\n    }\n    function isEmptyNode(node) {\n      return !isNonEmptyArray(node.children) && !hasComments(node);\n    }\n    function hasComments(node) {\n      return hasLeadingComments(node) || hasMiddleComments(node) || hasIndicatorComment(node) || hasTrailingComment(node) || hasEndComments(node);\n    }\n    function hasLeadingComments(node) {\n      return isNonEmptyArray(node === null || node === void 0 ? void 0 : node.leadingComments);\n    }\n    function hasMiddleComments(node) {\n      return isNonEmptyArray(node === null || node === void 0 ? void 0 : node.middleComments);\n    }\n    function hasIndicatorComment(node) {\n      return node === null || node === void 0 ? void 0 : node.indicatorComment;\n    }\n    function hasTrailingComment(node) {\n      return node === null || node === void 0 ? void 0 : node.trailingComment;\n    }\n    function hasEndComments(node) {\n      return isNonEmptyArray(node === null || node === void 0 ? void 0 : node.endComments);\n    }\n    function splitWithSingleSpace(text) {\n      const parts = [];\n      let lastPart;\n      for (const part of text.split(/( +)/)) {\n        if (part !== " ") {\n          if (lastPart === " ") {\n            parts.push(part);\n          } else {\n            parts.push((parts.pop() || "") + part);\n          }\n        } else if (lastPart === void 0) {\n          parts.unshift("");\n        }\n        lastPart = part;\n      }\n      if (lastPart === " ") {\n        parts.push((parts.pop() || "") + " ");\n      }\n      if (parts[0] === "") {\n        parts.shift();\n        parts.unshift(" " + (parts.shift() || ""));\n      }\n      return parts;\n    }\n    function getFlowScalarLineContents(nodeType, content, options) {\n      const rawLineContents = content.split("\\n").map((lineContent, index, lineContents) => index === 0 && index === lineContents.length - 1 ? lineContent : index !== 0 && index !== lineContents.length - 1 ? lineContent.trim() : index === 0 ? lineContent.trimEnd() : lineContent.trimStart());\n      if (options.proseWrap === "preserve") {\n        return rawLineContents.map((lineContent) => lineContent.length === 0 ? [] : [lineContent]);\n      }\n      return rawLineContents.map((lineContent) => lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)).reduce((reduced, lineContentWords, index) => index !== 0 && rawLineContents[index - 1].length > 0 && lineContentWords.length > 0 && !(nodeType === "quoteDouble" && getLast(getLast(reduced)).endsWith("\\\\")) ? [...reduced.slice(0, -1), [...getLast(reduced), ...lineContentWords]] : [...reduced, lineContentWords], []).map((lineContentWords) => options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords);\n    }\n    function getBlockValueLineContents(node, {\n      parentIndent,\n      isLastDescendant,\n      options\n    }) {\n      const content = node.position.start.line === node.position.end.line ? "" : options.originalText.slice(node.position.start.offset, node.position.end.offset).match(/^[^\\n]*\\n(.*)$/s)[1];\n      let leadingSpaceCount;\n      if (node.indent === null) {\n        const matches = content.match(/^(?<leadingSpace> *)[^\\n\\r ]/m);\n        leadingSpaceCount = matches ? matches.groups.leadingSpace.length : Number.POSITIVE_INFINITY;\n      } else {\n        leadingSpaceCount = node.indent - 1 + parentIndent;\n      }\n      const rawLineContents = content.split("\\n").map((lineContent) => lineContent.slice(leadingSpaceCount));\n      if (options.proseWrap === "preserve" || node.type === "blockLiteral") {\n        return removeUnnecessaryTrailingNewlines(rawLineContents.map((lineContent) => lineContent.length === 0 ? [] : [lineContent]));\n      }\n      return removeUnnecessaryTrailingNewlines(rawLineContents.map((lineContent) => lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)).reduce((reduced, lineContentWords, index) => index !== 0 && rawLineContents[index - 1].length > 0 && lineContentWords.length > 0 && !/^\\s/.test(lineContentWords[0]) && !/^\\s|\\s$/.test(getLast(reduced)) ? [...reduced.slice(0, -1), [...getLast(reduced), ...lineContentWords]] : [...reduced, lineContentWords], []).map((lineContentWords) => lineContentWords.reduce((reduced, word) => reduced.length > 0 && /\\s$/.test(getLast(reduced)) ? [...reduced.slice(0, -1), getLast(reduced) + " " + word] : [...reduced, word], [])).map((lineContentWords) => options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords));\n      function removeUnnecessaryTrailingNewlines(lineContents) {\n        if (node.chomping === "keep") {\n          return getLast(lineContents).length === 0 ? lineContents.slice(0, -1) : lineContents;\n        }\n        let trailingNewlineCount = 0;\n        for (let i = lineContents.length - 1; i >= 0; i--) {\n          if (lineContents[i].length === 0) {\n            trailingNewlineCount++;\n          } else {\n            break;\n          }\n        }\n        return trailingNewlineCount === 0 ? lineContents : trailingNewlineCount >= 2 && !isLastDescendant ? lineContents.slice(0, -(trailingNewlineCount - 1)) : lineContents.slice(0, -trailingNewlineCount);\n      }\n    }\n    function isInlineNode(node) {\n      if (!node) {\n        return true;\n      }\n      switch (node.type) {\n        case "plain":\n        case "quoteDouble":\n        case "quoteSingle":\n        case "alias":\n        case "flowMapping":\n        case "flowSequence":\n          return true;\n        default:\n          return false;\n      }\n    }\n    module2.exports = {\n      getLast,\n      getAncestorCount,\n      isNode,\n      isEmptyNode,\n      isInlineNode,\n      mapNode,\n      defineShortcut,\n      isNextLineEmpty,\n      isLastDescendantNode,\n      getBlockValueLineContents,\n      getFlowScalarLineContents,\n      getLastDescendantNode,\n      hasPrettierIgnore,\n      hasLeadingComments,\n      hasMiddleComments,\n      hasIndicatorComment,\n      hasTrailingComment,\n      hasEndComments\n    };\n  }\n});\nvar require_print_preprocess4 = __commonJS2({\n  "src/language-yaml/print-preprocess.js"(exports2, module2) {\n    "use strict";\n    var {\n      defineShortcut,\n      mapNode\n    } = require_utils12();\n    function preprocess(ast) {\n      return mapNode(ast, defineShortcuts);\n    }\n    function defineShortcuts(node) {\n      switch (node.type) {\n        case "document":\n          defineShortcut(node, "head", () => node.children[0]);\n          defineShortcut(node, "body", () => node.children[1]);\n          break;\n        case "documentBody":\n        case "sequenceItem":\n        case "flowSequenceItem":\n        case "mappingKey":\n        case "mappingValue":\n          defineShortcut(node, "content", () => node.children[0]);\n          break;\n        case "mappingItem":\n        case "flowMappingItem":\n          defineShortcut(node, "key", () => node.children[0]);\n          defineShortcut(node, "value", () => node.children[1]);\n          break;\n      }\n      return node;\n    }\n    module2.exports = preprocess;\n  }\n});\nvar require_misc2 = __commonJS2({\n  "src/language-yaml/print/misc.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        softline,\n        align\n      }\n    } = require("./doc.js");\n    var {\n      hasEndComments,\n      isNextLineEmpty,\n      isNode\n    } = require_utils12();\n    var printedEmptyLineCache = /* @__PURE__ */ new WeakMap();\n    function printNextEmptyLine(path, originalText) {\n      const node = path.getValue();\n      const root = path.stack[0];\n      let isNextEmptyLinePrintedSet;\n      if (printedEmptyLineCache.has(root)) {\n        isNextEmptyLinePrintedSet = printedEmptyLineCache.get(root);\n      } else {\n        isNextEmptyLinePrintedSet = /* @__PURE__ */ new Set();\n        printedEmptyLineCache.set(root, isNextEmptyLinePrintedSet);\n      }\n      if (!isNextEmptyLinePrintedSet.has(node.position.end.line)) {\n        isNextEmptyLinePrintedSet.add(node.position.end.line);\n        if (isNextLineEmpty(node, originalText) && !shouldPrintEndComments(path.getParentNode())) {\n          return softline;\n        }\n      }\n      return "";\n    }\n    function shouldPrintEndComments(node) {\n      return hasEndComments(node) && !isNode(node, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);\n    }\n    function alignWithSpaces(width, doc2) {\n      return align(" ".repeat(width), doc2);\n    }\n    module2.exports = {\n      alignWithSpaces,\n      shouldPrintEndComments,\n      printNextEmptyLine\n    };\n  }\n});\nvar require_flow_mapping_sequence = __commonJS2({\n  "src/language-yaml/print/flow-mapping-sequence.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        ifBreak,\n        line,\n        softline,\n        hardline,\n        join\n      }\n    } = require("./doc.js");\n    var {\n      isEmptyNode,\n      getLast,\n      hasEndComments\n    } = require_utils12();\n    var {\n      printNextEmptyLine,\n      alignWithSpaces\n    } = require_misc2();\n    function printFlowMapping(path, print, options) {\n      const node = path.getValue();\n      const isMapping = node.type === "flowMapping";\n      const openMarker = isMapping ? "{" : "[";\n      const closeMarker = isMapping ? "}" : "]";\n      let bracketSpacing = softline;\n      if (isMapping && node.children.length > 0 && options.bracketSpacing) {\n        bracketSpacing = line;\n      }\n      const lastItem = getLast(node.children);\n      const isLastItemEmptyMappingItem = lastItem && lastItem.type === "flowMappingItem" && isEmptyNode(lastItem.key) && isEmptyNode(lastItem.value);\n      return [openMarker, alignWithSpaces(options.tabWidth, [bracketSpacing, printChildren(path, print, options), options.trailingComma === "none" ? "" : ifBreak(","), hasEndComments(node) ? [hardline, join(hardline, path.map(print, "endComments"))] : ""]), isLastItemEmptyMappingItem ? "" : bracketSpacing, closeMarker];\n    }\n    function printChildren(path, print, options) {\n      const node = path.getValue();\n      const parts = path.map((childPath, index) => [print(), index === node.children.length - 1 ? "" : [",", line, node.children[index].position.start.line !== node.children[index + 1].position.start.line ? printNextEmptyLine(childPath, options.originalText) : ""]], "children");\n      return parts;\n    }\n    module2.exports = {\n      printFlowMapping,\n      printFlowSequence: printFlowMapping\n    };\n  }\n});\nvar require_mapping_item = __commonJS2({\n  "src/language-yaml/print/mapping-item.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        conditionalGroup,\n        group,\n        hardline,\n        ifBreak,\n        join,\n        line\n      }\n    } = require("./doc.js");\n    var {\n      hasLeadingComments,\n      hasMiddleComments,\n      hasTrailingComment,\n      hasEndComments,\n      isNode,\n      isEmptyNode,\n      isInlineNode\n    } = require_utils12();\n    var {\n      alignWithSpaces\n    } = require_misc2();\n    function printMappingItem(node, parentNode, path, print, options) {\n      const {\n        key,\n        value\n      } = node;\n      const isEmptyMappingKey = isEmptyNode(key);\n      const isEmptyMappingValue = isEmptyNode(value);\n      if (isEmptyMappingKey && isEmptyMappingValue) {\n        return ": ";\n      }\n      const printedKey = print("key");\n      const spaceBeforeColon = needsSpaceInFrontOfMappingValue(node) ? " " : "";\n      if (isEmptyMappingValue) {\n        if (node.type === "flowMappingItem" && parentNode.type === "flowMapping") {\n          return printedKey;\n        }\n        if (node.type === "mappingItem" && isAbsolutelyPrintedAsSingleLineNode(key.content, options) && !hasTrailingComment(key.content) && (!parentNode.tag || parentNode.tag.value !== "tag:yaml.org,2002:set")) {\n          return [printedKey, spaceBeforeColon, ":"];\n        }\n        return ["? ", alignWithSpaces(2, printedKey)];\n      }\n      const printedValue = print("value");\n      if (isEmptyMappingKey) {\n        return [": ", alignWithSpaces(2, printedValue)];\n      }\n      if (hasLeadingComments(value) || !isInlineNode(key.content)) {\n        return ["? ", alignWithSpaces(2, printedKey), hardline, join("", path.map(print, "value", "leadingComments").map((comment) => [comment, hardline])), ": ", alignWithSpaces(2, printedValue)];\n      }\n      if (isSingleLineNode(key.content) && !hasLeadingComments(key.content) && !hasMiddleComments(key.content) && !hasTrailingComment(key.content) && !hasEndComments(key) && !hasLeadingComments(value.content) && !hasMiddleComments(value.content) && !hasEndComments(value) && isAbsolutelyPrintedAsSingleLineNode(value.content, options)) {\n        return [printedKey, spaceBeforeColon, ": ", printedValue];\n      }\n      const groupId = Symbol("mappingKey");\n      const groupedKey = group([ifBreak("? "), group(alignWithSpaces(2, printedKey), {\n        id: groupId\n      })]);\n      const explicitMappingValue = [hardline, ": ", alignWithSpaces(2, printedValue)];\n      const implicitMappingValueParts = [spaceBeforeColon, ":"];\n      if (hasLeadingComments(value.content) || hasEndComments(value) && value.content && !isNode(value.content, ["mapping", "sequence"]) || parentNode.type === "mapping" && hasTrailingComment(key.content) && isInlineNode(value.content) || isNode(value.content, ["mapping", "sequence"]) && value.content.tag === null && value.content.anchor === null) {\n        implicitMappingValueParts.push(hardline);\n      } else if (value.content) {\n        implicitMappingValueParts.push(line);\n      }\n      implicitMappingValueParts.push(printedValue);\n      const implicitMappingValue = alignWithSpaces(options.tabWidth, implicitMappingValueParts);\n      if (isAbsolutelyPrintedAsSingleLineNode(key.content, options) && !hasLeadingComments(key.content) && !hasMiddleComments(key.content) && !hasEndComments(key)) {\n        return conditionalGroup([[printedKey, implicitMappingValue]]);\n      }\n      return conditionalGroup([[groupedKey, ifBreak(explicitMappingValue, implicitMappingValue, {\n        groupId\n      })]]);\n    }\n    function isAbsolutelyPrintedAsSingleLineNode(node, options) {\n      if (!node) {\n        return true;\n      }\n      switch (node.type) {\n        case "plain":\n        case "quoteSingle":\n        case "quoteDouble":\n          break;\n        case "alias":\n          return true;\n        default:\n          return false;\n      }\n      if (options.proseWrap === "preserve") {\n        return node.position.start.line === node.position.end.line;\n      }\n      if (/\\\\$/m.test(options.originalText.slice(node.position.start.offset, node.position.end.offset))) {\n        return false;\n      }\n      switch (options.proseWrap) {\n        case "never":\n          return !node.value.includes("\\n");\n        case "always":\n          return !/[\\n ]/.test(node.value);\n        default:\n          return false;\n      }\n    }\n    function needsSpaceInFrontOfMappingValue(node) {\n      return node.key.content && node.key.content.type === "alias";\n    }\n    function isSingleLineNode(node) {\n      if (!node) {\n        return true;\n      }\n      switch (node.type) {\n        case "plain":\n        case "quoteDouble":\n        case "quoteSingle":\n          return node.position.start.line === node.position.end.line;\n        case "alias":\n          return true;\n        default:\n          return false;\n      }\n    }\n    module2.exports = printMappingItem;\n  }\n});\nvar require_block2 = __commonJS2({\n  "src/language-yaml/print/block.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        dedent,\n        dedentToRoot,\n        fill,\n        hardline,\n        join,\n        line,\n        literalline,\n        markAsRoot\n      },\n      utils: {\n        getDocParts\n      }\n    } = require("./doc.js");\n    var {\n      getAncestorCount,\n      getBlockValueLineContents,\n      hasIndicatorComment,\n      isLastDescendantNode,\n      isNode\n    } = require_utils12();\n    var {\n      alignWithSpaces\n    } = require_misc2();\n    function printBlock(path, print, options) {\n      const node = path.getValue();\n      const parentIndent = getAncestorCount(path, (ancestorNode) => isNode(ancestorNode, ["sequence", "mapping"]));\n      const isLastDescendant = isLastDescendantNode(path);\n      const parts = [node.type === "blockFolded" ? ">" : "|"];\n      if (node.indent !== null) {\n        parts.push(node.indent.toString());\n      }\n      if (node.chomping !== "clip") {\n        parts.push(node.chomping === "keep" ? "+" : "-");\n      }\n      if (hasIndicatorComment(node)) {\n        parts.push(" ", print("indicatorComment"));\n      }\n      const lineContents = getBlockValueLineContents(node, {\n        parentIndent,\n        isLastDescendant,\n        options\n      });\n      const contentsParts = [];\n      for (const [index, lineWords] of lineContents.entries()) {\n        if (index === 0) {\n          contentsParts.push(hardline);\n        }\n        contentsParts.push(fill(getDocParts(join(line, lineWords))));\n        if (index !== lineContents.length - 1) {\n          contentsParts.push(lineWords.length === 0 ? hardline : markAsRoot(literalline));\n        } else if (node.chomping === "keep" && isLastDescendant) {\n          contentsParts.push(dedentToRoot(lineWords.length === 0 ? hardline : literalline));\n        }\n      }\n      if (node.indent === null) {\n        parts.push(dedent(alignWithSpaces(options.tabWidth, contentsParts)));\n      } else {\n        parts.push(dedentToRoot(alignWithSpaces(node.indent - 1 + parentIndent, contentsParts)));\n      }\n      return parts;\n    }\n    module2.exports = printBlock;\n  }\n});\nvar require_printer_yaml = __commonJS2({\n  "src/language-yaml/printer-yaml.js"(exports2, module2) {\n    "use strict";\n    var {\n      builders: {\n        breakParent,\n        fill,\n        group,\n        hardline,\n        join,\n        line,\n        lineSuffix,\n        literalline\n      },\n      utils: {\n        getDocParts,\n        replaceTextEndOfLine\n      }\n    } = require("./doc.js");\n    var {\n      isPreviousLineEmpty\n    } = require_util();\n    var {\n      insertPragma,\n      isPragma\n    } = require_pragma6();\n    var {\n      locStart\n    } = require_loc7();\n    var embed = require_embed5();\n    var {\n      getFlowScalarLineContents,\n      getLastDescendantNode,\n      hasLeadingComments,\n      hasMiddleComments,\n      hasTrailingComment,\n      hasEndComments,\n      hasPrettierIgnore,\n      isLastDescendantNode,\n      isNode,\n      isInlineNode\n    } = require_utils12();\n    var preprocess = require_print_preprocess4();\n    var {\n      alignWithSpaces,\n      printNextEmptyLine,\n      shouldPrintEndComments\n    } = require_misc2();\n    var {\n      printFlowMapping,\n      printFlowSequence\n    } = require_flow_mapping_sequence();\n    var printMappingItem = require_mapping_item();\n    var printBlock = require_block2();\n    function genericPrint(path, options, print) {\n      const node = path.getValue();\n      const parts = [];\n      if (node.type !== "mappingValue" && hasLeadingComments(node)) {\n        parts.push([join(hardline, path.map(print, "leadingComments")), hardline]);\n      }\n      const {\n        tag,\n        anchor\n      } = node;\n      if (tag) {\n        parts.push(print("tag"));\n      }\n      if (tag && anchor) {\n        parts.push(" ");\n      }\n      if (anchor) {\n        parts.push(print("anchor"));\n      }\n      let nextEmptyLine = "";\n      if (isNode(node, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !isLastDescendantNode(path)) {\n        nextEmptyLine = printNextEmptyLine(path, options.originalText);\n      }\n      if (tag || anchor) {\n        if (isNode(node, ["sequence", "mapping"]) && !hasMiddleComments(node)) {\n          parts.push(hardline);\n        } else {\n          parts.push(" ");\n        }\n      }\n      if (hasMiddleComments(node)) {\n        parts.push([node.middleComments.length === 1 ? "" : hardline, join(hardline, path.map(print, "middleComments")), hardline]);\n      }\n      const parentNode = path.getParentNode();\n      if (hasPrettierIgnore(path)) {\n        parts.push(replaceTextEndOfLine(options.originalText.slice(node.position.start.offset, node.position.end.offset).trimEnd(), literalline));\n      } else {\n        parts.push(group(printNode(node, parentNode, path, options, print)));\n      }\n      if (hasTrailingComment(node) && !isNode(node, ["document", "documentHead"])) {\n        parts.push(lineSuffix([node.type === "mappingValue" && !node.content ? "" : " ", parentNode.type === "mappingKey" && path.getParentNode(2).type === "mapping" && isInlineNode(node) ? "" : breakParent, print("trailingComment")]));\n      }\n      if (shouldPrintEndComments(node)) {\n        parts.push(alignWithSpaces(node.type === "sequenceItem" ? 2 : 0, [hardline, join(hardline, path.map((path2) => [isPreviousLineEmpty(options.originalText, path2.getValue(), locStart) ? hardline : "", print()], "endComments"))]));\n      }\n      parts.push(nextEmptyLine);\n      return parts;\n    }\n    function printNode(node, parentNode, path, options, print) {\n      switch (node.type) {\n        case "root": {\n          const {\n            children\n          } = node;\n          const parts = [];\n          path.each((childPath, index) => {\n            const document2 = children[index];\n            const nextDocument = children[index + 1];\n            if (index !== 0) {\n              parts.push(hardline);\n            }\n            parts.push(print());\n            if (shouldPrintDocumentEndMarker(document2, nextDocument)) {\n              parts.push(hardline, "...");\n              if (hasTrailingComment(document2)) {\n                parts.push(" ", print("trailingComment"));\n              }\n            } else if (nextDocument && !hasTrailingComment(nextDocument.head)) {\n              parts.push(hardline, "---");\n            }\n          }, "children");\n          const lastDescendantNode = getLastDescendantNode(node);\n          if (!isNode(lastDescendantNode, ["blockLiteral", "blockFolded"]) || lastDescendantNode.chomping !== "keep") {\n            parts.push(hardline);\n          }\n          return parts;\n        }\n        case "document": {\n          const nextDocument = parentNode.children[path.getName() + 1];\n          const parts = [];\n          if (shouldPrintDocumentHeadEndMarker(node, nextDocument, parentNode, options) === "head") {\n            if (node.head.children.length > 0 || node.head.endComments.length > 0) {\n              parts.push(print("head"));\n            }\n            if (hasTrailingComment(node.head)) {\n              parts.push(["---", " ", print(["head", "trailingComment"])]);\n            } else {\n              parts.push("---");\n            }\n          }\n          if (shouldPrintDocumentBody(node)) {\n            parts.push(print("body"));\n          }\n          return join(hardline, parts);\n        }\n        case "documentHead":\n          return join(hardline, [...path.map(print, "children"), ...path.map(print, "endComments")]);\n        case "documentBody": {\n          const {\n            children,\n            endComments\n          } = node;\n          let separator = "";\n          if (children.length > 0 && endComments.length > 0) {\n            const lastDescendantNode = getLastDescendantNode(node);\n            if (isNode(lastDescendantNode, ["blockFolded", "blockLiteral"])) {\n              if (lastDescendantNode.chomping !== "keep") {\n                separator = [hardline, hardline];\n              }\n            } else {\n              separator = hardline;\n            }\n          }\n          return [join(hardline, path.map(print, "children")), separator, join(hardline, path.map(print, "endComments"))];\n        }\n        case "directive":\n          return ["%", join(" ", [node.name, ...node.parameters])];\n        case "comment":\n          return ["#", node.value];\n        case "alias":\n          return ["*", node.value];\n        case "tag":\n          return options.originalText.slice(node.position.start.offset, node.position.end.offset);\n        case "anchor":\n          return ["&", node.value];\n        case "plain":\n          return printFlowScalarContent(node.type, options.originalText.slice(node.position.start.offset, node.position.end.offset), options);\n        case "quoteDouble":\n        case "quoteSingle": {\n          const singleQuote = "\'";\n          const doubleQuote = \'"\';\n          const raw = options.originalText.slice(node.position.start.offset + 1, node.position.end.offset - 1);\n          if (node.type === "quoteSingle" && raw.includes("\\\\") || node.type === "quoteDouble" && /\\\\[^"]/.test(raw)) {\n            const originalQuote = node.type === "quoteDouble" ? doubleQuote : singleQuote;\n            return [originalQuote, printFlowScalarContent(node.type, raw, options), originalQuote];\n          }\n          if (raw.includes(doubleQuote)) {\n            return [singleQuote, printFlowScalarContent(node.type, node.type === "quoteDouble" ? raw.replace(/\\\\"/g, doubleQuote).replace(/\'/g, singleQuote.repeat(2)) : raw, options), singleQuote];\n          }\n          if (raw.includes(singleQuote)) {\n            return [doubleQuote, printFlowScalarContent(node.type, node.type === "quoteSingle" ? raw.replace(/\'\'/g, singleQuote) : raw, options), doubleQuote];\n          }\n          const quote = options.singleQuote ? singleQuote : doubleQuote;\n          return [quote, printFlowScalarContent(node.type, raw, options), quote];\n        }\n        case "blockFolded":\n        case "blockLiteral": {\n          return printBlock(path, print, options);\n        }\n        case "mapping":\n        case "sequence":\n          return join(hardline, path.map(print, "children"));\n        case "sequenceItem":\n          return ["- ", alignWithSpaces(2, node.content ? print("content") : "")];\n        case "mappingKey":\n        case "mappingValue":\n          return !node.content ? "" : print("content");\n        case "mappingItem":\n        case "flowMappingItem": {\n          return printMappingItem(node, parentNode, path, print, options);\n        }\n        case "flowMapping":\n          return printFlowMapping(path, print, options);\n        case "flowSequence":\n          return printFlowSequence(path, print, options);\n        case "flowSequenceItem":\n          return print("content");\n        default:\n          throw new Error(`Unexpected node type ${node.type}`);\n      }\n    }\n    function shouldPrintDocumentBody(document2) {\n      return document2.body.children.length > 0 || hasEndComments(document2.body);\n    }\n    function shouldPrintDocumentEndMarker(document2, nextDocument) {\n      return hasTrailingComment(document2) || nextDocument && (nextDocument.head.children.length > 0 || hasEndComments(nextDocument.head));\n    }\n    function shouldPrintDocumentHeadEndMarker(document2, nextDocument, root, options) {\n      if (root.children[0] === document2 && /---(?:\\s|$)/.test(options.originalText.slice(locStart(document2), locStart(document2) + 4)) || document2.head.children.length > 0 || hasEndComments(document2.head) || hasTrailingComment(document2.head)) {\n        return "head";\n      }\n      if (shouldPrintDocumentEndMarker(document2, nextDocument)) {\n        return false;\n      }\n      return nextDocument ? "root" : false;\n    }\n    function printFlowScalarContent(nodeType, content, options) {\n      const lineContents = getFlowScalarLineContents(nodeType, content, options);\n      return join(hardline, lineContents.map((lineContentWords) => fill(getDocParts(join(line, lineContentWords)))));\n    }\n    function clean(node, newNode) {\n      if (isNode(newNode)) {\n        delete newNode.position;\n        switch (newNode.type) {\n          case "comment":\n            if (isPragma(newNode.value)) {\n              return null;\n            }\n            break;\n          case "quoteDouble":\n          case "quoteSingle":\n            newNode.type = "quote";\n            break;\n        }\n      }\n    }\n    module2.exports = {\n      preprocess,\n      embed,\n      print: genericPrint,\n      massageAstNode: clean,\n      insertPragma\n    };\n  }\n});\nvar require_options7 = __commonJS2({\n  "src/language-yaml/options.js"(exports2, module2) {\n    "use strict";\n    var commonOptions = require_common_options();\n    module2.exports = {\n      bracketSpacing: commonOptions.bracketSpacing,\n      singleQuote: commonOptions.singleQuote,\n      proseWrap: commonOptions.proseWrap\n    };\n  }\n});\nvar require_parsers7 = __commonJS2({\n  "src/language-yaml/parsers.js"(exports2, module2) {\n    "use strict";\n    module2.exports = {\n      get yaml() {\n        return require("./parser-yaml.js").parsers.yaml;\n      }\n    };\n  }\n});\nvar require_YAML = __commonJS2({\n  "node_modules/linguist-languages/data/YAML.json"(exports2, module2) {\n    module2.exports = {\n      name: "YAML",\n      type: "data",\n      color: "#cb171e",\n      tmScope: "source.yaml",\n      aliases: ["yml"],\n      extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"],\n      filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"],\n      aceMode: "yaml",\n      codemirrorMode: "yaml",\n      codemirrorMimeType: "text/x-yaml",\n      languageId: 407\n    };\n  }\n});\nvar require_language_yaml = __commonJS2({\n  "src/language-yaml/index.js"(exports2, module2) {\n    "use strict";\n    var createLanguage = require_create_language();\n    var printer = require_printer_yaml();\n    var options = require_options7();\n    var parsers = require_parsers7();\n    var languages = [createLanguage(require_YAML(), (data) => ({\n      since: "1.14.0",\n      parsers: ["yaml"],\n      vscodeLanguageIds: ["yaml", "ansible", "home-assistant"],\n      filenames: [...data.filenames.filter((filename) => filename !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"]\n    }))];\n    module2.exports = {\n      languages,\n      printers: {\n        yaml: printer\n      },\n      options,\n      parsers\n    };\n  }\n});\nvar require_languages = __commonJS2({\n  "src/languages.js"(exports2, module2) {\n    "use strict";\n    module2.exports = [require_language_js(), require_language_css(), require_language_handlebars(), require_language_graphql(), require_language_markdown(), require_language_html(), require_language_yaml()];\n  }\n});\nvar require_load_plugins = __commonJS2({\n  "src/common/load-plugins.js"(exports2, module2) {\n    "use strict";\n    var fs = require("fs");\n    var path = require("path");\n    var fastGlob = require_out4();\n    var partition = require_partition();\n    var uniqByKey = require_uniq_by_key();\n    var internalPlugins = require_languages();\n    var {\n      default: mem2,\n      memClear: memClear2\n    } = (init_dist(), __toCommonJS(dist_exports));\n    var thirdParty = require("./third-party.js");\n    var resolve = require_resolve2();\n    var memoizedLoad = mem2(load, {\n      cacheKey: JSON.stringify\n    });\n    var memoizedSearch = mem2(findPluginsInNodeModules);\n    var clearCache = () => {\n      memClear2(memoizedLoad);\n      memClear2(memoizedSearch);\n    };\n    function load(plugins2, pluginSearchDirs) {\n      if (!plugins2) {\n        plugins2 = [];\n      }\n      if (pluginSearchDirs === false) {\n        pluginSearchDirs = [];\n      } else {\n        pluginSearchDirs = pluginSearchDirs || [];\n        if (pluginSearchDirs.length === 0) {\n          const autoLoadDir = thirdParty.findParentDir(__dirname, "node_modules");\n          if (autoLoadDir) {\n            pluginSearchDirs = [autoLoadDir];\n          }\n        }\n      }\n      const [externalPluginNames, externalPluginInstances] = partition(plugins2, (plugin) => typeof plugin === "string");\n      const externalManualLoadPluginInfos = externalPluginNames.map((pluginName) => {\n        let requirePath;\n        try {\n          requirePath = resolve(path.resolve(process.cwd(), pluginName));\n        } catch {\n          requirePath = resolve(pluginName, {\n            paths: [process.cwd()]\n          });\n        }\n        return {\n          name: pluginName,\n          requirePath\n        };\n      });\n      const externalAutoLoadPluginInfos = pluginSearchDirs.flatMap((pluginSearchDir) => {\n        const resolvedPluginSearchDir = path.resolve(process.cwd(), pluginSearchDir);\n        const nodeModulesDir = path.resolve(resolvedPluginSearchDir, "node_modules");\n        if (!isDirectory(nodeModulesDir) && !isDirectory(resolvedPluginSearchDir)) {\n          throw new Error(`${pluginSearchDir} does not exist or is not a directory`);\n        }\n        return memoizedSearch(nodeModulesDir).map((pluginName) => ({\n          name: pluginName,\n          requirePath: resolve(pluginName, {\n            paths: [resolvedPluginSearchDir]\n          })\n        }));\n      });\n      const externalPlugins = [...uniqByKey([...externalManualLoadPluginInfos, ...externalAutoLoadPluginInfos], "requirePath").map((externalPluginInfo) => Object.assign({\n        name: externalPluginInfo.name\n      }, require(externalPluginInfo.requirePath))), ...externalPluginInstances];\n      return [...internalPlugins, ...externalPlugins];\n    }\n    function findPluginsInNodeModules(nodeModulesDir) {\n      const pluginPackageJsonPaths = fastGlob.sync(["prettier-plugin-*/package.json", "@*/prettier-plugin-*/package.json", "@prettier/plugin-*/package.json"], {\n        cwd: nodeModulesDir\n      });\n      return pluginPackageJsonPaths.map(path.dirname);\n    }\n    function isDirectory(dir) {\n      try {\n        return fs.statSync(dir).isDirectory();\n      } catch {\n        return false;\n      }\n    }\n    module2.exports = {\n      loadPlugins: memoizedLoad,\n      clearCache\n    };\n  }\n});\nvar {\n  version\n} = require("./package.json");\nvar core = require_core();\nvar {\n  getSupportInfo\n} = require_support();\nvar getFileInfo = require_get_file_info();\nvar sharedUtil = require_util_shared();\nvar plugins = require_load_plugins();\nvar config = require_resolve_config();\nvar doc = require("./doc.js");\nfunction _withPlugins(fn, optsArgIdx = 1) {\n  return (...args) => {\n    const opts = args[optsArgIdx] || {};\n    args[optsArgIdx] = Object.assign(Object.assign({}, opts), {}, {\n      plugins: plugins.loadPlugins(opts.plugins, opts.pluginSearchDirs)\n    });\n    return fn(...args);\n  };\n}\nfunction withPlugins(fn, optsArgIdx) {\n  const resultingFn = _withPlugins(fn, optsArgIdx);\n  if (fn.sync) {\n    resultingFn.sync = _withPlugins(fn.sync, optsArgIdx);\n  }\n  return resultingFn;\n}\nvar formatWithCursor = withPlugins(core.formatWithCursor);\nmodule.exports = {\n  formatWithCursor,\n  format(text, opts) {\n    return formatWithCursor(text, opts).formatted;\n  },\n  check(text, opts) {\n    const {\n      formatted\n    } = formatWithCursor(text, opts);\n    return formatted === text;\n  },\n  doc,\n  resolveConfig: config.resolveConfig,\n  resolveConfigFile: config.resolveConfigFile,\n  clearConfigCache() {\n    config.clearCache();\n    plugins.clearCache();\n  },\n  getFileInfo: withPlugins(getFileInfo),\n  getSupportInfo: withPlugins(getSupportInfo, 0),\n  version,\n  util: sharedUtil,\n  __internal: {\n    errors: require_errors(),\n    coreOptions: require_core_options(),\n    createIgnorer: require_create_ignorer(),\n    optionsModule: require_options(),\n    optionsNormalizer: require_options_normalizer(),\n    utils: {\n      arrayify: require_arrayify(),\n      getLast: require_get_last(),\n      partition: require_partition(),\n      isNonEmptyArray: require_util().isNonEmptyArray\n    }\n  },\n  __debug: {\n    parse: withPlugins(core.parse),\n    formatAST: withPlugins(core.formatAST),\n    formatDoc: withPlugins(core.formatDoc),\n    printToDoc: withPlugins(core.printToDoc),\n    printDocToString: withPlugins(core.printDocToString)\n  }\n};\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/prettier@2.8.7/node_modules/prettier/index.js?')},4753:function(module,exports){eval('(function(e){if(typeof exports=="object"&&typeof module=="object")module.exports=e();else if(typeof define=="function"&&define.amd)define(e);else{var i=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof self<"u"?self:this||{};i.prettierPlugins=i.prettierPlugins||{},i.prettierPlugins.yaml=e()}})(function(){"use strict";var yt=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports);var ln=yt((un,at)=>{var Ye=Object.defineProperty,bt=Object.getOwnPropertyDescriptor,De=Object.getOwnPropertyNames,wt=Object.prototype.hasOwnProperty,Ke=(n,e)=>function(){return n&&(e=(0,n[De(n)[0]])(n=0)),e},D=(n,e)=>function(){return e||(0,n[De(n)[0]])((e={exports:{}}).exports,e),e.exports},St=(n,e)=>{for(var r in e)Ye(n,r,{get:e[r],enumerable:!0})},Et=(n,e,r,c)=>{if(e&&typeof e=="object"||typeof e=="function")for(let h of De(e))!wt.call(n,h)&&h!==r&&Ye(n,h,{get:()=>e[h],enumerable:!(c=bt(e,h))||c.enumerable});return n},se=n=>Et(Ye({},"__esModule",{value:!0}),n),Te,Y=Ke({"<define:process>"(){Te={env:{},argv:[]}}}),Mt=D({"src/common/parser-create-error.js"(n,e){"use strict";Y();function r(c,h){let d=new SyntaxError(c+" ("+h.start.line+":"+h.start.column+")");return d.loc=h,d}e.exports=r}}),Ot=D({"src/language-yaml/pragma.js"(n,e){"use strict";Y();function r(d){return/^\\s*@(?:prettier|format)\\s*$/.test(d)}function c(d){return/^\\s*#[^\\S\\n]*@(?:prettier|format)\\s*?(?:\\n|$)/.test(d)}function h(d){return`# @format\n\n${d}`}e.exports={isPragma:r,hasPragma:c,insertPragma:h}}}),Lt=D({"src/language-yaml/loc.js"(n,e){"use strict";Y();function r(h){return h.position.start.offset}function c(h){return h.position.end.offset}e.exports={locStart:r,locEnd:c}}}),te={};St(te,{__assign:()=>qe,__asyncDelegator:()=>Yt,__asyncGenerator:()=>jt,__asyncValues:()=>Dt,__await:()=>Ce,__awaiter:()=>Pt,__classPrivateFieldGet:()=>Qt,__classPrivateFieldSet:()=>Ut,__createBinding:()=>Rt,__decorate:()=>Tt,__exportStar:()=>qt,__extends:()=>At,__generator:()=>It,__importDefault:()=>Vt,__importStar:()=>Wt,__makeTemplateObject:()=>Ft,__metadata:()=>kt,__param:()=>Ct,__read:()=>Je,__rest:()=>Nt,__spread:()=>$t,__spreadArrays:()=>Bt,__values:()=>je});function At(n,e){Re(n,e);function r(){this.constructor=n}n.prototype=e===null?Object.create(e):(r.prototype=e.prototype,new r)}function Nt(n,e){var r={};for(var c in n)Object.prototype.hasOwnProperty.call(n,c)&&e.indexOf(c)<0&&(r[c]=n[c]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var h=0,c=Object.getOwnPropertySymbols(n);h<c.length;h++)e.indexOf(c[h])<0&&Object.prototype.propertyIsEnumerable.call(n,c[h])&&(r[c[h]]=n[c[h]]);return r}function Tt(n,e,r,c){var h=arguments.length,d=h<3?e:c===null?c=Object.getOwnPropertyDescriptor(e,r):c,y;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")d=Reflect.decorate(n,e,r,c);else for(var E=n.length-1;E>=0;E--)(y=n[E])&&(d=(h<3?y(d):h>3?y(e,r,d):y(e,r))||d);return h>3&&d&&Object.defineProperty(e,r,d),d}function Ct(n,e){return function(r,c){e(r,c,n)}}function kt(n,e){if(typeof Reflect=="object"&&typeof Reflect.metadata=="function")return Reflect.metadata(n,e)}function Pt(n,e,r,c){function h(d){return d instanceof r?d:new r(function(y){y(d)})}return new(r||(r=Promise))(function(d,y){function E(M){try{S(c.next(M))}catch(T){y(T)}}function I(M){try{S(c.throw(M))}catch(T){y(T)}}function S(M){M.done?d(M.value):h(M.value).then(E,I)}S((c=c.apply(n,e||[])).next())})}function It(n,e){var r={label:0,sent:function(){if(d[0]&1)throw d[1];return d[1]},trys:[],ops:[]},c,h,d,y;return y={next:E(0),throw:E(1),return:E(2)},typeof Symbol=="function"&&(y[Symbol.iterator]=function(){return this}),y;function E(S){return function(M){return I([S,M])}}function I(S){if(c)throw new TypeError("Generator is already executing.");for(;r;)try{if(c=1,h&&(d=S[0]&2?h.return:S[0]?h.throw||((d=h.return)&&d.call(h),0):h.next)&&!(d=d.call(h,S[1])).done)return d;switch(h=0,d&&(S=[S[0]&2,d.value]),S[0]){case 0:case 1:d=S;break;case 4:return r.label++,{value:S[1],done:!1};case 5:r.label++,h=S[1],S=[0];continue;case 7:S=r.ops.pop(),r.trys.pop();continue;default:if(d=r.trys,!(d=d.length>0&&d[d.length-1])&&(S[0]===6||S[0]===2)){r=0;continue}if(S[0]===3&&(!d||S[1]>d[0]&&S[1]<d[3])){r.label=S[1];break}if(S[0]===6&&r.label<d[1]){r.label=d[1],d=S;break}if(d&&r.label<d[2]){r.label=d[2],r.ops.push(S);break}d[2]&&r.ops.pop(),r.trys.pop();continue}S=e.call(n,r)}catch(M){S=[6,M],h=0}finally{c=d=0}if(S[0]&5)throw S[1];return{value:S[0]?S[1]:void 0,done:!0}}}function Rt(n,e,r,c){c===void 0&&(c=r),n[c]=e[r]}function qt(n,e){for(var r in n)r!=="default"&&!e.hasOwnProperty(r)&&(e[r]=n[r])}function je(n){var e=typeof Symbol=="function"&&Symbol.iterator,r=e&&n[e],c=0;if(r)return r.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&c>=n.length&&(n=void 0),{value:n&&n[c++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}function Je(n,e){var r=typeof Symbol=="function"&&n[Symbol.iterator];if(!r)return n;var c=r.call(n),h,d=[],y;try{for(;(e===void 0||e-- >0)&&!(h=c.next()).done;)d.push(h.value)}catch(E){y={error:E}}finally{try{h&&!h.done&&(r=c.return)&&r.call(c)}finally{if(y)throw y.error}}return d}function $t(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(Je(arguments[e]));return n}function Bt(){for(var n=0,e=0,r=arguments.length;e<r;e++)n+=arguments[e].length;for(var c=Array(n),h=0,e=0;e<r;e++)for(var d=arguments[e],y=0,E=d.length;y<E;y++,h++)c[h]=d[y];return c}function Ce(n){return this instanceof Ce?(this.v=n,this):new Ce(n)}function jt(n,e,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var c=r.apply(n,e||[]),h,d=[];return h={},y("next"),y("throw"),y("return"),h[Symbol.asyncIterator]=function(){return this},h;function y(P){c[P]&&(h[P]=function(C){return new Promise(function(q,R){d.push([P,C,q,R])>1||E(P,C)})})}function E(P,C){try{I(c[P](C))}catch(q){T(d[0][3],q)}}function I(P){P.value instanceof Ce?Promise.resolve(P.value.v).then(S,M):T(d[0][2],P)}function S(P){E("next",P)}function M(P){E("throw",P)}function T(P,C){P(C),d.shift(),d.length&&E(d[0][0],d[0][1])}}function Yt(n){var e,r;return e={},c("next"),c("throw",function(h){throw h}),c("return"),e[Symbol.iterator]=function(){return this},e;function c(h,d){e[h]=n[h]?function(y){return(r=!r)?{value:Ce(n[h](y)),done:h==="return"}:d?d(y):y}:d}}function Dt(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e=n[Symbol.asyncIterator],r;return e?e.call(n):(n=typeof je=="function"?je(n):n[Symbol.iterator](),r={},c("next"),c("throw"),c("return"),r[Symbol.asyncIterator]=function(){return this},r);function c(d){r[d]=n[d]&&function(y){return new Promise(function(E,I){y=n[d](y),h(E,I,y.done,y.value)})}}function h(d,y,E,I){Promise.resolve(I).then(function(S){d({value:S,done:E})},y)}}function Ft(n,e){return Object.defineProperty?Object.defineProperty(n,"raw",{value:e}):n.raw=e,n}function Wt(n){if(n&&n.__esModule)return n;var e={};if(n!=null)for(var r in n)Object.hasOwnProperty.call(n,r)&&(e[r]=n[r]);return e.default=n,e}function Vt(n){return n&&n.__esModule?n:{default:n}}function Qt(n,e){if(!e.has(n))throw new TypeError("attempted to get private field on non-instance");return e.get(n)}function Ut(n,e,r){if(!e.has(n))throw new TypeError("attempted to set private field on non-instance");return e.set(n,r),r}var Re,qe,ie=Ke({"node_modules/tslib/tslib.es6.js"(){Y(),Re=function(n,e){return Re=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(r,c){r.__proto__=c}||function(r,c){for(var h in c)c.hasOwnProperty(h)&&(r[h]=c[h])},Re(n,e)},qe=function(){return qe=Object.assign||function(e){for(var r,c=1,h=arguments.length;c<h;c++){r=arguments[c];for(var d in r)Object.prototype.hasOwnProperty.call(r,d)&&(e[d]=r[d])}return e},qe.apply(this,arguments)}}}),Kt=D({"node_modules/yaml-unist-parser/node_modules/lines-and-columns/build/index.js"(n){"use strict";Y(),n.__esModule=!0,n.LinesAndColumns=void 0;var e=`\n`,r="\\r",c=function(){function h(d){this.string=d;for(var y=[0],E=0;E<d.length;)switch(d[E]){case e:E+=e.length,y.push(E);break;case r:E+=r.length,d[E]===e&&(E+=e.length),y.push(E);break;default:E++;break}this.offsets=y}return h.prototype.locationForIndex=function(d){if(d<0||d>this.string.length)return null;for(var y=0,E=this.offsets;E[y+1]<=d;)y++;var I=d-E[y];return{line:y,column:I}},h.prototype.indexForLocation=function(d){var y=d.line,E=d.column;return y<0||y>=this.offsets.length||E<0||E>this.lengthOfLine(y)?null:this.offsets[y]+E},h.prototype.lengthOfLine=function(d){var y=this.offsets[d],E=d===this.offsets.length-1?this.string.length:this.offsets[d+1];return E-y},h}();n.LinesAndColumns=c,n.default=c}}),Jt=D({"node_modules/yaml-unist-parser/lib/utils/define-parents.js"(n){"use strict";Y(),n.__esModule=!0;function e(r,c){c===void 0&&(c=null),"children"in r&&r.children.forEach(function(h){return e(h,r)}),"anchor"in r&&r.anchor&&e(r.anchor,r),"tag"in r&&r.tag&&e(r.tag,r),"leadingComments"in r&&r.leadingComments.forEach(function(h){return e(h,r)}),"middleComments"in r&&r.middleComments.forEach(function(h){return e(h,r)}),"indicatorComment"in r&&r.indicatorComment&&e(r.indicatorComment,r),"trailingComment"in r&&r.trailingComment&&e(r.trailingComment,r),"endComments"in r&&r.endComments.forEach(function(h){return e(h,r)}),Object.defineProperty(r,"_parent",{value:c,enumerable:!1})}n.defineParents=e}}),Fe=D({"node_modules/yaml-unist-parser/lib/utils/get-point-text.js"(n){"use strict";Y(),n.__esModule=!0;function e(r){return r.line+":"+r.column}n.getPointText=e}}),xt=D({"node_modules/yaml-unist-parser/lib/attach.js"(n){"use strict";Y(),n.__esModule=!0;var e=Jt(),r=Fe();function c(S){e.defineParents(S);var M=h(S),T=S.children.slice();S.comments.sort(function(P,C){return P.position.start.offset-C.position.end.offset}).filter(function(P){return!P._parent}).forEach(function(P){for(;T.length>1&&P.position.start.line>T[0].position.end.line;)T.shift();y(P,M,T[0])})}n.attachComments=c;function h(S){for(var M=Array.from(new Array(S.position.end.line),function(){return{}}),T=0,P=S.comments;T<P.length;T++){var C=P[T];M[C.position.start.line-1].comment=C}return d(M,S),M}function d(S,M){if(M.position.start.offset!==M.position.end.offset){if("leadingComments"in M){var T=M.position.start,P=S[T.line-1].leadingAttachableNode;(!P||T.column<P.position.start.column)&&(S[T.line-1].leadingAttachableNode=M)}if("trailingComment"in M&&M.position.end.column>1&&M.type!=="document"&&M.type!=="documentHead"){var C=M.position.end,q=S[C.line-1].trailingAttachableNode;(!q||C.column>=q.position.end.column)&&(S[C.line-1].trailingAttachableNode=M)}if(M.type!=="root"&&M.type!=="document"&&M.type!=="documentHead"&&M.type!=="documentBody")for(var R=M.position,T=R.start,C=R.end,B=[C.line].concat(T.line===C.line?[]:T.line),U=0,f=B;U<f.length;U++){var i=f[U],t=S[i-1].trailingNode;(!t||C.column>=t.position.end.column)&&(S[i-1].trailingNode=M)}"children"in M&&M.children.forEach(function(s){d(S,s)})}}function y(S,M,T){var P=S.position.start.line,C=M[P-1].trailingAttachableNode;if(C){if(C.trailingComment)throw new Error("Unexpected multiple trailing comment at "+r.getPointText(S.position.start));e.defineParents(S,C),C.trailingComment=S;return}for(var q=P;q>=T.position.start.line;q--){var R=M[q-1].trailingNode,B=void 0;if(R)B=R;else if(q!==P&&M[q-1].comment)B=M[q-1].comment._parent;else continue;if((B.type==="sequence"||B.type==="mapping")&&(B=B.children[0]),B.type==="mappingItem"){var U=B.children,f=U[0],i=U[1];B=I(f)?f:i}for(;;){if(E(B,S)){e.defineParents(S,B),B.endComments.push(S);return}if(!B._parent)break;B=B._parent}break}for(var q=P+1;q<=T.position.end.line;q++){var t=M[q-1].leadingAttachableNode;if(t){e.defineParents(S,t),t.leadingComments.push(S);return}}var s=T.children[1];e.defineParents(S,s),s.endComments.push(S)}function E(S,M){if(S.position.start.offset<M.position.start.offset&&S.position.end.offset>M.position.end.offset)switch(S.type){case"flowMapping":case"flowSequence":return S.children.length===0||M.position.start.line>S.children[S.children.length-1].position.end.line}if(M.position.end.offset<S.position.end.offset)return!1;switch(S.type){case"sequenceItem":return M.position.start.column>S.position.start.column;case"mappingKey":case"mappingValue":return M.position.start.column>S._parent.position.start.column&&(S.children.length===0||S.children.length===1&&S.children[0].type!=="blockFolded"&&S.children[0].type!=="blockLiteral")&&(S.type==="mappingValue"||I(S));default:return!1}}function I(S){return S.position.start!==S.position.end&&(S.children.length===0||S.position.start.offset!==S.children[0].position.start.offset)}}}),me=D({"node_modules/yaml-unist-parser/lib/factories/node.js"(n){"use strict";Y(),n.__esModule=!0;function e(r,c){return{type:r,position:c}}n.createNode=e}}),Ht=D({"node_modules/yaml-unist-parser/lib/factories/root.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=me();function c(h,d,y){return e.__assign(e.__assign({},r.createNode("root",h)),{children:d,comments:y})}n.createRoot=c}}),Gt=D({"node_modules/yaml-unist-parser/lib/preprocess.js"(n){"use strict";Y(),n.__esModule=!0;function e(r){switch(r.type){case"DOCUMENT":for(var c=r.contents.length-1;c>=0;c--)r.contents[c].type==="BLANK_LINE"?r.contents.splice(c,1):e(r.contents[c]);for(var c=r.directives.length-1;c>=0;c--)r.directives[c].type==="BLANK_LINE"&&r.directives.splice(c,1);break;case"FLOW_MAP":case"FLOW_SEQ":case"MAP":case"SEQ":for(var c=r.items.length-1;c>=0;c--){var h=r.items[c];"char"in h||(h.type==="BLANK_LINE"?r.items.splice(c,1):e(h))}break;case"MAP_KEY":case"MAP_VALUE":case"SEQ_ITEM":r.node&&e(r.node);break;case"ALIAS":case"BLANK_LINE":case"BLOCK_FOLDED":case"BLOCK_LITERAL":case"COMMENT":case"DIRECTIVE":case"PLAIN":case"QUOTE_DOUBLE":case"QUOTE_SINGLE":break;default:throw new Error("Unexpected node type "+JSON.stringify(r.type))}}n.removeCstBlankLine=e}}),Oe=D({"node_modules/yaml-unist-parser/lib/factories/leading-comment-attachable.js"(n){"use strict";Y(),n.__esModule=!0;function e(){return{leadingComments:[]}}n.createLeadingCommentAttachable=e}}),$e=D({"node_modules/yaml-unist-parser/lib/factories/trailing-comment-attachable.js"(n){"use strict";Y(),n.__esModule=!0;function e(r){return r===void 0&&(r=null),{trailingComment:r}}n.createTrailingCommentAttachable=e}}),Se=D({"node_modules/yaml-unist-parser/lib/factories/comment-attachable.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Oe(),c=$e();function h(){return e.__assign(e.__assign({},r.createLeadingCommentAttachable()),c.createTrailingCommentAttachable())}n.createCommentAttachable=h}}),zt=D({"node_modules/yaml-unist-parser/lib/factories/alias.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Se(),c=me();function h(d,y,E){return e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode("alias",d)),r.createCommentAttachable()),y),{value:E})}n.createAlias=h}}),Zt=D({"node_modules/yaml-unist-parser/lib/transforms/alias.js"(n){"use strict";Y(),n.__esModule=!0;var e=zt();function r(c,h){var d=c.cstNode;return e.createAlias(h.transformRange({origStart:d.valueRange.origStart-1,origEnd:d.valueRange.origEnd}),h.transformContent(c),d.rawValue)}n.transformAlias=r}}),Xt=D({"node_modules/yaml-unist-parser/lib/factories/block-folded.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te));function r(c){return e.__assign(e.__assign({},c),{type:"blockFolded"})}n.createBlockFolded=r}}),er=D({"node_modules/yaml-unist-parser/lib/factories/block-value.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Oe(),c=me();function h(d,y,E,I,S,M){return e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode("blockValue",d)),r.createLeadingCommentAttachable()),y),{chomping:E,indent:I,value:S,indicatorComment:M})}n.createBlockValue=h}}),xe=D({"node_modules/yaml-unist-parser/lib/constants.js"(n){"use strict";Y(),n.__esModule=!0;var e;(function(r){r.Tag="!",r.Anchor="&",r.Comment="#"})(e=n.PropLeadingCharacter||(n.PropLeadingCharacter={}))}}),tr=D({"node_modules/yaml-unist-parser/lib/factories/anchor.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=me();function c(h,d){return e.__assign(e.__assign({},r.createNode("anchor",h)),{value:d})}n.createAnchor=c}}),We=D({"node_modules/yaml-unist-parser/lib/factories/comment.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=me();function c(h,d){return e.__assign(e.__assign({},r.createNode("comment",h)),{value:d})}n.createComment=c}}),rr=D({"node_modules/yaml-unist-parser/lib/factories/content.js"(n){"use strict";Y(),n.__esModule=!0;function e(r,c,h){return{anchor:c,tag:r,middleComments:h}}n.createContent=e}}),nr=D({"node_modules/yaml-unist-parser/lib/factories/tag.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=me();function c(h,d){return e.__assign(e.__assign({},r.createNode("tag",h)),{value:d})}n.createTag=c}}),He=D({"node_modules/yaml-unist-parser/lib/transforms/content.js"(n){"use strict";Y(),n.__esModule=!0;var e=xe(),r=tr(),c=We(),h=rr(),d=nr();function y(E,I,S){S===void 0&&(S=function(){return!1});for(var M=E.cstNode,T=[],P=null,C=null,q=null,R=0,B=M.props;R<B.length;R++){var U=B[R],f=I.text[U.origStart];switch(f){case e.PropLeadingCharacter.Tag:P=P||U,C=d.createTag(I.transformRange(U),E.tag);break;case e.PropLeadingCharacter.Anchor:P=P||U,q=r.createAnchor(I.transformRange(U),M.anchor);break;case e.PropLeadingCharacter.Comment:{var i=c.createComment(I.transformRange(U),I.text.slice(U.origStart+1,U.origEnd));I.comments.push(i),!S(i)&&P&&P.origEnd<=U.origStart&&U.origEnd<=M.valueRange.origStart&&T.push(i);break}default:throw new Error("Unexpected leading character "+JSON.stringify(f))}}return h.createContent(C,q,T)}n.transformContent=y}}),Ge=D({"node_modules/yaml-unist-parser/lib/transforms/block-value.js"(n){"use strict";Y(),n.__esModule=!0;var e=er(),r=Fe(),c=He(),h;(function(y){y.CLIP="clip",y.STRIP="strip",y.KEEP="keep"})(h||(h={}));function d(y,E){var I=y.cstNode,S=1,M=I.chomping==="CLIP"?0:1,T=I.header.origEnd-I.header.origStart,P=T-S-M!==0,C=E.transformRange({origStart:I.header.origStart,origEnd:I.valueRange.origEnd}),q=null,R=c.transformContent(y,E,function(B){var U=C.start.offset<B.position.start.offset&&B.position.end.offset<C.end.offset;if(!U)return!1;if(q)throw new Error("Unexpected multiple indicator comments at "+r.getPointText(B.position.start));return q=B,!0});return e.createBlockValue(C,R,h[I.chomping],P?I.blockIndent:null,I.strValue,q)}n.transformAstBlockValue=d}}),sr=D({"node_modules/yaml-unist-parser/lib/transforms/block-folded.js"(n){"use strict";Y(),n.__esModule=!0;var e=Xt(),r=Ge();function c(h,d){return e.createBlockFolded(r.transformAstBlockValue(h,d))}n.transformBlockFolded=c}}),ir=D({"node_modules/yaml-unist-parser/lib/factories/block-literal.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te));function r(c){return e.__assign(e.__assign({},c),{type:"blockLiteral"})}n.createBlockLiteral=r}}),ar=D({"node_modules/yaml-unist-parser/lib/transforms/block-literal.js"(n){"use strict";Y(),n.__esModule=!0;var e=ir(),r=Ge();function c(h,d){return e.createBlockLiteral(r.transformAstBlockValue(h,d))}n.transformBlockLiteral=c}}),or=D({"node_modules/yaml-unist-parser/lib/transforms/comment.js"(n){"use strict";Y(),n.__esModule=!0;var e=We();function r(c,h){return e.createComment(h.transformRange(c.range),c.comment)}n.transformComment=r}}),lr=D({"node_modules/yaml-unist-parser/lib/factories/directive.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Se(),c=me();function h(d,y,E){return e.__assign(e.__assign(e.__assign({},c.createNode("directive",d)),r.createCommentAttachable()),{name:y,parameters:E})}n.createDirective=h}}),Ve=D({"node_modules/yaml-unist-parser/lib/utils/extract-prop-comments.js"(n){"use strict";Y(),n.__esModule=!0;var e=xe(),r=We();function c(h,d){for(var y=0,E=h.props;y<E.length;y++){var I=E[y],S=d.text[I.origStart];switch(S){case e.PropLeadingCharacter.Comment:d.comments.push(r.createComment(d.transformRange(I),d.text.slice(I.origStart+1,I.origEnd)));break;default:throw new Error("Unexpected leading character "+JSON.stringify(S))}}}n.extractPropComments=c}}),cr=D({"node_modules/yaml-unist-parser/lib/transforms/directive.js"(n){"use strict";Y(),n.__esModule=!0;var e=lr(),r=Ve();function c(h,d){return r.extractPropComments(h,d),e.createDirective(d.transformRange(h.range),h.name,h.parameters)}n.transformDirective=c}}),ur=D({"node_modules/yaml-unist-parser/lib/factories/document.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=me(),c=$e();function h(d,y,E,I){return e.__assign(e.__assign(e.__assign({},r.createNode("document",d)),c.createTrailingCommentAttachable(I)),{children:[y,E]})}n.createDocument=h}}),Le=D({"node_modules/yaml-unist-parser/lib/factories/position.js"(n){"use strict";Y(),n.__esModule=!0;function e(c,h){return{start:c,end:h}}n.createPosition=e;function r(c){return{start:c,end:c}}n.createEmptyPosition=r}}),Ee=D({"node_modules/yaml-unist-parser/lib/factories/end-comment-attachable.js"(n){"use strict";Y(),n.__esModule=!0;function e(r){return r===void 0&&(r=[]),{endComments:r}}n.createEndCommentAttachable=e}}),fr=D({"node_modules/yaml-unist-parser/lib/factories/document-body.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Ee(),c=me();function h(d,y,E){return e.__assign(e.__assign(e.__assign({},c.createNode("documentBody",d)),r.createEndCommentAttachable(E)),{children:y?[y]:[]})}n.createDocumentBody=h}}),Ae=D({"node_modules/yaml-unist-parser/lib/utils/get-last.js"(n){"use strict";Y(),n.__esModule=!0;function e(r){return r[r.length-1]}n.getLast=e}}),ze=D({"node_modules/yaml-unist-parser/lib/utils/get-match-index.js"(n){"use strict";Y(),n.__esModule=!0;function e(r,c){var h=r.match(c);return h?h.index:-1}n.getMatchIndex=e}}),mr=D({"node_modules/yaml-unist-parser/lib/transforms/document-body.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=fr(),c=Ae(),h=ze(),d=Fe();function y(S,M,T){var P,C=S.cstNode,q=E(C,M,T),R=q.comments,B=q.endComments,U=q.documentTrailingComment,f=q.documentHeadTrailingComment,i=M.transformNode(S.contents),t=I(C,i,M),s=t.position,a=t.documentEndPoint;return(P=M.comments).push.apply(P,e.__spreadArrays(R,B)),{documentBody:r.createDocumentBody(s,i,B),documentEndPoint:a,documentTrailingComment:U,documentHeadTrailingComment:f}}n.transformDocumentBody=y;function E(S,M,T){for(var P=[],C=[],q=[],R=[],B=!1,U=S.contents.length-1;U>=0;U--){var f=S.contents[U];if(f.type==="COMMENT"){var i=M.transformNode(f);T&&T.line===i.position.start.line?R.unshift(i):B?P.unshift(i):i.position.start.offset>=S.valueRange.origEnd?q.unshift(i):P.unshift(i)}else B=!0}if(q.length>1)throw new Error("Unexpected multiple document trailing comments at "+d.getPointText(q[1].position.start));if(R.length>1)throw new Error("Unexpected multiple documentHead trailing comments at "+d.getPointText(R[1].position.start));return{comments:P,endComments:C,documentTrailingComment:c.getLast(q)||null,documentHeadTrailingComment:c.getLast(R)||null}}function I(S,M,T){var P=h.getMatchIndex(T.text.slice(S.valueRange.origEnd),/^\\.\\.\\./),C=P===-1?S.valueRange.origEnd:Math.max(0,S.valueRange.origEnd-1);T.text[C-1]==="\\r"&&C--;var q=T.transformRange({origStart:M!==null?M.position.start.offset:C,origEnd:C}),R=P===-1?q.end:T.transformOffset(S.valueRange.origEnd+3);return{position:q,documentEndPoint:R}}}}),dr=D({"node_modules/yaml-unist-parser/lib/factories/document-head.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Ee(),c=me(),h=$e();function d(y,E,I,S){return e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode("documentHead",y)),r.createEndCommentAttachable(I)),h.createTrailingCommentAttachable(S)),{children:E})}n.createDocumentHead=d}}),hr=D({"node_modules/yaml-unist-parser/lib/transforms/document-head.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=dr(),c=ze();function h(E,I){var S,M=E.cstNode,T=d(M,I),P=T.directives,C=T.comments,q=T.endComments,R=y(M,P,I),B=R.position,U=R.endMarkerPoint;(S=I.comments).push.apply(S,e.__spreadArrays(C,q));var f=function(i){return i&&I.comments.push(i),r.createDocumentHead(B,P,q,i)};return{createDocumentHeadWithTrailingComment:f,documentHeadEndMarkerPoint:U}}n.transformDocumentHead=h;function d(E,I){for(var S=[],M=[],T=[],P=!1,C=E.directives.length-1;C>=0;C--){var q=I.transformNode(E.directives[C]);q.type==="comment"?P?M.unshift(q):T.unshift(q):(P=!0,S.unshift(q))}return{directives:S,comments:M,endComments:T}}function y(E,I,S){var M=c.getMatchIndex(S.text.slice(0,E.valueRange.origStart),/---\\s*$/);M>0&&!/[\\r\\n]/.test(S.text[M-1])&&(M=-1);var T=M===-1?{origStart:E.valueRange.origStart,origEnd:E.valueRange.origStart}:{origStart:M,origEnd:M+3};return I.length!==0&&(T.origStart=I[0].position.start.offset),{position:S.transformRange(T),endMarkerPoint:M===-1?null:S.transformOffset(M)}}}}),gr=D({"node_modules/yaml-unist-parser/lib/transforms/document.js"(n){"use strict";Y(),n.__esModule=!0;var e=ur(),r=Le(),c=mr(),h=hr();function d(y,E){var I=h.transformDocumentHead(y,E),S=I.createDocumentHeadWithTrailingComment,M=I.documentHeadEndMarkerPoint,T=c.transformDocumentBody(y,E,M),P=T.documentBody,C=T.documentEndPoint,q=T.documentTrailingComment,R=T.documentHeadTrailingComment,B=S(R);return q&&E.comments.push(q),e.createDocument(r.createPosition(B.position.start,C),B,P,q)}n.transformDocument=d}}),Ze=D({"node_modules/yaml-unist-parser/lib/factories/flow-collection.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Se(),c=Ee(),h=me();function d(y,E,I){return e.__assign(e.__assign(e.__assign(e.__assign(e.__assign({},h.createNode("flowCollection",y)),r.createCommentAttachable()),c.createEndCommentAttachable()),E),{children:I})}n.createFlowCollection=d}}),pr=D({"node_modules/yaml-unist-parser/lib/factories/flow-mapping.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Ze();function c(h,d,y){return e.__assign(e.__assign({},r.createFlowCollection(h,d,y)),{type:"flowMapping"})}n.createFlowMapping=c}}),Xe=D({"node_modules/yaml-unist-parser/lib/factories/flow-mapping-item.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Oe(),c=me();function h(d,y,E){return e.__assign(e.__assign(e.__assign({},c.createNode("flowMappingItem",d)),r.createLeadingCommentAttachable()),{children:[y,E]})}n.createFlowMappingItem=h}}),Be=D({"node_modules/yaml-unist-parser/lib/utils/extract-comments.js"(n){"use strict";Y(),n.__esModule=!0;function e(r,c){for(var h=[],d=0,y=r;d<y.length;d++){var E=y[d];E&&"type"in E&&E.type==="COMMENT"?c.comments.push(c.transformNode(E)):h.push(E)}return h}n.extractComments=e}}),et=D({"node_modules/yaml-unist-parser/lib/utils/get-flow-map-item-additional-ranges.js"(n){"use strict";Y(),n.__esModule=!0;function e(r){var c=["?",":"].map(function(y){var E=r.find(function(I){return"char"in I&&I.char===y});return E?{origStart:E.origOffset,origEnd:E.origOffset+1}:null}),h=c[0],d=c[1];return{additionalKeyRange:h,additionalValueRange:d}}n.getFlowMapItemAdditionalRanges=e}}),tt=D({"node_modules/yaml-unist-parser/lib/utils/create-slicer.js"(n){"use strict";Y(),n.__esModule=!0;function e(r,c){var h=c;return function(d){return r.slice(h,h=d)}}n.createSlicer=e}}),rt=D({"node_modules/yaml-unist-parser/lib/utils/group-cst-flow-collection-items.js"(n){"use strict";Y(),n.__esModule=!0;var e=tt();function r(c){for(var h=[],d=e.createSlicer(c,1),y=!1,E=1;E<c.length-1;E++){var I=c[E];if("char"in I&&I.char===","){h.push(d(E)),d(E+1),y=!1;continue}y=!0}return y&&h.push(d(c.length-1)),h}n.groupCstFlowCollectionItems=r}}),_r=D({"node_modules/yaml-unist-parser/lib/factories/mapping-key.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Ee(),c=me(),h=$e();function d(y,E){return e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode("mappingKey",y)),h.createTrailingCommentAttachable()),r.createEndCommentAttachable()),{children:E?[E]:[]})}n.createMappingKey=d}}),vr=D({"node_modules/yaml-unist-parser/lib/factories/mapping-value.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Se(),c=Ee(),h=me();function d(y,E){return e.__assign(e.__assign(e.__assign(e.__assign({},h.createNode("mappingValue",y)),r.createCommentAttachable()),c.createEndCommentAttachable()),{children:E?[E]:[]})}n.createMappingValue=d}}),Qe=D({"node_modules/yaml-unist-parser/lib/transforms/pair.js"(n){"use strict";Y(),n.__esModule=!0;var e=_r(),r=vr(),c=Le();function h(d,y,E,I,S){var M=y.transformNode(d.key),T=y.transformNode(d.value),P=M||I?e.createMappingKey(y.transformRange({origStart:I?I.origStart:M.position.start.offset,origEnd:M?M.position.end.offset:I.origStart+1}),M):null,C=T||S?r.createMappingValue(y.transformRange({origStart:S?S.origStart:T.position.start.offset,origEnd:T?T.position.end.offset:S.origStart+1}),T):null;return E(c.createPosition(P?P.position.start:C.position.start,C?C.position.end:P.position.end),P||e.createMappingKey(c.createEmptyPosition(C.position.start),null),C||r.createMappingValue(c.createEmptyPosition(P.position.end),null))}n.transformAstPair=h}}),yr=D({"node_modules/yaml-unist-parser/lib/transforms/flow-map.js"(n){"use strict";Y(),n.__esModule=!0;var e=pr(),r=Xe(),c=Be(),h=et(),d=Ae(),y=rt(),E=Qe();function I(S,M){var T=c.extractComments(S.cstNode.items,M),P=y.groupCstFlowCollectionItems(T),C=S.items.map(function(B,U){var f=P[U],i=h.getFlowMapItemAdditionalRanges(f),t=i.additionalKeyRange,s=i.additionalValueRange;return E.transformAstPair(B,M,r.createFlowMappingItem,t,s)}),q=T[0],R=d.getLast(T);return e.createFlowMapping(M.transformRange({origStart:q.origOffset,origEnd:R.origOffset+1}),M.transformContent(S),C)}n.transformFlowMap=I}}),br=D({"node_modules/yaml-unist-parser/lib/factories/flow-sequence.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Ze();function c(h,d,y){return e.__assign(e.__assign({},r.createFlowCollection(h,d,y)),{type:"flowSequence"})}n.createFlowSequence=c}}),wr=D({"node_modules/yaml-unist-parser/lib/factories/flow-sequence-item.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=me();function c(h,d){return e.__assign(e.__assign({},r.createNode("flowSequenceItem",h)),{children:[d]})}n.createFlowSequenceItem=c}}),Sr=D({"node_modules/yaml-unist-parser/lib/transforms/flow-seq.js"(n){"use strict";Y(),n.__esModule=!0;var e=Xe(),r=br(),c=wr(),h=Le(),d=Be(),y=et(),E=Ae(),I=rt(),S=Qe();function M(T,P){var C=d.extractComments(T.cstNode.items,P),q=I.groupCstFlowCollectionItems(C),R=T.items.map(function(f,i){if(f.type!=="PAIR"){var t=P.transformNode(f);return c.createFlowSequenceItem(h.createPosition(t.position.start,t.position.end),t)}else{var s=q[i],a=y.getFlowMapItemAdditionalRanges(s),m=a.additionalKeyRange,g=a.additionalValueRange;return S.transformAstPair(f,P,e.createFlowMappingItem,m,g)}}),B=C[0],U=E.getLast(C);return r.createFlowSequence(P.transformRange({origStart:B.origOffset,origEnd:U.origOffset+1}),P.transformContent(T),R)}n.transformFlowSeq=M}}),Er=D({"node_modules/yaml-unist-parser/lib/factories/mapping.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Oe(),c=me();function h(d,y,E){return e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode("mapping",d)),r.createLeadingCommentAttachable()),y),{children:E})}n.createMapping=h}}),Mr=D({"node_modules/yaml-unist-parser/lib/factories/mapping-item.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Oe(),c=me();function h(d,y,E){return e.__assign(e.__assign(e.__assign({},c.createNode("mappingItem",d)),r.createLeadingCommentAttachable()),{children:[y,E]})}n.createMappingItem=h}}),Or=D({"node_modules/yaml-unist-parser/lib/transforms/map.js"(n){"use strict";Y(),n.__esModule=!0;var e=Er(),r=Mr(),c=Le(),h=tt(),d=Be(),y=Ve(),E=Ae(),I=Qe();function S(T,P){var C=T.cstNode;C.items.filter(function(U){return U.type==="MAP_KEY"||U.type==="MAP_VALUE"}).forEach(function(U){return y.extractPropComments(U,P)});var q=d.extractComments(C.items,P),R=M(q),B=T.items.map(function(U,f){var i=R[f],t=i[0].type==="MAP_VALUE"?[null,i[0].range]:[i[0].range,i.length===1?null:i[1].range],s=t[0],a=t[1];return I.transformAstPair(U,P,r.createMappingItem,s,a)});return e.createMapping(c.createPosition(B[0].position.start,E.getLast(B).position.end),P.transformContent(T),B)}n.transformMap=S;function M(T){for(var P=[],C=h.createSlicer(T,0),q=!1,R=0;R<T.length;R++){var B=T[R];if(B.type==="MAP_VALUE"){P.push(C(R+1)),q=!1;continue}q&&P.push(C(R)),q=!0}return q&&P.push(C(1/0)),P}}}),Lr=D({"node_modules/yaml-unist-parser/lib/factories/plain.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Se(),c=me();function h(d,y,E){return e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode("plain",d)),r.createCommentAttachable()),y),{value:E})}n.createPlain=h}}),Ar=D({"node_modules/yaml-unist-parser/lib/utils/find-last-char-index.js"(n){"use strict";Y(),n.__esModule=!0;function e(r,c,h){for(var d=c;d>=0;d--)if(h.test(r[d]))return d;return-1}n.findLastCharIndex=e}}),Nr=D({"node_modules/yaml-unist-parser/lib/transforms/plain.js"(n){"use strict";Y(),n.__esModule=!0;var e=Lr(),r=Ar();function c(h,d){var y=h.cstNode;return e.createPlain(d.transformRange({origStart:y.valueRange.origStart,origEnd:r.findLastCharIndex(d.text,y.valueRange.origEnd-1,/\\S/)+1}),d.transformContent(h),y.strValue)}n.transformPlain=c}}),Tr=D({"node_modules/yaml-unist-parser/lib/factories/quote-double.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te));function r(c){return e.__assign(e.__assign({},c),{type:"quoteDouble"})}n.createQuoteDouble=r}}),Cr=D({"node_modules/yaml-unist-parser/lib/factories/quote-value.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Se(),c=me();function h(d,y,E){return e.__assign(e.__assign(e.__assign(e.__assign({},c.createNode("quoteValue",d)),y),r.createCommentAttachable()),{value:E})}n.createQuoteValue=h}}),nt=D({"node_modules/yaml-unist-parser/lib/transforms/quote-value.js"(n){"use strict";Y(),n.__esModule=!0;var e=Cr();function r(c,h){var d=c.cstNode;return e.createQuoteValue(h.transformRange(d.valueRange),h.transformContent(c),d.strValue)}n.transformAstQuoteValue=r}}),kr=D({"node_modules/yaml-unist-parser/lib/transforms/quote-double.js"(n){"use strict";Y(),n.__esModule=!0;var e=Tr(),r=nt();function c(h,d){return e.createQuoteDouble(r.transformAstQuoteValue(h,d))}n.transformQuoteDouble=c}}),Pr=D({"node_modules/yaml-unist-parser/lib/factories/quote-single.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te));function r(c){return e.__assign(e.__assign({},c),{type:"quoteSingle"})}n.createQuoteSingle=r}}),Ir=D({"node_modules/yaml-unist-parser/lib/transforms/quote-single.js"(n){"use strict";Y(),n.__esModule=!0;var e=Pr(),r=nt();function c(h,d){return e.createQuoteSingle(r.transformAstQuoteValue(h,d))}n.transformQuoteSingle=c}}),Rr=D({"node_modules/yaml-unist-parser/lib/factories/sequence.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Ee(),c=Oe(),h=me();function d(y,E,I){return e.__assign(e.__assign(e.__assign(e.__assign(e.__assign({},h.createNode("sequence",y)),c.createLeadingCommentAttachable()),r.createEndCommentAttachable()),E),{children:I})}n.createSequence=d}}),qr=D({"node_modules/yaml-unist-parser/lib/factories/sequence-item.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te)),r=Se(),c=Ee(),h=me();function d(y,E){return e.__assign(e.__assign(e.__assign(e.__assign({},h.createNode("sequenceItem",y)),r.createCommentAttachable()),c.createEndCommentAttachable()),{children:E?[E]:[]})}n.createSequenceItem=d}}),$r=D({"node_modules/yaml-unist-parser/lib/transforms/seq.js"(n){"use strict";Y(),n.__esModule=!0;var e=Le(),r=Rr(),c=qr(),h=Be(),d=Ve(),y=Ae();function E(I,S){var M=h.extractComments(I.cstNode.items,S),T=M.map(function(P,C){d.extractPropComments(P,S);var q=S.transformNode(I.items[C]);return c.createSequenceItem(e.createPosition(S.transformOffset(P.valueRange.origStart),q===null?S.transformOffset(P.valueRange.origStart+1):q.position.end),q)});return r.createSequence(e.createPosition(T[0].position.start,y.getLast(T).position.end),S.transformContent(I),T)}n.transformSeq=E}}),Br=D({"node_modules/yaml-unist-parser/lib/transform.js"(n){"use strict";Y(),n.__esModule=!0;var e=Zt(),r=sr(),c=ar(),h=or(),d=cr(),y=gr(),E=yr(),I=Sr(),S=Or(),M=Nr(),T=kr(),P=Ir(),C=$r();function q(R,B){if(R===null||R.type===void 0&&R.value===null)return null;switch(R.type){case"ALIAS":return e.transformAlias(R,B);case"BLOCK_FOLDED":return r.transformBlockFolded(R,B);case"BLOCK_LITERAL":return c.transformBlockLiteral(R,B);case"COMMENT":return h.transformComment(R,B);case"DIRECTIVE":return d.transformDirective(R,B);case"DOCUMENT":return y.transformDocument(R,B);case"FLOW_MAP":return E.transformFlowMap(R,B);case"FLOW_SEQ":return I.transformFlowSeq(R,B);case"MAP":return S.transformMap(R,B);case"PLAIN":return M.transformPlain(R,B);case"QUOTE_DOUBLE":return T.transformQuoteDouble(R,B);case"QUOTE_SINGLE":return P.transformQuoteSingle(R,B);case"SEQ":return C.transformSeq(R,B);default:throw new Error("Unexpected node type "+R.type)}}n.transformNode=q}}),jr=D({"node_modules/yaml-unist-parser/lib/factories/error.js"(n){"use strict";Y(),n.__esModule=!0;function e(r,c,h){var d=new SyntaxError(r);return d.name="YAMLSyntaxError",d.source=c,d.position=h,d}n.createError=e}}),Yr=D({"node_modules/yaml-unist-parser/lib/transforms/error.js"(n){"use strict";Y(),n.__esModule=!0;var e=jr();function r(c,h){var d=c.source.range||c.source.valueRange;return e.createError(c.message,h.text,h.transformRange(d))}n.transformError=r}}),Dr=D({"node_modules/yaml-unist-parser/lib/factories/point.js"(n){"use strict";Y(),n.__esModule=!0;function e(r,c,h){return{offset:r,line:c,column:h}}n.createPoint=e}}),Fr=D({"node_modules/yaml-unist-parser/lib/transforms/offset.js"(n){"use strict";Y(),n.__esModule=!0;var e=Dr();function r(c,h){c<0?c=0:c>h.text.length&&(c=h.text.length);var d=h.locator.locationForIndex(c);return e.createPoint(c,d.line+1,d.column+1)}n.transformOffset=r}}),Wr=D({"node_modules/yaml-unist-parser/lib/transforms/range.js"(n){"use strict";Y(),n.__esModule=!0;var e=Le();function r(c,h){return e.createPosition(h.transformOffset(c.origStart),h.transformOffset(c.origEnd))}n.transformRange=r}}),Vr=D({"node_modules/yaml-unist-parser/lib/utils/add-orig-range.js"(n){"use strict";Y(),n.__esModule=!0;var e=!0;function r(y){if(!y.setOrigRanges()){var E=function(I){if(h(I))return I.origStart=I.start,I.origEnd=I.end,e;if(d(I))return I.origOffset=I.offset,e};y.forEach(function(I){return c(I,E)})}}n.addOrigRange=r;function c(y,E){if(!(!y||typeof y!="object")&&E(y)!==e)for(var I=0,S=Object.keys(y);I<S.length;I++){var M=S[I];if(!(M==="context"||M==="error")){var T=y[M];Array.isArray(T)?T.forEach(function(P){return c(P,E)}):c(T,E)}}}function h(y){return typeof y.start=="number"}function d(y){return typeof y.offset=="number"}}}),Qr=D({"node_modules/yaml-unist-parser/lib/utils/remove-fake-nodes.js"(n){"use strict";Y(),n.__esModule=!0;function e(r){if("children"in r){if(r.children.length===1){var c=r.children[0];if(c.type==="plain"&&c.tag===null&&c.anchor===null&&c.value==="")return r.children.splice(0,1),r}r.children.forEach(e)}return r}n.removeFakeNodes=e}}),Ur=D({"node_modules/yaml-unist-parser/lib/utils/create-updater.js"(n){"use strict";Y(),n.__esModule=!0;function e(r,c,h,d){var y=c(r);return function(E){d(y,E)&&h(r,y=E)}}n.createUpdater=e}}),Kr=D({"node_modules/yaml-unist-parser/lib/utils/update-positions.js"(n){"use strict";Y(),n.__esModule=!0;var e=Ur(),r=Ae();function c(M){if(!(M===null||!("children"in M))){var T=M.children;if(T.forEach(c),M.type==="document"){var P=M.children,C=P[0],q=P[1];C.position.start.offset===C.position.end.offset?C.position.start=C.position.end=q.position.start:q.position.start.offset===q.position.end.offset&&(q.position.start=q.position.end=C.position.end)}var R=e.createUpdater(M.position,h,d,I),B=e.createUpdater(M.position,y,E,S);"endComments"in M&&M.endComments.length!==0&&(R(M.endComments[0].position.start),B(r.getLast(M.endComments).position.end));var U=T.filter(function(t){return t!==null});if(U.length!==0){var f=U[0],i=r.getLast(U);R(f.position.start),B(i.position.end),"leadingComments"in f&&f.leadingComments.length!==0&&R(f.leadingComments[0].position.start),"tag"in f&&f.tag&&R(f.tag.position.start),"anchor"in f&&f.anchor&&R(f.anchor.position.start),"trailingComment"in i&&i.trailingComment&&B(i.trailingComment.position.end)}}}n.updatePositions=c;function h(M){return M.start}function d(M,T){M.start=T}function y(M){return M.end}function E(M,T){M.end=T}function I(M,T){return T.offset<M.offset}function S(M,T){return T.offset>M.offset}}}),Me=D({"node_modules/yaml/dist/PlainValue-ec8e588e.js"(n){"use strict";Y();var e={ANCHOR:"&",COMMENT:"#",TAG:"!",DIRECTIVES_END:"-",DOCUMENT_END:"."},r={ALIAS:"ALIAS",BLANK_LINE:"BLANK_LINE",BLOCK_FOLDED:"BLOCK_FOLDED",BLOCK_LITERAL:"BLOCK_LITERAL",COMMENT:"COMMENT",DIRECTIVE:"DIRECTIVE",DOCUMENT:"DOCUMENT",FLOW_MAP:"FLOW_MAP",FLOW_SEQ:"FLOW_SEQ",MAP:"MAP",MAP_KEY:"MAP_KEY",MAP_VALUE:"MAP_VALUE",PLAIN:"PLAIN",QUOTE_DOUBLE:"QUOTE_DOUBLE",QUOTE_SINGLE:"QUOTE_SINGLE",SEQ:"SEQ",SEQ_ITEM:"SEQ_ITEM"},c="tag:yaml.org,2002:",h={MAP:"tag:yaml.org,2002:map",SEQ:"tag:yaml.org,2002:seq",STR:"tag:yaml.org,2002:str"};function d(i){let t=[0],s=i.indexOf(`\n`);for(;s!==-1;)s+=1,t.push(s),s=i.indexOf(`\n`,s);return t}function y(i){let t,s;return typeof i=="string"?(t=d(i),s=i):(Array.isArray(i)&&(i=i[0]),i&&i.context&&(i.lineStarts||(i.lineStarts=d(i.context.src)),t=i.lineStarts,s=i.context.src)),{lineStarts:t,src:s}}function E(i,t){if(typeof i!="number"||i<0)return null;let{lineStarts:s,src:a}=y(t);if(!s||!a||i>a.length)return null;for(let g=0;g<s.length;++g){let u=s[g];if(i<u)return{line:g,col:i-s[g-1]+1};if(i===u)return{line:g+1,col:1}}let m=s.length;return{line:m,col:i-s[m-1]+1}}function I(i,t){let{lineStarts:s,src:a}=y(t);if(!s||!(i>=1)||i>s.length)return null;let m=s[i-1],g=s[i];for(;g&&g>m&&a[g-1]===`\n`;)--g;return a.slice(m,g)}function S(i,t){let{start:s,end:a}=i,m=arguments.length>2&&arguments[2]!==void 0?arguments[2]:80,g=I(s.line,t);if(!g)return null;let{col:u}=s;if(g.length>m)if(u<=m-10)g=g.substr(0,m-1)+"\\u2026";else{let K=Math.round(m/2);g.length>u+K&&(g=g.substr(0,u+K-1)+"\\u2026"),u-=g.length-m,g="\\u2026"+g.substr(1-m)}let p=1,L="";a&&(a.line===s.line&&u+(a.col-s.col)<=m+1?p=a.col-s.col:(p=Math.min(g.length+1,m)-u,L="\\u2026"));let k=u>1?" ".repeat(u-1):"",$="^".repeat(p);return`${g}\n${k}${$}${L}`}var M=class{static copy(i){return new M(i.start,i.end)}constructor(i,t){this.start=i,this.end=t||i}isEmpty(){return typeof this.start!="number"||!this.end||this.end<=this.start}setOrigRange(i,t){let{start:s,end:a}=this;if(i.length===0||a<=i[0])return this.origStart=s,this.origEnd=a,t;let m=t;for(;m<i.length&&!(i[m]>s);)++m;this.origStart=s+m;let g=m;for(;m<i.length&&!(i[m]>=a);)++m;return this.origEnd=a+m,g}},T=class{static addStringTerminator(i,t,s){if(s[s.length-1]===`\n`)return s;let a=T.endOfWhiteSpace(i,t);return a>=i.length||i[a]===`\n`?s+`\n`:s}static atDocumentBoundary(i,t,s){let a=i[t];if(!a)return!0;let m=i[t-1];if(m&&m!==`\n`)return!1;if(s){if(a!==s)return!1}else if(a!==e.DIRECTIVES_END&&a!==e.DOCUMENT_END)return!1;let g=i[t+1],u=i[t+2];if(g!==a||u!==a)return!1;let p=i[t+3];return!p||p===`\n`||p==="\t"||p===" "}static endOfIdentifier(i,t){let s=i[t],a=s==="<",m=a?[`\n`,"\t"," ",">"]:[`\n`,"\t"," ","[","]","{","}",","];for(;s&&m.indexOf(s)===-1;)s=i[t+=1];return a&&s===">"&&(t+=1),t}static endOfIndent(i,t){let s=i[t];for(;s===" ";)s=i[t+=1];return t}static endOfLine(i,t){let s=i[t];for(;s&&s!==`\n`;)s=i[t+=1];return t}static endOfWhiteSpace(i,t){let s=i[t];for(;s==="\t"||s===" ";)s=i[t+=1];return t}static startOfLine(i,t){let s=i[t-1];if(s===`\n`)return t;for(;s&&s!==`\n`;)s=i[t-=1];return t+1}static endOfBlockIndent(i,t,s){let a=T.endOfIndent(i,s);if(a>s+t)return a;{let m=T.endOfWhiteSpace(i,a),g=i[m];if(!g||g===`\n`)return m}return null}static atBlank(i,t,s){let a=i[t];return a===`\n`||a==="\t"||a===" "||s&&!a}static nextNodeIsIndented(i,t,s){return!i||t<0?!1:t>0?!0:s&&i==="-"}static normalizeOffset(i,t){let s=i[t];return s?s!==`\n`&&i[t-1]===`\n`?t-1:T.endOfWhiteSpace(i,t):t}static foldNewline(i,t,s){let a=0,m=!1,g="",u=i[t+1];for(;u===" "||u==="\t"||u===`\n`;){switch(u){case`\n`:a=0,t+=1,g+=`\n`;break;case"\t":a<=s&&(m=!0),t=T.endOfWhiteSpace(i,t+2)-1;break;case" ":a+=1,t+=1;break}u=i[t+1]}return g||(g=" "),u&&a<=s&&(m=!0),{fold:g,offset:t,error:m}}constructor(i,t,s){Object.defineProperty(this,"context",{value:s||null,writable:!0}),this.error=null,this.range=null,this.valueRange=null,this.props=t||[],this.type=i,this.value=null}getPropValue(i,t,s){if(!this.context)return null;let{src:a}=this.context,m=this.props[i];return m&&a[m.start]===t?a.slice(m.start+(s?1:0),m.end):null}get anchor(){for(let i=0;i<this.props.length;++i){let t=this.getPropValue(i,e.ANCHOR,!0);if(t!=null)return t}return null}get comment(){let i=[];for(let t=0;t<this.props.length;++t){let s=this.getPropValue(t,e.COMMENT,!0);s!=null&&i.push(s)}return i.length>0?i.join(`\n`):null}commentHasRequiredWhitespace(i){let{src:t}=this.context;if(this.header&&i===this.header.end||!this.valueRange)return!1;let{end:s}=this.valueRange;return i!==s||T.atBlank(t,s-1)}get hasComment(){if(this.context){let{src:i}=this.context;for(let t=0;t<this.props.length;++t)if(i[this.props[t].start]===e.COMMENT)return!0}return!1}get hasProps(){if(this.context){let{src:i}=this.context;for(let t=0;t<this.props.length;++t)if(i[this.props[t].start]!==e.COMMENT)return!0}return!1}get includesTrailingLines(){return!1}get jsonLike(){return[r.FLOW_MAP,r.FLOW_SEQ,r.QUOTE_DOUBLE,r.QUOTE_SINGLE].indexOf(this.type)!==-1}get rangeAsLinePos(){if(!this.range||!this.context)return;let i=E(this.range.start,this.context.root);if(!i)return;let t=E(this.range.end,this.context.root);return{start:i,end:t}}get rawValue(){if(!this.valueRange||!this.context)return null;let{start:i,end:t}=this.valueRange;return this.context.src.slice(i,t)}get tag(){for(let i=0;i<this.props.length;++i){let t=this.getPropValue(i,e.TAG,!1);if(t!=null){if(t[1]==="<")return{verbatim:t.slice(2,-1)};{let[s,a,m]=t.match(/^(.*!)([^!]*)$/);return{handle:a,suffix:m}}}}return null}get valueRangeContainsNewline(){if(!this.valueRange||!this.context)return!1;let{start:i,end:t}=this.valueRange,{src:s}=this.context;for(let a=i;a<t;++a)if(s[a]===`\n`)return!0;return!1}parseComment(i){let{src:t}=this.context;if(t[i]===e.COMMENT){let s=T.endOfLine(t,i+1),a=new M(i,s);return this.props.push(a),s}return i}setOrigRanges(i,t){return this.range&&(t=this.range.setOrigRange(i,t)),this.valueRange&&this.valueRange.setOrigRange(i,t),this.props.forEach(s=>s.setOrigRange(i,t)),t}toString(){let{context:{src:i},range:t,value:s}=this;if(s!=null)return s;let a=i.slice(t.start,t.end);return T.addStringTerminator(i,t.end,a)}},P=class extends Error{constructor(i,t,s){if(!s||!(t instanceof T))throw new Error(`Invalid arguments for new ${i}`);super(),this.name=i,this.message=s,this.source=t}makePretty(){if(!this.source)return;this.nodeType=this.source.type;let i=this.source.context&&this.source.context.root;if(typeof this.offset=="number"){this.range=new M(this.offset,this.offset+1);let t=i&&E(this.offset,i);if(t){let s={line:t.line,col:t.col+1};this.linePos={start:t,end:s}}delete this.offset}else this.range=this.source.range,this.linePos=this.source.rangeAsLinePos;if(this.linePos){let{line:t,col:s}=this.linePos.start;this.message+=` at line ${t}, column ${s}`;let a=i&&S(this.linePos,i);a&&(this.message+=`:\n\n${a}\n`)}delete this.source}},C=class extends P{constructor(i,t){super("YAMLReferenceError",i,t)}},q=class extends P{constructor(i,t){super("YAMLSemanticError",i,t)}},R=class extends P{constructor(i,t){super("YAMLSyntaxError",i,t)}},B=class extends P{constructor(i,t){super("YAMLWarning",i,t)}};function U(i,t,s){return t in i?Object.defineProperty(i,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):i[t]=s,i}var f=class extends T{static endOfLine(i,t,s){let a=i[t],m=t;for(;a&&a!==`\n`&&!(s&&(a==="["||a==="]"||a==="{"||a==="}"||a===","));){let g=i[m+1];if(a===":"&&(!g||g===`\n`||g==="\t"||g===" "||s&&g===",")||(a===" "||a==="\t")&&g==="#")break;m+=1,a=g}return m}get strValue(){if(!this.valueRange||!this.context)return null;let{start:i,end:t}=this.valueRange,{src:s}=this.context,a=s[t-1];for(;i<t&&(a===`\n`||a==="\t"||a===" ");)a=s[--t-1];let m="";for(let u=i;u<t;++u){let p=s[u];if(p===`\n`){let{fold:L,offset:k}=T.foldNewline(s,u,-1);m+=L,u=k}else if(p===" "||p==="\t"){let L=u,k=s[u+1];for(;u<t&&(k===" "||k==="\t");)u+=1,k=s[u+1];k!==`\n`&&(m+=u>L?s.slice(L,u+1):p)}else m+=p}let g=s[i];switch(g){case"\t":{let u="Plain value cannot start with a tab character";return{errors:[new q(this,u)],str:m}}case"@":case"`":{let u=`Plain value cannot start with reserved character ${g}`;return{errors:[new q(this,u)],str:m}}default:return m}}parseBlockValue(i){let{indent:t,inFlow:s,src:a}=this.context,m=i,g=i;for(let u=a[m];u===`\n`&&!T.atDocumentBoundary(a,m+1);u=a[m]){let p=T.endOfBlockIndent(a,t,m+1);if(p===null||a[p]==="#")break;a[p]===`\n`?m=p:(g=f.endOfLine(a,p,s),m=g)}return this.valueRange.isEmpty()&&(this.valueRange.start=i),this.valueRange.end=g,g}parse(i,t){this.context=i;let{inFlow:s,src:a}=i,m=t,g=a[m];return g&&g!=="#"&&g!==`\n`&&(m=f.endOfLine(a,t,s)),this.valueRange=new M(t,m),m=T.endOfWhiteSpace(a,m),m=this.parseComment(m),(!this.hasComment||this.valueRange.isEmpty())&&(m=this.parseBlockValue(m)),m}};n.Char=e,n.Node=T,n.PlainValue=f,n.Range=M,n.Type=r,n.YAMLError=P,n.YAMLReferenceError=C,n.YAMLSemanticError=q,n.YAMLSyntaxError=R,n.YAMLWarning=B,n._defineProperty=U,n.defaultTagPrefix=c,n.defaultTags=h}}),Jr=D({"node_modules/yaml/dist/parse-cst.js"(n){"use strict";Y();var e=Me(),r=class extends e.Node{constructor(){super(e.Type.BLANK_LINE)}get includesTrailingLines(){return!0}parse(f,i){return this.context=f,this.range=new e.Range(i,i+1),i+1}},c=class extends e.Node{constructor(f,i){super(f,i),this.node=null}get includesTrailingLines(){return!!this.node&&this.node.includesTrailingLines}parse(f,i){this.context=f;let{parseNode:t,src:s}=f,{atLineStart:a,lineStart:m}=f;!a&&this.type===e.Type.SEQ_ITEM&&(this.error=new e.YAMLSemanticError(this,"Sequence items must not have preceding content on the same line"));let g=a?i-m:f.indent,u=e.Node.endOfWhiteSpace(s,i+1),p=s[u],L=p==="#",k=[],$=null;for(;p===`\n`||p==="#";){if(p==="#"){let V=e.Node.endOfLine(s,u+1);k.push(new e.Range(u,V)),u=V}else{a=!0,m=u+1;let V=e.Node.endOfWhiteSpace(s,m);s[V]===`\n`&&k.length===0&&($=new r,m=$.parse({src:s},m)),u=e.Node.endOfIndent(s,m)}p=s[u]}if(e.Node.nextNodeIsIndented(p,u-(m+g),this.type!==e.Type.SEQ_ITEM)?this.node=t({atLineStart:a,inCollection:!1,indent:g,lineStart:m,parent:this},u):p&&m>i+1&&(u=m-1),this.node){if($){let V=f.parent.items||f.parent.contents;V&&V.push($)}k.length&&Array.prototype.push.apply(this.props,k),u=this.node.range.end}else if(L){let V=k[0];this.props.push(V),u=V.end}else u=e.Node.endOfLine(s,i+1);let K=this.node?this.node.valueRange.end:u;return this.valueRange=new e.Range(i,K),u}setOrigRanges(f,i){return i=super.setOrigRanges(f,i),this.node?this.node.setOrigRanges(f,i):i}toString(){let{context:{src:f},node:i,range:t,value:s}=this;if(s!=null)return s;let a=i?f.slice(t.start,i.range.start)+String(i):f.slice(t.start,t.end);return e.Node.addStringTerminator(f,t.end,a)}},h=class extends e.Node{constructor(){super(e.Type.COMMENT)}parse(f,i){this.context=f;let t=this.parseComment(i);return this.range=new e.Range(i,t),t}};function d(f){let i=f;for(;i instanceof c;)i=i.node;if(!(i instanceof y))return null;let t=i.items.length,s=-1;for(let g=t-1;g>=0;--g){let u=i.items[g];if(u.type===e.Type.COMMENT){let{indent:p,lineStart:L}=u.context;if(p>0&&u.range.start>=L+p)break;s=g}else if(u.type===e.Type.BLANK_LINE)s=g;else break}if(s===-1)return null;let a=i.items.splice(s,t-s),m=a[0].range.start;for(;i.range.end=m,i.valueRange&&i.valueRange.end>m&&(i.valueRange.end=m),i!==f;)i=i.context.parent;return a}var y=class extends e.Node{static nextContentHasIndent(f,i,t){let s=e.Node.endOfLine(f,i)+1;i=e.Node.endOfWhiteSpace(f,s);let a=f[i];return a?i>=s+t?!0:a!=="#"&&a!==`\n`?!1:y.nextContentHasIndent(f,i,t):!1}constructor(f){super(f.type===e.Type.SEQ_ITEM?e.Type.SEQ:e.Type.MAP);for(let t=f.props.length-1;t>=0;--t)if(f.props[t].start<f.context.lineStart){this.props=f.props.slice(0,t+1),f.props=f.props.slice(t+1);let s=f.props[0]||f.valueRange;f.range.start=s.start;break}this.items=[f];let i=d(f);i&&Array.prototype.push.apply(this.items,i)}get includesTrailingLines(){return this.items.length>0}parse(f,i){this.context=f;let{parseNode:t,src:s}=f,a=e.Node.startOfLine(s,i),m=this.items[0];m.context.parent=this,this.valueRange=e.Range.copy(m.valueRange);let g=m.range.start-m.context.lineStart,u=i;u=e.Node.normalizeOffset(s,u);let p=s[u],L=e.Node.endOfWhiteSpace(s,a)===u,k=!1;for(;p;){for(;p===`\n`||p==="#";){if(L&&p===`\n`&&!k){let V=new r;if(u=V.parse({src:s},u),this.valueRange.end=u,u>=s.length){p=null;break}this.items.push(V),u-=1}else if(p==="#"){if(u<a+g&&!y.nextContentHasIndent(s,u,g))return u;let V=new h;if(u=V.parse({indent:g,lineStart:a,src:s},u),this.items.push(V),this.valueRange.end=u,u>=s.length){p=null;break}}if(a=u+1,u=e.Node.endOfIndent(s,a),e.Node.atBlank(s,u)){let V=e.Node.endOfWhiteSpace(s,u),z=s[V];(!z||z===`\n`||z==="#")&&(u=V)}p=s[u],L=!0}if(!p)break;if(u!==a+g&&(L||p!==":")){if(u<a+g){a>i&&(u=a);break}else if(!this.error){let V="All collection items must start at the same column";this.error=new e.YAMLSyntaxError(this,V)}}if(m.type===e.Type.SEQ_ITEM){if(p!=="-"){a>i&&(u=a);break}}else if(p==="-"&&!this.error){let V=s[u+1];if(!V||V===`\n`||V==="\t"||V===" "){let z="A collection cannot be both a mapping and a sequence";this.error=new e.YAMLSyntaxError(this,z)}}let $=t({atLineStart:L,inCollection:!0,indent:g,lineStart:a,parent:this},u);if(!$)return u;if(this.items.push($),this.valueRange.end=$.valueRange.end,u=e.Node.normalizeOffset(s,$.range.end),p=s[u],L=!1,k=$.includesTrailingLines,p){let V=u-1,z=s[V];for(;z===" "||z==="\t";)z=s[--V];z===`\n`&&(a=V+1,L=!0)}let K=d($);K&&Array.prototype.push.apply(this.items,K)}return u}setOrigRanges(f,i){return i=super.setOrigRanges(f,i),this.items.forEach(t=>{i=t.setOrigRanges(f,i)}),i}toString(){let{context:{src:f},items:i,range:t,value:s}=this;if(s!=null)return s;let a=f.slice(t.start,i[0].range.start)+String(i[0]);for(let m=1;m<i.length;++m){let g=i[m],{atLineStart:u,indent:p}=g.context;if(u)for(let L=0;L<p;++L)a+=" ";a+=String(g)}return e.Node.addStringTerminator(f,t.end,a)}},E=class extends e.Node{constructor(){super(e.Type.DIRECTIVE),this.name=null}get parameters(){let f=this.rawValue;return f?f.trim().split(/[ \\t]+/):[]}parseName(f){let{src:i}=this.context,t=f,s=i[t];for(;s&&s!==`\n`&&s!=="\t"&&s!==" ";)s=i[t+=1];return this.name=i.slice(f,t),t}parseParameters(f){let{src:i}=this.context,t=f,s=i[t];for(;s&&s!==`\n`&&s!=="#";)s=i[t+=1];return this.valueRange=new e.Range(f,t),t}parse(f,i){this.context=f;let t=this.parseName(i+1);return t=this.parseParameters(t),t=this.parseComment(t),this.range=new e.Range(i,t),t}},I=class extends e.Node{static startCommentOrEndBlankLine(f,i){let t=e.Node.endOfWhiteSpace(f,i),s=f[t];return s==="#"||s===`\n`?t:i}constructor(){super(e.Type.DOCUMENT),this.directives=null,this.contents=null,this.directivesEndMarker=null,this.documentEndMarker=null}parseDirectives(f){let{src:i}=this.context;this.directives=[];let t=!0,s=!1,a=f;for(;!e.Node.atDocumentBoundary(i,a,e.Char.DIRECTIVES_END);)switch(a=I.startCommentOrEndBlankLine(i,a),i[a]){case`\n`:if(t){let m=new r;a=m.parse({src:i},a),a<i.length&&this.directives.push(m)}else a+=1,t=!0;break;case"#":{let m=new h;a=m.parse({src:i},a),this.directives.push(m),t=!1}break;case"%":{let m=new E;a=m.parse({parent:this,src:i},a),this.directives.push(m),s=!0,t=!1}break;default:return s?this.error=new e.YAMLSemanticError(this,"Missing directives-end indicator line"):this.directives.length>0&&(this.contents=this.directives,this.directives=[]),a}return i[a]?(this.directivesEndMarker=new e.Range(a,a+3),a+3):(s?this.error=new e.YAMLSemanticError(this,"Missing directives-end indicator line"):this.directives.length>0&&(this.contents=this.directives,this.directives=[]),a)}parseContents(f){let{parseNode:i,src:t}=this.context;this.contents||(this.contents=[]);let s=f;for(;t[s-1]==="-";)s-=1;let a=e.Node.endOfWhiteSpace(t,f),m=s===f;for(this.valueRange=new e.Range(a);!e.Node.atDocumentBoundary(t,a,e.Char.DOCUMENT_END);){switch(t[a]){case`\n`:if(m){let g=new r;a=g.parse({src:t},a),a<t.length&&this.contents.push(g)}else a+=1,m=!0;s=a;break;case"#":{let g=new h;a=g.parse({src:t},a),this.contents.push(g),m=!1}break;default:{let g=e.Node.endOfIndent(t,a),p=i({atLineStart:m,indent:-1,inFlow:!1,inCollection:!1,lineStart:s,parent:this},g);if(!p)return this.valueRange.end=g;this.contents.push(p),a=p.range.end,m=!1;let L=d(p);L&&Array.prototype.push.apply(this.contents,L)}}a=I.startCommentOrEndBlankLine(t,a)}if(this.valueRange.end=a,t[a]&&(this.documentEndMarker=new e.Range(a,a+3),a+=3,t[a])){if(a=e.Node.endOfWhiteSpace(t,a),t[a]==="#"){let g=new h;a=g.parse({src:t},a),this.contents.push(g)}switch(t[a]){case`\n`:a+=1;break;case void 0:break;default:this.error=new e.YAMLSyntaxError(this,"Document end marker line cannot have a non-comment suffix")}}return a}parse(f,i){f.root=this,this.context=f;let{src:t}=f,s=t.charCodeAt(i)===65279?i+1:i;return s=this.parseDirectives(s),s=this.parseContents(s),s}setOrigRanges(f,i){return i=super.setOrigRanges(f,i),this.directives.forEach(t=>{i=t.setOrigRanges(f,i)}),this.directivesEndMarker&&(i=this.directivesEndMarker.setOrigRange(f,i)),this.contents.forEach(t=>{i=t.setOrigRanges(f,i)}),this.documentEndMarker&&(i=this.documentEndMarker.setOrigRange(f,i)),i}toString(){let{contents:f,directives:i,value:t}=this;if(t!=null)return t;let s=i.join("");return f.length>0&&((i.length>0||f[0].type===e.Type.COMMENT)&&(s+=`---\n`),s+=f.join("")),s[s.length-1]!==`\n`&&(s+=`\n`),s}},S=class extends e.Node{parse(f,i){this.context=f;let{src:t}=f,s=e.Node.endOfIdentifier(t,i+1);return this.valueRange=new e.Range(i+1,s),s=e.Node.endOfWhiteSpace(t,s),s=this.parseComment(s),s}},M={CLIP:"CLIP",KEEP:"KEEP",STRIP:"STRIP"},T=class extends e.Node{constructor(f,i){super(f,i),this.blockIndent=null,this.chomping=M.CLIP,this.header=null}get includesTrailingLines(){return this.chomping===M.KEEP}get strValue(){if(!this.valueRange||!this.context)return null;let{start:f,end:i}=this.valueRange,{indent:t,src:s}=this.context;if(this.valueRange.isEmpty())return"";let a=null,m=s[i-1];for(;m===`\n`||m==="\t"||m===" ";){if(i-=1,i<=f){if(this.chomping===M.KEEP)break;return""}m===`\n`&&(a=i),m=s[i-1]}let g=i+1;a&&(this.chomping===M.KEEP?(g=a,i=this.valueRange.end):i=a);let u=t+this.blockIndent,p=this.type===e.Type.BLOCK_FOLDED,L=!0,k="",$="",K=!1;for(let V=f;V<i;++V){for(let ae=0;ae<u&&s[V]===" ";++ae)V+=1;let z=s[V];if(z===`\n`)$===`\n`?k+=`\n`:$=`\n`;else{let ae=e.Node.endOfLine(s,V),ue=s.slice(V,ae);V=ae,p&&(z===" "||z==="\t")&&V<g?($===" "?$=`\n`:!K&&!L&&$===`\n`&&($=`\n\n`),k+=$+ue,$=ae<i&&s[ae]||"",K=!0):(k+=$+ue,$=p&&V<g?" ":`\n`,K=!1),L&&ue!==""&&(L=!1)}}return this.chomping===M.STRIP?k:k+`\n`}parseBlockHeader(f){let{src:i}=this.context,t=f+1,s="";for(;;){let a=i[t];switch(a){case"-":this.chomping=M.STRIP;break;case"+":this.chomping=M.KEEP;break;case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":s+=a;break;default:return this.blockIndent=Number(s)||null,this.header=new e.Range(f,t),t}t+=1}}parseBlockValue(f){let{indent:i,src:t}=this.context,s=!!this.blockIndent,a=f,m=f,g=1;for(let u=t[a];u===`\n`&&(a+=1,!e.Node.atDocumentBoundary(t,a));u=t[a]){let p=e.Node.endOfBlockIndent(t,i,a);if(p===null)break;let L=t[p],k=p-(a+i);if(this.blockIndent){if(L&&L!==`\n`&&k<this.blockIndent){if(t[p]==="#")break;if(!this.error){let K=`Block scalars must not be less indented than their ${s?"explicit indentation indicator":"first line"}`;this.error=new e.YAMLSemanticError(this,K)}}}else if(t[p]!==`\n`){if(k<g){let $="Block scalars with more-indented leading empty lines must use an explicit indentation indicator";this.error=new e.YAMLSemanticError(this,$)}this.blockIndent=k}else k>g&&(g=k);t[p]===`\n`?a=p:a=m=e.Node.endOfLine(t,p)}return this.chomping!==M.KEEP&&(a=t[m]?m+1:m),this.valueRange=new e.Range(f+1,a),a}parse(f,i){this.context=f;let{src:t}=f,s=this.parseBlockHeader(i);return s=e.Node.endOfWhiteSpace(t,s),s=this.parseComment(s),s=this.parseBlockValue(s),s}setOrigRanges(f,i){return i=super.setOrigRanges(f,i),this.header?this.header.setOrigRange(f,i):i}},P=class extends e.Node{constructor(f,i){super(f,i),this.items=null}prevNodeIsJsonLike(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:this.items.length,i=this.items[f-1];return!!i&&(i.jsonLike||i.type===e.Type.COMMENT&&this.prevNodeIsJsonLike(f-1))}parse(f,i){this.context=f;let{parseNode:t,src:s}=f,{indent:a,lineStart:m}=f,g=s[i];this.items=[{char:g,offset:i}];let u=e.Node.endOfWhiteSpace(s,i+1);for(g=s[u];g&&g!=="]"&&g!=="}";){switch(g){case`\n`:{m=u+1;let p=e.Node.endOfWhiteSpace(s,m);if(s[p]===`\n`){let L=new r;m=L.parse({src:s},m),this.items.push(L)}if(u=e.Node.endOfIndent(s,m),u<=m+a&&(g=s[u],u<m+a||g!=="]"&&g!=="}")){let L="Insufficient indentation in flow collection";this.error=new e.YAMLSemanticError(this,L)}}break;case",":this.items.push({char:g,offset:u}),u+=1;break;case"#":{let p=new h;u=p.parse({src:s},u),this.items.push(p)}break;case"?":case":":{let p=s[u+1];if(p===`\n`||p==="\t"||p===" "||p===","||g===":"&&this.prevNodeIsJsonLike()){this.items.push({char:g,offset:u}),u+=1;break}}default:{let p=t({atLineStart:!1,inCollection:!1,inFlow:!0,indent:-1,lineStart:m,parent:this},u);if(!p)return this.valueRange=new e.Range(i,u),u;this.items.push(p),u=e.Node.normalizeOffset(s,p.range.end)}}u=e.Node.endOfWhiteSpace(s,u),g=s[u]}return this.valueRange=new e.Range(i,u+1),g&&(this.items.push({char:g,offset:u}),u=e.Node.endOfWhiteSpace(s,u+1),u=this.parseComment(u)),u}setOrigRanges(f,i){return i=super.setOrigRanges(f,i),this.items.forEach(t=>{if(t instanceof e.Node)i=t.setOrigRanges(f,i);else if(f.length===0)t.origOffset=t.offset;else{let s=i;for(;s<f.length&&!(f[s]>t.offset);)++s;t.origOffset=t.offset+s,i=s}}),i}toString(){let{context:{src:f},items:i,range:t,value:s}=this;if(s!=null)return s;let a=i.filter(u=>u instanceof e.Node),m="",g=t.start;return a.forEach(u=>{let p=f.slice(g,u.range.start);g=u.range.end,m+=p+String(u),m[m.length-1]===`\n`&&f[g-1]!==`\n`&&f[g]===`\n`&&(g+=1)}),m+=f.slice(g,t.end),e.Node.addStringTerminator(f,t.end,m)}},C=class extends e.Node{static endOfQuote(f,i){let t=f[i];for(;t&&t!==\'"\';)i+=t==="\\\\"?2:1,t=f[i];return i+1}get strValue(){if(!this.valueRange||!this.context)return null;let f=[],{start:i,end:t}=this.valueRange,{indent:s,src:a}=this.context;a[t-1]!==\'"\'&&f.push(new e.YAMLSyntaxError(this,\'Missing closing "quote\'));let m="";for(let g=i+1;g<t-1;++g){let u=a[g];if(u===`\n`){e.Node.atDocumentBoundary(a,g+1)&&f.push(new e.YAMLSemanticError(this,"Document boundary indicators are not allowed within string values"));let{fold:p,offset:L,error:k}=e.Node.foldNewline(a,g,s);m+=p,g=L,k&&f.push(new e.YAMLSemanticError(this,"Multi-line double-quoted string needs to be sufficiently indented"))}else if(u==="\\\\")switch(g+=1,a[g]){case"0":m+="\\0";break;case"a":m+="\\x07";break;case"b":m+="\\b";break;case"e":m+="\\x1B";break;case"f":m+="\\f";break;case"n":m+=`\n`;break;case"r":m+="\\r";break;case"t":m+="\t";break;case"v":m+="\\v";break;case"N":m+="\\x85";break;case"_":m+="\\xA0";break;case"L":m+="\\u2028";break;case"P":m+="\\u2029";break;case" ":m+=" ";break;case\'"\':m+=\'"\';break;case"/":m+="/";break;case"\\\\":m+="\\\\";break;case"\t":m+="\t";break;case"x":m+=this.parseCharCode(g+1,2,f),g+=2;break;case"u":m+=this.parseCharCode(g+1,4,f),g+=4;break;case"U":m+=this.parseCharCode(g+1,8,f),g+=8;break;case`\n`:for(;a[g+1]===" "||a[g+1]==="\t";)g+=1;break;default:f.push(new e.YAMLSyntaxError(this,`Invalid escape sequence ${a.substr(g-1,2)}`)),m+="\\\\"+a[g]}else if(u===" "||u==="\t"){let p=g,L=a[g+1];for(;L===" "||L==="\t";)g+=1,L=a[g+1];L!==`\n`&&(m+=g>p?a.slice(p,g+1):u)}else m+=u}return f.length>0?{errors:f,str:m}:m}parseCharCode(f,i,t){let{src:s}=this.context,a=s.substr(f,i),g=a.length===i&&/^[0-9a-fA-F]+$/.test(a)?parseInt(a,16):NaN;return isNaN(g)?(t.push(new e.YAMLSyntaxError(this,`Invalid escape sequence ${s.substr(f-2,i+2)}`)),s.substr(f-2,i+2)):String.fromCodePoint(g)}parse(f,i){this.context=f;let{src:t}=f,s=C.endOfQuote(t,i+1);return this.valueRange=new e.Range(i,s),s=e.Node.endOfWhiteSpace(t,s),s=this.parseComment(s),s}},q=class extends e.Node{static endOfQuote(f,i){let t=f[i];for(;t;)if(t==="\'"){if(f[i+1]!=="\'")break;t=f[i+=2]}else t=f[i+=1];return i+1}get strValue(){if(!this.valueRange||!this.context)return null;let f=[],{start:i,end:t}=this.valueRange,{indent:s,src:a}=this.context;a[t-1]!=="\'"&&f.push(new e.YAMLSyntaxError(this,"Missing closing \'quote"));let m="";for(let g=i+1;g<t-1;++g){let u=a[g];if(u===`\n`){e.Node.atDocumentBoundary(a,g+1)&&f.push(new e.YAMLSemanticError(this,"Document boundary indicators are not allowed within string values"));let{fold:p,offset:L,error:k}=e.Node.foldNewline(a,g,s);m+=p,g=L,k&&f.push(new e.YAMLSemanticError(this,"Multi-line single-quoted string needs to be sufficiently indented"))}else if(u==="\'")m+=u,g+=1,a[g]!=="\'"&&f.push(new e.YAMLSyntaxError(this,"Unescaped single quote? This should not happen."));else if(u===" "||u==="\t"){let p=g,L=a[g+1];for(;L===" "||L==="\t";)g+=1,L=a[g+1];L!==`\n`&&(m+=g>p?a.slice(p,g+1):u)}else m+=u}return f.length>0?{errors:f,str:m}:m}parse(f,i){this.context=f;let{src:t}=f,s=q.endOfQuote(t,i+1);return this.valueRange=new e.Range(i,s),s=e.Node.endOfWhiteSpace(t,s),s=this.parseComment(s),s}};function R(f,i){switch(f){case e.Type.ALIAS:return new S(f,i);case e.Type.BLOCK_FOLDED:case e.Type.BLOCK_LITERAL:return new T(f,i);case e.Type.FLOW_MAP:case e.Type.FLOW_SEQ:return new P(f,i);case e.Type.MAP_KEY:case e.Type.MAP_VALUE:case e.Type.SEQ_ITEM:return new c(f,i);case e.Type.COMMENT:case e.Type.PLAIN:return new e.PlainValue(f,i);case e.Type.QUOTE_DOUBLE:return new C(f,i);case e.Type.QUOTE_SINGLE:return new q(f,i);default:return null}}var B=class{static parseType(f,i,t){switch(f[i]){case"*":return e.Type.ALIAS;case">":return e.Type.BLOCK_FOLDED;case"|":return e.Type.BLOCK_LITERAL;case"{":return e.Type.FLOW_MAP;case"[":return e.Type.FLOW_SEQ;case"?":return!t&&e.Node.atBlank(f,i+1,!0)?e.Type.MAP_KEY:e.Type.PLAIN;case":":return!t&&e.Node.atBlank(f,i+1,!0)?e.Type.MAP_VALUE:e.Type.PLAIN;case"-":return!t&&e.Node.atBlank(f,i+1,!0)?e.Type.SEQ_ITEM:e.Type.PLAIN;case\'"\':return e.Type.QUOTE_DOUBLE;case"\'":return e.Type.QUOTE_SINGLE;default:return e.Type.PLAIN}}constructor(){let f=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},{atLineStart:i,inCollection:t,inFlow:s,indent:a,lineStart:m,parent:g}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};e._defineProperty(this,"parseNode",(u,p)=>{if(e.Node.atDocumentBoundary(this.src,p))return null;let L=new B(this,u),{props:k,type:$,valueStart:K}=L.parseProps(p),V=R($,k),z=V.parse(L,K);if(V.range=new e.Range(p,z),z<=p&&(V.error=new Error("Node#parse consumed no characters"),V.error.parseEnd=z,V.error.source=V,V.range.end=p+1),L.nodeStartsCollection(V)){!V.error&&!L.atLineStart&&L.parent.type===e.Type.DOCUMENT&&(V.error=new e.YAMLSyntaxError(V,"Block collection must not have preceding content here (e.g. directives-end indicator)"));let ae=new y(V);return z=ae.parse(new B(L),z),ae.range=new e.Range(p,z),ae}return V}),this.atLineStart=i!=null?i:f.atLineStart||!1,this.inCollection=t!=null?t:f.inCollection||!1,this.inFlow=s!=null?s:f.inFlow||!1,this.indent=a!=null?a:f.indent,this.lineStart=m!=null?m:f.lineStart,this.parent=g!=null?g:f.parent||{},this.root=f.root,this.src=f.src}nodeStartsCollection(f){let{inCollection:i,inFlow:t,src:s}=this;if(i||t)return!1;if(f instanceof c)return!0;let a=f.range.end;return s[a]===`\n`||s[a-1]===`\n`?!1:(a=e.Node.endOfWhiteSpace(s,a),s[a]===":")}parseProps(f){let{inFlow:i,parent:t,src:s}=this,a=[],m=!1;f=this.atLineStart?e.Node.endOfIndent(s,f):e.Node.endOfWhiteSpace(s,f);let g=s[f];for(;g===e.Char.ANCHOR||g===e.Char.COMMENT||g===e.Char.TAG||g===`\n`;){if(g===`\n`){let p=f,L;do L=p+1,p=e.Node.endOfIndent(s,L);while(s[p]===`\n`);let k=p-(L+this.indent),$=t.type===e.Type.SEQ_ITEM&&t.context.atLineStart;if(s[p]!=="#"&&!e.Node.nextNodeIsIndented(s[p],k,!$))break;this.atLineStart=!0,this.lineStart=L,m=!1,f=p}else if(g===e.Char.COMMENT){let p=e.Node.endOfLine(s,f+1);a.push(new e.Range(f,p)),f=p}else{let p=e.Node.endOfIdentifier(s,f+1);g===e.Char.TAG&&s[p]===","&&/^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(s.slice(f+1,p+13))&&(p=e.Node.endOfIdentifier(s,p+5)),a.push(new e.Range(f,p)),m=!0,f=e.Node.endOfWhiteSpace(s,p)}g=s[f]}m&&g===":"&&e.Node.atBlank(s,f+1,!0)&&(f-=1);let u=B.parseType(s,f,i);return{props:a,type:u,valueStart:f}}};function U(f){let i=[];f.indexOf("\\r")!==-1&&(f=f.replace(/\\r\\n?/g,(a,m)=>(a.length>1&&i.push(m),`\n`)));let t=[],s=0;do{let a=new I,m=new B({src:f});s=a.parse(m,s),t.push(a)}while(s<f.length);return t.setOrigRanges=()=>{if(i.length===0)return!1;for(let m=1;m<i.length;++m)i[m]-=m;let a=0;for(let m=0;m<t.length;++m)a=t[m].setOrigRanges(i,a);return i.splice(0,i.length),!0},t.toString=()=>t.join(`...\n`),t}n.parse=U}}),ke=D({"node_modules/yaml/dist/resolveSeq-d03cb037.js"(n){"use strict";Y();var e=Me();function r(o,l,_){return _?`#${_.replace(/[\\s\\S]^/gm,`$&${l}#`)}\n${l}${o}`:o}function c(o,l,_){return _?_.indexOf(`\n`)===-1?`${o} #${_}`:`${o}\n`+_.replace(/^/gm,`${l||""}#`):o}var h=class{};function d(o,l,_){if(Array.isArray(o))return o.map((v,b)=>d(v,String(b),_));if(o&&typeof o.toJSON=="function"){let v=_&&_.anchors&&_.anchors.get(o);v&&(_.onCreate=w=>{v.res=w,delete _.onCreate});let b=o.toJSON(l,_);return v&&_.onCreate&&_.onCreate(b),b}return(!_||!_.keep)&&typeof o=="bigint"?Number(o):o}var y=class extends h{constructor(o){super(),this.value=o}toJSON(o,l){return l&&l.keep?this.value:d(this.value,o,l)}toString(){return String(this.value)}};function E(o,l,_){let v=_;for(let b=l.length-1;b>=0;--b){let w=l[b];if(Number.isInteger(w)&&w>=0){let A=[];A[w]=v,v=A}else{let A={};Object.defineProperty(A,w,{value:v,writable:!0,enumerable:!0,configurable:!0}),v=A}}return o.createNode(v,!1)}var I=o=>o==null||typeof o=="object"&&o[Symbol.iterator]().next().done,S=class extends h{constructor(o){super(),e._defineProperty(this,"items",[]),this.schema=o}addIn(o,l){if(I(o))this.add(l);else{let[_,...v]=o,b=this.get(_,!0);if(b instanceof S)b.addIn(v,l);else if(b===void 0&&this.schema)this.set(_,E(this.schema,v,l));else throw new Error(`Expected YAML collection at ${_}. Remaining path: ${v}`)}}deleteIn(o){let[l,..._]=o;if(_.length===0)return this.delete(l);let v=this.get(l,!0);if(v instanceof S)return v.deleteIn(_);throw new Error(`Expected YAML collection at ${l}. Remaining path: ${_}`)}getIn(o,l){let[_,...v]=o,b=this.get(_,!0);return v.length===0?!l&&b instanceof y?b.value:b:b instanceof S?b.getIn(v,l):void 0}hasAllNullValues(){return this.items.every(o=>{if(!o||o.type!=="PAIR")return!1;let l=o.value;return l==null||l instanceof y&&l.value==null&&!l.commentBefore&&!l.comment&&!l.tag})}hasIn(o){let[l,..._]=o;if(_.length===0)return this.has(l);let v=this.get(l,!0);return v instanceof S?v.hasIn(_):!1}setIn(o,l){let[_,...v]=o;if(v.length===0)this.set(_,l);else{let b=this.get(_,!0);if(b instanceof S)b.setIn(v,l);else if(b===void 0&&this.schema)this.set(_,E(this.schema,v,l));else throw new Error(`Expected YAML collection at ${_}. Remaining path: ${v}`)}}toJSON(){return null}toString(o,l,_,v){let{blockItem:b,flowChars:w,isMap:A,itemIndent:N}=l,{indent:j,indentStep:F,stringify:Q}=o,H=this.type===e.Type.FLOW_MAP||this.type===e.Type.FLOW_SEQ||o.inFlow;H&&(N+=F);let oe=A&&this.hasAllNullValues();o=Object.assign({},o,{allNullValues:oe,indent:N,inFlow:H,type:null});let le=!1,Z=!1,ee=this.items.reduce((de,ne,he)=>{let ce;ne&&(!le&&ne.spaceBefore&&de.push({type:"comment",str:""}),ne.commentBefore&&ne.commentBefore.match(/^.*$/gm).forEach(Ie=>{de.push({type:"comment",str:`#${Ie}`})}),ne.comment&&(ce=ne.comment),H&&(!le&&ne.spaceBefore||ne.commentBefore||ne.comment||ne.key&&(ne.key.commentBefore||ne.key.comment)||ne.value&&(ne.value.commentBefore||ne.value.comment))&&(Z=!0)),le=!1;let fe=Q(ne,o,()=>ce=null,()=>le=!0);return H&&!Z&&fe.includes(`\n`)&&(Z=!0),H&&he<this.items.length-1&&(fe+=","),fe=c(fe,N,ce),le&&(ce||H)&&(le=!1),de.push({type:"item",str:fe}),de},[]),X;if(ee.length===0)X=w.start+w.end;else if(H){let{start:de,end:ne}=w,he=ee.map(ce=>ce.str);if(Z||he.reduce((ce,fe)=>ce+fe.length+2,2)>S.maxFlowStringSingleLineLength){X=de;for(let ce of he)X+=ce?`\n${F}${j}${ce}`:`\n`;X+=`\n${j}${ne}`}else X=`${de} ${he.join(" ")} ${ne}`}else{let de=ee.map(b);X=de.shift();for(let ne of de)X+=ne?`\n${j}${ne}`:`\n`}return this.comment?(X+=`\n`+this.comment.replace(/^/gm,`${j}#`),_&&_()):le&&v&&v(),X}};e._defineProperty(S,"maxFlowStringSingleLineLength",60);function M(o){let l=o instanceof y?o.value:o;return l&&typeof l=="string"&&(l=Number(l)),Number.isInteger(l)&&l>=0?l:null}var T=class extends S{add(o){this.items.push(o)}delete(o){let l=M(o);return typeof l!="number"?!1:this.items.splice(l,1).length>0}get(o,l){let _=M(o);if(typeof _!="number")return;let v=this.items[_];return!l&&v instanceof y?v.value:v}has(o){let l=M(o);return typeof l=="number"&&l<this.items.length}set(o,l){let _=M(o);if(typeof _!="number")throw new Error(`Expected a valid index, not ${o}.`);this.items[_]=l}toJSON(o,l){let _=[];l&&l.onCreate&&l.onCreate(_);let v=0;for(let b of this.items)_.push(d(b,String(v++),l));return _}toString(o,l,_){return o?super.toString(o,{blockItem:v=>v.type==="comment"?v.str:`- ${v.str}`,flowChars:{start:"[",end:"]"},isMap:!1,itemIndent:(o.indent||"")+"  "},l,_):JSON.stringify(this)}},P=(o,l,_)=>l===null?"":typeof l!="object"?String(l):o instanceof h&&_&&_.doc?o.toString({anchors:Object.create(null),doc:_.doc,indent:"",indentStep:_.indentStep,inFlow:!0,inStringifyKey:!0,stringify:_.stringify}):JSON.stringify(l),C=class extends h{constructor(o){let l=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null;super(),this.key=o,this.value=l,this.type=C.Type.PAIR}get commentBefore(){return this.key instanceof h?this.key.commentBefore:void 0}set commentBefore(o){if(this.key==null&&(this.key=new y(null)),this.key instanceof h)this.key.commentBefore=o;else{let l="Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.";throw new Error(l)}}addToJSMap(o,l){let _=d(this.key,"",o);if(l instanceof Map){let v=d(this.value,_,o);l.set(_,v)}else if(l instanceof Set)l.add(_);else{let v=P(this.key,_,o),b=d(this.value,v,o);v in l?Object.defineProperty(l,v,{value:b,writable:!0,enumerable:!0,configurable:!0}):l[v]=b}return l}toJSON(o,l){let _=l&&l.mapAsMap?new Map:{};return this.addToJSMap(l,_)}toString(o,l,_){if(!o||!o.doc)return JSON.stringify(this);let{indent:v,indentSeq:b,simpleKeys:w}=o.doc.options,{key:A,value:N}=this,j=A instanceof h&&A.comment;if(w){if(j)throw new Error("With simple keys, key nodes cannot have comments");if(A instanceof S){let ce="With simple keys, collection cannot be used as a key value";throw new Error(ce)}}let F=!w&&(!A||j||(A instanceof h?A instanceof S||A.type===e.Type.BLOCK_FOLDED||A.type===e.Type.BLOCK_LITERAL:typeof A=="object")),{doc:Q,indent:H,indentStep:oe,stringify:le}=o;o=Object.assign({},o,{implicitKey:!F,indent:H+oe});let Z=!1,ee=le(A,o,()=>j=null,()=>Z=!0);if(ee=c(ee,o.indent,j),!F&&ee.length>1024){if(w)throw new Error("With simple keys, single line scalar must not span more than 1024 characters");F=!0}if(o.allNullValues&&!w)return this.comment?(ee=c(ee,o.indent,this.comment),l&&l()):Z&&!j&&_&&_(),o.inFlow&&!F?ee:`? ${ee}`;ee=F?`? ${ee}\n${H}:`:`${ee}:`,this.comment&&(ee=c(ee,o.indent,this.comment),l&&l());let X="",de=null;if(N instanceof h){if(N.spaceBefore&&(X=`\n`),N.commentBefore){let ce=N.commentBefore.replace(/^/gm,`${o.indent}#`);X+=`\n${ce}`}de=N.comment}else N&&typeof N=="object"&&(N=Q.schema.createNode(N,!0));o.implicitKey=!1,!F&&!this.comment&&N instanceof y&&(o.indentAtStart=ee.length+1),Z=!1,!b&&v>=2&&!o.inFlow&&!F&&N instanceof T&&N.type!==e.Type.FLOW_SEQ&&!N.tag&&!Q.anchors.getName(N)&&(o.indent=o.indent.substr(2));let ne=le(N,o,()=>de=null,()=>Z=!0),he=" ";return X||this.comment?he=`${X}\n${o.indent}`:!F&&N instanceof S?(!(ne[0]==="["||ne[0]==="{")||ne.includes(`\n`))&&(he=`\n${o.indent}`):ne[0]===`\n`&&(he=""),Z&&!de&&_&&_(),c(ee+he+ne,o.indent,de)}};e._defineProperty(C,"Type",{PAIR:"PAIR",MERGE_PAIR:"MERGE_PAIR"});var q=(o,l)=>{if(o instanceof R){let _=l.get(o.source);return _.count*_.aliasCount}else if(o instanceof S){let _=0;for(let v of o.items){let b=q(v,l);b>_&&(_=b)}return _}else if(o instanceof C){let _=q(o.key,l),v=q(o.value,l);return Math.max(_,v)}return 1},R=class extends h{static stringify(o,l){let{range:_,source:v}=o,{anchors:b,doc:w,implicitKey:A,inStringifyKey:N}=l,j=Object.keys(b).find(Q=>b[Q]===v);if(!j&&N&&(j=w.anchors.getName(v)||w.anchors.newName()),j)return`*${j}${A?" ":""}`;let F=w.anchors.getName(v)?"Alias node must be after source node":"Source node not found for alias node";throw new Error(`${F} [${_}]`)}constructor(o){super(),this.source=o,this.type=e.Type.ALIAS}set tag(o){throw new Error("Alias nodes cannot have tags")}toJSON(o,l){if(!l)return d(this.source,o,l);let{anchors:_,maxAliasCount:v}=l,b=_.get(this.source);if(!b||b.res===void 0){let w="This should not happen: Alias anchor was not resolved?";throw this.cstNode?new e.YAMLReferenceError(this.cstNode,w):new ReferenceError(w)}if(v>=0&&(b.count+=1,b.aliasCount===0&&(b.aliasCount=q(this.source,_)),b.count*b.aliasCount>v)){let w="Excessive alias count indicates a resource exhaustion attack";throw this.cstNode?new e.YAMLReferenceError(this.cstNode,w):new ReferenceError(w)}return b.res}toString(o){return R.stringify(this,o)}};e._defineProperty(R,"default",!0);function B(o,l){let _=l instanceof y?l.value:l;for(let v of o)if(v instanceof C&&(v.key===l||v.key===_||v.key&&v.key.value===_))return v}var U=class extends S{add(o,l){o?o instanceof C||(o=new C(o.key||o,o.value)):o=new C(o);let _=B(this.items,o.key),v=this.schema&&this.schema.sortMapEntries;if(_)if(l)_.value=o.value;else throw new Error(`Key ${o.key} already set`);else if(v){let b=this.items.findIndex(w=>v(o,w)<0);b===-1?this.items.push(o):this.items.splice(b,0,o)}else this.items.push(o)}delete(o){let l=B(this.items,o);return l?this.items.splice(this.items.indexOf(l),1).length>0:!1}get(o,l){let _=B(this.items,o),v=_&&_.value;return!l&&v instanceof y?v.value:v}has(o){return!!B(this.items,o)}set(o,l){this.add(new C(o,l),!0)}toJSON(o,l,_){let v=_?new _:l&&l.mapAsMap?new Map:{};l&&l.onCreate&&l.onCreate(v);for(let b of this.items)b.addToJSMap(l,v);return v}toString(o,l,_){if(!o)return JSON.stringify(this);for(let v of this.items)if(!(v instanceof C))throw new Error(`Map items must all be pairs; found ${JSON.stringify(v)} instead`);return super.toString(o,{blockItem:v=>v.str,flowChars:{start:"{",end:"}"},isMap:!0,itemIndent:o.indent||""},l,_)}},f="<<",i=class extends C{constructor(o){if(o instanceof C){let l=o.value;l instanceof T||(l=new T,l.items.push(o.value),l.range=o.value.range),super(o.key,l),this.range=o.range}else super(new y(f),new T);this.type=C.Type.MERGE_PAIR}addToJSMap(o,l){for(let{source:_}of this.value.items){if(!(_ instanceof U))throw new Error("Merge sources must be maps");let v=_.toJSON(null,o,Map);for(let[b,w]of v)l instanceof Map?l.has(b)||l.set(b,w):l instanceof Set?l.add(b):Object.prototype.hasOwnProperty.call(l,b)||Object.defineProperty(l,b,{value:w,writable:!0,enumerable:!0,configurable:!0})}return l}toString(o,l){let _=this.value;if(_.items.length>1)return super.toString(o,l);this.value=_.items[0];let v=super.toString(o,l);return this.value=_,v}},t={defaultType:e.Type.BLOCK_LITERAL,lineWidth:76},s={trueStr:"true",falseStr:"false"},a={asBigInt:!1},m={nullStr:"null"},g={defaultType:e.Type.PLAIN,doubleQuoted:{jsonEncoding:!1,minMultiLineLength:40},fold:{lineWidth:80,minContentWidth:20}};function u(o,l,_){for(let{format:v,test:b,resolve:w}of l)if(b){let A=o.match(b);if(A){let N=w.apply(null,A);return N instanceof y||(N=new y(N)),v&&(N.format=v),N}}return _&&(o=_(o)),new y(o)}var p="flow",L="block",k="quoted",$=(o,l)=>{let _=o[l+1];for(;_===" "||_==="\t";){do _=o[l+=1];while(_&&_!==`\n`);_=o[l+1]}return l};function K(o,l,_,v){let{indentAtStart:b,lineWidth:w=80,minContentWidth:A=20,onFold:N,onOverflow:j}=v;if(!w||w<0)return o;let F=Math.max(1+A,1+w-l.length);if(o.length<=F)return o;let Q=[],H={},oe=w-l.length;typeof b=="number"&&(b>w-Math.max(2,A)?Q.push(0):oe=w-b);let le,Z,ee=!1,X=-1,de=-1,ne=-1;_===L&&(X=$(o,X),X!==-1&&(oe=X+F));for(let ce;ce=o[X+=1];){if(_===k&&ce==="\\\\"){switch(de=X,o[X+1]){case"x":X+=3;break;case"u":X+=5;break;case"U":X+=9;break;default:X+=1}ne=X}if(ce===`\n`)_===L&&(X=$(o,X)),oe=X+F,le=void 0;else{if(ce===" "&&Z&&Z!==" "&&Z!==`\n`&&Z!=="\t"){let fe=o[X+1];fe&&fe!==" "&&fe!==`\n`&&fe!=="\t"&&(le=X)}if(X>=oe)if(le)Q.push(le),oe=le+F,le=void 0;else if(_===k){for(;Z===" "||Z==="\t";)Z=ce,ce=o[X+=1],ee=!0;let fe=X>ne+1?X-2:de-1;if(H[fe])return o;Q.push(fe),H[fe]=!0,oe=fe+F,le=void 0}else ee=!0}Z=ce}if(ee&&j&&j(),Q.length===0)return o;N&&N();let he=o.slice(0,Q[0]);for(let ce=0;ce<Q.length;++ce){let fe=Q[ce],Ie=Q[ce+1]||o.length;fe===0?he=`\n${l}${o.slice(0,Ie)}`:(_===k&&H[fe]&&(he+=`${o[fe]}\\\\`),he+=`\n${l}${o.slice(fe+1,Ie)}`)}return he}var V=o=>{let{indentAtStart:l}=o;return l?Object.assign({indentAtStart:l},g.fold):g.fold},z=o=>/^(%|---|\\.\\.\\.)/m.test(o);function ae(o,l,_){if(!l||l<0)return!1;let v=l-_,b=o.length;if(b<=v)return!1;for(let w=0,A=0;w<b;++w)if(o[w]===`\n`){if(w-A>v)return!0;if(A=w+1,b-A<=v)return!1}return!0}function ue(o,l){let{implicitKey:_}=l,{jsonEncoding:v,minMultiLineLength:b}=g.doubleQuoted,w=JSON.stringify(o);if(v)return w;let A=l.indent||(z(o)?"  ":""),N="",j=0;for(let F=0,Q=w[F];Q;Q=w[++F])if(Q===" "&&w[F+1]==="\\\\"&&w[F+2]==="n"&&(N+=w.slice(j,F)+"\\\\ ",F+=1,j=F,Q="\\\\"),Q==="\\\\")switch(w[F+1]){case"u":{N+=w.slice(j,F);let H=w.substr(F+2,4);switch(H){case"0000":N+="\\\\0";break;case"0007":N+="\\\\a";break;case"000b":N+="\\\\v";break;case"001b":N+="\\\\e";break;case"0085":N+="\\\\N";break;case"00a0":N+="\\\\_";break;case"2028":N+="\\\\L";break;case"2029":N+="\\\\P";break;default:H.substr(0,2)==="00"?N+="\\\\x"+H.substr(2):N+=w.substr(F,6)}F+=5,j=F+1}break;case"n":if(_||w[F+2]===\'"\'||w.length<b)F+=1;else{for(N+=w.slice(j,F)+`\n\n`;w[F+2]==="\\\\"&&w[F+3]==="n"&&w[F+4]!==\'"\';)N+=`\n`,F+=2;N+=A,w[F+2]===" "&&(N+="\\\\"),F+=1,j=F+1}break;default:F+=1}return N=j?N+w.slice(j):w,_?N:K(N,A,k,V(l))}function pe(o,l){if(l.implicitKey){if(/\\n/.test(o))return ue(o,l)}else if(/[ \\t]\\n|\\n[ \\t]/.test(o))return ue(o,l);let _=l.indent||(z(o)?"  ":""),v="\'"+o.replace(/\'/g,"\'\'").replace(/\\n+/g,`$&\n${_}`)+"\'";return l.implicitKey?v:K(v,_,p,V(l))}function ge(o,l,_,v){let{comment:b,type:w,value:A}=o;if(/\\n[\\t ]+$/.test(A)||/^\\s*$/.test(A))return ue(A,l);let N=l.indent||(l.forceBlockIndent||z(A)?"  ":""),j=N?"2":"1",F=w===e.Type.BLOCK_FOLDED?!1:w===e.Type.BLOCK_LITERAL?!0:!ae(A,g.fold.lineWidth,N.length),Q=F?"|":">";if(!A)return Q+`\n`;let H="",oe="";if(A=A.replace(/[\\n\\t ]*$/,Z=>{let ee=Z.indexOf(`\n`);return ee===-1?Q+="-":(A===Z||ee!==Z.length-1)&&(Q+="+",v&&v()),oe=Z.replace(/\\n$/,""),""}).replace(/^[\\n ]*/,Z=>{Z.indexOf(" ")!==-1&&(Q+=j);let ee=Z.match(/ +$/);return ee?(H=Z.slice(0,-ee[0].length),ee[0]):(H=Z,"")}),oe&&(oe=oe.replace(/\\n+(?!\\n|$)/g,`$&${N}`)),H&&(H=H.replace(/\\n+/g,`$&${N}`)),b&&(Q+=" #"+b.replace(/ ?[\\r\\n]+/g," "),_&&_()),!A)return`${Q}${j}\n${N}${oe}`;if(F)return A=A.replace(/\\n+/g,`$&${N}`),`${Q}\n${N}${H}${A}${oe}`;A=A.replace(/\\n+/g,`\n$&`).replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g,"$1$2").replace(/\\n+/g,`$&${N}`);let le=K(`${H}${A}${oe}`,N,L,g.fold);return`${Q}\n${N}${le}`}function O(o,l,_,v){let{comment:b,type:w,value:A}=o,{actualString:N,implicitKey:j,indent:F,inFlow:Q}=l;if(j&&/[\\n[\\]{},]/.test(A)||Q&&/[[\\]{},]/.test(A))return ue(A,l);if(!A||/^[\\n\\t ,[\\]{}#&*!|>\'"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(A))return j||Q||A.indexOf(`\n`)===-1?A.indexOf(\'"\')!==-1&&A.indexOf("\'")===-1?pe(A,l):ue(A,l):ge(o,l,_,v);if(!j&&!Q&&w!==e.Type.PLAIN&&A.indexOf(`\n`)!==-1)return ge(o,l,_,v);if(F===""&&z(A))return l.forceBlockIndent=!0,ge(o,l,_,v);let H=A.replace(/\\n+/g,`$&\n${F}`);if(N){let{tags:le}=l.doc.schema;if(typeof u(H,le,le.scalarFallback).value!="string")return ue(A,l)}let oe=j?H:K(H,F,p,V(l));return b&&!Q&&(oe.indexOf(`\n`)!==-1||b.indexOf(`\n`)!==-1)?(_&&_(),r(oe,F,b)):oe}function W(o,l,_,v){let{defaultType:b}=g,{implicitKey:w,inFlow:A}=l,{type:N,value:j}=o;typeof j!="string"&&(j=String(j),o=Object.assign({},o,{value:j}));let F=H=>{switch(H){case e.Type.BLOCK_FOLDED:case e.Type.BLOCK_LITERAL:return ge(o,l,_,v);case e.Type.QUOTE_DOUBLE:return ue(j,l);case e.Type.QUOTE_SINGLE:return pe(j,l);case e.Type.PLAIN:return O(o,l,_,v);default:return null}};(N!==e.Type.QUOTE_DOUBLE&&/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f]/.test(j)||(w||A)&&(N===e.Type.BLOCK_FOLDED||N===e.Type.BLOCK_LITERAL))&&(N=e.Type.QUOTE_DOUBLE);let Q=F(N);if(Q===null&&(Q=F(b),Q===null))throw new Error(`Unsupported default string type ${b}`);return Q}function J(o){let{format:l,minFractionDigits:_,tag:v,value:b}=o;if(typeof b=="bigint")return String(b);if(!isFinite(b))return isNaN(b)?".nan":b<0?"-.inf":".inf";let w=JSON.stringify(b);if(!l&&_&&(!v||v==="tag:yaml.org,2002:float")&&/^\\d/.test(w)){let A=w.indexOf(".");A<0&&(A=w.length,w+=".");let N=_-(w.length-A-1);for(;N-- >0;)w+="0"}return w}function x(o,l){let _,v;switch(l.type){case e.Type.FLOW_MAP:_="}",v="flow map";break;case e.Type.FLOW_SEQ:_="]",v="flow sequence";break;default:o.push(new e.YAMLSemanticError(l,"Not a flow collection!?"));return}let b;for(let w=l.items.length-1;w>=0;--w){let A=l.items[w];if(!A||A.type!==e.Type.COMMENT){b=A;break}}if(b&&b.char!==_){let w=`Expected ${v} to end with ${_}`,A;typeof b.offset=="number"?(A=new e.YAMLSemanticError(l,w),A.offset=b.offset+1):(A=new e.YAMLSemanticError(b,w),b.range&&b.range.end&&(A.offset=b.range.end-b.range.start)),o.push(A)}}function G(o,l){let _=l.context.src[l.range.start-1];if(_!==`\n`&&_!=="\t"&&_!==" "){let v="Comments must be separated from other tokens by white space characters";o.push(new e.YAMLSemanticError(l,v))}}function re(o,l){let _=String(l),v=_.substr(0,8)+"..."+_.substr(-8);return new e.YAMLSemanticError(o,`The "${v}" key is too long`)}function _e(o,l){for(let{afterKey:_,before:v,comment:b}of l){let w=o.items[v];w?(_&&w.value&&(w=w.value),b===void 0?(_||!w.commentBefore)&&(w.spaceBefore=!0):w.commentBefore?w.commentBefore+=`\n`+b:w.commentBefore=b):b!==void 0&&(o.comment?o.comment+=`\n`+b:o.comment=b)}}function ye(o,l){let _=l.strValue;return _?typeof _=="string"?_:(_.errors.forEach(v=>{v.source||(v.source=l),o.errors.push(v)}),_.str):""}function be(o,l){let{handle:_,suffix:v}=l.tag,b=o.tagPrefixes.find(w=>w.handle===_);if(!b){let w=o.getDefaults().tagPrefixes;if(w&&(b=w.find(A=>A.handle===_)),!b)throw new e.YAMLSemanticError(l,`The ${_} tag handle is non-default and was not declared.`)}if(!v)throw new e.YAMLSemanticError(l,`The ${_} tag has no suffix.`);if(_==="!"&&(o.version||o.options.version)==="1.0"){if(v[0]==="^")return o.warnings.push(new e.YAMLWarning(l,"YAML 1.0 ^ tag expansion is not supported")),v;if(/[:/]/.test(v)){let w=v.match(/^([a-z0-9-]+)\\/(.*)/i);return w?`tag:${w[1]}.yaml.org,2002:${w[2]}`:`tag:${v}`}}return b.prefix+decodeURIComponent(v)}function ve(o,l){let{tag:_,type:v}=l,b=!1;if(_){let{handle:w,suffix:A,verbatim:N}=_;if(N){if(N!=="!"&&N!=="!!")return N;let j=`Verbatim tags aren\'t resolved, so ${N} is invalid.`;o.errors.push(new e.YAMLSemanticError(l,j))}else if(w==="!"&&!A)b=!0;else try{return be(o,l)}catch(j){o.errors.push(j)}}switch(v){case e.Type.BLOCK_FOLDED:case e.Type.BLOCK_LITERAL:case e.Type.QUOTE_DOUBLE:case e.Type.QUOTE_SINGLE:return e.defaultTags.STR;case e.Type.FLOW_MAP:case e.Type.MAP:return e.defaultTags.MAP;case e.Type.FLOW_SEQ:case e.Type.SEQ:return e.defaultTags.SEQ;case e.Type.PLAIN:return b?e.defaultTags.STR:null;default:return null}}function Ne(o,l,_){let{tags:v}=o.schema,b=[];for(let A of v)if(A.tag===_)if(A.test)b.push(A);else{let N=A.resolve(o,l);return N instanceof S?N:new y(N)}let w=ye(o,l);return typeof w=="string"&&b.length>0?u(w,b,v.scalarFallback):null}function Pe(o){let{type:l}=o;switch(l){case e.Type.FLOW_MAP:case e.Type.MAP:return e.defaultTags.MAP;case e.Type.FLOW_SEQ:case e.Type.SEQ:return e.defaultTags.SEQ;default:return e.defaultTags.STR}}function ot(o,l,_){try{let v=Ne(o,l,_);if(v)return _&&l.tag&&(v.tag=_),v}catch(v){return v.source||(v.source=l),o.errors.push(v),null}try{let v=Pe(l);if(!v)throw new Error(`The tag ${_} is unavailable`);let b=`The tag ${_} is unavailable, falling back to ${v}`;o.warnings.push(new e.YAMLWarning(l,b));let w=Ne(o,l,v);return w.tag=_,w}catch(v){let b=new e.YAMLReferenceError(l,v.message);return b.stack=v.stack,o.errors.push(b),null}}var lt=o=>{if(!o)return!1;let{type:l}=o;return l===e.Type.MAP_KEY||l===e.Type.MAP_VALUE||l===e.Type.SEQ_ITEM};function ct(o,l){let _={before:[],after:[]},v=!1,b=!1,w=lt(l.context.parent)?l.context.parent.props.concat(l.props):l.props;for(let{start:A,end:N}of w)switch(l.context.src[A]){case e.Char.COMMENT:{if(!l.commentHasRequiredWhitespace(A)){let H="Comments must be separated from other tokens by white space characters";o.push(new e.YAMLSemanticError(l,H))}let{header:j,valueRange:F}=l;(F&&(A>F.start||j&&A>j.start)?_.after:_.before).push(l.context.src.slice(A+1,N));break}case e.Char.ANCHOR:if(v){let j="A node can have at most one anchor";o.push(new e.YAMLSemanticError(l,j))}v=!0;break;case e.Char.TAG:if(b){let j="A node can have at most one tag";o.push(new e.YAMLSemanticError(l,j))}b=!0;break}return{comments:_,hasAnchor:v,hasTag:b}}function ut(o,l){let{anchors:_,errors:v,schema:b}=o;if(l.type===e.Type.ALIAS){let A=l.rawValue,N=_.getNode(A);if(!N){let F=`Aliased anchor not found: ${A}`;return v.push(new e.YAMLReferenceError(l,F)),null}let j=new R(N);return _._cstAliases.push(j),j}let w=ve(o,l);if(w)return ot(o,l,w);if(l.type!==e.Type.PLAIN){let A=`Failed to resolve ${l.type} node here`;return v.push(new e.YAMLSyntaxError(l,A)),null}try{let A=ye(o,l);return u(A,b.tags,b.tags.scalarFallback)}catch(A){return A.source||(A.source=l),v.push(A),null}}function we(o,l){if(!l)return null;l.error&&o.errors.push(l.error);let{comments:_,hasAnchor:v,hasTag:b}=ct(o.errors,l);if(v){let{anchors:A}=o,N=l.anchor,j=A.getNode(N);j&&(A.map[A.newName(N)]=j),A.map[N]=l}if(l.type===e.Type.ALIAS&&(v||b)){let A="An alias node must not specify any properties";o.errors.push(new e.YAMLSemanticError(l,A))}let w=ut(o,l);if(w){w.range=[l.range.start,l.range.end],o.options.keepCstNodes&&(w.cstNode=l),o.options.keepNodeTypes&&(w.type=l.type);let A=_.before.join(`\n`);A&&(w.commentBefore=w.commentBefore?`${w.commentBefore}\n${A}`:A);let N=_.after.join(`\n`);N&&(w.comment=w.comment?`${w.comment}\n${N}`:N)}return l.resolved=w}function ft(o,l){if(l.type!==e.Type.MAP&&l.type!==e.Type.FLOW_MAP){let A=`A ${l.type} node cannot be resolved as a mapping`;return o.errors.push(new e.YAMLSyntaxError(l,A)),null}let{comments:_,items:v}=l.type===e.Type.FLOW_MAP?gt(o,l):ht(o,l),b=new U;b.items=v,_e(b,_);let w=!1;for(let A=0;A<v.length;++A){let{key:N}=v[A];if(N instanceof S&&(w=!0),o.schema.merge&&N&&N.value===f){v[A]=new i(v[A]);let j=v[A].value.items,F=null;j.some(Q=>{if(Q instanceof R){let{type:H}=Q.source;return H===e.Type.MAP||H===e.Type.FLOW_MAP?!1:F="Merge nodes aliases can only point to maps"}return F="Merge nodes can only have Alias nodes as values"}),F&&o.errors.push(new e.YAMLSemanticError(l,F))}else for(let j=A+1;j<v.length;++j){let{key:F}=v[j];if(N===F||N&&F&&Object.prototype.hasOwnProperty.call(N,"value")&&N.value===F.value){let Q=`Map keys must be unique; "${N}" is repeated`;o.errors.push(new e.YAMLSemanticError(l,Q));break}}}if(w&&!o.options.mapAsMap){let A="Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";o.warnings.push(new e.YAMLWarning(l,A))}return l.resolved=b,b}var mt=o=>{let{context:{lineStart:l,node:_,src:v},props:b}=o;if(b.length===0)return!1;let{start:w}=b[0];if(_&&w>_.valueRange.start||v[w]!==e.Char.COMMENT)return!1;for(let A=l;A<w;++A)if(v[A]===`\n`)return!1;return!0};function dt(o,l){if(!mt(o))return;let _=o.getPropValue(0,e.Char.COMMENT,!0),v=!1,b=l.value.commentBefore;if(b&&b.startsWith(_))l.value.commentBefore=b.substr(_.length+1),v=!0;else{let w=l.value.comment;!o.node&&w&&w.startsWith(_)&&(l.value.comment=w.substr(_.length+1),v=!0)}v&&(l.comment=_)}function ht(o,l){let _=[],v=[],b,w=null;for(let A=0;A<l.items.length;++A){let N=l.items[A];switch(N.type){case e.Type.BLANK_LINE:_.push({afterKey:!!b,before:v.length});break;case e.Type.COMMENT:_.push({afterKey:!!b,before:v.length,comment:N.comment});break;case e.Type.MAP_KEY:b!==void 0&&v.push(new C(b)),N.error&&o.errors.push(N.error),b=we(o,N.node),w=null;break;case e.Type.MAP_VALUE:{if(b===void 0&&(b=null),N.error&&o.errors.push(N.error),!N.context.atLineStart&&N.node&&N.node.type===e.Type.MAP&&!N.node.context.atLineStart){let Q="Nested mappings are not allowed in compact mappings";o.errors.push(new e.YAMLSemanticError(N.node,Q))}let j=N.node;if(!j&&N.props.length>0){j=new e.PlainValue(e.Type.PLAIN,[]),j.context={parent:N,src:N.context.src};let Q=N.range.start+1;if(j.range={start:Q,end:Q},j.valueRange={start:Q,end:Q},typeof N.range.origStart=="number"){let H=N.range.origStart+1;j.range.origStart=j.range.origEnd=H,j.valueRange.origStart=j.valueRange.origEnd=H}}let F=new C(b,we(o,j));dt(N,F),v.push(F),b&&typeof w=="number"&&N.range.start>w+1024&&o.errors.push(re(l,b)),b=void 0,w=null}break;default:b!==void 0&&v.push(new C(b)),b=we(o,N),w=N.range.start,N.error&&o.errors.push(N.error);e:for(let j=A+1;;++j){let F=l.items[j];switch(F&&F.type){case e.Type.BLANK_LINE:case e.Type.COMMENT:continue e;case e.Type.MAP_VALUE:break e;default:{let Q="Implicit map keys need to be followed by map values";o.errors.push(new e.YAMLSemanticError(N,Q));break e}}}if(N.valueRangeContainsNewline){let j="Implicit map keys need to be on a single line";o.errors.push(new e.YAMLSemanticError(N,j))}}}return b!==void 0&&v.push(new C(b)),{comments:_,items:v}}function gt(o,l){let _=[],v=[],b,w=!1,A="{";for(let N=0;N<l.items.length;++N){let j=l.items[N];if(typeof j.char=="string"){let{char:F,offset:Q}=j;if(F==="?"&&b===void 0&&!w){w=!0,A=":";continue}if(F===":"){if(b===void 0&&(b=null),A===":"){A=",";continue}}else if(w&&(b===void 0&&F!==","&&(b=null),w=!1),b!==void 0&&(v.push(new C(b)),b=void 0,F===",")){A=":";continue}if(F==="}"){if(N===l.items.length-1)continue}else if(F===A){A=":";continue}let H=`Flow map contains an unexpected ${F}`,oe=new e.YAMLSyntaxError(l,H);oe.offset=Q,o.errors.push(oe)}else j.type===e.Type.BLANK_LINE?_.push({afterKey:!!b,before:v.length}):j.type===e.Type.COMMENT?(G(o.errors,j),_.push({afterKey:!!b,before:v.length,comment:j.comment})):b===void 0?(A===","&&o.errors.push(new e.YAMLSemanticError(j,"Separator , missing in flow map")),b=we(o,j)):(A!==","&&o.errors.push(new e.YAMLSemanticError(j,"Indicator : missing in flow map entry")),v.push(new C(b,we(o,j))),b=void 0,w=!1)}return x(o.errors,l),b!==void 0&&v.push(new C(b)),{comments:_,items:v}}function pt(o,l){if(l.type!==e.Type.SEQ&&l.type!==e.Type.FLOW_SEQ){let w=`A ${l.type} node cannot be resolved as a sequence`;return o.errors.push(new e.YAMLSyntaxError(l,w)),null}let{comments:_,items:v}=l.type===e.Type.FLOW_SEQ?vt(o,l):_t(o,l),b=new T;if(b.items=v,_e(b,_),!o.options.mapAsMap&&v.some(w=>w instanceof C&&w.key instanceof S)){let w="Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.";o.warnings.push(new e.YAMLWarning(l,w))}return l.resolved=b,b}function _t(o,l){let _=[],v=[];for(let b=0;b<l.items.length;++b){let w=l.items[b];switch(w.type){case e.Type.BLANK_LINE:_.push({before:v.length});break;case e.Type.COMMENT:_.push({comment:w.comment,before:v.length});break;case e.Type.SEQ_ITEM:if(w.error&&o.errors.push(w.error),v.push(we(o,w.node)),w.hasProps){let A="Sequence items cannot have tags or anchors before the - indicator";o.errors.push(new e.YAMLSemanticError(w,A))}break;default:w.error&&o.errors.push(w.error),o.errors.push(new e.YAMLSyntaxError(w,`Unexpected ${w.type} node in sequence`))}}return{comments:_,items:v}}function vt(o,l){let _=[],v=[],b=!1,w,A=null,N="[",j=null;for(let F=0;F<l.items.length;++F){let Q=l.items[F];if(typeof Q.char=="string"){let{char:H,offset:oe}=Q;if(H!==":"&&(b||w!==void 0)&&(b&&w===void 0&&(w=N?v.pop():null),v.push(new C(w)),b=!1,w=void 0,A=null),H===N)N=null;else if(!N&&H==="?")b=!0;else if(N!=="["&&H===":"&&w===void 0){if(N===","){if(w=v.pop(),w instanceof C){let le="Chaining flow sequence pairs is invalid",Z=new e.YAMLSemanticError(l,le);Z.offset=oe,o.errors.push(Z)}if(!b&&typeof A=="number"){let le=Q.range?Q.range.start:Q.offset;le>A+1024&&o.errors.push(re(l,w));let{src:Z}=j.context;for(let ee=A;ee<le;++ee)if(Z[ee]===`\n`){let X="Implicit keys of flow sequence pairs need to be on a single line";o.errors.push(new e.YAMLSemanticError(j,X));break}}}else w=null;A=null,b=!1,N=null}else if(N==="["||H!=="]"||F<l.items.length-1){let le=`Flow sequence contains an unexpected ${H}`,Z=new e.YAMLSyntaxError(l,le);Z.offset=oe,o.errors.push(Z)}}else if(Q.type===e.Type.BLANK_LINE)_.push({before:v.length});else if(Q.type===e.Type.COMMENT)G(o.errors,Q),_.push({comment:Q.comment,before:v.length});else{if(N){let oe=`Expected a ${N} in flow sequence`;o.errors.push(new e.YAMLSemanticError(Q,oe))}let H=we(o,Q);w===void 0?(v.push(H),j=Q):(v.push(new C(w,H)),w=void 0),A=Q.range.start,N=","}}return x(o.errors,l),w!==void 0&&v.push(new C(w)),{comments:_,items:v}}n.Alias=R,n.Collection=S,n.Merge=i,n.Node=h,n.Pair=C,n.Scalar=y,n.YAMLMap=U,n.YAMLSeq=T,n.addComment=c,n.binaryOptions=t,n.boolOptions=s,n.findPair=B,n.intOptions=a,n.isEmptyPath=I,n.nullOptions=m,n.resolveMap=ft,n.resolveNode=we,n.resolveSeq=pt,n.resolveString=ye,n.strOptions=g,n.stringifyNumber=J,n.stringifyString=W,n.toJSON=d}}),st=D({"node_modules/yaml/dist/warnings-1000a372.js"(n){"use strict";Y();var e=Me(),r=ke(),c={identify:u=>u instanceof Uint8Array,default:!1,tag:"tag:yaml.org,2002:binary",resolve:(u,p)=>{let L=r.resolveString(u,p);if(typeof Buffer=="function")return Buffer.from(L,"base64");if(typeof atob=="function"){let k=atob(L.replace(/[\\n\\r]/g,"")),$=new Uint8Array(k.length);for(let K=0;K<k.length;++K)$[K]=k.charCodeAt(K);return $}else{let k="This environment does not support reading binary tags; either Buffer or atob is required";return u.errors.push(new e.YAMLReferenceError(p,k)),null}},options:r.binaryOptions,stringify:(u,p,L,k)=>{let{comment:$,type:K,value:V}=u,z;if(typeof Buffer=="function")z=V instanceof Buffer?V.toString("base64"):Buffer.from(V.buffer).toString("base64");else if(typeof btoa=="function"){let ae="";for(let ue=0;ue<V.length;++ue)ae+=String.fromCharCode(V[ue]);z=btoa(ae)}else throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");if(K||(K=r.binaryOptions.defaultType),K===e.Type.QUOTE_DOUBLE)V=z;else{let{lineWidth:ae}=r.binaryOptions,ue=Math.ceil(z.length/ae),pe=new Array(ue);for(let ge=0,O=0;ge<ue;++ge,O+=ae)pe[ge]=z.substr(O,ae);V=pe.join(K===e.Type.BLOCK_LITERAL?`\n`:" ")}return r.stringifyString({comment:$,type:K,value:V},p,L,k)}};function h(u,p){let L=r.resolveSeq(u,p);for(let k=0;k<L.items.length;++k){let $=L.items[k];if(!($ instanceof r.Pair)){if($ instanceof r.YAMLMap){if($.items.length>1){let V="Each pair must have its own sequence indicator";throw new e.YAMLSemanticError(p,V)}let K=$.items[0]||new r.Pair;$.commentBefore&&(K.commentBefore=K.commentBefore?`${$.commentBefore}\n${K.commentBefore}`:$.commentBefore),$.comment&&(K.comment=K.comment?`${$.comment}\n${K.comment}`:$.comment),$=K}L.items[k]=$ instanceof r.Pair?$:new r.Pair($)}}return L}function d(u,p,L){let k=new r.YAMLSeq(u);k.tag="tag:yaml.org,2002:pairs";for(let $ of p){let K,V;if(Array.isArray($))if($.length===2)K=$[0],V=$[1];else throw new TypeError(`Expected [key, value] tuple: ${$}`);else if($&&$ instanceof Object){let ae=Object.keys($);if(ae.length===1)K=ae[0],V=$[K];else throw new TypeError(`Expected { key: value } tuple: ${$}`)}else K=$;let z=u.createPair(K,V,L);k.items.push(z)}return k}var y={default:!1,tag:"tag:yaml.org,2002:pairs",resolve:h,createNode:d},E=class extends r.YAMLSeq{constructor(){super(),e._defineProperty(this,"add",r.YAMLMap.prototype.add.bind(this)),e._defineProperty(this,"delete",r.YAMLMap.prototype.delete.bind(this)),e._defineProperty(this,"get",r.YAMLMap.prototype.get.bind(this)),e._defineProperty(this,"has",r.YAMLMap.prototype.has.bind(this)),e._defineProperty(this,"set",r.YAMLMap.prototype.set.bind(this)),this.tag=E.tag}toJSON(u,p){let L=new Map;p&&p.onCreate&&p.onCreate(L);for(let k of this.items){let $,K;if(k instanceof r.Pair?($=r.toJSON(k.key,"",p),K=r.toJSON(k.value,$,p)):$=r.toJSON(k,"",p),L.has($))throw new Error("Ordered maps must not include duplicate keys");L.set($,K)}return L}};e._defineProperty(E,"tag","tag:yaml.org,2002:omap");function I(u,p){let L=h(u,p),k=[];for(let{key:$}of L.items)if($ instanceof r.Scalar)if(k.includes($.value)){let K="Ordered maps must not include duplicate keys";throw new e.YAMLSemanticError(p,K)}else k.push($.value);return Object.assign(new E,L)}function S(u,p,L){let k=d(u,p,L),$=new E;return $.items=k.items,$}var M={identify:u=>u instanceof Map,nodeClass:E,default:!1,tag:"tag:yaml.org,2002:omap",resolve:I,createNode:S},T=class extends r.YAMLMap{constructor(){super(),this.tag=T.tag}add(u){let p=u instanceof r.Pair?u:new r.Pair(u);r.findPair(this.items,p.key)||this.items.push(p)}get(u,p){let L=r.findPair(this.items,u);return!p&&L instanceof r.Pair?L.key instanceof r.Scalar?L.key.value:L.key:L}set(u,p){if(typeof p!="boolean")throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof p}`);let L=r.findPair(this.items,u);L&&!p?this.items.splice(this.items.indexOf(L),1):!L&&p&&this.items.push(new r.Pair(u))}toJSON(u,p){return super.toJSON(u,p,Set)}toString(u,p,L){if(!u)return JSON.stringify(this);if(this.hasAllNullValues())return super.toString(u,p,L);throw new Error("Set items must all have null values")}};e._defineProperty(T,"tag","tag:yaml.org,2002:set");function P(u,p){let L=r.resolveMap(u,p);if(!L.hasAllNullValues())throw new e.YAMLSemanticError(p,"Set items must all have null values");return Object.assign(new T,L)}function C(u,p,L){let k=new T;for(let $ of p)k.items.push(u.createPair($,null,L));return k}var q={identify:u=>u instanceof Set,nodeClass:T,default:!1,tag:"tag:yaml.org,2002:set",resolve:P,createNode:C},R=(u,p)=>{let L=p.split(":").reduce((k,$)=>k*60+Number($),0);return u==="-"?-L:L},B=u=>{let{value:p}=u;if(isNaN(p)||!isFinite(p))return r.stringifyNumber(p);let L="";p<0&&(L="-",p=Math.abs(p));let k=[p%60];return p<60?k.unshift(0):(p=Math.round((p-k[0])/60),k.unshift(p%60),p>=60&&(p=Math.round((p-k[0])/60),k.unshift(p))),L+k.map($=>$<10?"0"+String($):String($)).join(":").replace(/000000\\d*$/,"")},U={identify:u=>typeof u=="number",default:!0,tag:"tag:yaml.org,2002:int",format:"TIME",test:/^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,resolve:(u,p,L)=>R(p,L.replace(/_/g,"")),stringify:B},f={identify:u=>typeof u=="number",default:!0,tag:"tag:yaml.org,2002:float",format:"TIME",test:/^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*)$/,resolve:(u,p,L)=>R(p,L.replace(/_/g,"")),stringify:B},i={identify:u=>u instanceof Date,default:!0,tag:"tag:yaml.org,2002:timestamp",test:RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\\\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),resolve:(u,p,L,k,$,K,V,z,ae)=>{z&&(z=(z+"00").substr(1,3));let ue=Date.UTC(p,L-1,k,$||0,K||0,V||0,z||0);if(ae&&ae!=="Z"){let pe=R(ae[0],ae.slice(1));Math.abs(pe)<30&&(pe*=60),ue-=6e4*pe}return new Date(ue)},stringify:u=>{let{value:p}=u;return p.toISOString().replace(/((T00:00)?:00)?\\.000Z$/,"")}};function t(u){let p=typeof Te<"u"&&Te.env||{};return u?typeof YAML_SILENCE_DEPRECATION_WARNINGS<"u"?!YAML_SILENCE_DEPRECATION_WARNINGS:!p.YAML_SILENCE_DEPRECATION_WARNINGS:typeof YAML_SILENCE_WARNINGS<"u"?!YAML_SILENCE_WARNINGS:!p.YAML_SILENCE_WARNINGS}function s(u,p){if(t(!1)){let L=typeof Te<"u"&&Te.emitWarning;L?L(u,p):console.warn(p?`${p}: ${u}`:u)}}function a(u){if(t(!0)){let p=u.replace(/.*yaml[/\\\\]/i,"").replace(/\\.js$/,"").replace(/\\\\/g,"/");s(`The endpoint \'yaml/${p}\' will be removed in a future release.`,"DeprecationWarning")}}var m={};function g(u,p){if(!m[u]&&t(!0)){m[u]=!0;let L=`The option \'${u}\' will be removed in a future release`;L+=p?`, use \'${p}\' instead.`:".",s(L,"DeprecationWarning")}}n.binary=c,n.floatTime=f,n.intTime=U,n.omap=M,n.pairs=y,n.set=q,n.timestamp=i,n.warn=s,n.warnFileDeprecation=a,n.warnOptionDeprecation=g}}),it=D({"node_modules/yaml/dist/Schema-88e323a7.js"(n){"use strict";Y();var e=Me(),r=ke(),c=st();function h(O,W,J){let x=new r.YAMLMap(O);if(W instanceof Map)for(let[G,re]of W)x.items.push(O.createPair(G,re,J));else if(W&&typeof W=="object")for(let G of Object.keys(W))x.items.push(O.createPair(G,W[G],J));return typeof O.sortMapEntries=="function"&&x.items.sort(O.sortMapEntries),x}var d={createNode:h,default:!0,nodeClass:r.YAMLMap,tag:"tag:yaml.org,2002:map",resolve:r.resolveMap};function y(O,W,J){let x=new r.YAMLSeq(O);if(W&&W[Symbol.iterator])for(let G of W){let re=O.createNode(G,J.wrapScalars,null,J);x.items.push(re)}return x}var E={createNode:y,default:!0,nodeClass:r.YAMLSeq,tag:"tag:yaml.org,2002:seq",resolve:r.resolveSeq},I={identify:O=>typeof O=="string",default:!0,tag:"tag:yaml.org,2002:str",resolve:r.resolveString,stringify(O,W,J,x){return W=Object.assign({actualString:!0},W),r.stringifyString(O,W,J,x)},options:r.strOptions},S=[d,E,I],M=O=>typeof O=="bigint"||Number.isInteger(O),T=(O,W,J)=>r.intOptions.asBigInt?BigInt(O):parseInt(W,J);function P(O,W,J){let{value:x}=O;return M(x)&&x>=0?J+x.toString(W):r.stringifyNumber(O)}var C={identify:O=>O==null,createNode:(O,W,J)=>J.wrapScalars?new r.Scalar(null):null,default:!0,tag:"tag:yaml.org,2002:null",test:/^(?:~|[Nn]ull|NULL)?$/,resolve:()=>null,options:r.nullOptions,stringify:()=>r.nullOptions.nullStr},q={identify:O=>typeof O=="boolean",default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,resolve:O=>O[0]==="t"||O[0]==="T",options:r.boolOptions,stringify:O=>{let{value:W}=O;return W?r.boolOptions.trueStr:r.boolOptions.falseStr}},R={identify:O=>M(O)&&O>=0,default:!0,tag:"tag:yaml.org,2002:int",format:"OCT",test:/^0o([0-7]+)$/,resolve:(O,W)=>T(O,W,8),options:r.intOptions,stringify:O=>P(O,8,"0o")},B={identify:M,default:!0,tag:"tag:yaml.org,2002:int",test:/^[-+]?[0-9]+$/,resolve:O=>T(O,O,10),options:r.intOptions,stringify:r.stringifyNumber},U={identify:O=>M(O)&&O>=0,default:!0,tag:"tag:yaml.org,2002:int",format:"HEX",test:/^0x([0-9a-fA-F]+)$/,resolve:(O,W)=>T(O,W,16),options:r.intOptions,stringify:O=>P(O,16,"0x")},f={identify:O=>typeof O=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^(?:[-+]?\\.inf|(\\.nan))$/i,resolve:(O,W)=>W?NaN:O[0]==="-"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,stringify:r.stringifyNumber},i={identify:O=>typeof O=="number",default:!0,tag:"tag:yaml.org,2002:float",format:"EXP",test:/^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,resolve:O=>parseFloat(O),stringify:O=>{let{value:W}=O;return Number(W).toExponential()}},t={identify:O=>typeof O=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^[-+]?(?:\\.([0-9]+)|[0-9]+\\.([0-9]*))$/,resolve(O,W,J){let x=W||J,G=new r.Scalar(parseFloat(O));return x&&x[x.length-1]==="0"&&(G.minFractionDigits=x.length),G},stringify:r.stringifyNumber},s=S.concat([C,q,R,B,U,f,i,t]),a=O=>typeof O=="bigint"||Number.isInteger(O),m=O=>{let{value:W}=O;return JSON.stringify(W)},g=[d,E,{identify:O=>typeof O=="string",default:!0,tag:"tag:yaml.org,2002:str",resolve:r.resolveString,stringify:m},{identify:O=>O==null,createNode:(O,W,J)=>J.wrapScalars?new r.Scalar(null):null,default:!0,tag:"tag:yaml.org,2002:null",test:/^null$/,resolve:()=>null,stringify:m},{identify:O=>typeof O=="boolean",default:!0,tag:"tag:yaml.org,2002:bool",test:/^true|false$/,resolve:O=>O==="true",stringify:m},{identify:a,default:!0,tag:"tag:yaml.org,2002:int",test:/^-?(?:0|[1-9][0-9]*)$/,resolve:O=>r.intOptions.asBigInt?BigInt(O):parseInt(O,10),stringify:O=>{let{value:W}=O;return a(W)?W.toString():JSON.stringify(W)}},{identify:O=>typeof O=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,resolve:O=>parseFloat(O),stringify:m}];g.scalarFallback=O=>{throw new SyntaxError(`Unresolved plain scalar ${JSON.stringify(O)}`)};var u=O=>{let{value:W}=O;return W?r.boolOptions.trueStr:r.boolOptions.falseStr},p=O=>typeof O=="bigint"||Number.isInteger(O);function L(O,W,J){let x=W.replace(/_/g,"");if(r.intOptions.asBigInt){switch(J){case 2:x=`0b${x}`;break;case 8:x=`0o${x}`;break;case 16:x=`0x${x}`;break}let re=BigInt(x);return O==="-"?BigInt(-1)*re:re}let G=parseInt(x,J);return O==="-"?-1*G:G}function k(O,W,J){let{value:x}=O;if(p(x)){let G=x.toString(W);return x<0?"-"+J+G.substr(1):J+G}return r.stringifyNumber(O)}var $=S.concat([{identify:O=>O==null,createNode:(O,W,J)=>J.wrapScalars?new r.Scalar(null):null,default:!0,tag:"tag:yaml.org,2002:null",test:/^(?:~|[Nn]ull|NULL)?$/,resolve:()=>null,options:r.nullOptions,stringify:()=>r.nullOptions.nullStr},{identify:O=>typeof O=="boolean",default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,resolve:()=>!0,options:r.boolOptions,stringify:u},{identify:O=>typeof O=="boolean",default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,resolve:()=>!1,options:r.boolOptions,stringify:u},{identify:p,default:!0,tag:"tag:yaml.org,2002:int",format:"BIN",test:/^([-+]?)0b([0-1_]+)$/,resolve:(O,W,J)=>L(W,J,2),stringify:O=>k(O,2,"0b")},{identify:p,default:!0,tag:"tag:yaml.org,2002:int",format:"OCT",test:/^([-+]?)0([0-7_]+)$/,resolve:(O,W,J)=>L(W,J,8),stringify:O=>k(O,8,"0")},{identify:p,default:!0,tag:"tag:yaml.org,2002:int",test:/^([-+]?)([0-9][0-9_]*)$/,resolve:(O,W,J)=>L(W,J,10),stringify:r.stringifyNumber},{identify:p,default:!0,tag:"tag:yaml.org,2002:int",format:"HEX",test:/^([-+]?)0x([0-9a-fA-F_]+)$/,resolve:(O,W,J)=>L(W,J,16),stringify:O=>k(O,16,"0x")},{identify:O=>typeof O=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^(?:[-+]?\\.inf|(\\.nan))$/i,resolve:(O,W)=>W?NaN:O[0]==="-"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,stringify:r.stringifyNumber},{identify:O=>typeof O=="number",default:!0,tag:"tag:yaml.org,2002:float",format:"EXP",test:/^[-+]?([0-9][0-9_]*)?(\\.[0-9_]*)?[eE][-+]?[0-9]+$/,resolve:O=>parseFloat(O.replace(/_/g,"")),stringify:O=>{let{value:W}=O;return Number(W).toExponential()}},{identify:O=>typeof O=="number",default:!0,tag:"tag:yaml.org,2002:float",test:/^[-+]?(?:[0-9][0-9_]*)?\\.([0-9_]*)$/,resolve(O,W){let J=new r.Scalar(parseFloat(O.replace(/_/g,"")));if(W){let x=W.replace(/_/g,"");x[x.length-1]==="0"&&(J.minFractionDigits=x.length)}return J},stringify:r.stringifyNumber}],c.binary,c.omap,c.pairs,c.set,c.intTime,c.floatTime,c.timestamp),K={core:s,failsafe:S,json:g,yaml11:$},V={binary:c.binary,bool:q,float:t,floatExp:i,floatNaN:f,floatTime:c.floatTime,int:B,intHex:U,intOct:R,intTime:c.intTime,map:d,null:C,omap:c.omap,pairs:c.pairs,seq:E,set:c.set,timestamp:c.timestamp};function z(O,W,J){if(W){let x=J.filter(re=>re.tag===W),G=x.find(re=>!re.format)||x[0];if(!G)throw new Error(`Tag ${W} not found`);return G}return J.find(x=>(x.identify&&x.identify(O)||x.class&&O instanceof x.class)&&!x.format)}function ae(O,W,J){if(O instanceof r.Node)return O;let{defaultPrefix:x,onTagObj:G,prevObjects:re,schema:_e,wrapScalars:ye}=J;W&&W.startsWith("!!")&&(W=x+W.slice(2));let be=z(O,W,_e.tags);if(!be){if(typeof O.toJSON=="function"&&(O=O.toJSON()),!O||typeof O!="object")return ye?new r.Scalar(O):O;be=O instanceof Map?d:O[Symbol.iterator]?E:d}G&&(G(be),delete J.onTagObj);let ve={value:void 0,node:void 0};if(O&&typeof O=="object"&&re){let Ne=re.get(O);if(Ne){let Pe=new r.Alias(Ne);return J.aliasNodes.push(Pe),Pe}ve.value=O,re.set(O,ve)}return ve.node=be.createNode?be.createNode(J.schema,O,J):ye?new r.Scalar(O):O,W&&ve.node instanceof r.Node&&(ve.node.tag=W),ve.node}function ue(O,W,J,x){let G=O[x.replace(/\\W/g,"")];if(!G){let re=Object.keys(O).map(_e=>JSON.stringify(_e)).join(", ");throw new Error(`Unknown schema "${x}"; use one of ${re}`)}if(Array.isArray(J))for(let re of J)G=G.concat(re);else typeof J=="function"&&(G=J(G.slice()));for(let re=0;re<G.length;++re){let _e=G[re];if(typeof _e=="string"){let ye=W[_e];if(!ye){let be=Object.keys(W).map(ve=>JSON.stringify(ve)).join(", ");throw new Error(`Unknown custom tag "${_e}"; use one of ${be}`)}G[re]=ye}}return G}var pe=(O,W)=>O.key<W.key?-1:O.key>W.key?1:0,ge=class{constructor(O){let{customTags:W,merge:J,schema:x,sortMapEntries:G,tags:re}=O;this.merge=!!J,this.name=x,this.sortMapEntries=G===!0?pe:G||null,!W&&re&&c.warnOptionDeprecation("tags","customTags"),this.tags=ue(K,V,W||re,x)}createNode(O,W,J,x){let G={defaultPrefix:ge.defaultPrefix,schema:this,wrapScalars:W},re=x?Object.assign(x,G):G;return ae(O,J,re)}createPair(O,W,J){J||(J={wrapScalars:!0});let x=this.createNode(O,J.wrapScalars,null,J),G=this.createNode(W,J.wrapScalars,null,J);return new r.Pair(x,G)}};e._defineProperty(ge,"defaultPrefix",e.defaultTagPrefix),e._defineProperty(ge,"defaultTags",e.defaultTags),n.Schema=ge}}),xr=D({"node_modules/yaml/dist/Document-9b4560a1.js"(n){"use strict";Y();var e=Me(),r=ke(),c=it(),h={anchorPrefix:"a",customTags:null,indent:2,indentSeq:!0,keepCstNodes:!1,keepNodeTypes:!0,keepBlobsInJSON:!0,mapAsMap:!1,maxAliasCount:100,prettyErrors:!1,simpleKeys:!1,version:"1.2"},d={get binary(){return r.binaryOptions},set binary(t){Object.assign(r.binaryOptions,t)},get bool(){return r.boolOptions},set bool(t){Object.assign(r.boolOptions,t)},get int(){return r.intOptions},set int(t){Object.assign(r.intOptions,t)},get null(){return r.nullOptions},set null(t){Object.assign(r.nullOptions,t)},get str(){return r.strOptions},set str(t){Object.assign(r.strOptions,t)}},y={"1.0":{schema:"yaml-1.1",merge:!0,tagPrefixes:[{handle:"!",prefix:e.defaultTagPrefix},{handle:"!!",prefix:"tag:private.yaml.org,2002:"}]},1.1:{schema:"yaml-1.1",merge:!0,tagPrefixes:[{handle:"!",prefix:"!"},{handle:"!!",prefix:e.defaultTagPrefix}]},1.2:{schema:"core",merge:!1,tagPrefixes:[{handle:"!",prefix:"!"},{handle:"!!",prefix:e.defaultTagPrefix}]}};function E(t,s){if((t.version||t.options.version)==="1.0"){let g=s.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);if(g)return"!"+g[1];let u=s.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);return u?`!${u[1]}/${u[2]}`:`!${s.replace(/^tag:/,"")}`}let a=t.tagPrefixes.find(g=>s.indexOf(g.prefix)===0);if(!a){let g=t.getDefaults().tagPrefixes;a=g&&g.find(u=>s.indexOf(u.prefix)===0)}if(!a)return s[0]==="!"?s:`!<${s}>`;let m=s.substr(a.prefix.length).replace(/[!,[\\]{}]/g,g=>({"!":"%21",",":"%2C","[":"%5B","]":"%5D","{":"%7B","}":"%7D"})[g]);return a.handle+m}function I(t,s){if(s instanceof r.Alias)return r.Alias;if(s.tag){let g=t.filter(u=>u.tag===s.tag);if(g.length>0)return g.find(u=>u.format===s.format)||g[0]}let a,m;if(s instanceof r.Scalar){m=s.value;let g=t.filter(u=>u.identify&&u.identify(m)||u.class&&m instanceof u.class);a=g.find(u=>u.format===s.format)||g.find(u=>!u.format)}else m=s,a=t.find(g=>g.nodeClass&&m instanceof g.nodeClass);if(!a){let g=m&&m.constructor?m.constructor.name:typeof m;throw new Error(`Tag not resolved for ${g} value`)}return a}function S(t,s,a){let{anchors:m,doc:g}=a,u=[],p=g.anchors.getName(t);return p&&(m[p]=t,u.push(`&${p}`)),t.tag?u.push(E(g,t.tag)):s.default||u.push(E(g,s.tag)),u.join(" ")}function M(t,s,a,m){let{anchors:g,schema:u}=s.doc,p;if(!(t instanceof r.Node)){let $={aliasNodes:[],onTagObj:K=>p=K,prevObjects:new Map};t=u.createNode(t,!0,null,$);for(let K of $.aliasNodes){K.source=K.source.node;let V=g.getName(K.source);V||(V=g.newName(),g.map[V]=K.source)}}if(t instanceof r.Pair)return t.toString(s,a,m);p||(p=I(u.tags,t));let L=S(t,p,s);L.length>0&&(s.indentAtStart=(s.indentAtStart||0)+L.length+1);let k=typeof p.stringify=="function"?p.stringify(t,s,a,m):t instanceof r.Scalar?r.stringifyString(t,s,a,m):t.toString(s,a,m);return L?t instanceof r.Scalar||k[0]==="{"||k[0]==="["?`${L} ${k}`:`${L}\n${s.indent}${k}`:k}var T=class{static validAnchorNode(t){return t instanceof r.Scalar||t instanceof r.YAMLSeq||t instanceof r.YAMLMap}constructor(t){e._defineProperty(this,"map",Object.create(null)),this.prefix=t}createAlias(t,s){return this.setAnchor(t,s),new r.Alias(t)}createMergePair(){let t=new r.Merge;for(var s=arguments.length,a=new Array(s),m=0;m<s;m++)a[m]=arguments[m];return t.value.items=a.map(g=>{if(g instanceof r.Alias){if(g.source instanceof r.YAMLMap)return g}else if(g instanceof r.YAMLMap)return this.createAlias(g);throw new Error("Merge sources must be Map nodes or their Aliases")}),t}getName(t){let{map:s}=this;return Object.keys(s).find(a=>s[a]===t)}getNames(){return Object.keys(this.map)}getNode(t){return this.map[t]}newName(t){t||(t=this.prefix);let s=Object.keys(this.map);for(let a=1;;++a){let m=`${t}${a}`;if(!s.includes(m))return m}}resolveNodes(){let{map:t,_cstAliases:s}=this;Object.keys(t).forEach(a=>{t[a]=t[a].resolved}),s.forEach(a=>{a.source=a.source.resolved}),delete this._cstAliases}setAnchor(t,s){if(t!=null&&!T.validAnchorNode(t))throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");if(s&&/[\\x00-\\x19\\s,[\\]{}]/.test(s))throw new Error("Anchor names must not contain whitespace or control characters");let{map:a}=this,m=t&&Object.keys(a).find(g=>a[g]===t);if(m)if(s)m!==s&&(delete a[m],a[s]=t);else return m;else{if(!s){if(!t)return null;s=this.newName()}a[s]=t}return s}},P=(t,s)=>{if(t&&typeof t=="object"){let{tag:a}=t;t instanceof r.Collection?(a&&(s[a]=!0),t.items.forEach(m=>P(m,s))):t instanceof r.Pair?(P(t.key,s),P(t.value,s)):t instanceof r.Scalar&&a&&(s[a]=!0)}return s},C=t=>Object.keys(P(t,{}));function q(t,s){let a={before:[],after:[]},m,g=!1;for(let u of s)if(u.valueRange){if(m!==void 0){let L="Document contains trailing content not separated by a ... or --- line";t.errors.push(new e.YAMLSyntaxError(u,L));break}let p=r.resolveNode(t,u);g&&(p.spaceBefore=!0,g=!1),m=p}else u.comment!==null?(m===void 0?a.before:a.after).push(u.comment):u.type===e.Type.BLANK_LINE&&(g=!0,m===void 0&&a.before.length>0&&!t.commentBefore&&(t.commentBefore=a.before.join(`\n`),a.before=[]));if(t.contents=m||null,!m)t.comment=a.before.concat(a.after).join(`\n`)||null;else{let u=a.before.join(`\n`);if(u){let p=m instanceof r.Collection&&m.items[0]?m.items[0]:m;p.commentBefore=p.commentBefore?`${u}\n${p.commentBefore}`:u}t.comment=a.after.join(`\n`)||null}}function R(t,s){let{tagPrefixes:a}=t,[m,g]=s.parameters;if(!m||!g){let u="Insufficient parameters given for %TAG directive";throw new e.YAMLSemanticError(s,u)}if(a.some(u=>u.handle===m)){let u="The %TAG directive must only be given at most once per handle in the same document.";throw new e.YAMLSemanticError(s,u)}return{handle:m,prefix:g}}function B(t,s){let[a]=s.parameters;if(s.name==="YAML:1.0"&&(a="1.0"),!a){let m="Insufficient parameters given for %YAML directive";throw new e.YAMLSemanticError(s,m)}if(!y[a]){let g=`Document will be parsed as YAML ${t.version||t.options.version} rather than YAML ${a}`;t.warnings.push(new e.YAMLWarning(s,g))}return a}function U(t,s,a){let m=[],g=!1;for(let u of s){let{comment:p,name:L}=u;switch(L){case"TAG":try{t.tagPrefixes.push(R(t,u))}catch(k){t.errors.push(k)}g=!0;break;case"YAML":case"YAML:1.0":if(t.version){let k="The %YAML directive must only be given at most once per document.";t.errors.push(new e.YAMLSemanticError(u,k))}try{t.version=B(t,u)}catch(k){t.errors.push(k)}g=!0;break;default:if(L){let k=`YAML only supports %TAG and %YAML directives, and not %${L}`;t.warnings.push(new e.YAMLWarning(u,k))}}p&&m.push(p)}if(a&&!g&&(t.version||a.version||t.options.version)==="1.1"){let u=p=>{let{handle:L,prefix:k}=p;return{handle:L,prefix:k}};t.tagPrefixes=a.tagPrefixes.map(u),t.version=a.version}t.commentBefore=m.join(`\n`)||null}function f(t){if(t instanceof r.Collection)return!0;throw new Error("Expected a YAML collection as document contents")}var i=class{constructor(t){this.anchors=new T(t.anchorPrefix),this.commentBefore=null,this.comment=null,this.contents=null,this.directivesEndMarker=null,this.errors=[],this.options=t,this.schema=null,this.tagPrefixes=[],this.version=null,this.warnings=[]}add(t){return f(this.contents),this.contents.add(t)}addIn(t,s){f(this.contents),this.contents.addIn(t,s)}delete(t){return f(this.contents),this.contents.delete(t)}deleteIn(t){return r.isEmptyPath(t)?this.contents==null?!1:(this.contents=null,!0):(f(this.contents),this.contents.deleteIn(t))}getDefaults(){return i.defaults[this.version]||i.defaults[this.options.version]||{}}get(t,s){return this.contents instanceof r.Collection?this.contents.get(t,s):void 0}getIn(t,s){return r.isEmptyPath(t)?!s&&this.contents instanceof r.Scalar?this.contents.value:this.contents:this.contents instanceof r.Collection?this.contents.getIn(t,s):void 0}has(t){return this.contents instanceof r.Collection?this.contents.has(t):!1}hasIn(t){return r.isEmptyPath(t)?this.contents!==void 0:this.contents instanceof r.Collection?this.contents.hasIn(t):!1}set(t,s){f(this.contents),this.contents.set(t,s)}setIn(t,s){r.isEmptyPath(t)?this.contents=s:(f(this.contents),this.contents.setIn(t,s))}setSchema(t,s){if(!t&&!s&&this.schema)return;typeof t=="number"&&(t=t.toFixed(1)),t==="1.0"||t==="1.1"||t==="1.2"?(this.version?this.version=t:this.options.version=t,delete this.options.schema):t&&typeof t=="string"&&(this.options.schema=t),Array.isArray(s)&&(this.options.customTags=s);let a=Object.assign({},this.getDefaults(),this.options);this.schema=new c.Schema(a)}parse(t,s){this.options.keepCstNodes&&(this.cstNode=t),this.options.keepNodeTypes&&(this.type="DOCUMENT");let{directives:a=[],contents:m=[],directivesEndMarker:g,error:u,valueRange:p}=t;if(u&&(u.source||(u.source=this),this.errors.push(u)),U(this,a,s),g&&(this.directivesEndMarker=!0),this.range=p?[p.start,p.end]:null,this.setSchema(),this.anchors._cstAliases=[],q(this,m),this.anchors.resolveNodes(),this.options.prettyErrors){for(let L of this.errors)L instanceof e.YAMLError&&L.makePretty();for(let L of this.warnings)L instanceof e.YAMLError&&L.makePretty()}return this}listNonDefaultTags(){return C(this.contents).filter(t=>t.indexOf(c.Schema.defaultPrefix)!==0)}setTagPrefix(t,s){if(t[0]!=="!"||t[t.length-1]!=="!")throw new Error("Handle must start and end with !");if(s){let a=this.tagPrefixes.find(m=>m.handle===t);a?a.prefix=s:this.tagPrefixes.push({handle:t,prefix:s})}else this.tagPrefixes=this.tagPrefixes.filter(a=>a.handle!==t)}toJSON(t,s){let{keepBlobsInJSON:a,mapAsMap:m,maxAliasCount:g}=this.options,u=a&&(typeof t!="string"||!(this.contents instanceof r.Scalar)),p={doc:this,indentStep:"  ",keep:u,mapAsMap:u&&!!m,maxAliasCount:g,stringify:M},L=Object.keys(this.anchors.map);L.length>0&&(p.anchors=new Map(L.map($=>[this.anchors.map[$],{alias:[],aliasCount:0,count:1}])));let k=r.toJSON(this.contents,t,p);if(typeof s=="function"&&p.anchors)for(let{count:$,res:K}of p.anchors.values())s(K,$);return k}toString(){if(this.errors.length>0)throw new Error("Document with errors cannot be stringified");let t=this.options.indent;if(!Number.isInteger(t)||t<=0){let L=JSON.stringify(t);throw new Error(`"indent" option must be a positive integer, not ${L}`)}this.setSchema();let s=[],a=!1;if(this.version){let L="%YAML 1.2";this.schema.name==="yaml-1.1"&&(this.version==="1.0"?L="%YAML:1.0":this.version==="1.1"&&(L="%YAML 1.1")),s.push(L),a=!0}let m=this.listNonDefaultTags();this.tagPrefixes.forEach(L=>{let{handle:k,prefix:$}=L;m.some(K=>K.indexOf($)===0)&&(s.push(`%TAG ${k} ${$}`),a=!0)}),(a||this.directivesEndMarker)&&s.push("---"),this.commentBefore&&((a||!this.directivesEndMarker)&&s.unshift(""),s.unshift(this.commentBefore.replace(/^/gm,"#")));let g={anchors:Object.create(null),doc:this,indent:"",indentStep:" ".repeat(t),stringify:M},u=!1,p=null;if(this.contents){this.contents instanceof r.Node&&(this.contents.spaceBefore&&(a||this.directivesEndMarker)&&s.push(""),this.contents.commentBefore&&s.push(this.contents.commentBefore.replace(/^/gm,"#")),g.forceBlockIndent=!!this.comment,p=this.contents.comment);let L=p?null:()=>u=!0,k=M(this.contents,g,()=>p=null,L);s.push(r.addComment(k,"",p))}else this.contents!==void 0&&s.push(M(this.contents,g));return this.comment&&((!u||p)&&s[s.length-1]!==""&&s.push(""),s.push(this.comment.replace(/^/gm,"#"))),s.join(`\n`)+`\n`}};e._defineProperty(i,"defaults",y),n.Document=i,n.defaultOptions=h,n.scalarOptions=d}}),Hr=D({"node_modules/yaml/dist/index.js"(n){"use strict";Y();var e=Jr(),r=xr(),c=it(),h=Me(),d=st();ke();function y(C){let q=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0,R=arguments.length>2?arguments[2]:void 0;R===void 0&&typeof q=="string"&&(R=q,q=!0);let B=Object.assign({},r.Document.defaults[r.defaultOptions.version],r.defaultOptions);return new c.Schema(B).createNode(C,q,R)}var E=class extends r.Document{constructor(C){super(Object.assign({},r.defaultOptions,C))}};function I(C,q){let R=[],B;for(let U of e.parse(C)){let f=new E(q);f.parse(U,B),R.push(f),B=f}return R}function S(C,q){let R=e.parse(C),B=new E(q).parse(R[0]);if(R.length>1){let U="Source contains multiple documents; please use YAML.parseAllDocuments()";B.errors.unshift(new h.YAMLSemanticError(R[1],U))}return B}function M(C,q){let R=S(C,q);if(R.warnings.forEach(B=>d.warn(B)),R.errors.length>0)throw R.errors[0];return R.toJSON()}function T(C,q){let R=new E(q);return R.contents=C,String(R)}var P={createNode:y,defaultOptions:r.defaultOptions,Document:E,parse:M,parseAllDocuments:I,parseCST:e.parse,parseDocument:S,scalarOptions:r.scalarOptions,stringify:T};n.YAML=P}}),Ue=D({"node_modules/yaml/index.js"(n,e){Y(),e.exports=Hr().YAML}}),Gr=D({"node_modules/yaml/dist/util.js"(n){"use strict";Y();var e=ke(),r=Me();n.findPair=e.findPair,n.parseMap=e.resolveMap,n.parseSeq=e.resolveSeq,n.stringifyNumber=e.stringifyNumber,n.stringifyString=e.stringifyString,n.toJSON=e.toJSON,n.Type=r.Type,n.YAMLError=r.YAMLError,n.YAMLReferenceError=r.YAMLReferenceError,n.YAMLSemanticError=r.YAMLSemanticError,n.YAMLSyntaxError=r.YAMLSyntaxError,n.YAMLWarning=r.YAMLWarning}}),zr=D({"node_modules/yaml/util.js"(n){Y();var e=Gr();n.findPair=e.findPair,n.toJSON=e.toJSON,n.parseMap=e.parseMap,n.parseSeq=e.parseSeq,n.stringifyNumber=e.stringifyNumber,n.stringifyString=e.stringifyString,n.Type=e.Type,n.YAMLError=e.YAMLError,n.YAMLReferenceError=e.YAMLReferenceError,n.YAMLSemanticError=e.YAMLSemanticError,n.YAMLSyntaxError=e.YAMLSyntaxError,n.YAMLWarning=e.YAMLWarning}}),Zr=D({"node_modules/yaml-unist-parser/lib/yaml.js"(n){"use strict";Y(),n.__esModule=!0;var e=Ue();n.Document=e.Document;var r=Ue();n.parseCST=r.parseCST;var c=zr();n.YAMLError=c.YAMLError,n.YAMLSyntaxError=c.YAMLSyntaxError,n.YAMLSemanticError=c.YAMLSemanticError}}),Xr=D({"node_modules/yaml-unist-parser/lib/parse.js"(n){"use strict";Y(),n.__esModule=!0;var e=Kt(),r=xt(),c=Ht(),h=Gt(),d=Br(),y=He(),E=Yr(),I=Fr(),S=Wr(),M=Vr(),T=Qr(),P=Kr(),C=Zr();function q(R){var B=C.parseCST(R);M.addOrigRange(B);for(var U=B.map(function(k){return new C.Document({merge:!1,keepCstNodes:!0}).parse(k)}),f=new e.default(R),i=[],t={text:R,locator:f,comments:i,transformOffset:function(k){return I.transformOffset(k,t)},transformRange:function(k){return S.transformRange(k,t)},transformNode:function(k){return d.transformNode(k,t)},transformContent:function(k){return y.transformContent(k,t)}},s=0,a=U;s<a.length;s++)for(var m=a[s],g=0,u=m.errors;g<u.length;g++){var p=u[g];if(!(p instanceof C.YAMLSemanticError&&p.message===\'Map keys must be unique; "<<" is repeated\'))throw E.transformError(p,t)}U.forEach(function(k){return h.removeCstBlankLine(k.cstNode)});var L=c.createRoot(t.transformRange({origStart:0,origEnd:t.text.length}),U.map(t.transformNode),i);return r.attachComments(L),P.updatePositions(L),T.removeFakeNodes(L),L}n.parse=q}}),en=D({"node_modules/yaml-unist-parser/lib/index.js"(n){"use strict";Y(),n.__esModule=!0;var e=(ie(),se(te));e.__exportStar(Xr(),n)}});Y();var tn=Mt(),{hasPragma:rn}=Ot(),{locStart:nn,locEnd:sn}=Lt();function an(n){let{parse:e}=en();try{let r=e(n);return delete r.comments,r}catch(r){throw r!=null&&r.position?tn(r.message,r.position):r}}var on={astFormat:"yaml",parse:an,hasPragma:rn,locStart:nn,locEnd:sn};at.exports={parsers:{yaml:on}}});return ln();});\n\n//# sourceURL=webpack:///../node_modules/.pnpm/prettier@2.8.7/node_modules/prettier/parser-yaml.js?')},6663:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst core = __importStar(__webpack_require__(8117));\nconst path = __importStar(__webpack_require__(1017));\nconst src_1 = __webpack_require__(6633);\nasync function run() {\n    let rootPath = process.env['GITHUB_WORKSPACE'];\n    let relativeToRoot = core.getInput('root', { trimWhitespace: true });\n    if (relativeToRoot) {\n        rootPath = path.resolve(rootPath, relativeToRoot);\n    }\n    let schemaMapping;\n    let inputSchemaMapping = core.getInput('schemaMapping');\n    if (inputSchemaMapping) {\n        schemaMapping = JSON.parse(inputSchemaMapping);\n        console.log('Using schema mapping:', schemaMapping);\n    }\n    let yamlVersionInput = core.getInput('yamlVersion');\n    let yamlVersion = yamlVersionInput == '' ? undefined : yamlVersionInput;\n    if (yamlVersion) {\n        console.log('Using YAML specification version:', yamlVersion);\n    }\n    const results = await (0, src_1.validateDirectory)({ yamlVersion }, rootPath, schemaMapping);\n    if (results && results.length > 0) {\n        for (const result of results) {\n            for (const error of result.error) {\n                core.error(`${result.filePath}:${error.range.start.line + 1}:${error.range.start.character + 1}: ${error.message}`, {\n                    title: error.message,\n                    file: result.filePath,\n                    startLine: error.range.start.line,\n                    endLine: error.range.end.line,\n                    startColumn: error.range.start.character,\n                    endColumn: error.range.end.character,\n                });\n            }\n        }\n        core.setFailed(`${results.length} file(s) failed validation`);\n        core.setOutput('invalidFiles', results.map((result) => result.filePath));\n    }\n}\ntry {\n    run();\n}\ncatch (error) {\n    core.setFailed(error.message);\n}\n\n\n//# sourceURL=webpack:///./index.ts?")},6633:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n__exportStar(__webpack_require__(223), exports);\n\n\n//# sourceURL=webpack:///../src/index.ts?')},223:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateWithSchema = exports.validateDirectory = exports.getValidationResults = exports.ConsoleTelemetry = void 0;\nconst fs = __importStar(__webpack_require__(7147));\nconst path = __importStar(__webpack_require__(1017));\nconst yamlSchemaService_1 = __webpack_require__(7188);\nconst yamlValidation_1 = __webpack_require__(4882);\nconst vscode_languageserver_textdocument_1 = __webpack_require__(1793);\nconst util_1 = __webpack_require__(6584);\nconst schema_handler_1 = __webpack_require__(4252);\nconst glob_1 = __webpack_require__(2360);\nclass ConsoleTelemetry {\n    constructor() { }\n    send(event) {\n        console.error('send:', event);\n    }\n    sendError(name, properties) {\n        console.error('sendError:', name, properties);\n    }\n    sendTrack(name, properties) {\n        console.error('sendTrack:', name, properties);\n    }\n}\nexports.ConsoleTelemetry = ConsoleTelemetry;\nfunction hasRootDir(settings) {\n    return (settings === null || settings === void 0 ? void 0 : settings.rootDir) !== undefined;\n}\nfunction hasSchema(settings) {\n    return (settings === null || settings === void 0 ? void 0 : settings.schema) !== undefined;\n}\n/**\n * Validates YAML files given with the specified settings.\n * @param files Paths to files to validate.\n * @param settings Settings defining how the files should be validated, and against which schemas.\n * @returns A list errors found in the files.\n */\nasync function getValidationResults(files, settings) {\n    var _a;\n    let workspaceContext;\n    let schemaMapping = {};\n    let rootPath;\n    if (hasRootDir(settings)) {\n        rootPath = settings.rootDir;\n        workspaceContext = {\n            resolveRelativePath: (relativePath, resource) => {\n                return path.join(settings.rootDir, path.dirname(resource), relativePath);\n            },\n        };\n        if (settings.schemaMapping) {\n            schemaMapping = settings.schemaMapping;\n        }\n        else {\n            const settingsPath = path.join(settings.rootDir, '.vscode', 'settings.json');\n            if (fs.existsSync(settingsPath)) {\n                schemaMapping = (0, util_1.readJson)(settingsPath)['yaml.schemas'];\n            }\n        }\n    }\n    else if (hasSchema(settings)) {\n        schemaMapping = {\n            [settings.schema]: '*',\n        };\n        workspaceContext = {\n            resolveRelativePath: (relativePath, resource) => {\n                return path.join(path.dirname(resource), relativePath);\n            },\n        };\n    }\n    const schemaService = new yamlSchemaService_1.YAMLSchemaService((0, schema_handler_1.createSchemaRequestHandler)(rootPath), workspaceContext);\n    for (const uri in schemaMapping) {\n        schemaService.addSchemaPriority(uri, 0);\n        let patterns = schemaMapping[uri];\n        if (!(patterns instanceof Array)) {\n            patterns = [patterns];\n        }\n        schemaService.registerExternalSchema(uri, patterns);\n    }\n    const yamlValidation = new yamlValidation_1.YAMLValidation(schemaService, new ConsoleTelemetry());\n    yamlValidation.configure({\n        validate: true,\n        yamlVersion: (_a = settings === null || settings === void 0 ? void 0 : settings.yamlVersion) !== null && _a !== void 0 ? _a : '1.2',\n        disableAdditionalProperties: false,\n        customTags: [],\n    });\n    return await Promise.all(files.map(async (relativePath) => {\n        const filePath = rootPath ? path.join(rootPath, relativePath) : relativePath;\n        const doc = vscode_languageserver_textdocument_1.TextDocument.create(relativePath, 'yaml', 0, fs.readFileSync(filePath).toString());\n        return await yamlValidation.doValidation(doc).then((error) => ({ filePath, error }));\n    })).then((rs) => rs.filter((r) => r.error.length > 0));\n}\nexports.getValidationResults = getValidationResults;\n/**\n * Validates the files with the given settings.\n * @param files Paths to files to validate.\n * @param settings Settings defining how the files should be validated, and against which schemas.\n * @returns A list errors found in the files.\n */\nasync function validateAndOutput(files, settings) {\n    console.log(`Validating ${files.length} YAML files.`);\n    const results = await getValidationResults(files, settings);\n    if (results.length == 0) {\n        console.log(`Validation complete.`);\n        return;\n    }\n    console.error('Found invalid files:');\n    for (const result of results) {\n        for (const error of result.error) {\n            console.error(`${result.filePath}:${error.range.start.line + 1}:${error.range.start.character + 1}: ${error.message}`);\n        }\n    }\n    return results;\n}\n/**\n * Validates all YAML files found in the given directory.\n * It will automatically use the schema mapping in .vscode/settings.json, if present.\n * @param rootDir Path to root directory containing the YAML files to be validated.\n * @returns A list errors found in the files.\n */\nasync function validateDirectory(settings, rootDir, schemaMapping) {\n    console.log(`Looking for YAML files to validate at: ${rootDir}`);\n    const filePaths = await new Promise((callback, error) => {\n        (0, glob_1.glob)('**/*.{yml,yaml}', { cwd: rootDir, silent: true, nodir: true }, (err, files) => {\n            if (err) {\n                error(err);\n            }\n            callback(files);\n        });\n    });\n    return validateAndOutput(filePaths, { ...settings, rootDir, schemaMapping });\n}\nexports.validateDirectory = validateDirectory;\n/**\n * Validates any files matching the given pattern(s) against the given schema.\n * @param schema Path to schema file.\n * @param patterns List of glob patterns to files to validate with the given schema.\n * @returns A list errors found in the files.\n */\nasync function validateWithSchema(settings, schema, ...patterns) {\n    const files = await Promise.all(patterns.map((pattern) => new Promise((callback, error) => {\n        (0, glob_1.glob)(pattern, { silent: true, nodir: true }, (err, files) => {\n            if (err) {\n                error(err);\n            }\n            callback(files);\n        });\n    }))).then((filesArrays) => filesArrays.flat());\n    return validateAndOutput(files, { ...settings, schema });\n}\nexports.validateWithSchema = validateWithSchema;\n\n\n//# sourceURL=webpack:///../src/lib.ts?")},4252:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createSchemaRequestHandler = void 0;\nconst fs = __importStar(__webpack_require__(7147));\nconst https = __importStar(__webpack_require__(5687));\nconst vscode_uri_1 = __webpack_require__(5472);\nconst paths_1 = __webpack_require__(6614);\nconst util_1 = __webpack_require__(6584);\nfunction createSchemaRequestHandler(rootPath) {\n    return async (uri) => {\n        if (!uri) {\n            return Promise.reject('No schema specified');\n        }\n        // If the requested schema URI is a relative file path\n        // Convert it into a proper absolute path URI\n        if (rootPath && (0, paths_1.isRelativePath)(uri)) {\n            uri = (0, util_1.relativeToAbsolutePath)(rootPath, uri);\n        }\n        let scheme = vscode_uri_1.URI.parse(uri).scheme.toLowerCase();\n        // test if uri is windows path, ie starts with 'c:\\'\n        if (/^[a-z]:[\\\\/]/i.test(uri)) {\n            const winUri = vscode_uri_1.URI.file(uri);\n            scheme = winUri.scheme.toLowerCase();\n            uri = winUri.toString();\n        }\n        // If the requested schema is a local file, read and return the file contents\n        if (scheme === 'file') {\n            return new Promise((callback, error) => {\n                const fsPath = (0, util_1.trimStartChars)(vscode_uri_1.URI.parse(uri).fsPath, '\\\\');\n                fs.readFile(fsPath, (err, result) => {\n                    // If there was an error reading the file, return empty error message\n                    // Otherwise return the file contents as a string\n                    if (err) {\n                        console.error(`Could not find schema file at: ${fsPath}`);\n                    }\n                    return err ? error('') : callback(result.toString());\n                });\n            });\n        }\n        // Fall back to fetching with a GET request\n        return new Promise((callback, error) => {\n            let chunks = [];\n            const request = https.get(uri, (res) => {\n                res.setEncoding('utf8');\n                res.on('data', (data) => {\n                    chunks.push(data.toString());\n                });\n                res.on('end', () => {\n                    callback(chunks.join(''));\n                });\n            });\n            request.on('error', (err) => error(err));\n            request.end();\n        });\n    };\n}\nexports.createSchemaRequestHandler = createSchemaRequestHandler;\n\n\n//# sourceURL=webpack:///../src/schema-handler.ts?")},6584:function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.readJson = exports.relativeToAbsolutePath = exports.trimStartChars = void 0;\nconst fs = __importStar(__webpack_require__(7147));\nconst path = __importStar(__webpack_require__(1017));\nconst vscode_uri_1 = __webpack_require__(5472);\nfunction trimStartChars(str, ch) {\n    let start = 0;\n    while (start < str.length && str[start] === ch)\n        ++start;\n    return start > 0 ? str.substring(start) : str;\n}\nexports.trimStartChars = trimStartChars;\nconst relativeToAbsolutePath = (rootPath, uri) => {\n    // If a root folder was not specified, resolve the relative URI\n    // Against the location of the workspace file instead\n    if (rootPath) {\n        return vscode_uri_1.URI.file(path.join(rootPath, vscode_uri_1.URI.parse(uri).fsPath)).toString();\n    }\n    // Fallback in case nothing could be applied\n    return path.normalize(uri);\n};\nexports.relativeToAbsolutePath = relativeToAbsolutePath;\nfunction readJson(path) {\n    return JSON.parse(fs.readFileSync(path).toString());\n}\nexports.readJson = readJson;\n\n\n//# sourceURL=webpack:///../src/util.ts?')},4251:(module,__unused_webpack_exports,__webpack_require__)=>{eval("module.exports = __webpack_require__(8542);\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js?")},8542:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar net = __webpack_require__(1808);\nvar tls = __webpack_require__(4404);\nvar http = __webpack_require__(3685);\nvar https = __webpack_require__(5687);\nvar events = __webpack_require__(2361);\nvar assert = __webpack_require__(9491);\nvar util = __webpack_require__(3837);\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js?")},5648:function(__unused_webpack_module,exports){eval('/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, (function (exports) { \'use strict\';\n\nfunction merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n        sets[_key] = arguments[_key];\n    }\n\n    if (sets.length > 1) {\n        sets[0] = sets[0].slice(0, -1);\n        var xl = sets.length - 1;\n        for (var x = 1; x < xl; ++x) {\n            sets[x] = sets[x].slice(1, -1);\n        }\n        sets[xl] = sets[xl].slice(1);\n        return sets.join(\'\');\n    } else {\n        return sets[0];\n    }\n}\nfunction subexp(str) {\n    return "(?:" + str + ")";\n}\nfunction typeOf(o) {\n    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();\n}\nfunction toUpperCase(str) {\n    return str.toUpperCase();\n}\nfunction toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n}\nfunction assign(target, source) {\n    var obj = target;\n    if (source) {\n        for (var key in source) {\n            obj[key] = source[key];\n        }\n    }\n    return obj;\n}\n\nfunction buildExps(isIRI) {\n    var ALPHA$$ = "[A-Za-z]",\n        CR$ = "[\\\\x0D]",\n        DIGIT$$ = "[0-9]",\n        DQUOTE$$ = "[\\\\x22]",\n        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),\n        //case-insensitive\n    LF$$ = "[\\\\x0A]",\n        SP$$ = "[\\\\x20]",\n        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),\n        //expanded\n    GEN_DELIMS$$ = "[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]",\n        SUB_DELIMS$$ = "[\\\\!\\\\$\\\\&\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]",\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n        UCSCHAR$$ = isIRI ? "[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]" : "[]",\n        //subset, excludes bidi control characters\n    IPRIVATE$$ = isIRI ? "[\\\\uE000-\\\\uF8FF]" : "[]",\n        //subset\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\\\-\\\\.\\\\_\\\\~]", UCSCHAR$$),\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\\\+\\\\-\\\\.]") + "*"),\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\\\:]")) + "*"),\n        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),\n        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),\n        //relaxed parsing rules\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\\\." + DEC_OCTET_RELAXED$ + "\\\\." + DEC_OCTET_RELAXED$ + "\\\\." + DEC_OCTET_RELAXED$),\n        H16$ = subexp(HEXDIG$$ + "{1,4}"),\n        LS32$ = subexp(subexp(H16$ + "\\\\:" + H16$) + "|" + IPV4ADDRESS$),\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\\\:") + "{6}" + LS32$),\n        //                           6( h16 ":" ) ls32\n    IPV6ADDRESS2$ = subexp("\\\\:\\\\:" + subexp(H16$ + "\\\\:") + "{5}" + LS32$),\n        //                      "::" 5( h16 ":" ) ls32\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\\\:\\\\:" + subexp(H16$ + "\\\\:") + "{4}" + LS32$),\n        //[               h16 ] "::" 4( h16 ":" ) ls32\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,1}" + H16$) + "?\\\\:\\\\:" + subexp(H16$ + "\\\\:") + "{3}" + LS32$),\n        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,2}" + H16$) + "?\\\\:\\\\:" + subexp(H16$ + "\\\\:") + "{2}" + LS32$),\n        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,3}" + H16$) + "?\\\\:\\\\:" + H16$ + "\\\\:" + LS32$),\n        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,4}" + H16$) + "?\\\\:\\\\:" + LS32$),\n        //[ *4( h16 ":" ) h16 ] "::"              ls32\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,5}" + H16$) + "?\\\\:\\\\:" + H16$),\n        //[ *5( h16 ":" ) h16 ] "::"              h16\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\\\:") + "{0,6}" + H16$) + "?\\\\:\\\\:"),\n        //[ *6( h16 ":" ) h16 ] "::"\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),\n        //RFC 6874\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\\\%25" + ZONEID$),\n        //RFC 6874\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\\\%25|\\\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),\n        //RFC 6874, with relaxed parsing rules\n    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\\\:]") + "+"),\n        IP_LITERAL$ = subexp("\\\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\\\]"),\n        //RFC 6874\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),\n        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),\n        PORT$ = subexp(DIGIT$$ + "*"),\n        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\\\:" + PORT$) + "?"),\n        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\\\:\\\\@]")),\n        SEGMENT$ = subexp(PCHAR$ + "*"),\n        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\\\@]")) + "+"),\n        PATH_ABEMPTY$ = subexp(subexp("\\\\/" + SEGMENT$) + "*"),\n        PATH_ABSOLUTE$ = subexp("\\\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),\n        //simplified\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",\n        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),\n        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\\\/\\\\?]", IPRIVATE$$)) + "*"),\n        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\\\/\\\\?]") + "*"),\n        HIER_PART$ = subexp(subexp("\\\\/\\\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),\n        URI$ = subexp(SCHEME$ + "\\\\:" + HIER_PART$ + subexp("\\\\?" + QUERY$) + "?" + subexp("\\\\#" + FRAGMENT$) + "?"),\n        RELATIVE_PART$ = subexp(subexp("\\\\/\\\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\\\?" + QUERY$) + "?" + subexp("\\\\#" + FRAGMENT$) + "?"),\n        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),\n        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\\\:" + HIER_PART$ + subexp("\\\\?" + QUERY$) + "?"),\n        GENERIC_REF$ = "^(" + SCHEME$ + ")\\\\:" + subexp(subexp("\\\\/\\\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\\\?(" + QUERY$ + ")") + "?" + subexp("\\\\#(" + FRAGMENT$ + ")") + "?$",\n        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\\\/\\\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\\\?(" + QUERY$ + ")") + "?" + subexp("\\\\#(" + FRAGMENT$ + ")") + "?$",\n        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\\\:" + subexp(subexp("\\\\/\\\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\\\?(" + QUERY$ + ")") + "?$",\n        SAMEDOC_REF$ = "^" + subexp("\\\\#(" + FRAGMENT$ + ")") + "?$",\n        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\\\:(" + PORT$ + ")") + "?$";\n    return {\n        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\\\+\\\\-\\\\.]"), "g"),\n        NOT_USERINFO: new RegExp(merge("[^\\\\%\\\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),\n        NOT_HOST: new RegExp(merge("[^\\\\%\\\\[\\\\]\\\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),\n        NOT_PATH: new RegExp(merge("[^\\\\%\\\\/\\\\:\\\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),\n        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\\\%\\\\/\\\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),\n        NOT_QUERY: new RegExp(merge("[^\\\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\\\:\\\\@\\\\/\\\\?]", IPRIVATE$$), "g"),\n        NOT_FRAGMENT: new RegExp(merge("[^\\\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\\\:\\\\@\\\\/\\\\?]"), "g"),\n        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),\n        UNRESERVED: new RegExp(UNRESERVED$$, "g"),\n        OTHER_CHARS: new RegExp(merge("[^\\\\%]", UNRESERVED$$, RESERVED$$), "g"),\n        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),\n        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),\n        IPV6ADDRESS: new RegExp("^\\\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\\\%25|\\\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\\\]?$") //RFC 6874, with relaxed parsing rules\n    };\n}\nvar URI_PROTOCOL = buildExps(false);\n\nvar IRI_PROTOCOL = buildExps(true);\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i["return"]) _i["return"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError("Invalid attempt to destructure non-iterable instance");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/** Highest positive signed 32-bit float value */\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = \'-\'; // \'\\x2D\'\n\n/** Regular expressions */\nvar regexPunycode = /^xn--/;\nvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nvar errors = {\n\t\'overflow\': \'Overflow: input needs wider integers to process\',\n\t\'not-basic\': \'Illegal input >= 0x80 (not a basic code point)\',\n\t\'invalid-input\': \'Invalid input\'\n};\n\n/** Convenience shortcuts */\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error$1(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tvar result = [];\n\tvar length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tvar parts = string.split(\'@\');\n\tvar result = \'\';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + \'@\';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, \'\\x2E\');\n\tvar labels = string.split(\'.\');\n\tvar encoded = map(labels, fn).join(\'.\');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It\'s a high surrogate, and there is a next character.\n\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t// Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It\'s an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nvar ucs2encode = function ucs2encode(array) {\n\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\n};\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nvar basicToDigit = function basicToDigit(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nvar digitToBasic = function digitToBasic(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nvar adapt = function adapt(delta, numPoints, firstTime) {\n\tvar k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nvar decode = function decode(input) {\n\t// Don\'t use UCS-2.\n\tvar output = [];\n\tvar inputLength = input.length;\n\tvar i = 0;\n\tvar n = initialN;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tvar basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (var j = 0; j < basic; ++j) {\n\t\t// if it\'s not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror$1(\'not-basic\');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tvar oldi = i;\n\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror$1(\'invalid-input\');\n\t\t\t}\n\n\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror$1(\'overflow\');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror$1(\'overflow\');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\t\t}\n\n\t\tvar out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we\'ll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror$1(\'overflow\');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\t}\n\n\treturn String.fromCodePoint.apply(String, output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nvar encode = function encode(input) {\n\tvar output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tvar inputLength = input.length;\n\n\t// Initialize the state.\n\tvar n = initialN;\n\tvar delta = 0;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points.\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar _currentValue2 = _step.value;\n\n\t\t\tif (_currentValue2 < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar basicLength = output.length;\n\tvar handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it\'s empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tvar m = maxInt;\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar currentValue = _step2.value;\n\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder\'s <n,i> state to <m,0>,\n\t\t\t// but guard against overflow.\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror$1(\'overflow\');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tvar _iteratorNormalCompletion3 = true;\n\t\tvar _didIteratorError3 = false;\n\t\tvar _iteratorError3 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\tvar _currentValue = _step3.value;\n\n\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror$1(\'overflow\');\n\t\t\t\t}\n\t\t\t\tif (_currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\t\tvar q = delta;\n\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\n\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar qMinusT = q - t;\n\t\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError3 = true;\n\t\t\t_iteratorError3 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t_iterator3.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\t}\n\treturn output.join(\'\');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn\'t matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nvar toUnicode = function toUnicode(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn\'t matter if you call it with a domain that\'s already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nvar toASCII = function toASCII(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexNonASCII.test(string) ? \'xn--\' + encode(string) : string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nvar punycode = {\n\t/**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */\n\t\'version\': \'2.1.0\',\n\t/**\n  * An object of methods to convert from JavaScript\'s internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */\n\t\'ucs2\': {\n\t\t\'decode\': ucs2decode,\n\t\t\'encode\': ucs2encode\n\t},\n\t\'decode\': decode,\n\t\'encode\': encode,\n\t\'toASCII\': toASCII,\n\t\'toUnicode\': toUnicode\n};\n\n/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS\'\' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nvar SCHEMES = {};\nfunction pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n}\nfunction pctDecChars(str) {\n    var newStr = "";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n        var c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n            newStr += String.fromCharCode(c);\n            i += 3;\n        } else if (c >= 194 && c < 224) {\n            if (il - i >= 6) {\n                var c2 = parseInt(str.substr(i + 4, 2), 16);\n                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n            } else {\n                newStr += str.substr(i, 6);\n            }\n            i += 6;\n        } else if (c >= 224) {\n            if (il - i >= 9) {\n                var _c = parseInt(str.substr(i + 4, 2), 16);\n                var c3 = parseInt(str.substr(i + 7, 2), 16);\n                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n            } else {\n                newStr += str.substr(i, 9);\n            }\n            i += 9;\n        } else {\n            newStr += str.substr(i, 3);\n            i += 3;\n        }\n    }\n    return newStr;\n}\nfunction _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n}\n\nfunction _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, "$1") || "0";\n}\nfunction _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n    var _matches = slicedToArray(matches, 2),\n        address = _matches[1];\n\n    if (address) {\n        return address.split(".").map(_stripLeadingZeros).join(".");\n    } else {\n        return host;\n    }\n}\nfunction _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n    var _matches2 = slicedToArray(matches, 3),\n        address = _matches2[1],\n        zone = _matches2[2];\n\n    if (address) {\n        var _address$toLowerCase$ = address.toLowerCase().split(\'::\').reverse(),\n            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n            last = _address$toLowerCase$2[0],\n            first = _address$toLowerCase$2[1];\n\n        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];\n        var lastFields = last.split(":").map(_stripLeadingZeros);\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        var lastFieldsStart = lastFields.length - fieldCount;\n        var fields = Array(fieldCount);\n        for (var x = 0; x < fieldCount; ++x) {\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || \'\';\n        }\n        if (isLastFieldIPv4Address) {\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        var allZeroFields = fields.reduce(function (acc, field, index) {\n            if (!field || field === "0") {\n                var lastLongest = acc[acc.length - 1];\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                    lastLongest.length++;\n                } else {\n                    acc.push({ index: index, length: 1 });\n                }\n            }\n            return acc;\n        }, []);\n        var longestZeroFields = allZeroFields.sort(function (a, b) {\n            return b.length - a.length;\n        })[0];\n        var newHost = void 0;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n            var newFirst = fields.slice(0, longestZeroFields.index);\n            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n            newHost = newFirst.join(":") + "::" + newLast.join(":");\n        } else {\n            newHost = fields.join(":");\n        }\n        if (zone) {\n            newHost += "%" + zone;\n        }\n        return newHost;\n    } else {\n        return host;\n    }\n}\nvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nvar NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;\nfunction parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n            //store each component\n            components.scheme = matches[1];\n            components.userinfo = matches[3];\n            components.host = matches[4];\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || "";\n            components.query = matches[7];\n            components.fragment = matches[8];\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = matches[5];\n            }\n        } else {\n            //IE FIX for improper RegExp matching\n            //store each component\n            components.scheme = matches[1] || undefined;\n            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;\n            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || "";\n            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;\n            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n            }\n        }\n        if (components.host) {\n            //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        //determine reference type\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n            components.reference = "same-document";\n        } else if (components.scheme === undefined) {\n            components.reference = "relative";\n        } else if (components.fragment === undefined) {\n            components.reference = "absolute";\n        } else {\n            components.reference = "uri";\n        }\n        //check for reference errors\n        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {\n            components.error = components.error || "URI is not a " + options.reference + " reference.";\n        }\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];\n        //check if scheme can\'t handle IRIs\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n            //if host component is a domain name\n            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                } catch (e) {\n                    components.error = components.error || "Host\'s domain name can not be converted to ASCII via punycode: " + e;\n                }\n            }\n            //convert IRI -> URI\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\n        } else {\n            //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n        }\n        //perform scheme specific parsing\n        if (schemeHandler && schemeHandler.parse) {\n            schemeHandler.parse(components, options);\n        }\n    } else {\n        components.error = components.error || "URI can not be parsed.";\n    }\n    return components;\n}\n\nfunction _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push("@");\n    }\n    if (components.host !== undefined) {\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";\n        }));\n    }\n    if (typeof components.port === "number" || typeof components.port === "string") {\n        uriTokens.push(":");\n        uriTokens.push(String(components.port));\n    }\n    return uriTokens.length ? uriTokens.join("") : undefined;\n}\n\nvar RDS1 = /^\\.\\.?\\//;\nvar RDS2 = /^\\/\\.(\\/|$)/;\nvar RDS3 = /^\\/\\.\\.(\\/|$)/;\nvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nfunction removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n        if (input.match(RDS1)) {\n            input = input.replace(RDS1, "");\n        } else if (input.match(RDS2)) {\n            input = input.replace(RDS2, "/");\n        } else if (input.match(RDS3)) {\n            input = input.replace(RDS3, "/");\n            output.pop();\n        } else if (input === "." || input === "..") {\n            input = "";\n        } else {\n            var im = input.match(RDS5);\n            if (im) {\n                var s = im[0];\n                input = input.slice(s.length);\n                output.push(s);\n            } else {\n                throw new Error("Unexpected dot segment condition");\n            }\n        }\n    }\n    return output.join("");\n}\n\nfunction serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n        //if host component is an IPv6 address\n        if (protocol.IPV6ADDRESS.test(components.host)) {}\n        //TODO: normalize IPv6 address as per RFC 5952\n\n        //if host component is a domain name\n        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || "Host\'s domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;\n                }\n            }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== "suffix" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(":");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n        if (options.reference !== "suffix") {\n            uriTokens.push("//");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== "/") {\n            uriTokens.push("/");\n        }\n    }\n    if (components.path !== undefined) {\n        var s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n            s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n            s = s.replace(/^\\/\\//, "/%2F"); //don\'t allow the path to start with "//"\n        }\n        uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n        uriTokens.push("?");\n        uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n        uriTokens.push("#");\n        uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(""); //merge tokens into a string\n}\n\nfunction resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n\n    var target = {};\n    if (!skipNormalization) {\n        base = parse(serialize(base, options), options); //normalize base components\n        relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || "");\n        target.query = relative.query;\n    } else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || "");\n            target.query = relative.query;\n        } else {\n            if (!relative.path) {\n                target.path = base.path;\n                if (relative.query !== undefined) {\n                    target.query = relative.query;\n                } else {\n                    target.query = base.query;\n                }\n            } else {\n                if (relative.path.charAt(0) === "/") {\n                    target.path = removeDotSegments(relative.path);\n                } else {\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                        target.path = "/" + relative.path;\n                    } else if (!base.path) {\n                        target.path = relative.path;\n                    } else {\n                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;\n                    }\n                    target.path = removeDotSegments(target.path);\n                }\n                target.query = relative.query;\n            }\n            //target.authority = base.authority;\n            target.userinfo = base.userinfo;\n            target.host = base.host;\n            target.port = base.port;\n        }\n        target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n}\n\nfunction resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({ scheme: \'null\' }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n\nfunction normalize(uri, options) {\n    if (typeof uri === "string") {\n        uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === "object") {\n        uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n}\n\nfunction equal(uriA, uriB, options) {\n    if (typeof uriA === "string") {\n        uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === "object") {\n        uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === "string") {\n        uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === "object") {\n        uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n}\n\nfunction escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n\nfunction unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n\nvar handler = {\n    scheme: "http",\n    domainHost: true,\n    parse: function parse(components, options) {\n        //report missing host\n        if (!components.host) {\n            components.error = components.error || "HTTP URIs must have a host.";\n        }\n        return components;\n    },\n    serialize: function serialize(components, options) {\n        var secure = String(components.scheme).toLowerCase() === "https";\n        //normalize the default port\n        if (components.port === (secure ? 443 : 80) || components.port === "") {\n            components.port = undefined;\n        }\n        //normalize the empty path\n        if (!components.path) {\n            components.path = "/";\n        }\n        //NOTE: We do not parse query strings for HTTP URIs\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n        //and not the HTTP spec.\n        return components;\n    }\n};\n\nvar handler$1 = {\n    scheme: "https",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n};\n\nfunction isSecure(wsComponents) {\n    return typeof wsComponents.secure === \'boolean\' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";\n}\n//RFC 6455\nvar handler$2 = {\n    scheme: "ws",\n    domainHost: true,\n    parse: function parse(components, options) {\n        var wsComponents = components;\n        //indicate if the secure flag is set\n        wsComponents.secure = isSecure(wsComponents);\n        //construct resouce name\n        wsComponents.resourceName = (wsComponents.path || \'/\') + (wsComponents.query ? \'?\' + wsComponents.query : \'\');\n        wsComponents.path = undefined;\n        wsComponents.query = undefined;\n        return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n        //normalize the default port\n        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {\n            wsComponents.port = undefined;\n        }\n        //ensure scheme matches secure flag\n        if (typeof wsComponents.secure === \'boolean\') {\n            wsComponents.scheme = wsComponents.secure ? \'wss\' : \'ws\';\n            wsComponents.secure = undefined;\n        }\n        //reconstruct path from resource name\n        if (wsComponents.resourceName) {\n            var _wsComponents$resourc = wsComponents.resourceName.split(\'?\'),\n                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n                path = _wsComponents$resourc2[0],\n                query = _wsComponents$resourc2[1];\n\n            wsComponents.path = path && path !== \'/\' ? path : undefined;\n            wsComponents.query = query;\n            wsComponents.resourceName = undefined;\n        }\n        //forbid fragment component\n        wsComponents.fragment = undefined;\n        return wsComponents;\n    }\n};\n\nvar handler$3 = {\n    scheme: "wss",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n};\n\nvar O = {};\nvar isIRI = true;\n//RFC 3986\nvar UNRESERVED$$ = "[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~" + (isIRI ? "\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF" : "") + "]";\nvar HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive\nvar PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = "[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]";\n//const WSP$$ = "[\\\\x20\\\\x09]";\n//const OBS_QTEXT$$ = "[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge("[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = "[\\\\x21-\\\\x7E]";\n//const WSP$$ = "[\\\\x20\\\\x09]";\n//const OBS_QP$ = subexp("\\\\\\\\" + merge("[\\\\x00\\\\x0D\\\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\\\x0D\\\\x0A") + "?" + WSP$$ + "+");\n//const QUOTED_PAIR$ = subexp(subexp("\\\\\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);\n//const QUOTED_STRING$ = subexp(\'\\\\"\' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + \'\\\\"\');\nvar ATEXT$$ = "[A-Za-z0-9\\\\!\\\\$\\\\%\\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]";\nvar QTEXT$$ = "[\\\\!\\\\$\\\\%\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]";\nvar VCHAR$$ = merge(QTEXT$$, "[\\\\\\"\\\\\\\\]");\nvar SOME_DELIMS$$ = "[\\\\!\\\\$\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]";\nvar UNRESERVED = new RegExp(UNRESERVED$$, "g");\nvar PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");\nvar NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\\\.]", \'[\\\\"]\', VCHAR$$), "g");\nvar NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");\nvar NOT_HFVALUE = NOT_HFNAME;\nfunction decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n}\nvar handler$4 = {\n    scheme: "mailto",\n    parse: function parse$$1(components, options) {\n        var mailtoComponents = components;\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n            var unknownHeaders = false;\n            var headers = {};\n            var hfields = mailtoComponents.query.split("&");\n            for (var x = 0, xl = hfields.length; x < xl; ++x) {\n                var hfield = hfields[x].split("=");\n                switch (hfield[0]) {\n                    case "to":\n                        var toAddrs = hfield[1].split(",");\n                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                            to.push(toAddrs[_x]);\n                        }\n                        break;\n                    case "subject":\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                        break;\n                    case "body":\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n                        break;\n                    default:\n                        unknownHeaders = true;\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                        break;\n                }\n            }\n            if (unknownHeaders) mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n            var addr = to[_x2].split("@");\n            addr[0] = unescapeComponent(addr[0]);\n            if (!options.unicodeSupport) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                } catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || "Email address\'s domain name can not be converted to ASCII via punycode: " + e;\n                }\n            } else {\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n            }\n            to[_x2] = addr.join("@");\n        }\n        return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n        var components = mailtoComponents;\n        var to = toArray(mailtoComponents.to);\n        if (to) {\n            for (var x = 0, xl = to.length; x < xl; ++x) {\n                var toAddr = String(to[x]);\n                var atIdx = toAddr.lastIndexOf("@");\n                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                var domain = toAddr.slice(atIdx + 1);\n                //convert IDN via punycode\n                try {\n                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                } catch (e) {\n                    components.error = components.error || "Email address\'s domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;\n                }\n                to[x] = localPart + "@" + domain;\n            }\n            components.path = to.join(",");\n        }\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;\n        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;\n        var fields = [];\n        for (var name in headers) {\n            if (headers[name] !== O[name]) {\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            }\n        }\n        if (fields.length) {\n            components.query = fields.join("&");\n        }\n        return components;\n    }\n};\n\nvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\n//RFC 2141\nvar handler$5 = {\n    scheme: "urn",\n    parse: function parse$$1(components, options) {\n        var matches = components.path && components.path.match(URN_PARSE);\n        var urnComponents = components;\n        if (matches) {\n            var scheme = options.scheme || urnComponents.scheme || "urn";\n            var nid = matches[1].toLowerCase();\n            var nss = matches[2];\n            var urnScheme = scheme + ":" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            urnComponents.nid = nid;\n            urnComponents.nss = nss;\n            urnComponents.path = undefined;\n            if (schemeHandler) {\n                urnComponents = schemeHandler.parse(urnComponents, options);\n            }\n        } else {\n            urnComponents.error = urnComponents.error || "URN can not be parsed.";\n        }\n        return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n        var scheme = options.scheme || urnComponents.scheme || "urn";\n        var nid = urnComponents.nid;\n        var urnScheme = scheme + ":" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        if (schemeHandler) {\n            urnComponents = schemeHandler.serialize(urnComponents, options);\n        }\n        var uriComponents = urnComponents;\n        var nss = urnComponents.nss;\n        uriComponents.path = (nid || options.nid) + ":" + nss;\n        return uriComponents;\n    }\n};\n\nvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n//RFC 4122\nvar handler$6 = {\n    scheme: "urn:uuid",\n    parse: function parse(urnComponents, options) {\n        var uuidComponents = urnComponents;\n        uuidComponents.uuid = uuidComponents.nss;\n        uuidComponents.nss = undefined;\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n            uuidComponents.error = uuidComponents.error || "UUID is not valid.";\n        }\n        return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n        var urnComponents = uuidComponents;\n        //normalize UUID\n        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();\n        return urnComponents;\n    }\n};\n\nSCHEMES[handler.scheme] = handler;\nSCHEMES[handler$1.scheme] = handler$1;\nSCHEMES[handler$2.scheme] = handler$2;\nSCHEMES[handler$3.scheme] = handler$3;\nSCHEMES[handler$4.scheme] = handler$4;\nSCHEMES[handler$5.scheme] = handler$5;\nSCHEMES[handler$6.scheme] = handler$6;\n\nexports.SCHEMES = SCHEMES;\nexports.pctEncChar = pctEncChar;\nexports.pctDecChars = pctDecChars;\nexports.parse = parse;\nexports.removeDotSegments = removeDotSegments;\nexports.serialize = serialize;\nexports.resolveComponents = resolveComponents;\nexports.resolve = resolve;\nexports.normalize = normalize;\nexports.equal = equal;\nexports.escapeComponent = escapeComponent;\nexports.unescapeComponent = unescapeComponent;\n\nObject.defineProperty(exports, \'__esModule\', { value: true });\n\n})));\n//# sourceMappingURL=uri.all.js.map\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/uri-js@4.4.1/node_modules/uri-js/dist/es5/uri.all.js?')},9991:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  NIL: () => (/* reexport */ nil),\n  parse: () => (/* reexport */ esm_node_parse),\n  stringify: () => (/* reexport */ esm_node_stringify),\n  v1: () => (/* reexport */ esm_node_v1),\n  v3: () => (/* reexport */ esm_node_v3),\n  v4: () => (/* reexport */ esm_node_v4),\n  v5: () => (/* reexport */ esm_node_v5),\n  validate: () => (/* reexport */ esm_node_validate),\n  version: () => (/* reexport */ esm_node_version)\n});\n\n;// CONCATENATED MODULE: external \"crypto\"\nconst external_crypto_namespaceObject = require(\"crypto\");\nvar external_crypto_default = /*#__PURE__*/__webpack_require__.n(external_crypto_namespaceObject);\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/rng.js\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    external_crypto_default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/regex.js\n/* harmony default export */ const regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/validate.js\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && regex.test(uuid);\n}\n\n/* harmony default export */ const esm_node_validate = (validate);\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/stringify.js\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!esm_node_validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const esm_node_stringify = (stringify);\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v1.js\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || rng)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || esm_node_stringify(b);\n}\n\n/* harmony default export */ const esm_node_v1 = (v1);\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/parse.js\n\n\nfunction parse(uuid) {\n  if (!esm_node_validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ const esm_node_parse = (parse);\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v35.js\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\n/* harmony default export */ function v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = esm_node_parse(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return esm_node_stringify(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/md5.js\n\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return external_crypto_default().createHash('md5').update(bytes).digest();\n}\n\n/* harmony default export */ const esm_node_md5 = (md5);\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v3.js\n\n\nconst v3 = v35('v3', 0x30, esm_node_md5);\n/* harmony default export */ const esm_node_v3 = (v3);\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v4.js\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return esm_node_stringify(rnds);\n}\n\n/* harmony default export */ const esm_node_v4 = (v4);\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/sha1.js\n\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return external_crypto_default().createHash('sha1').update(bytes).digest();\n}\n\n/* harmony default export */ const esm_node_sha1 = (sha1);\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/v5.js\n\n\nconst v5 = v35('v5', 0x50, esm_node_sha1);\n/* harmony default export */ const esm_node_v5 = (v5);\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/nil.js\n/* harmony default export */ const nil = ('00000000-0000-0000-0000-000000000000');\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/version.js\n\n\nfunction version(uuid) {\n  if (!esm_node_validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\n/* harmony default export */ const esm_node_version = (version);\n;// CONCATENATED MODULE: ../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/index.js\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-node/index.js_+_15_modules?")},5355:function(module,exports){eval("/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { JSONCompletion } from './services/jsonCompletion';\nimport { JSONHover } from './services/jsonHover';\nimport { JSONValidation } from './services/jsonValidation';\nimport { JSONDocumentSymbols } from './services/jsonDocumentSymbols';\nimport { parse as parseJSON, newJSONDocument } from './parser/jsonParser';\nimport { schemaContributions } from './services/configuration';\nimport { JSONSchemaService } from './services/jsonSchemaService';\nimport { getFoldingRanges } from './services/jsonFolding';\nimport { getSelectionRanges } from './services/jsonSelectionRanges';\nimport { format as formatJSON } from 'jsonc-parser';\nimport { Range, TextEdit } from './jsonLanguageTypes';\nimport { findLinks } from './services/jsonLinks';\nexport * from './jsonLanguageTypes';\nexport function getLanguageService(params) {\n    var promise = params.promiseConstructor || Promise;\n    var jsonSchemaService = new JSONSchemaService(params.schemaRequestService, params.workspaceContext, promise);\n    jsonSchemaService.setSchemaContributions(schemaContributions);\n    var jsonCompletion = new JSONCompletion(jsonSchemaService, params.contributions, promise, params.clientCapabilities);\n    var jsonHover = new JSONHover(jsonSchemaService, params.contributions, promise);\n    var jsonDocumentSymbols = new JSONDocumentSymbols(jsonSchemaService);\n    var jsonValidation = new JSONValidation(jsonSchemaService, promise);\n    return {\n        configure: function (settings) {\n            jsonSchemaService.clearExternalSchemas();\n            if (settings.schemas) {\n                settings.schemas.forEach(function (settings) {\n                    jsonSchemaService.registerExternalSchema(settings.uri, settings.fileMatch, settings.schema);\n                });\n            }\n            jsonValidation.configure(settings);\n        },\n        resetSchema: function (uri) { return jsonSchemaService.onResourceChange(uri); },\n        doValidation: jsonValidation.doValidation.bind(jsonValidation),\n        parseJSONDocument: function (document) { return parseJSON(document, { collectComments: true }); },\n        newJSONDocument: function (root, diagnostics) { return newJSONDocument(root, diagnostics); },\n        getMatchingSchemas: jsonSchemaService.getMatchingSchemas.bind(jsonSchemaService),\n        doResolve: jsonCompletion.doResolve.bind(jsonCompletion),\n        doComplete: jsonCompletion.doComplete.bind(jsonCompletion),\n        findDocumentSymbols: jsonDocumentSymbols.findDocumentSymbols.bind(jsonDocumentSymbols),\n        findDocumentSymbols2: jsonDocumentSymbols.findDocumentSymbols2.bind(jsonDocumentSymbols),\n        findDocumentColors: jsonDocumentSymbols.findDocumentColors.bind(jsonDocumentSymbols),\n        getColorPresentations: jsonDocumentSymbols.getColorPresentations.bind(jsonDocumentSymbols),\n        doHover: jsonHover.doHover.bind(jsonHover),\n        getFoldingRanges: getFoldingRanges,\n        getSelectionRanges: getSelectionRanges,\n        findDefinition: function () { return Promise.resolve([]); },\n        findLinks: findLinks,\n        format: function (d, r, o) {\n            var range = undefined;\n            if (r) {\n                var offset = d.offsetAt(r.start);\n                var length = d.offsetAt(r.end) - offset;\n                range = { offset: offset, length: length };\n            }\n            var options = { tabSize: o ? o.tabSize : 4, insertSpaces: (o === null || o === void 0 ? void 0 : o.insertSpaces) === true, insertFinalNewline: (o === null || o === void 0 ? void 0 : o.insertFinalNewline) === true, eol: '\\n' };\n            return formatJSON(d.getText(), range, options).map(function (e) {\n                return TextEdit.replace(Range.create(d.positionAt(e.offset), d.positionAt(e.offset + e.length)), e.content);\n            });\n        }\n    };\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/vscode-json-languageservice@4.1.8/node_modules/vscode-json-languageservice/lib/esm/jsonLanguageService.js?")},2613:function(module,exports){eval("/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../parser/jsonParser\", \"../utils/strings\", \"../utils/colors\", \"../jsonLanguageTypes\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.JSONDocumentSymbols = void 0;\n    var Parser = require(\"../parser/jsonParser\");\n    var Strings = require(\"../utils/strings\");\n    var colors_1 = require(\"../utils/colors\");\n    var jsonLanguageTypes_1 = require(\"../jsonLanguageTypes\");\n    var JSONDocumentSymbols = /** @class */ (function () {\n        function JSONDocumentSymbols(schemaService) {\n            this.schemaService = schemaService;\n        }\n        JSONDocumentSymbols.prototype.findDocumentSymbols = function (document, doc, context) {\n            var _this = this;\n            if (context === void 0) { context = { resultLimit: Number.MAX_VALUE }; }\n            var root = doc.root;\n            if (!root) {\n                return [];\n            }\n            var limit = context.resultLimit || Number.MAX_VALUE;\n            // special handling for key bindings\n            var resourceString = document.uri;\n            if ((resourceString === 'vscode://defaultsettings/keybindings.json') || Strings.endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {\n                if (root.type === 'array') {\n                    var result_1 = [];\n                    for (var _i = 0, _a = root.items; _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        if (item.type === 'object') {\n                            for (var _b = 0, _c = item.properties; _b < _c.length; _b++) {\n                                var property = _c[_b];\n                                if (property.keyNode.value === 'key' && property.valueNode) {\n                                    var location = jsonLanguageTypes_1.Location.create(document.uri, getRange(document, item));\n                                    result_1.push({ name: Parser.getNodeValue(property.valueNode), kind: jsonLanguageTypes_1.SymbolKind.Function, location: location });\n                                    limit--;\n                                    if (limit <= 0) {\n                                        if (context && context.onResultLimitExceeded) {\n                                            context.onResultLimitExceeded(resourceString);\n                                        }\n                                        return result_1;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return result_1;\n                }\n            }\n            var toVisit = [\n                { node: root, containerName: '' }\n            ];\n            var nextToVisit = 0;\n            var limitExceeded = false;\n            var result = [];\n            var collectOutlineEntries = function (node, containerName) {\n                if (node.type === 'array') {\n                    node.items.forEach(function (node) {\n                        if (node) {\n                            toVisit.push({ node: node, containerName: containerName });\n                        }\n                    });\n                }\n                else if (node.type === 'object') {\n                    node.properties.forEach(function (property) {\n                        var valueNode = property.valueNode;\n                        if (valueNode) {\n                            if (limit > 0) {\n                                limit--;\n                                var location = jsonLanguageTypes_1.Location.create(document.uri, getRange(document, property));\n                                var childContainerName = containerName ? containerName + '.' + property.keyNode.value : property.keyNode.value;\n                                result.push({ name: _this.getKeyLabel(property), kind: _this.getSymbolKind(valueNode.type), location: location, containerName: containerName });\n                                toVisit.push({ node: valueNode, containerName: childContainerName });\n                            }\n                            else {\n                                limitExceeded = true;\n                            }\n                        }\n                    });\n                }\n            };\n            // breath first traversal\n            while (nextToVisit < toVisit.length) {\n                var next = toVisit[nextToVisit++];\n                collectOutlineEntries(next.node, next.containerName);\n            }\n            if (limitExceeded && context && context.onResultLimitExceeded) {\n                context.onResultLimitExceeded(resourceString);\n            }\n            return result;\n        };\n        JSONDocumentSymbols.prototype.findDocumentSymbols2 = function (document, doc, context) {\n            var _this = this;\n            if (context === void 0) { context = { resultLimit: Number.MAX_VALUE }; }\n            var root = doc.root;\n            if (!root) {\n                return [];\n            }\n            var limit = context.resultLimit || Number.MAX_VALUE;\n            // special handling for key bindings\n            var resourceString = document.uri;\n            if ((resourceString === 'vscode://defaultsettings/keybindings.json') || Strings.endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {\n                if (root.type === 'array') {\n                    var result_2 = [];\n                    for (var _i = 0, _a = root.items; _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        if (item.type === 'object') {\n                            for (var _b = 0, _c = item.properties; _b < _c.length; _b++) {\n                                var property = _c[_b];\n                                if (property.keyNode.value === 'key' && property.valueNode) {\n                                    var range = getRange(document, item);\n                                    var selectionRange = getRange(document, property.keyNode);\n                                    result_2.push({ name: Parser.getNodeValue(property.valueNode), kind: jsonLanguageTypes_1.SymbolKind.Function, range: range, selectionRange: selectionRange });\n                                    limit--;\n                                    if (limit <= 0) {\n                                        if (context && context.onResultLimitExceeded) {\n                                            context.onResultLimitExceeded(resourceString);\n                                        }\n                                        return result_2;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return result_2;\n                }\n            }\n            var result = [];\n            var toVisit = [\n                { node: root, result: result }\n            ];\n            var nextToVisit = 0;\n            var limitExceeded = false;\n            var collectOutlineEntries = function (node, result) {\n                if (node.type === 'array') {\n                    node.items.forEach(function (node, index) {\n                        if (node) {\n                            if (limit > 0) {\n                                limit--;\n                                var range = getRange(document, node);\n                                var selectionRange = range;\n                                var name = String(index);\n                                var symbol = { name: name, kind: _this.getSymbolKind(node.type), range: range, selectionRange: selectionRange, children: [] };\n                                result.push(symbol);\n                                toVisit.push({ result: symbol.children, node: node });\n                            }\n                            else {\n                                limitExceeded = true;\n                            }\n                        }\n                    });\n                }\n                else if (node.type === 'object') {\n                    node.properties.forEach(function (property) {\n                        var valueNode = property.valueNode;\n                        if (valueNode) {\n                            if (limit > 0) {\n                                limit--;\n                                var range = getRange(document, property);\n                                var selectionRange = getRange(document, property.keyNode);\n                                var children = [];\n                                var symbol = { name: _this.getKeyLabel(property), kind: _this.getSymbolKind(valueNode.type), range: range, selectionRange: selectionRange, children: children, detail: _this.getDetail(valueNode) };\n                                result.push(symbol);\n                                toVisit.push({ result: children, node: valueNode });\n                            }\n                            else {\n                                limitExceeded = true;\n                            }\n                        }\n                    });\n                }\n            };\n            // breath first traversal\n            while (nextToVisit < toVisit.length) {\n                var next = toVisit[nextToVisit++];\n                collectOutlineEntries(next.node, next.result);\n            }\n            if (limitExceeded && context && context.onResultLimitExceeded) {\n                context.onResultLimitExceeded(resourceString);\n            }\n            return result;\n        };\n        JSONDocumentSymbols.prototype.getSymbolKind = function (nodeType) {\n            switch (nodeType) {\n                case 'object':\n                    return jsonLanguageTypes_1.SymbolKind.Module;\n                case 'string':\n                    return jsonLanguageTypes_1.SymbolKind.String;\n                case 'number':\n                    return jsonLanguageTypes_1.SymbolKind.Number;\n                case 'array':\n                    return jsonLanguageTypes_1.SymbolKind.Array;\n                case 'boolean':\n                    return jsonLanguageTypes_1.SymbolKind.Boolean;\n                default: // 'null'\n                    return jsonLanguageTypes_1.SymbolKind.Variable;\n            }\n        };\n        JSONDocumentSymbols.prototype.getKeyLabel = function (property) {\n            var name = property.keyNode.value;\n            if (name) {\n                name = name.replace(/[\\n]/g, '');\n            }\n            if (name && name.trim()) {\n                return name;\n            }\n            return \"\\\"\" + name + \"\\\"\";\n        };\n        JSONDocumentSymbols.prototype.getDetail = function (node) {\n            if (!node) {\n                return undefined;\n            }\n            if (node.type === 'boolean' || node.type === 'number' || node.type === 'null' || node.type === 'string') {\n                return String(node.value);\n            }\n            else {\n                if (node.type === 'array') {\n                    return node.children.length ? undefined : '[]';\n                }\n                else if (node.type === 'object') {\n                    return node.children.length ? undefined : '{}';\n                }\n            }\n            return undefined;\n        };\n        JSONDocumentSymbols.prototype.findDocumentColors = function (document, doc, context) {\n            return this.schemaService.getSchemaForResource(document.uri, doc).then(function (schema) {\n                var result = [];\n                if (schema) {\n                    var limit = context && typeof context.resultLimit === 'number' ? context.resultLimit : Number.MAX_VALUE;\n                    var matchingSchemas = doc.getMatchingSchemas(schema.schema);\n                    var visitedNode = {};\n                    for (var _i = 0, matchingSchemas_1 = matchingSchemas; _i < matchingSchemas_1.length; _i++) {\n                        var s = matchingSchemas_1[_i];\n                        if (!s.inverted && s.schema && (s.schema.format === 'color' || s.schema.format === 'color-hex') && s.node && s.node.type === 'string') {\n                            var nodeId = String(s.node.offset);\n                            if (!visitedNode[nodeId]) {\n                                var color = colors_1.colorFromHex(Parser.getNodeValue(s.node));\n                                if (color) {\n                                    var range = getRange(document, s.node);\n                                    result.push({ color: color, range: range });\n                                }\n                                visitedNode[nodeId] = true;\n                                limit--;\n                                if (limit <= 0) {\n                                    if (context && context.onResultLimitExceeded) {\n                                        context.onResultLimitExceeded(document.uri);\n                                    }\n                                    return result;\n                                }\n                            }\n                        }\n                    }\n                }\n                return result;\n            });\n        };\n        JSONDocumentSymbols.prototype.getColorPresentations = function (document, doc, color, range) {\n            var result = [];\n            var red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);\n            function toTwoDigitHex(n) {\n                var r = n.toString(16);\n                return r.length !== 2 ? '0' + r : r;\n            }\n            var label;\n            if (color.alpha === 1) {\n                label = \"#\" + toTwoDigitHex(red256) + toTwoDigitHex(green256) + toTwoDigitHex(blue256);\n            }\n            else {\n                label = \"#\" + toTwoDigitHex(red256) + toTwoDigitHex(green256) + toTwoDigitHex(blue256) + toTwoDigitHex(Math.round(color.alpha * 255));\n            }\n            result.push({ label: label, textEdit: jsonLanguageTypes_1.TextEdit.replace(range, JSON.stringify(label)) });\n            return result;\n        };\n        return JSONDocumentSymbols;\n    }());\n    exports.JSONDocumentSymbols = JSONDocumentSymbols;\n    function getRange(document, node) {\n        return jsonLanguageTypes_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));\n    }\n});\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/vscode-json-languageservice@4.1.8/node_modules/vscode-json-languageservice/lib/umd/services/jsonDocumentSymbols.js?")},8833:function(module,exports){eval('/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n(function (factory) {\n    if (typeof module === "object" && typeof module.exports === "object") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === "function" && define.amd) {\n        define(["require", "exports", "../jsonLanguageTypes"], factory);\n    }\n})(function (require, exports) {\n    "use strict";\n    Object.defineProperty(exports, "__esModule", { value: true });\n    exports.findLinks = void 0;\n    var jsonLanguageTypes_1 = require("../jsonLanguageTypes");\n    function findLinks(document, doc) {\n        var links = [];\n        doc.visit(function (node) {\n            var _a;\n            if (node.type === "property" && node.keyNode.value === "$ref" && ((_a = node.valueNode) === null || _a === void 0 ? void 0 : _a.type) === \'string\') {\n                var path = node.valueNode.value;\n                var targetNode = findTargetNode(doc, path);\n                if (targetNode) {\n                    var targetPos = document.positionAt(targetNode.offset);\n                    links.push({\n                        target: document.uri + "#" + (targetPos.line + 1) + "," + (targetPos.character + 1),\n                        range: createRange(document, node.valueNode)\n                    });\n                }\n            }\n            return true;\n        });\n        return Promise.resolve(links);\n    }\n    exports.findLinks = findLinks;\n    function createRange(document, node) {\n        return jsonLanguageTypes_1.Range.create(document.positionAt(node.offset + 1), document.positionAt(node.offset + node.length - 1));\n    }\n    function findTargetNode(doc, path) {\n        var tokens = parseJSONPointer(path);\n        if (!tokens) {\n            return null;\n        }\n        return findNode(tokens, doc.root);\n    }\n    function findNode(pointer, node) {\n        if (!node) {\n            return null;\n        }\n        if (pointer.length === 0) {\n            return node;\n        }\n        var token = pointer.shift();\n        if (node && node.type === \'object\') {\n            var propertyNode = node.properties.find(function (propertyNode) { return propertyNode.keyNode.value === token; });\n            if (!propertyNode) {\n                return null;\n            }\n            return findNode(pointer, propertyNode.valueNode);\n        }\n        else if (node && node.type === \'array\') {\n            if (token.match(/^(0|[1-9][0-9]*)$/)) {\n                var index = Number.parseInt(token);\n                var arrayItem = node.items[index];\n                if (!arrayItem) {\n                    return null;\n                }\n                return findNode(pointer, arrayItem);\n            }\n        }\n        return null;\n    }\n    function parseJSONPointer(path) {\n        if (path === "#") {\n            return [];\n        }\n        if (path[0] !== \'#\' || path[1] !== \'/\') {\n            return null;\n        }\n        return path.substring(2).split(/\\//).map(unescape);\n    }\n    function unescape(str) {\n        return str.replace(/~1/g, \'/\').replace(/~0/g, \'~\');\n    }\n});\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/vscode-json-languageservice@4.1.8/node_modules/vscode-json-languageservice/lib/umd/services/jsonLinks.js?')},9967:function(module,exports){eval("/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"jsonc-parser\", \"vscode-uri\", \"../utils/strings\", \"../parser/jsonParser\", \"vscode-nls\", \"../utils/glob\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.JSONSchemaService = exports.ResolvedSchema = exports.UnresolvedSchema = void 0;\n    var Json = require(\"jsonc-parser\");\n    var vscode_uri_1 = require(\"vscode-uri\");\n    var Strings = require(\"../utils/strings\");\n    var Parser = require(\"../parser/jsonParser\");\n    var nls = require(\"vscode-nls\");\n    var glob_1 = require(\"../utils/glob\");\n    var localize = nls.loadMessageBundle();\n    var BANG = '!';\n    var PATH_SEP = '/';\n    var FilePatternAssociation = /** @class */ (function () {\n        function FilePatternAssociation(pattern, uris) {\n            this.globWrappers = [];\n            try {\n                for (var _i = 0, pattern_1 = pattern; _i < pattern_1.length; _i++) {\n                    var patternString = pattern_1[_i];\n                    var include = patternString[0] !== BANG;\n                    if (!include) {\n                        patternString = patternString.substring(1);\n                    }\n                    if (patternString.length > 0) {\n                        if (patternString[0] === PATH_SEP) {\n                            patternString = patternString.substring(1);\n                        }\n                        this.globWrappers.push({\n                            regexp: glob_1.createRegex('**/' + patternString, { extended: true, globstar: true }),\n                            include: include,\n                        });\n                    }\n                }\n                ;\n                this.uris = uris;\n            }\n            catch (e) {\n                this.globWrappers.length = 0;\n                this.uris = [];\n            }\n        }\n        FilePatternAssociation.prototype.matchesPattern = function (fileName) {\n            var match = false;\n            for (var _i = 0, _a = this.globWrappers; _i < _a.length; _i++) {\n                var _b = _a[_i], regexp = _b.regexp, include = _b.include;\n                if (regexp.test(fileName)) {\n                    match = include;\n                }\n            }\n            return match;\n        };\n        FilePatternAssociation.prototype.getURIs = function () {\n            return this.uris;\n        };\n        return FilePatternAssociation;\n    }());\n    var SchemaHandle = /** @class */ (function () {\n        function SchemaHandle(service, url, unresolvedSchemaContent) {\n            this.service = service;\n            this.url = url;\n            this.dependencies = {};\n            if (unresolvedSchemaContent) {\n                this.unresolvedSchema = this.service.promise.resolve(new UnresolvedSchema(unresolvedSchemaContent));\n            }\n        }\n        SchemaHandle.prototype.getUnresolvedSchema = function () {\n            if (!this.unresolvedSchema) {\n                this.unresolvedSchema = this.service.loadSchema(this.url);\n            }\n            return this.unresolvedSchema;\n        };\n        SchemaHandle.prototype.getResolvedSchema = function () {\n            var _this = this;\n            if (!this.resolvedSchema) {\n                this.resolvedSchema = this.getUnresolvedSchema().then(function (unresolved) {\n                    return _this.service.resolveSchemaContent(unresolved, _this.url, _this.dependencies);\n                });\n            }\n            return this.resolvedSchema;\n        };\n        SchemaHandle.prototype.clearSchema = function () {\n            this.resolvedSchema = undefined;\n            this.unresolvedSchema = undefined;\n            this.dependencies = {};\n        };\n        return SchemaHandle;\n    }());\n    var UnresolvedSchema = /** @class */ (function () {\n        function UnresolvedSchema(schema, errors) {\n            if (errors === void 0) { errors = []; }\n            this.schema = schema;\n            this.errors = errors;\n        }\n        return UnresolvedSchema;\n    }());\n    exports.UnresolvedSchema = UnresolvedSchema;\n    var ResolvedSchema = /** @class */ (function () {\n        function ResolvedSchema(schema, errors) {\n            if (errors === void 0) { errors = []; }\n            this.schema = schema;\n            this.errors = errors;\n        }\n        ResolvedSchema.prototype.getSection = function (path) {\n            var schemaRef = this.getSectionRecursive(path, this.schema);\n            if (schemaRef) {\n                return Parser.asSchema(schemaRef);\n            }\n            return undefined;\n        };\n        ResolvedSchema.prototype.getSectionRecursive = function (path, schema) {\n            if (!schema || typeof schema === 'boolean' || path.length === 0) {\n                return schema;\n            }\n            var next = path.shift();\n            if (schema.properties && typeof schema.properties[next]) {\n                return this.getSectionRecursive(path, schema.properties[next]);\n            }\n            else if (schema.patternProperties) {\n                for (var _i = 0, _a = Object.keys(schema.patternProperties); _i < _a.length; _i++) {\n                    var pattern = _a[_i];\n                    var regex = Strings.extendedRegExp(pattern);\n                    if (regex.test(next)) {\n                        return this.getSectionRecursive(path, schema.patternProperties[pattern]);\n                    }\n                }\n            }\n            else if (typeof schema.additionalProperties === 'object') {\n                return this.getSectionRecursive(path, schema.additionalProperties);\n            }\n            else if (next.match('[0-9]+')) {\n                if (Array.isArray(schema.items)) {\n                    var index = parseInt(next, 10);\n                    if (!isNaN(index) && schema.items[index]) {\n                        return this.getSectionRecursive(path, schema.items[index]);\n                    }\n                }\n                else if (schema.items) {\n                    return this.getSectionRecursive(path, schema.items);\n                }\n            }\n            return undefined;\n        };\n        return ResolvedSchema;\n    }());\n    exports.ResolvedSchema = ResolvedSchema;\n    var JSONSchemaService = /** @class */ (function () {\n        function JSONSchemaService(requestService, contextService, promiseConstructor) {\n            this.contextService = contextService;\n            this.requestService = requestService;\n            this.promiseConstructor = promiseConstructor || Promise;\n            this.callOnDispose = [];\n            this.contributionSchemas = {};\n            this.contributionAssociations = [];\n            this.schemasById = {};\n            this.filePatternAssociations = [];\n            this.registeredSchemasIds = {};\n        }\n        JSONSchemaService.prototype.getRegisteredSchemaIds = function (filter) {\n            return Object.keys(this.registeredSchemasIds).filter(function (id) {\n                var scheme = vscode_uri_1.URI.parse(id).scheme;\n                return scheme !== 'schemaservice' && (!filter || filter(scheme));\n            });\n        };\n        Object.defineProperty(JSONSchemaService.prototype, \"promise\", {\n            get: function () {\n                return this.promiseConstructor;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        JSONSchemaService.prototype.dispose = function () {\n            while (this.callOnDispose.length > 0) {\n                this.callOnDispose.pop()();\n            }\n        };\n        JSONSchemaService.prototype.onResourceChange = function (uri) {\n            var _this = this;\n            // always clear this local cache when a resource changes\n            this.cachedSchemaForResource = undefined;\n            var hasChanges = false;\n            uri = normalizeId(uri);\n            var toWalk = [uri];\n            var all = Object.keys(this.schemasById).map(function (key) { return _this.schemasById[key]; });\n            while (toWalk.length) {\n                var curr = toWalk.pop();\n                for (var i = 0; i < all.length; i++) {\n                    var handle = all[i];\n                    if (handle && (handle.url === curr || handle.dependencies[curr])) {\n                        if (handle.url !== curr) {\n                            toWalk.push(handle.url);\n                        }\n                        handle.clearSchema();\n                        all[i] = undefined;\n                        hasChanges = true;\n                    }\n                }\n            }\n            return hasChanges;\n        };\n        JSONSchemaService.prototype.setSchemaContributions = function (schemaContributions) {\n            if (schemaContributions.schemas) {\n                var schemas = schemaContributions.schemas;\n                for (var id in schemas) {\n                    var normalizedId = normalizeId(id);\n                    this.contributionSchemas[normalizedId] = this.addSchemaHandle(normalizedId, schemas[id]);\n                }\n            }\n            if (Array.isArray(schemaContributions.schemaAssociations)) {\n                var schemaAssociations = schemaContributions.schemaAssociations;\n                for (var _i = 0, schemaAssociations_1 = schemaAssociations; _i < schemaAssociations_1.length; _i++) {\n                    var schemaAssociation = schemaAssociations_1[_i];\n                    var uris = schemaAssociation.uris.map(normalizeId);\n                    var association = this.addFilePatternAssociation(schemaAssociation.pattern, uris);\n                    this.contributionAssociations.push(association);\n                }\n            }\n        };\n        JSONSchemaService.prototype.addSchemaHandle = function (id, unresolvedSchemaContent) {\n            var schemaHandle = new SchemaHandle(this, id, unresolvedSchemaContent);\n            this.schemasById[id] = schemaHandle;\n            return schemaHandle;\n        };\n        JSONSchemaService.prototype.getOrAddSchemaHandle = function (id, unresolvedSchemaContent) {\n            return this.schemasById[id] || this.addSchemaHandle(id, unresolvedSchemaContent);\n        };\n        JSONSchemaService.prototype.addFilePatternAssociation = function (pattern, uris) {\n            var fpa = new FilePatternAssociation(pattern, uris);\n            this.filePatternAssociations.push(fpa);\n            return fpa;\n        };\n        JSONSchemaService.prototype.registerExternalSchema = function (uri, filePatterns, unresolvedSchemaContent) {\n            var id = normalizeId(uri);\n            this.registeredSchemasIds[id] = true;\n            this.cachedSchemaForResource = undefined;\n            if (filePatterns) {\n                this.addFilePatternAssociation(filePatterns, [uri]);\n            }\n            return unresolvedSchemaContent ? this.addSchemaHandle(id, unresolvedSchemaContent) : this.getOrAddSchemaHandle(id);\n        };\n        JSONSchemaService.prototype.clearExternalSchemas = function () {\n            this.schemasById = {};\n            this.filePatternAssociations = [];\n            this.registeredSchemasIds = {};\n            this.cachedSchemaForResource = undefined;\n            for (var id in this.contributionSchemas) {\n                this.schemasById[id] = this.contributionSchemas[id];\n                this.registeredSchemasIds[id] = true;\n            }\n            for (var _i = 0, _a = this.contributionAssociations; _i < _a.length; _i++) {\n                var contributionAssociation = _a[_i];\n                this.filePatternAssociations.push(contributionAssociation);\n            }\n        };\n        JSONSchemaService.prototype.getResolvedSchema = function (schemaId) {\n            var id = normalizeId(schemaId);\n            var schemaHandle = this.schemasById[id];\n            if (schemaHandle) {\n                return schemaHandle.getResolvedSchema();\n            }\n            return this.promise.resolve(undefined);\n        };\n        JSONSchemaService.prototype.loadSchema = function (url) {\n            if (!this.requestService) {\n                var errorMessage = localize('json.schema.norequestservice', 'Unable to load schema from \\'{0}\\'. No schema request service available', toDisplayString(url));\n                return this.promise.resolve(new UnresolvedSchema({}, [errorMessage]));\n            }\n            return this.requestService(url).then(function (content) {\n                if (!content) {\n                    var errorMessage = localize('json.schema.nocontent', 'Unable to load schema from \\'{0}\\': No content.', toDisplayString(url));\n                    return new UnresolvedSchema({}, [errorMessage]);\n                }\n                var schemaContent = {};\n                var jsonErrors = [];\n                schemaContent = Json.parse(content, jsonErrors);\n                var errors = jsonErrors.length ? [localize('json.schema.invalidFormat', 'Unable to parse content from \\'{0}\\': Parse error at offset {1}.', toDisplayString(url), jsonErrors[0].offset)] : [];\n                return new UnresolvedSchema(schemaContent, errors);\n            }, function (error) {\n                var errorMessage = error.toString();\n                var errorSplit = error.toString().split('Error: ');\n                if (errorSplit.length > 1) {\n                    // more concise error message, URL and context are attached by caller anyways\n                    errorMessage = errorSplit[1];\n                }\n                if (Strings.endsWith(errorMessage, '.')) {\n                    errorMessage = errorMessage.substr(0, errorMessage.length - 1);\n                }\n                return new UnresolvedSchema({}, [localize('json.schema.nocontent', 'Unable to load schema from \\'{0}\\': {1}.', toDisplayString(url), errorMessage)]);\n            });\n        };\n        JSONSchemaService.prototype.resolveSchemaContent = function (schemaToResolve, schemaURL, dependencies) {\n            var _this = this;\n            var resolveErrors = schemaToResolve.errors.slice(0);\n            var schema = schemaToResolve.schema;\n            if (schema.$schema) {\n                var id = normalizeId(schema.$schema);\n                if (id === 'http://json-schema.org/draft-03/schema') {\n                    return this.promise.resolve(new ResolvedSchema({}, [localize('json.schema.draft03.notsupported', \"Draft-03 schemas are not supported.\")]));\n                }\n                else if (id === 'https://json-schema.org/draft/2019-09/schema') {\n                    resolveErrors.push(localize('json.schema.draft201909.notsupported', \"Draft 2019-09 schemas are not yet fully supported.\"));\n                }\n            }\n            var contextService = this.contextService;\n            var findSection = function (schema, path) {\n                if (!path) {\n                    return schema;\n                }\n                var current = schema;\n                if (path[0] === '/') {\n                    path = path.substr(1);\n                }\n                path.split('/').some(function (part) {\n                    part = part.replace(/~1/g, '/').replace(/~0/g, '~');\n                    current = current[part];\n                    return !current;\n                });\n                return current;\n            };\n            var merge = function (target, sourceRoot, sourceURI, refSegment) {\n                var path = refSegment ? decodeURIComponent(refSegment) : undefined;\n                var section = findSection(sourceRoot, path);\n                if (section) {\n                    for (var key in section) {\n                        if (section.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n                            target[key] = section[key];\n                        }\n                    }\n                }\n                else {\n                    resolveErrors.push(localize('json.schema.invalidref', '$ref \\'{0}\\' in \\'{1}\\' can not be resolved.', path, sourceURI));\n                }\n            };\n            var resolveExternalLink = function (node, uri, refSegment, parentSchemaURL, parentSchemaDependencies) {\n                if (contextService && !/^[A-Za-z][A-Za-z0-9+\\-.+]*:\\/\\/.*/.test(uri)) {\n                    uri = contextService.resolveRelativePath(uri, parentSchemaURL);\n                }\n                uri = normalizeId(uri);\n                var referencedHandle = _this.getOrAddSchemaHandle(uri);\n                return referencedHandle.getUnresolvedSchema().then(function (unresolvedSchema) {\n                    parentSchemaDependencies[uri] = true;\n                    if (unresolvedSchema.errors.length) {\n                        var loc = refSegment ? uri + '#' + refSegment : uri;\n                        resolveErrors.push(localize('json.schema.problemloadingref', 'Problems loading reference \\'{0}\\': {1}', loc, unresolvedSchema.errors[0]));\n                    }\n                    merge(node, unresolvedSchema.schema, uri, refSegment);\n                    return resolveRefs(node, unresolvedSchema.schema, uri, referencedHandle.dependencies);\n                });\n            };\n            var resolveRefs = function (node, parentSchema, parentSchemaURL, parentSchemaDependencies) {\n                if (!node || typeof node !== 'object') {\n                    return Promise.resolve(null);\n                }\n                var toWalk = [node];\n                var seen = [];\n                var openPromises = [];\n                var collectEntries = function () {\n                    var entries = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        entries[_i] = arguments[_i];\n                    }\n                    for (var _a = 0, entries_1 = entries; _a < entries_1.length; _a++) {\n                        var entry = entries_1[_a];\n                        if (typeof entry === 'object') {\n                            toWalk.push(entry);\n                        }\n                    }\n                };\n                var collectMapEntries = function () {\n                    var maps = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        maps[_i] = arguments[_i];\n                    }\n                    for (var _a = 0, maps_1 = maps; _a < maps_1.length; _a++) {\n                        var map = maps_1[_a];\n                        if (typeof map === 'object') {\n                            for (var k in map) {\n                                var key = k;\n                                var entry = map[key];\n                                if (typeof entry === 'object') {\n                                    toWalk.push(entry);\n                                }\n                            }\n                        }\n                    }\n                };\n                var collectArrayEntries = function () {\n                    var arrays = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        arrays[_i] = arguments[_i];\n                    }\n                    for (var _a = 0, arrays_1 = arrays; _a < arrays_1.length; _a++) {\n                        var array = arrays_1[_a];\n                        if (Array.isArray(array)) {\n                            for (var _b = 0, array_1 = array; _b < array_1.length; _b++) {\n                                var entry = array_1[_b];\n                                if (typeof entry === 'object') {\n                                    toWalk.push(entry);\n                                }\n                            }\n                        }\n                    }\n                };\n                var handleRef = function (next) {\n                    var seenRefs = [];\n                    while (next.$ref) {\n                        var ref = next.$ref;\n                        var segments = ref.split('#', 2);\n                        delete next.$ref;\n                        if (segments[0].length > 0) {\n                            openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies));\n                            return;\n                        }\n                        else {\n                            if (seenRefs.indexOf(ref) === -1) {\n                                merge(next, parentSchema, parentSchemaURL, segments[1]); // can set next.$ref again, use seenRefs to avoid circle\n                                seenRefs.push(ref);\n                            }\n                        }\n                    }\n                    collectEntries(next.items, next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else);\n                    collectMapEntries(next.definitions, next.properties, next.patternProperties, next.dependencies);\n                    collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.items);\n                };\n                while (toWalk.length) {\n                    var next = toWalk.pop();\n                    if (seen.indexOf(next) >= 0) {\n                        continue;\n                    }\n                    seen.push(next);\n                    handleRef(next);\n                }\n                return _this.promise.all(openPromises);\n            };\n            return resolveRefs(schema, schema, schemaURL, dependencies).then(function (_) { return new ResolvedSchema(schema, resolveErrors); });\n        };\n        JSONSchemaService.prototype.getSchemaForResource = function (resource, document) {\n            // first use $schema if present\n            if (document && document.root && document.root.type === 'object') {\n                var schemaProperties = document.root.properties.filter(function (p) { return (p.keyNode.value === '$schema') && p.valueNode && p.valueNode.type === 'string'; });\n                if (schemaProperties.length > 0) {\n                    var valueNode = schemaProperties[0].valueNode;\n                    if (valueNode && valueNode.type === 'string') {\n                        var schemeId = Parser.getNodeValue(valueNode);\n                        if (schemeId && Strings.startsWith(schemeId, '.') && this.contextService) {\n                            schemeId = this.contextService.resolveRelativePath(schemeId, resource);\n                        }\n                        if (schemeId) {\n                            var id = normalizeId(schemeId);\n                            return this.getOrAddSchemaHandle(id).getResolvedSchema();\n                        }\n                    }\n                }\n            }\n            if (this.cachedSchemaForResource && this.cachedSchemaForResource.resource === resource) {\n                return this.cachedSchemaForResource.resolvedSchema;\n            }\n            var seen = Object.create(null);\n            var schemas = [];\n            var normalizedResource = normalizeResourceForMatching(resource);\n            for (var _i = 0, _a = this.filePatternAssociations; _i < _a.length; _i++) {\n                var entry = _a[_i];\n                if (entry.matchesPattern(normalizedResource)) {\n                    for (var _b = 0, _c = entry.getURIs(); _b < _c.length; _b++) {\n                        var schemaId = _c[_b];\n                        if (!seen[schemaId]) {\n                            schemas.push(schemaId);\n                            seen[schemaId] = true;\n                        }\n                    }\n                }\n            }\n            var resolvedSchema = schemas.length > 0 ? this.createCombinedSchema(resource, schemas).getResolvedSchema() : this.promise.resolve(undefined);\n            this.cachedSchemaForResource = { resource: resource, resolvedSchema: resolvedSchema };\n            return resolvedSchema;\n        };\n        JSONSchemaService.prototype.createCombinedSchema = function (resource, schemaIds) {\n            if (schemaIds.length === 1) {\n                return this.getOrAddSchemaHandle(schemaIds[0]);\n            }\n            else {\n                var combinedSchemaId = 'schemaservice://combinedSchema/' + encodeURIComponent(resource);\n                var combinedSchema = {\n                    allOf: schemaIds.map(function (schemaId) { return ({ $ref: schemaId }); })\n                };\n                return this.addSchemaHandle(combinedSchemaId, combinedSchema);\n            }\n        };\n        JSONSchemaService.prototype.getMatchingSchemas = function (document, jsonDocument, schema) {\n            if (schema) {\n                var id = schema.id || ('schemaservice://untitled/matchingSchemas/' + idCounter++);\n                return this.resolveSchemaContent(new UnresolvedSchema(schema), id, {}).then(function (resolvedSchema) {\n                    return jsonDocument.getMatchingSchemas(resolvedSchema.schema).filter(function (s) { return !s.inverted; });\n                });\n            }\n            return this.getSchemaForResource(document.uri, jsonDocument).then(function (schema) {\n                if (schema) {\n                    return jsonDocument.getMatchingSchemas(schema.schema).filter(function (s) { return !s.inverted; });\n                }\n                return [];\n            });\n        };\n        return JSONSchemaService;\n    }());\n    exports.JSONSchemaService = JSONSchemaService;\n    var idCounter = 0;\n    function normalizeId(id) {\n        // remove trailing '#', normalize drive capitalization\n        try {\n            return vscode_uri_1.URI.parse(id).toString();\n        }\n        catch (e) {\n            return id;\n        }\n    }\n    function normalizeResourceForMatching(resource) {\n        // remove queries and fragments, normalize drive capitalization\n        try {\n            return vscode_uri_1.URI.parse(resource).with({ fragment: null, query: null }).toString();\n        }\n        catch (e) {\n            return resource;\n        }\n    }\n    function toDisplayString(url) {\n        try {\n            var uri = vscode_uri_1.URI.parse(url);\n            if (uri.scheme === 'file') {\n                return uri.fsPath;\n            }\n        }\n        catch (e) {\n            // ignore\n        }\n        return url;\n    }\n});\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/vscode-json-languageservice@4.1.8/node_modules/vscode-json-languageservice/lib/umd/services/jsonSchemaService.js?")},2636:function(module,exports){eval("/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"./jsonSchemaService\", \"../jsonLanguageTypes\", \"vscode-nls\", \"../utils/objects\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.JSONValidation = void 0;\n    var jsonSchemaService_1 = require(\"./jsonSchemaService\");\n    var jsonLanguageTypes_1 = require(\"../jsonLanguageTypes\");\n    var nls = require(\"vscode-nls\");\n    var objects_1 = require(\"../utils/objects\");\n    var localize = nls.loadMessageBundle();\n    var JSONValidation = /** @class */ (function () {\n        function JSONValidation(jsonSchemaService, promiseConstructor) {\n            this.jsonSchemaService = jsonSchemaService;\n            this.promise = promiseConstructor;\n            this.validationEnabled = true;\n        }\n        JSONValidation.prototype.configure = function (raw) {\n            if (raw) {\n                this.validationEnabled = raw.validate !== false;\n                this.commentSeverity = raw.allowComments ? undefined : jsonLanguageTypes_1.DiagnosticSeverity.Error;\n            }\n        };\n        JSONValidation.prototype.doValidation = function (textDocument, jsonDocument, documentSettings, schema) {\n            var _this = this;\n            if (!this.validationEnabled) {\n                return this.promise.resolve([]);\n            }\n            var diagnostics = [];\n            var added = {};\n            var addProblem = function (problem) {\n                // remove duplicated messages\n                var signature = problem.range.start.line + ' ' + problem.range.start.character + ' ' + problem.message;\n                if (!added[signature]) {\n                    added[signature] = true;\n                    diagnostics.push(problem);\n                }\n            };\n            var getDiagnostics = function (schema) {\n                var trailingCommaSeverity = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.trailingCommas) ? toDiagnosticSeverity(documentSettings.trailingCommas) : jsonLanguageTypes_1.DiagnosticSeverity.Error;\n                var commentSeverity = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.comments) ? toDiagnosticSeverity(documentSettings.comments) : _this.commentSeverity;\n                var schemaValidation = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.schemaValidation) ? toDiagnosticSeverity(documentSettings.schemaValidation) : jsonLanguageTypes_1.DiagnosticSeverity.Warning;\n                var schemaRequest = (documentSettings === null || documentSettings === void 0 ? void 0 : documentSettings.schemaRequest) ? toDiagnosticSeverity(documentSettings.schemaRequest) : jsonLanguageTypes_1.DiagnosticSeverity.Warning;\n                if (schema) {\n                    if (schema.errors.length && jsonDocument.root && schemaRequest) {\n                        var astRoot = jsonDocument.root;\n                        var property = astRoot.type === 'object' ? astRoot.properties[0] : undefined;\n                        if (property && property.keyNode.value === '$schema') {\n                            var node = property.valueNode || property;\n                            var range = jsonLanguageTypes_1.Range.create(textDocument.positionAt(node.offset), textDocument.positionAt(node.offset + node.length));\n                            addProblem(jsonLanguageTypes_1.Diagnostic.create(range, schema.errors[0], schemaRequest, jsonLanguageTypes_1.ErrorCode.SchemaResolveError));\n                        }\n                        else {\n                            var range = jsonLanguageTypes_1.Range.create(textDocument.positionAt(astRoot.offset), textDocument.positionAt(astRoot.offset + 1));\n                            addProblem(jsonLanguageTypes_1.Diagnostic.create(range, schema.errors[0], schemaRequest, jsonLanguageTypes_1.ErrorCode.SchemaResolveError));\n                        }\n                    }\n                    else if (schemaValidation) {\n                        var semanticErrors = jsonDocument.validate(textDocument, schema.schema, schemaValidation);\n                        if (semanticErrors) {\n                            semanticErrors.forEach(addProblem);\n                        }\n                    }\n                    if (schemaAllowsComments(schema.schema)) {\n                        commentSeverity = undefined;\n                    }\n                    if (schemaAllowsTrailingCommas(schema.schema)) {\n                        trailingCommaSeverity = undefined;\n                    }\n                }\n                for (var _i = 0, _a = jsonDocument.syntaxErrors; _i < _a.length; _i++) {\n                    var p = _a[_i];\n                    if (p.code === jsonLanguageTypes_1.ErrorCode.TrailingComma) {\n                        if (typeof trailingCommaSeverity !== 'number') {\n                            continue;\n                        }\n                        p.severity = trailingCommaSeverity;\n                    }\n                    addProblem(p);\n                }\n                if (typeof commentSeverity === 'number') {\n                    var message_1 = localize('InvalidCommentToken', 'Comments are not permitted in JSON.');\n                    jsonDocument.comments.forEach(function (c) {\n                        addProblem(jsonLanguageTypes_1.Diagnostic.create(c, message_1, commentSeverity, jsonLanguageTypes_1.ErrorCode.CommentNotPermitted));\n                    });\n                }\n                return diagnostics;\n            };\n            if (schema) {\n                var id = schema.id || ('schemaservice://untitled/' + idCounter++);\n                return this.jsonSchemaService.resolveSchemaContent(new jsonSchemaService_1.UnresolvedSchema(schema), id, {}).then(function (resolvedSchema) {\n                    return getDiagnostics(resolvedSchema);\n                });\n            }\n            return this.jsonSchemaService.getSchemaForResource(textDocument.uri, jsonDocument).then(function (schema) {\n                return getDiagnostics(schema);\n            });\n        };\n        return JSONValidation;\n    }());\n    exports.JSONValidation = JSONValidation;\n    var idCounter = 0;\n    function schemaAllowsComments(schemaRef) {\n        if (schemaRef && typeof schemaRef === 'object') {\n            if (objects_1.isBoolean(schemaRef.allowComments)) {\n                return schemaRef.allowComments;\n            }\n            if (schemaRef.allOf) {\n                for (var _i = 0, _a = schemaRef.allOf; _i < _a.length; _i++) {\n                    var schema = _a[_i];\n                    var allow = schemaAllowsComments(schema);\n                    if (objects_1.isBoolean(allow)) {\n                        return allow;\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n    function schemaAllowsTrailingCommas(schemaRef) {\n        if (schemaRef && typeof schemaRef === 'object') {\n            if (objects_1.isBoolean(schemaRef.allowTrailingCommas)) {\n                return schemaRef.allowTrailingCommas;\n            }\n            var deprSchemaRef = schemaRef;\n            if (objects_1.isBoolean(deprSchemaRef['allowsTrailingCommas'])) { // deprecated\n                return deprSchemaRef['allowsTrailingCommas'];\n            }\n            if (schemaRef.allOf) {\n                for (var _i = 0, _a = schemaRef.allOf; _i < _a.length; _i++) {\n                    var schema = _a[_i];\n                    var allow = schemaAllowsTrailingCommas(schema);\n                    if (objects_1.isBoolean(allow)) {\n                        return allow;\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n    function toDiagnosticSeverity(severityLevel) {\n        switch (severityLevel) {\n            case 'error': return jsonLanguageTypes_1.DiagnosticSeverity.Error;\n            case 'warning': return jsonLanguageTypes_1.DiagnosticSeverity.Warning;\n            case 'ignore': return undefined;\n        }\n        return undefined;\n    }\n});\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/vscode-json-languageservice@4.1.8/node_modules/vscode-json-languageservice/lib/umd/services/jsonValidation.js?")},1793:function(module,exports){eval("/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar FullTextDocument = /** @class */ (function () {\n    function FullTextDocument(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n        get: function () {\n            return this._uri;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n        get: function () {\n            return this._languageId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\n        get: function () {\n            return this._version;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FullTextDocument.prototype.getText = function (range) {\n        if (range) {\n            var start = this.offsetAt(range.start);\n            var end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    };\n    FullTextDocument.prototype.update = function (changes, version) {\n        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\n            var change = changes_1[_i];\n            if (FullTextDocument.isIncremental(change)) {\n                // makes sure start is before end\n                var range = getWellformedRange(change.range);\n                // update content\n                var startOffset = this.offsetAt(range.start);\n                var endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                // update the offsets\n                var startLine = Math.max(range.start.line, 0);\n                var endLine = Math.max(range.end.line, 0);\n                var lineOffsets = this._lineOffsets;\n                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) {\n                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    }\n                }\n                else {\n                    if (addedLineOffsets.length < 10000) {\n                        lineOffsets.splice.apply(lineOffsets, __spreadArray([startLine + 1, endLine - startLine], addedLineOffsets, false));\n                    }\n                    else { // avoid too many arguments for splice\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    }\n                }\n                var diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) {\n                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                        lineOffsets[i] = lineOffsets[i] + diff;\n                    }\n                }\n            }\n            else if (FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = undefined;\n            }\n            else {\n                throw new Error('Unknown change event received');\n            }\n        }\n        this._version = version;\n    };\n    FullTextDocument.prototype.getLineOffsets = function () {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    };\n    FullTextDocument.prototype.positionAt = function (offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        var lineOffsets = this.getLineOffsets();\n        var low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        var line = low - 1;\n        return { line: line, character: offset - lineOffsets[line] };\n    };\n    FullTextDocument.prototype.offsetAt = function (position) {\n        var lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        var lineOffset = lineOffsets[position.line];\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    };\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n        get: function () {\n            return this.getLineOffsets().length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FullTextDocument.isIncremental = function (event) {\n        var candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    };\n    FullTextDocument.isFull = function (event) {\n        var candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    };\n    return FullTextDocument;\n}());\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new text document.\n     *\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param version The document's initial version number.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Updates a TextDocument by modifying its content.\n     *\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n     * @param changes the changes to apply to the document.\n     * @param version the changes version for the document.\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n     *\n     */\n    function update(document, changes, version) {\n        if (document instanceof FullTextDocument) {\n            document.update(changes, version);\n            return document;\n        }\n        else {\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n    }\n    TextDocument.update = update;\n    function applyEdits(document, edits) {\n        var text = document.getText();\n        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {\n            var diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        var lastModifiedOffset = 0;\n        var spans = [];\n        for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {\n            var e = sortedEdits_1[_i];\n            var startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) {\n                throw new Error('Overlapping edit');\n            }\n            else if (startOffset > lastModifiedOffset) {\n                spans.push(text.substring(lastModifiedOffset, startOffset));\n            }\n            if (e.newText.length) {\n                spans.push(e.newText);\n            }\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join('');\n    }\n    TextDocument.applyEdits = applyEdits;\n})(TextDocument || (TextDocument = {}));\nfunction mergeSort(data, compare) {\n    if (data.length <= 1) {\n        // sorted\n        return data;\n    }\n    var p = (data.length / 2) | 0;\n    var left = data.slice(0, p);\n    var right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    var leftIdx = 0;\n    var rightIdx = 0;\n    var i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n        var ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) {\n            // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n        }\n        else {\n            // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n    }\n    while (leftIdx < left.length) {\n        data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n        data[i++] = right[rightIdx++];\n    }\n    return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset) {\n    if (textOffset === void 0) { textOffset = 0; }\n    var result = isAtLineStart ? [textOffset] : [];\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charCodeAt(i);\n        if (ch === 13 /* CharCode.CarriageReturn */ || ch === 10 /* CharCode.LineFeed */) {\n            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\nfunction getWellformedRange(range) {\n    var start = range.start;\n    var end = range.end;\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n        return { start: end, end: start };\n    }\n    return range;\n}\nfunction getWellformedEdit(textEdit) {\n    var range = getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) {\n        return { newText: textEdit.newText, range: range };\n    }\n    return textEdit;\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/vscode-languageserver-textdocument@1.0.8/node_modules/vscode-languageserver-textdocument/lib/esm/main.js?")},3798:function(module,exports){eval('/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\'use strict\';\nexport var DocumentUri;\n(function (DocumentUri) {\n    function is(value) {\n        return typeof value === \'string\';\n    }\n    DocumentUri.is = is;\n})(DocumentUri || (DocumentUri = {}));\nexport var URI;\n(function (URI) {\n    function is(value) {\n        return typeof value === \'string\';\n    }\n    URI.is = is;\n})(URI || (URI = {}));\nexport var integer;\n(function (integer) {\n    integer.MIN_VALUE = -2147483648;\n    integer.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === \'number\' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n    }\n    integer.is = is;\n})(integer || (integer = {}));\nexport var uinteger;\n(function (uinteger) {\n    uinteger.MIN_VALUE = 0;\n    uinteger.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === \'number\' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n    }\n    uinteger.is = is;\n})(uinteger || (uinteger = {}));\n/**\n * The Position namespace provides helper functions to work with\n * {@link Position} literals.\n */\nexport var Position;\n(function (Position) {\n    /**\n     * Creates a new Position literal from the given line and character.\n     * @param line The position\'s line.\n     * @param character The position\'s character.\n     */\n    function create(line, character) {\n        if (line === Number.MAX_VALUE) {\n            line = uinteger.MAX_VALUE;\n        }\n        if (character === Number.MAX_VALUE) {\n            character = uinteger.MAX_VALUE;\n        }\n        return { line: line, character: character };\n    }\n    Position.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Position} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n    }\n    Position.is = is;\n})(Position || (Position = {}));\n/**\n * The Range namespace provides helper functions to work with\n * {@link Range} literals.\n */\nexport var Range;\n(function (Range) {\n    function create(one, two, three, four) {\n        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n            return { start: Position.create(one, two), end: Position.create(three, four) };\n        }\n        else if (Position.is(one) && Position.is(two)) {\n            return { start: one, end: two };\n        }\n        else {\n            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));\n        }\n    }\n    Range.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Range} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n    }\n    Range.is = is;\n})(Range || (Range = {}));\n/**\n * The Location namespace provides helper functions to work with\n * {@link Location} literals.\n */\nexport var Location;\n(function (Location) {\n    /**\n     * Creates a Location literal.\n     * @param uri The location\'s uri.\n     * @param range The location\'s range.\n     */\n    function create(uri, range) {\n        return { uri: uri, range: range };\n    }\n    Location.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Location} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n    }\n    Location.is = is;\n})(Location || (Location = {}));\n/**\n * The LocationLink namespace provides helper functions to work with\n * {@link LocationLink} literals.\n */\nexport var LocationLink;\n(function (LocationLink) {\n    /**\n     * Creates a LocationLink literal.\n     * @param targetUri The definition\'s uri.\n     * @param targetRange The full range of the definition.\n     * @param targetSelectionRange The span of the symbol definition at the target.\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\n     */\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\n    }\n    LocationLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link LocationLink} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n            && Range.is(candidate.targetSelectionRange)\n            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n    }\n    LocationLink.is = is;\n})(LocationLink || (LocationLink = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link Color} literals.\n */\nexport var Color;\n(function (Color) {\n    /**\n     * Creates a new Color literal.\n     */\n    function create(red, green, blue, alpha) {\n        return {\n            red: red,\n            green: green,\n            blue: blue,\n            alpha: alpha,\n        };\n    }\n    Color.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Color} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\n            && Is.numberRange(candidate.green, 0, 1)\n            && Is.numberRange(candidate.blue, 0, 1)\n            && Is.numberRange(candidate.alpha, 0, 1);\n    }\n    Color.is = is;\n})(Color || (Color = {}));\n/**\n * The ColorInformation namespace provides helper functions to work with\n * {@link ColorInformation} literals.\n */\nexport var ColorInformation;\n(function (ColorInformation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(range, color) {\n        return {\n            range: range,\n            color: color,\n        };\n    }\n    ColorInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n    }\n    ColorInformation.is = is;\n})(ColorInformation || (ColorInformation = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link ColorPresentation} literals.\n */\nexport var ColorPresentation;\n(function (ColorPresentation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(label, textEdit, additionalTextEdits) {\n        return {\n            label: label,\n            textEdit: textEdit,\n            additionalTextEdits: additionalTextEdits,\n        };\n    }\n    ColorPresentation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label)\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n    }\n    ColorPresentation.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\n/**\n * A set of predefined range kinds.\n */\nexport var FoldingRangeKind;\n(function (FoldingRangeKind) {\n    /**\n     * Folding range for a comment\n     */\n    FoldingRangeKind.Comment = \'comment\';\n    /**\n     * Folding range for an import or include\n     */\n    FoldingRangeKind.Imports = \'imports\';\n    /**\n     * Folding range for a region (e.g. `#region`)\n     */\n    FoldingRangeKind.Region = \'region\';\n})(FoldingRangeKind || (FoldingRangeKind = {}));\n/**\n * The folding range namespace provides helper functions to work with\n * {@link FoldingRange} literals.\n */\nexport var FoldingRange;\n(function (FoldingRange) {\n    /**\n     * Creates a new FoldingRange literal.\n     */\n    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n        var result = {\n            startLine: startLine,\n            endLine: endLine\n        };\n        if (Is.defined(startCharacter)) {\n            result.startCharacter = startCharacter;\n        }\n        if (Is.defined(endCharacter)) {\n            result.endCharacter = endCharacter;\n        }\n        if (Is.defined(kind)) {\n            result.kind = kind;\n        }\n        if (Is.defined(collapsedText)) {\n            result.collapsedText = collapsedText;\n        }\n        return result;\n    }\n    FoldingRange.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n    }\n    FoldingRange.is = is;\n})(FoldingRange || (FoldingRange = {}));\n/**\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\n * {@link DiagnosticRelatedInformation} literals.\n */\nexport var DiagnosticRelatedInformation;\n(function (DiagnosticRelatedInformation) {\n    /**\n     * Creates a new DiagnosticRelatedInformation literal.\n     */\n    function create(location, message) {\n        return {\n            location: location,\n            message: message\n        };\n    }\n    DiagnosticRelatedInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n    }\n    DiagnosticRelatedInformation.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\n/**\n * The diagnostic\'s severity.\n */\nexport var DiagnosticSeverity;\n(function (DiagnosticSeverity) {\n    /**\n     * Reports an error.\n     */\n    DiagnosticSeverity.Error = 1;\n    /**\n     * Reports a warning.\n     */\n    DiagnosticSeverity.Warning = 2;\n    /**\n     * Reports an information.\n     */\n    DiagnosticSeverity.Information = 3;\n    /**\n     * Reports a hint.\n     */\n    DiagnosticSeverity.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\n/**\n * The diagnostic tags.\n *\n * @since 3.15.0\n */\nexport var DiagnosticTag;\n(function (DiagnosticTag) {\n    /**\n     * Unused or unnecessary code.\n     *\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\n     * an error squiggle.\n     */\n    DiagnosticTag.Unnecessary = 1;\n    /**\n     * Deprecated or obsolete code.\n     *\n     * Clients are allowed to rendered diagnostics with this tag strike through.\n     */\n    DiagnosticTag.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\n/**\n * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n *\n * @since 3.16.0\n */\nexport var CodeDescription;\n(function (CodeDescription) {\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.href);\n    }\n    CodeDescription.is = is;\n})(CodeDescription || (CodeDescription = {}));\n/**\n * The Diagnostic namespace provides helper functions to work with\n * {@link Diagnostic} literals.\n */\nexport var Diagnostic;\n(function (Diagnostic) {\n    /**\n     * Creates a new Diagnostic literal.\n     */\n    function create(range, message, severity, code, source, relatedInformation) {\n        var result = { range: range, message: message };\n        if (Is.defined(severity)) {\n            result.severity = severity;\n        }\n        if (Is.defined(code)) {\n            result.code = code;\n        }\n        if (Is.defined(source)) {\n            result.source = source;\n        }\n        if (Is.defined(relatedInformation)) {\n            result.relatedInformation = relatedInformation;\n        }\n        return result;\n    }\n    Diagnostic.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n     */\n    function is(value) {\n        var _a;\n        var candidate = value;\n        return Is.defined(candidate)\n            && Range.is(candidate.range)\n            && Is.string(candidate.message)\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n    }\n    Diagnostic.is = is;\n})(Diagnostic || (Diagnostic = {}));\n/**\n * The Command namespace provides helper functions to work with\n * {@link Command} literals.\n */\nexport var Command;\n(function (Command) {\n    /**\n     * Creates a new Command literal.\n     */\n    function create(title, command) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        var result = { title: title, command: command };\n        if (Is.defined(args) && args.length > 0) {\n            result.arguments = args;\n        }\n        return result;\n    }\n    Command.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Command} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n    }\n    Command.is = is;\n})(Command || (Command = {}));\n/**\n * The TextEdit namespace provides helper function to create replace,\n * insert and delete edits more easily.\n */\nexport var TextEdit;\n(function (TextEdit) {\n    /**\n     * Creates a replace text edit.\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     */\n    function replace(range, newText) {\n        return { range: range, newText: newText };\n    }\n    TextEdit.replace = replace;\n    /**\n     * Creates an insert text edit.\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     */\n    function insert(position, newText) {\n        return { range: { start: position, end: position }, newText: newText };\n    }\n    TextEdit.insert = insert;\n    /**\n     * Creates a delete text edit.\n     * @param range The range of text to be deleted.\n     */\n    function del(range) {\n        return { range: range, newText: \'\' };\n    }\n    TextEdit.del = del;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate)\n            && Is.string(candidate.newText)\n            && Range.is(candidate.range);\n    }\n    TextEdit.is = is;\n})(TextEdit || (TextEdit = {}));\nexport var ChangeAnnotation;\n(function (ChangeAnnotation) {\n    function create(label, needsConfirmation, description) {\n        var result = { label: label };\n        if (needsConfirmation !== undefined) {\n            result.needsConfirmation = needsConfirmation;\n        }\n        if (description !== undefined) {\n            result.description = description;\n        }\n        return result;\n    }\n    ChangeAnnotation.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    ChangeAnnotation.is = is;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nexport var ChangeAnnotationIdentifier;\n(function (ChangeAnnotationIdentifier) {\n    function is(value) {\n        var candidate = value;\n        return Is.string(candidate);\n    }\n    ChangeAnnotationIdentifier.is = is;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nexport var AnnotatedTextEdit;\n(function (AnnotatedTextEdit) {\n    /**\n     * Creates an annotated replace text edit.\n     *\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     * @param annotation The annotation.\n     */\n    function replace(range, newText, annotation) {\n        return { range: range, newText: newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.replace = replace;\n    /**\n     * Creates an annotated insert text edit.\n     *\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     * @param annotation The annotation.\n     */\n    function insert(position, newText, annotation) {\n        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.insert = insert;\n    /**\n     * Creates an annotated delete text edit.\n     *\n     * @param range The range of text to be deleted.\n     * @param annotation The annotation.\n     */\n    function del(range, annotation) {\n        return { range: range, newText: \'\', annotationId: annotation };\n    }\n    AnnotatedTextEdit.del = del;\n    function is(value) {\n        var candidate = value;\n        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    AnnotatedTextEdit.is = is;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\n/**\n * The TextDocumentEdit namespace provides helper function to create\n * an edit that manipulates a text document.\n */\nexport var TextDocumentEdit;\n(function (TextDocumentEdit) {\n    /**\n     * Creates a new `TextDocumentEdit`\n     */\n    function create(textDocument, edits) {\n        return { textDocument: textDocument, edits: edits };\n    }\n    TextDocumentEdit.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate)\n            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n            && Array.isArray(candidate.edits);\n    }\n    TextDocumentEdit.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nexport var CreateFile;\n(function (CreateFile) {\n    function create(uri, options, annotation) {\n        var result = {\n            kind: \'create\',\n            uri: uri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    CreateFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === \'create\' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    CreateFile.is = is;\n})(CreateFile || (CreateFile = {}));\nexport var RenameFile;\n(function (RenameFile) {\n    function create(oldUri, newUri, options, annotation) {\n        var result = {\n            kind: \'rename\',\n            oldUri: oldUri,\n            newUri: newUri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    RenameFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === \'rename\' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    RenameFile.is = is;\n})(RenameFile || (RenameFile = {}));\nexport var DeleteFile;\n(function (DeleteFile) {\n    function create(uri, options, annotation) {\n        var result = {\n            kind: \'delete\',\n            uri: uri\n        };\n        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    DeleteFile.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && candidate.kind === \'delete\' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    DeleteFile.is = is;\n})(DeleteFile || (DeleteFile = {}));\nexport var WorkspaceEdit;\n(function (WorkspaceEdit) {\n    function is(value) {\n        var candidate = value;\n        return candidate &&\n            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {\n                if (Is.string(change.kind)) {\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                }\n                else {\n                    return TextDocumentEdit.is(change);\n                }\n            }));\n    }\n    WorkspaceEdit.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nvar TextEditChangeImpl = /** @class */ (function () {\n    function TextEditChangeImpl(edits, changeAnnotations) {\n        this.edits = edits;\n        this.changeAnnotations = changeAnnotations;\n    }\n    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = TextEdit.insert(position, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.insert(position, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.insert(position, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = TextEdit.replace(range, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.replace(range, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.replace(range, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.delete = function (range, annotation) {\n        var edit;\n        var id;\n        if (annotation === undefined) {\n            edit = TextEdit.del(range);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.del(range, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.del(range, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    TextEditChangeImpl.prototype.add = function (edit) {\n        this.edits.push(edit);\n    };\n    TextEditChangeImpl.prototype.all = function () {\n        return this.edits;\n    };\n    TextEditChangeImpl.prototype.clear = function () {\n        this.edits.splice(0, this.edits.length);\n    };\n    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {\n        if (value === undefined) {\n            throw new Error("Text edit change is not configured to manage change annotations.");\n        }\n    };\n    return TextEditChangeImpl;\n}());\n/**\n * A helper class\n */\nvar ChangeAnnotations = /** @class */ (function () {\n    function ChangeAnnotations(annotations) {\n        this._annotations = annotations === undefined ? Object.create(null) : annotations;\n        this._counter = 0;\n        this._size = 0;\n    }\n    ChangeAnnotations.prototype.all = function () {\n        return this._annotations;\n    };\n    Object.defineProperty(ChangeAnnotations.prototype, "size", {\n        get: function () {\n            return this._size;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {\n        var id;\n        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n            id = idOrAnnotation;\n        }\n        else {\n            id = this.nextId();\n            annotation = idOrAnnotation;\n        }\n        if (this._annotations[id] !== undefined) {\n            throw new Error("Id ".concat(id, " is already in use."));\n        }\n        if (annotation === undefined) {\n            throw new Error("No annotation provided for id ".concat(id));\n        }\n        this._annotations[id] = annotation;\n        this._size++;\n        return id;\n    };\n    ChangeAnnotations.prototype.nextId = function () {\n        this._counter++;\n        return this._counter.toString();\n    };\n    return ChangeAnnotations;\n}());\n/**\n * A workspace change helps constructing changes to a workspace.\n */\nvar WorkspaceChange = /** @class */ (function () {\n    function WorkspaceChange(workspaceEdit) {\n        var _this = this;\n        this._textEditChanges = Object.create(null);\n        if (workspaceEdit !== undefined) {\n            this._workspaceEdit = workspaceEdit;\n            if (workspaceEdit.documentChanges) {\n                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                workspaceEdit.documentChanges.forEach(function (change) {\n                    if (TextDocumentEdit.is(change)) {\n                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\n                        _this._textEditChanges[change.textDocument.uri] = textEditChange;\n                    }\n                });\n            }\n            else if (workspaceEdit.changes) {\n                Object.keys(workspaceEdit.changes).forEach(function (key) {\n                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    _this._textEditChanges[key] = textEditChange;\n                });\n            }\n        }\n        else {\n            this._workspaceEdit = {};\n        }\n    }\n    Object.defineProperty(WorkspaceChange.prototype, "edit", {\n        /**\n         * Returns the underlying {@link WorkspaceEdit} literal\n         * use to be returned from a workspace edit operation like rename.\n         */\n        get: function () {\n            this.initDocumentChanges();\n            if (this._changeAnnotations !== undefined) {\n                if (this._changeAnnotations.size === 0) {\n                    this._workspaceEdit.changeAnnotations = undefined;\n                }\n                else {\n                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                }\n            }\n            return this._workspaceEdit;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WorkspaceChange.prototype.getTextEditChange = function (key) {\n        if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error(\'Workspace edit is not configured for document changes.\');\n            }\n            var textDocument = { uri: key.uri, version: key.version };\n            var result = this._textEditChanges[textDocument.uri];\n            if (!result) {\n                var edits = [];\n                var textDocumentEdit = {\n                    textDocument: textDocument,\n                    edits: edits\n                };\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                this._textEditChanges[textDocument.uri] = result;\n            }\n            return result;\n        }\n        else {\n            this.initChanges();\n            if (this._workspaceEdit.changes === undefined) {\n                throw new Error(\'Workspace edit is not configured for normal text edit changes.\');\n            }\n            var result = this._textEditChanges[key];\n            if (!result) {\n                var edits = [];\n                this._workspaceEdit.changes[key] = edits;\n                result = new TextEditChangeImpl(edits);\n                this._textEditChanges[key] = result;\n            }\n            return result;\n        }\n    };\n    WorkspaceChange.prototype.initDocumentChanges = function () {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._changeAnnotations = new ChangeAnnotations();\n            this._workspaceEdit.documentChanges = [];\n            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        }\n    };\n    WorkspaceChange.prototype.initChanges = function () {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._workspaceEdit.changes = Object.create(null);\n        }\n    };\n    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error(\'Workspace edit is not configured for document changes.\');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = CreateFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = CreateFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error(\'Workspace edit is not configured for document changes.\');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = RenameFile.create(oldUri, newUri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = RenameFile.create(oldUri, newUri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error(\'Workspace edit is not configured for document changes.\');\n        }\n        var annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        var operation;\n        var id;\n        if (annotation === undefined) {\n            operation = DeleteFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = DeleteFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    };\n    return WorkspaceChange;\n}());\nexport { WorkspaceChange };\n/**\n * The TextDocumentIdentifier namespace provides helper functions to work with\n * {@link TextDocumentIdentifier} literals.\n */\nexport var TextDocumentIdentifier;\n(function (TextDocumentIdentifier) {\n    /**\n     * Creates a new TextDocumentIdentifier literal.\n     * @param uri The document\'s uri.\n     */\n    function create(uri) {\n        return { uri: uri };\n    }\n    TextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri);\n    }\n    TextDocumentIdentifier.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\n/**\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link VersionedTextDocumentIdentifier} literals.\n */\nexport var VersionedTextDocumentIdentifier;\n(function (VersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new VersionedTextDocumentIdentifier literal.\n     * @param uri The document\'s uri.\n     * @param version The document\'s version.\n     */\n    function create(uri, version) {\n        return { uri: uri, version: version };\n    }\n    VersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n    }\n    VersionedTextDocumentIdentifier.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\n/**\n * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link OptionalVersionedTextDocumentIdentifier} literals.\n */\nexport var OptionalVersionedTextDocumentIdentifier;\n(function (OptionalVersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n     * @param uri The document\'s uri.\n     * @param version The document\'s version.\n     */\n    function create(uri, version) {\n        return { uri: uri, version: version };\n    }\n    OptionalVersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n    }\n    OptionalVersionedTextDocumentIdentifier.is = is;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\n/**\n * The TextDocumentItem namespace provides helper functions to work with\n * {@link TextDocumentItem} literals.\n */\nexport var TextDocumentItem;\n(function (TextDocumentItem) {\n    /**\n     * Creates a new TextDocumentItem literal.\n     * @param uri The document\'s uri.\n     * @param languageId The document\'s language identifier.\n     * @param version The document\'s version number.\n     * @param text The document\'s text.\n     */\n    function create(uri, languageId, version, text) {\n        return { uri: uri, languageId: languageId, version: version, text: text };\n    }\n    TextDocumentItem.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n    }\n    TextDocumentItem.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\n/**\n * Describes the content type that a client supports in various\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n *\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\n * are reserved for internal usage.\n */\nexport var MarkupKind;\n(function (MarkupKind) {\n    /**\n     * Plain text is supported as a content format\n     */\n    MarkupKind.PlainText = \'plaintext\';\n    /**\n     * Markdown is supported as a content format\n     */\n    MarkupKind.Markdown = \'markdown\';\n    /**\n     * Checks whether the given value is a value of the {@link MarkupKind} type.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n    }\n    MarkupKind.is = is;\n})(MarkupKind || (MarkupKind = {}));\nexport var MarkupContent;\n(function (MarkupContent) {\n    /**\n     * Checks whether the given value conforms to the {@link MarkupContent} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n    }\n    MarkupContent.is = is;\n})(MarkupContent || (MarkupContent = {}));\n/**\n * The kind of a completion entry.\n */\nexport var CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind.Text = 1;\n    CompletionItemKind.Method = 2;\n    CompletionItemKind.Function = 3;\n    CompletionItemKind.Constructor = 4;\n    CompletionItemKind.Field = 5;\n    CompletionItemKind.Variable = 6;\n    CompletionItemKind.Class = 7;\n    CompletionItemKind.Interface = 8;\n    CompletionItemKind.Module = 9;\n    CompletionItemKind.Property = 10;\n    CompletionItemKind.Unit = 11;\n    CompletionItemKind.Value = 12;\n    CompletionItemKind.Enum = 13;\n    CompletionItemKind.Keyword = 14;\n    CompletionItemKind.Snippet = 15;\n    CompletionItemKind.Color = 16;\n    CompletionItemKind.File = 17;\n    CompletionItemKind.Reference = 18;\n    CompletionItemKind.Folder = 19;\n    CompletionItemKind.EnumMember = 20;\n    CompletionItemKind.Constant = 21;\n    CompletionItemKind.Struct = 22;\n    CompletionItemKind.Event = 23;\n    CompletionItemKind.Operator = 24;\n    CompletionItemKind.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\n/**\n * Defines whether the insert text in a completion item should be interpreted as\n * plain text or a snippet.\n */\nexport var InsertTextFormat;\n(function (InsertTextFormat) {\n    /**\n     * The primary text to be inserted is treated as a plain string.\n     */\n    InsertTextFormat.PlainText = 1;\n    /**\n     * The primary text to be inserted is treated as a snippet.\n     *\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n     * the end of the snippet. Placeholders with equal identifiers are linked,\n     * that is typing in one will update others too.\n     *\n     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n     */\n    InsertTextFormat.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\n/**\n * Completion item tags are extra annotations that tweak the rendering of a completion\n * item.\n *\n * @since 3.15.0\n */\nexport var CompletionItemTag;\n(function (CompletionItemTag) {\n    /**\n     * Render a completion as obsolete, usually using a strike-out.\n     */\n    CompletionItemTag.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\n/**\n * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n *\n * @since 3.16.0\n */\nexport var InsertReplaceEdit;\n(function (InsertReplaceEdit) {\n    /**\n     * Creates a new insert / replace edit\n     */\n    function create(newText, insert, replace) {\n        return { newText: newText, insert: insert, replace: replace };\n    }\n    InsertReplaceEdit.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n    }\n    InsertReplaceEdit.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\n/**\n * How whitespace and indentation is handled during completion\n * item insertion.\n *\n * @since 3.16.0\n */\nexport var InsertTextMode;\n(function (InsertTextMode) {\n    /**\n     * The insertion or replace strings is taken as it is. If the\n     * value is multi line the lines below the cursor will be\n     * inserted using the indentation defined in the string value.\n     * The client will not apply any kind of adjustments to the\n     * string.\n     */\n    InsertTextMode.asIs = 1;\n    /**\n     * The editor adjusts leading whitespace of new lines so that\n     * they match the indentation up to the cursor of the line for\n     * which the item is accepted.\n     *\n     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n     * multi line completion item is indented using 2 tabs and all\n     * following lines inserted will be indented using 2 tabs as well.\n     */\n    InsertTextMode.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\nexport var CompletionItemLabelDetails;\n(function (CompletionItemLabelDetails) {\n    function is(value) {\n        var candidate = value;\n        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    CompletionItemLabelDetails.is = is;\n})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));\n/**\n * The CompletionItem namespace provides functions to deal with\n * completion items.\n */\nexport var CompletionItem;\n(function (CompletionItem) {\n    /**\n     * Create a completion item and seed it with a label.\n     * @param label The completion item\'s label\n     */\n    function create(label) {\n        return { label: label };\n    }\n    CompletionItem.create = create;\n})(CompletionItem || (CompletionItem = {}));\n/**\n * The CompletionList namespace provides functions to deal with\n * completion lists.\n */\nexport var CompletionList;\n(function (CompletionList) {\n    /**\n     * Creates a new completion list.\n     *\n     * @param items The completion items.\n     * @param isIncomplete The list is not complete.\n     */\n    function create(items, isIncomplete) {\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\n    }\n    CompletionList.create = create;\n})(CompletionList || (CompletionList = {}));\nexport var MarkedString;\n(function (MarkedString) {\n    /**\n     * Creates a marked string from plain text.\n     *\n     * @param plainText The plain text.\n     */\n    function fromPlainText(plainText) {\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \'\\\\$&\'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    MarkedString.fromPlainText = fromPlainText;\n    /**\n     * Checks whether the given value conforms to the {@link MarkedString} type.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n    }\n    MarkedString.is = is;\n})(MarkedString || (MarkedString = {}));\nexport var Hover;\n(function (Hover) {\n    /**\n     * Checks whether the given value conforms to the {@link Hover} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n            MarkedString.is(candidate.contents) ||\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n    }\n    Hover.is = is;\n})(Hover || (Hover = {}));\n/**\n * The ParameterInformation namespace provides helper functions to work with\n * {@link ParameterInformation} literals.\n */\nexport var ParameterInformation;\n(function (ParameterInformation) {\n    /**\n     * Creates a new parameter information literal.\n     *\n     * @param label A label string.\n     * @param documentation A doc string.\n     */\n    function create(label, documentation) {\n        return documentation ? { label: label, documentation: documentation } : { label: label };\n    }\n    ParameterInformation.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\n/**\n * The SignatureInformation namespace provides helper functions to work with\n * {@link SignatureInformation} literals.\n */\nexport var SignatureInformation;\n(function (SignatureInformation) {\n    function create(label, documentation) {\n        var parameters = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            parameters[_i - 2] = arguments[_i];\n        }\n        var result = { label: label };\n        if (Is.defined(documentation)) {\n            result.documentation = documentation;\n        }\n        if (Is.defined(parameters)) {\n            result.parameters = parameters;\n        }\n        else {\n            result.parameters = [];\n        }\n        return result;\n    }\n    SignatureInformation.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind.Text = 1;\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind.Read = 2;\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * DocumentHighlight namespace to provide helper functions to work with\n * {@link DocumentHighlight} literals.\n */\nexport var DocumentHighlight;\n(function (DocumentHighlight) {\n    /**\n     * Create a DocumentHighlight object.\n     * @param range The range the highlight applies to.\n     * @param kind The highlight kind\n     */\n    function create(range, kind) {\n        var result = { range: range };\n        if (Is.number(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    DocumentHighlight.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\n/**\n * A symbol kind.\n */\nexport var SymbolKind;\n(function (SymbolKind) {\n    SymbolKind.File = 1;\n    SymbolKind.Module = 2;\n    SymbolKind.Namespace = 3;\n    SymbolKind.Package = 4;\n    SymbolKind.Class = 5;\n    SymbolKind.Method = 6;\n    SymbolKind.Property = 7;\n    SymbolKind.Field = 8;\n    SymbolKind.Constructor = 9;\n    SymbolKind.Enum = 10;\n    SymbolKind.Interface = 11;\n    SymbolKind.Function = 12;\n    SymbolKind.Variable = 13;\n    SymbolKind.Constant = 14;\n    SymbolKind.String = 15;\n    SymbolKind.Number = 16;\n    SymbolKind.Boolean = 17;\n    SymbolKind.Array = 18;\n    SymbolKind.Object = 19;\n    SymbolKind.Key = 20;\n    SymbolKind.Null = 21;\n    SymbolKind.EnumMember = 22;\n    SymbolKind.Struct = 23;\n    SymbolKind.Event = 24;\n    SymbolKind.Operator = 25;\n    SymbolKind.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\n/**\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\n *\n * @since 3.16\n */\nexport var SymbolTag;\n(function (SymbolTag) {\n    /**\n     * Render a symbol as obsolete, usually using a strike-out.\n     */\n    SymbolTag.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nexport var SymbolInformation;\n(function (SymbolInformation) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the location of the symbol.\n     * @param uri The resource of the location of symbol.\n     * @param containerName The name of the symbol containing the symbol.\n     */\n    function create(name, kind, range, uri, containerName) {\n        var result = {\n            name: name,\n            kind: kind,\n            location: { uri: uri, range: range }\n        };\n        if (containerName) {\n            result.containerName = containerName;\n        }\n        return result;\n    }\n    SymbolInformation.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nexport var WorkspaceSymbol;\n(function (WorkspaceSymbol) {\n    /**\n     * Create a new workspace symbol.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param uri The resource of the location of the symbol.\n     * @param range An options range of the location.\n     * @returns A WorkspaceSymbol.\n     */\n    function create(name, kind, uri, range) {\n        return range !== undefined\n            ? { name: name, kind: kind, location: { uri: uri, range: range } }\n            : { name: name, kind: kind, location: { uri: uri } };\n    }\n    WorkspaceSymbol.create = create;\n})(WorkspaceSymbol || (WorkspaceSymbol = {}));\nexport var DocumentSymbol;\n(function (DocumentSymbol) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param detail The detail of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the symbol.\n     * @param selectionRange The selectionRange of the symbol.\n     * @param children Children of the symbol.\n     */\n    function create(name, detail, kind, range, selectionRange, children) {\n        var result = {\n            name: name,\n            detail: detail,\n            kind: kind,\n            range: range,\n            selectionRange: selectionRange\n        };\n        if (children !== undefined) {\n            result.children = children;\n        }\n        return result;\n    }\n    DocumentSymbol.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return candidate &&\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\n            (candidate.detail === undefined || Is.string(candidate.detail)) &&\n            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n            (candidate.children === undefined || Array.isArray(candidate.children)) &&\n            (candidate.tags === undefined || Array.isArray(candidate.tags));\n    }\n    DocumentSymbol.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\n/**\n * A set of predefined code action kinds\n */\nexport var CodeActionKind;\n(function (CodeActionKind) {\n    /**\n     * Empty kind.\n     */\n    CodeActionKind.Empty = \'\';\n    /**\n     * Base kind for quickfix actions: \'quickfix\'\n     */\n    CodeActionKind.QuickFix = \'quickfix\';\n    /**\n     * Base kind for refactoring actions: \'refactor\'\n     */\n    CodeActionKind.Refactor = \'refactor\';\n    /**\n     * Base kind for refactoring extraction actions: \'refactor.extract\'\n     *\n     * Example extract actions:\n     *\n     * - Extract method\n     * - Extract function\n     * - Extract variable\n     * - Extract interface from class\n     * - ...\n     */\n    CodeActionKind.RefactorExtract = \'refactor.extract\';\n    /**\n     * Base kind for refactoring inline actions: \'refactor.inline\'\n     *\n     * Example inline actions:\n     *\n     * - Inline function\n     * - Inline variable\n     * - Inline constant\n     * - ...\n     */\n    CodeActionKind.RefactorInline = \'refactor.inline\';\n    /**\n     * Base kind for refactoring rewrite actions: \'refactor.rewrite\'\n     *\n     * Example rewrite actions:\n     *\n     * - Convert JavaScript function to class\n     * - Add or remove parameter\n     * - Encapsulate field\n     * - Make method static\n     * - Move method to base class\n     * - ...\n     */\n    CodeActionKind.RefactorRewrite = \'refactor.rewrite\';\n    /**\n     * Base kind for source actions: `source`\n     *\n     * Source code actions apply to the entire file.\n     */\n    CodeActionKind.Source = \'source\';\n    /**\n     * Base kind for an organize imports source action: `source.organizeImports`\n     */\n    CodeActionKind.SourceOrganizeImports = \'source.organizeImports\';\n    /**\n     * Base kind for auto-fix source actions: `source.fixAll`.\n     *\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n     *\n     * @since 3.15.0\n     */\n    CodeActionKind.SourceFixAll = \'source.fixAll\';\n})(CodeActionKind || (CodeActionKind = {}));\n/**\n * The reason why code actions were requested.\n *\n * @since 3.17.0\n */\nexport var CodeActionTriggerKind;\n(function (CodeActionTriggerKind) {\n    /**\n     * Code actions were explicitly requested by the user or by an extension.\n     */\n    CodeActionTriggerKind.Invoked = 1;\n    /**\n     * Code actions were requested automatically.\n     *\n     * This typically happens when current selection in a file changes, but can\n     * also be triggered when file content changes.\n     */\n    CodeActionTriggerKind.Automatic = 2;\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));\n/**\n * The CodeActionContext namespace provides helper functions to work with\n * {@link CodeActionContext} literals.\n */\nexport var CodeActionContext;\n(function (CodeActionContext) {\n    /**\n     * Creates a new CodeActionContext literal.\n     */\n    function create(diagnostics, only, triggerKind) {\n        var result = { diagnostics: diagnostics };\n        if (only !== undefined && only !== null) {\n            result.only = only;\n        }\n        if (triggerKind !== undefined && triggerKind !== null) {\n            result.triggerKind = triggerKind;\n        }\n        return result;\n    }\n    CodeActionContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\n            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\n            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n    }\n    CodeActionContext.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nexport var CodeAction;\n(function (CodeAction) {\n    function create(title, kindOrCommandOrEdit, kind) {\n        var result = { title: title };\n        var checkKind = true;\n        if (typeof kindOrCommandOrEdit === \'string\') {\n            checkKind = false;\n            result.kind = kindOrCommandOrEdit;\n        }\n        else if (Command.is(kindOrCommandOrEdit)) {\n            result.command = kindOrCommandOrEdit;\n        }\n        else {\n            result.edit = kindOrCommandOrEdit;\n        }\n        if (checkKind && kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    CodeAction.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate && Is.string(candidate.title) &&\n            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n            (candidate.kind === undefined || Is.string(candidate.kind)) &&\n            (candidate.edit !== undefined || candidate.command !== undefined) &&\n            (candidate.command === undefined || Command.is(candidate.command)) &&\n            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n    }\n    CodeAction.is = is;\n})(CodeAction || (CodeAction = {}));\n/**\n * The CodeLens namespace provides helper functions to work with\n * {@link CodeLens} literals.\n */\nexport var CodeLens;\n(function (CodeLens) {\n    /**\n     * Creates a new CodeLens literal.\n     */\n    function create(range, data) {\n        var result = { range: range };\n        if (Is.defined(data)) {\n            result.data = data;\n        }\n        return result;\n    }\n    CodeLens.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeLens} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n    }\n    CodeLens.is = is;\n})(CodeLens || (CodeLens = {}));\n/**\n * The FormattingOptions namespace provides helper functions to work with\n * {@link FormattingOptions} literals.\n */\nexport var FormattingOptions;\n(function (FormattingOptions) {\n    /**\n     * Creates a new FormattingOptions literal.\n     */\n    function create(tabSize, insertSpaces) {\n        return { tabSize: tabSize, insertSpaces: insertSpaces };\n    }\n    FormattingOptions.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n    }\n    FormattingOptions.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\n/**\n * The DocumentLink namespace provides helper functions to work with\n * {@link DocumentLink} literals.\n */\nexport var DocumentLink;\n(function (DocumentLink) {\n    /**\n     * Creates a new DocumentLink literal.\n     */\n    function create(range, target, data) {\n        return { range: range, target: target, data: data };\n    }\n    DocumentLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n    }\n    DocumentLink.is = is;\n})(DocumentLink || (DocumentLink = {}));\n/**\n * The SelectionRange namespace provides helper function to work with\n * SelectionRange literals.\n */\nexport var SelectionRange;\n(function (SelectionRange) {\n    /**\n     * Creates a new SelectionRange\n     * @param range the range.\n     * @param parent an optional parent.\n     */\n    function create(range, parent) {\n        return { range: range, parent: parent };\n    }\n    SelectionRange.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n    }\n    SelectionRange.is = is;\n})(SelectionRange || (SelectionRange = {}));\n/**\n * A set of predefined token types. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenTypes;\n(function (SemanticTokenTypes) {\n    SemanticTokenTypes["namespace"] = "namespace";\n    /**\n     * Represents a generic type. Acts as a fallback for types which can\'t be mapped to\n     * a specific type like class or enum.\n     */\n    SemanticTokenTypes["type"] = "type";\n    SemanticTokenTypes["class"] = "class";\n    SemanticTokenTypes["enum"] = "enum";\n    SemanticTokenTypes["interface"] = "interface";\n    SemanticTokenTypes["struct"] = "struct";\n    SemanticTokenTypes["typeParameter"] = "typeParameter";\n    SemanticTokenTypes["parameter"] = "parameter";\n    SemanticTokenTypes["variable"] = "variable";\n    SemanticTokenTypes["property"] = "property";\n    SemanticTokenTypes["enumMember"] = "enumMember";\n    SemanticTokenTypes["event"] = "event";\n    SemanticTokenTypes["function"] = "function";\n    SemanticTokenTypes["method"] = "method";\n    SemanticTokenTypes["macro"] = "macro";\n    SemanticTokenTypes["keyword"] = "keyword";\n    SemanticTokenTypes["modifier"] = "modifier";\n    SemanticTokenTypes["comment"] = "comment";\n    SemanticTokenTypes["string"] = "string";\n    SemanticTokenTypes["number"] = "number";\n    SemanticTokenTypes["regexp"] = "regexp";\n    SemanticTokenTypes["operator"] = "operator";\n    /**\n     * @since 3.17.0\n     */\n    SemanticTokenTypes["decorator"] = "decorator";\n})(SemanticTokenTypes || (SemanticTokenTypes = {}));\n/**\n * A set of predefined token modifiers. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nexport var SemanticTokenModifiers;\n(function (SemanticTokenModifiers) {\n    SemanticTokenModifiers["declaration"] = "declaration";\n    SemanticTokenModifiers["definition"] = "definition";\n    SemanticTokenModifiers["readonly"] = "readonly";\n    SemanticTokenModifiers["static"] = "static";\n    SemanticTokenModifiers["deprecated"] = "deprecated";\n    SemanticTokenModifiers["abstract"] = "abstract";\n    SemanticTokenModifiers["async"] = "async";\n    SemanticTokenModifiers["modification"] = "modification";\n    SemanticTokenModifiers["documentation"] = "documentation";\n    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";\n})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));\n/**\n * @since 3.16.0\n */\nexport var SemanticTokens;\n(function (SemanticTokens) {\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === \'string\') &&\n            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === \'number\');\n    }\n    SemanticTokens.is = is;\n})(SemanticTokens || (SemanticTokens = {}));\n/**\n * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n *\n * @since 3.17.0\n */\nexport var InlineValueText;\n(function (InlineValueText) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, text) {\n        return { range: range, text: text };\n    }\n    InlineValueText.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n    }\n    InlineValueText.is = is;\n})(InlineValueText || (InlineValueText = {}));\n/**\n * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n *\n * @since 3.17.0\n */\nexport var InlineValueVariableLookup;\n(function (InlineValueVariableLookup) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, variableName, caseSensitiveLookup) {\n        return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };\n    }\n    InlineValueVariableLookup.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\n            && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n    }\n    InlineValueVariableLookup.is = is;\n})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));\n/**\n * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n *\n * @since 3.17.0\n */\nexport var InlineValueEvaluatableExpression;\n(function (InlineValueEvaluatableExpression) {\n    /**\n     * Creates a new InlineValueEvaluatableExpression literal.\n     */\n    function create(range, expression) {\n        return { range: range, expression: expression };\n    }\n    InlineValueEvaluatableExpression.create = create;\n    function is(value) {\n        var candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range)\n            && (Is.string(candidate.expression) || candidate.expression === undefined);\n    }\n    InlineValueEvaluatableExpression.is = is;\n})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));\n/**\n * The InlineValueContext namespace provides helper functions to work with\n * {@link InlineValueContext} literals.\n *\n * @since 3.17.0\n */\nexport var InlineValueContext;\n(function (InlineValueContext) {\n    /**\n     * Creates a new InlineValueContext literal.\n     */\n    function create(frameId, stoppedLocation) {\n        return { frameId: frameId, stoppedLocation: stoppedLocation };\n    }\n    InlineValueContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Range.is(value.stoppedLocation);\n    }\n    InlineValueContext.is = is;\n})(InlineValueContext || (InlineValueContext = {}));\n/**\n * Inlay hint kinds.\n *\n * @since 3.17.0\n */\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    /**\n     * An inlay hint that for a type annotation.\n     */\n    InlayHintKind.Type = 1;\n    /**\n     * An inlay hint that is for a parameter.\n     */\n    InlayHintKind.Parameter = 2;\n    function is(value) {\n        return value === 1 || value === 2;\n    }\n    InlayHintKind.is = is;\n})(InlayHintKind || (InlayHintKind = {}));\nexport var InlayHintLabelPart;\n(function (InlayHintLabelPart) {\n    function create(value) {\n        return { value: value };\n    }\n    InlayHintLabelPart.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.location === undefined || Location.is(candidate.location))\n            && (candidate.command === undefined || Command.is(candidate.command));\n    }\n    InlayHintLabelPart.is = is;\n})(InlayHintLabelPart || (InlayHintLabelPart = {}));\nexport var InlayHint;\n(function (InlayHint) {\n    function create(position, label, kind) {\n        var result = { position: position, label: label };\n        if (kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    InlayHint.create = create;\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.position)\n            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\n            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\n            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\n            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n    }\n    InlayHint.is = is;\n})(InlayHint || (InlayHint = {}));\nexport var WorkspaceFolder;\n(function (WorkspaceFolder) {\n    function is(value) {\n        var candidate = value;\n        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n    }\n    WorkspaceFolder.is = is;\n})(WorkspaceFolder || (WorkspaceFolder = {}));\nexport var EOL = [\'\\n\', \'\\r\\n\', \'\\r\'];\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new ITextDocument literal from the given uri and content.\n     * @param uri The document\'s uri.\n     * @param languageId The document\'s language Id.\n     * @param version The document\'s version.\n     * @param content The document\'s content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n     */\n    function is(value) {\n        var candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n    }\n    TextDocument.is = is;\n    function applyEdits(document, edits) {\n        var text = document.getText();\n        var sortedEdits = mergeSort(edits, function (a, b) {\n            var diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        var lastModifiedOffset = text.length;\n        for (var i = sortedEdits.length - 1; i >= 0; i--) {\n            var e = sortedEdits[i];\n            var startOffset = document.offsetAt(e.range.start);\n            var endOffset = document.offsetAt(e.range.end);\n            if (endOffset <= lastModifiedOffset) {\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n            }\n            else {\n                throw new Error(\'Overlapping edit\');\n            }\n            lastModifiedOffset = startOffset;\n        }\n        return text;\n    }\n    TextDocument.applyEdits = applyEdits;\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        var p = (data.length / 2) | 0;\n        var left = data.slice(0, p);\n        var right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        var leftIdx = 0;\n        var rightIdx = 0;\n        var i = 0;\n        while (leftIdx < left.length && rightIdx < right.length) {\n            var ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            }\n            else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while (leftIdx < left.length) {\n            data[i++] = left[leftIdx++];\n        }\n        while (rightIdx < right.length) {\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n})(TextDocument || (TextDocument = {}));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nvar FullTextDocument = /** @class */ (function () {\n    function FullTextDocument(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    Object.defineProperty(FullTextDocument.prototype, "uri", {\n        get: function () {\n            return this._uri;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, "languageId", {\n        get: function () {\n            return this._languageId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, "version", {\n        get: function () {\n            return this._version;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FullTextDocument.prototype.getText = function (range) {\n        if (range) {\n            var start = this.offsetAt(range.start);\n            var end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    };\n    FullTextDocument.prototype.update = function (event, version) {\n        this._content = event.text;\n        this._version = version;\n        this._lineOffsets = undefined;\n    };\n    FullTextDocument.prototype.getLineOffsets = function () {\n        if (this._lineOffsets === undefined) {\n            var lineOffsets = [];\n            var text = this._content;\n            var isLineStart = true;\n            for (var i = 0; i < text.length; i++) {\n                if (isLineStart) {\n                    lineOffsets.push(i);\n                    isLineStart = false;\n                }\n                var ch = text.charAt(i);\n                isLineStart = (ch === \'\\r\' || ch === \'\\n\');\n                if (ch === \'\\r\' && i + 1 < text.length && text.charAt(i + 1) === \'\\n\') {\n                    i++;\n                }\n            }\n            if (isLineStart && text.length > 0) {\n                lineOffsets.push(text.length);\n            }\n            this._lineOffsets = lineOffsets;\n        }\n        return this._lineOffsets;\n    };\n    FullTextDocument.prototype.positionAt = function (offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        var lineOffsets = this.getLineOffsets();\n        var low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return Position.create(0, offset);\n        }\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        var line = low - 1;\n        return Position.create(line, offset - lineOffsets[line]);\n    };\n    FullTextDocument.prototype.offsetAt = function (position) {\n        var lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        var lineOffset = lineOffsets[position.line];\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    };\n    Object.defineProperty(FullTextDocument.prototype, "lineCount", {\n        get: function () {\n            return this.getLineOffsets().length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return FullTextDocument;\n}());\nvar Is;\n(function (Is) {\n    var toString = Object.prototype.toString;\n    function defined(value) {\n        return typeof value !== \'undefined\';\n    }\n    Is.defined = defined;\n    function undefined(value) {\n        return typeof value === \'undefined\';\n    }\n    Is.undefined = undefined;\n    function boolean(value) {\n        return value === true || value === false;\n    }\n    Is.boolean = boolean;\n    function string(value) {\n        return toString.call(value) === \'[object String]\';\n    }\n    Is.string = string;\n    function number(value) {\n        return toString.call(value) === \'[object Number]\';\n    }\n    Is.number = number;\n    function numberRange(value, min, max) {\n        return toString.call(value) === \'[object Number]\' && min <= value && value <= max;\n    }\n    Is.numberRange = numberRange;\n    function integer(value) {\n        return toString.call(value) === \'[object Number]\' && -2147483648 <= value && value <= 2147483647;\n    }\n    Is.integer = integer;\n    function uinteger(value) {\n        return toString.call(value) === \'[object Number]\' && 0 <= value && value <= 2147483647;\n    }\n    Is.uinteger = uinteger;\n    function func(value) {\n        return toString.call(value) === \'[object Function]\';\n    }\n    Is.func = func;\n    function objectLiteral(value) {\n        // Strictly speaking class instances pass this check as well. Since the LSP\n        // doesn\'t use classes we ignore this for now. If we do we need to add something\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n        return value !== null && typeof value === \'object\';\n    }\n    Is.objectLiteral = objectLiteral;\n    function typedArray(value, check) {\n        return Array.isArray(value) && value.every(check);\n    }\n    Is.typedArray = typedArray;\n})(Is || (Is = {}));\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/vscode-languageserver-types@3.17.3/node_modules/vscode-languageserver-types/lib/esm/main.js?')},864:function(module,exports){eval("\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n/// <reference path=\"../../typings/thenable.d.ts\" />\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createConnection = exports.Files = void 0;\nconst Is = require(\"../common/utils/is\");\nconst server_1 = require(\"../common/server\");\nconst fm = require(\"./files\");\nconst node_1 = require(\"vscode-languageserver-protocol/node\");\n__exportStar(require(\"vscode-languageserver-protocol/node\"), exports);\n__exportStar(require(\"../common/api\"), exports);\nvar Files;\n(function (Files) {\n    Files.uriToFilePath = fm.uriToFilePath;\n    Files.resolveGlobalNodePath = fm.resolveGlobalNodePath;\n    Files.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;\n    Files.resolve = fm.resolve;\n    Files.resolveModulePath = fm.resolveModulePath;\n})(Files = exports.Files || (exports.Files = {}));\nlet _protocolConnection;\nfunction endProtocolConnection() {\n    if (_protocolConnection === undefined) {\n        return;\n    }\n    try {\n        _protocolConnection.end();\n    }\n    catch (_err) {\n        // Ignore. The client process could have already\n        // did and we can't send an end into the connection.\n    }\n}\nlet _shutdownReceived = false;\nlet exitTimer = undefined;\nfunction setupExitTimer() {\n    const argName = '--clientProcessId';\n    function runTimer(value) {\n        try {\n            let processId = parseInt(value);\n            if (!isNaN(processId)) {\n                exitTimer = setInterval(() => {\n                    try {\n                        process.kill(processId, 0);\n                    }\n                    catch (ex) {\n                        // Parent process doesn't exist anymore. Exit the server.\n                        endProtocolConnection();\n                        process.exit(_shutdownReceived ? 0 : 1);\n                    }\n                }, 3000);\n            }\n        }\n        catch (e) {\n            // Ignore errors;\n        }\n    }\n    for (let i = 2; i < process.argv.length; i++) {\n        let arg = process.argv[i];\n        if (arg === argName && i + 1 < process.argv.length) {\n            runTimer(process.argv[i + 1]);\n            return;\n        }\n        else {\n            let args = arg.split('=');\n            if (args[0] === argName) {\n                runTimer(args[1]);\n            }\n        }\n    }\n}\nsetupExitTimer();\nconst watchDog = {\n    initialize: (params) => {\n        const processId = params.processId;\n        if (Is.number(processId) && exitTimer === undefined) {\n            // We received a parent process id. Set up a timer to periodically check\n            // if the parent is still alive.\n            setInterval(() => {\n                try {\n                    process.kill(processId, 0);\n                }\n                catch (ex) {\n                    // Parent process doesn't exist anymore. Exit the server.\n                    process.exit(_shutdownReceived ? 0 : 1);\n                }\n            }, 3000);\n        }\n    },\n    get shutdownReceived() {\n        return _shutdownReceived;\n    },\n    set shutdownReceived(value) {\n        _shutdownReceived = value;\n    },\n    exit: (code) => {\n        endProtocolConnection();\n        process.exit(code);\n    }\n};\nfunction createConnection(arg1, arg2, arg3, arg4) {\n    let factories;\n    let input;\n    let output;\n    let options;\n    if (arg1 !== void 0 && arg1.__brand === 'features') {\n        factories = arg1;\n        arg1 = arg2;\n        arg2 = arg3;\n        arg3 = arg4;\n    }\n    if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {\n        options = arg1;\n    }\n    else {\n        input = arg1;\n        output = arg2;\n        options = arg3;\n    }\n    return _createConnection(input, output, options, factories);\n}\nexports.createConnection = createConnection;\nfunction _createConnection(input, output, options, factories) {\n    if (!input && !output && process.argv.length > 2) {\n        let port = void 0;\n        let pipeName = void 0;\n        let argv = process.argv.slice(2);\n        for (let i = 0; i < argv.length; i++) {\n            let arg = argv[i];\n            if (arg === '--node-ipc') {\n                input = new node_1.IPCMessageReader(process);\n                output = new node_1.IPCMessageWriter(process);\n                break;\n            }\n            else if (arg === '--stdio') {\n                input = process.stdin;\n                output = process.stdout;\n                break;\n            }\n            else if (arg === '--socket') {\n                port = parseInt(argv[i + 1]);\n                break;\n            }\n            else if (arg === '--pipe') {\n                pipeName = argv[i + 1];\n                break;\n            }\n            else {\n                var args = arg.split('=');\n                if (args[0] === '--socket') {\n                    port = parseInt(args[1]);\n                    break;\n                }\n                else if (args[0] === '--pipe') {\n                    pipeName = args[1];\n                    break;\n                }\n            }\n        }\n        if (port) {\n            let transport = node_1.createServerSocketTransport(port);\n            input = transport[0];\n            output = transport[1];\n        }\n        else if (pipeName) {\n            let transport = node_1.createServerPipeTransport(pipeName);\n            input = transport[0];\n            output = transport[1];\n        }\n    }\n    var commandLineMessage = 'Use arguments of createConnection or set command line parameters: \\'--node-ipc\\', \\'--stdio\\' or \\'--socket={number}\\'';\n    if (!input) {\n        throw new Error('Connection input stream is not set. ' + commandLineMessage);\n    }\n    if (!output) {\n        throw new Error('Connection output stream is not set. ' + commandLineMessage);\n    }\n    // Backwards compatibility\n    if (Is.func(input.read) && Is.func(input.on)) {\n        let inputStream = input;\n        inputStream.on('end', () => {\n            endProtocolConnection();\n            process.exit(_shutdownReceived ? 0 : 1);\n        });\n        inputStream.on('close', () => {\n            endProtocolConnection();\n            process.exit(_shutdownReceived ? 0 : 1);\n        });\n    }\n    const connectionFactory = (logger) => {\n        const result = node_1.createProtocolConnection(input, output, logger, options);\n        return result;\n    };\n    return server_1.createConnection(connectionFactory, watchDog, factories);\n}\n//# sourceMappingURL=main.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/vscode-languageserver@7.0.0/node_modules/vscode-languageserver/lib/node/main.js?")},5055:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.config = exports.loadMessageBundle = exports.localize = exports.format = exports.setPseudo = exports.isPseudo = exports.isDefined = exports.BundleFormat = exports.MessageFormat = void 0;\nvar ral_1 = __webpack_require__(8764);\nvar MessageFormat;\n(function (MessageFormat) {\n    MessageFormat["file"] = "file";\n    MessageFormat["bundle"] = "bundle";\n    MessageFormat["both"] = "both";\n})(MessageFormat = exports.MessageFormat || (exports.MessageFormat = {}));\nvar BundleFormat;\n(function (BundleFormat) {\n    // the nls.bundle format\n    BundleFormat["standalone"] = "standalone";\n    BundleFormat["languagePack"] = "languagePack";\n})(BundleFormat = exports.BundleFormat || (exports.BundleFormat = {}));\nvar LocalizeInfo;\n(function (LocalizeInfo) {\n    function is(value) {\n        var candidate = value;\n        return candidate && isDefined(candidate.key) && isDefined(candidate.comment);\n    }\n    LocalizeInfo.is = is;\n})(LocalizeInfo || (LocalizeInfo = {}));\nfunction isDefined(value) {\n    return typeof value !== \'undefined\';\n}\nexports.isDefined = isDefined;\nexports.isPseudo = false;\nfunction setPseudo(pseudo) {\n    exports.isPseudo = pseudo;\n}\nexports.setPseudo = setPseudo;\nfunction format(message, args) {\n    var result;\n    if (exports.isPseudo) {\n        // FF3B and FF3D is the Unicode zenkaku representation for [ and ]\n        message = \'\\uFF3B\' + message.replace(/[aouei]/g, \'$&$&\') + \'\\uFF3D\';\n    }\n    if (args.length === 0) {\n        result = message;\n    }\n    else {\n        result = message.replace(/\\{(\\d+)\\}/g, function (match, rest) {\n            var index = rest[0];\n            var arg = args[index];\n            var replacement = match;\n            if (typeof arg === \'string\') {\n                replacement = arg;\n            }\n            else if (typeof arg === \'number\' || typeof arg === \'boolean\' || arg === void 0 || arg === null) {\n                replacement = String(arg);\n            }\n            return replacement;\n        });\n    }\n    return result;\n}\nexports.format = format;\nfunction localize(_key, message) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    return format(message, args);\n}\nexports.localize = localize;\nfunction loadMessageBundle(file) {\n    return (0, ral_1.default)().loadMessageBundle(file);\n}\nexports.loadMessageBundle = loadMessageBundle;\nfunction config(opts) {\n    return (0, ral_1.default)().config(opts);\n}\nexports.config = config;\n//# sourceMappingURL=common.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/vscode-nls@5.2.0/node_modules/vscode-nls/lib/common/common.js?')},8764:(__unused_webpack_module,exports)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nvar _ral;\nfunction RAL() {\n    if (_ral === undefined) {\n        throw new Error("No runtime abstraction layer installed");\n    }\n    return _ral;\n}\n(function (RAL) {\n    function install(ral) {\n        if (ral === undefined) {\n            throw new Error("No runtime abstraction layer provided");\n        }\n        _ral = ral;\n    }\n    RAL.install = install;\n})(RAL || (RAL = {}));\nexports["default"] = RAL;\n//# sourceMappingURL=ral.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/vscode-nls@5.2.0/node_modules/vscode-nls/lib/common/ral.js?')},731:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.config = exports.loadMessageBundle = exports.BundleFormat = exports.MessageFormat = void 0;\nvar path = __webpack_require__(1017);\nvar fs = __webpack_require__(7147);\nvar ral_1 = __webpack_require__(8764);\nvar common_1 = __webpack_require__(5055);\nvar common_2 = __webpack_require__(5055);\nObject.defineProperty(exports, \"MessageFormat\", ({ enumerable: true, get: function () { return common_2.MessageFormat; } }));\nObject.defineProperty(exports, \"BundleFormat\", ({ enumerable: true, get: function () { return common_2.BundleFormat; } }));\nvar toString = Object.prototype.toString;\nfunction isNumber(value) {\n    return toString.call(value) === '[object Number]';\n}\nfunction isString(value) {\n    return toString.call(value) === '[object String]';\n}\nfunction isBoolean(value) {\n    return value === true || value === false;\n}\nfunction readJsonFileSync(filename) {\n    return JSON.parse(fs.readFileSync(filename, 'utf8'));\n}\nvar resolvedBundles;\nvar options;\nfunction initializeSettings() {\n    options = { locale: undefined, language: undefined, languagePackSupport: false, cacheLanguageResolution: true, messageFormat: common_1.MessageFormat.bundle };\n    if (isString(process.env.VSCODE_NLS_CONFIG)) {\n        try {\n            var vscodeOptions_1 = JSON.parse(process.env.VSCODE_NLS_CONFIG);\n            var language = void 0;\n            if (vscodeOptions_1.availableLanguages) {\n                var value = vscodeOptions_1.availableLanguages['*'];\n                if (isString(value)) {\n                    language = value;\n                }\n            }\n            if (isString(vscodeOptions_1.locale)) {\n                options.locale = vscodeOptions_1.locale.toLowerCase();\n            }\n            if (language === undefined) {\n                options.language = options.locale;\n            }\n            else if (language !== 'en') {\n                options.language = language;\n            }\n            if (isBoolean(vscodeOptions_1._languagePackSupport)) {\n                options.languagePackSupport = vscodeOptions_1._languagePackSupport;\n            }\n            if (isString(vscodeOptions_1._cacheRoot)) {\n                options.cacheRoot = vscodeOptions_1._cacheRoot;\n            }\n            if (isString(vscodeOptions_1._languagePackId)) {\n                options.languagePackId = vscodeOptions_1._languagePackId;\n            }\n            if (isString(vscodeOptions_1._translationsConfigFile)) {\n                options.translationsConfigFile = vscodeOptions_1._translationsConfigFile;\n                try {\n                    options.translationsConfig = readJsonFileSync(options.translationsConfigFile);\n                }\n                catch (error) {\n                    // We can't read the translation config file. Mark the cache as corrupted.\n                    if (vscodeOptions_1._corruptedFile) {\n                        var dirname = path.dirname(vscodeOptions_1._corruptedFile);\n                        fs.exists(dirname, function (exists) {\n                            if (exists) {\n                                fs.writeFile(vscodeOptions_1._corruptedFile, 'corrupted', 'utf8', function (err) {\n                                    console.error(err);\n                                });\n                            }\n                        });\n                    }\n                }\n            }\n        }\n        catch (_a) {\n            // Do nothing.\n        }\n    }\n    (0, common_1.setPseudo)(options.locale === 'pseudo');\n    resolvedBundles = Object.create(null);\n}\ninitializeSettings();\nfunction supportsLanguagePack() {\n    return options.languagePackSupport === true && options.cacheRoot !== undefined && options.languagePackId !== undefined && options.translationsConfigFile !== undefined\n        && options.translationsConfig !== undefined;\n}\nfunction createScopedLocalizeFunction(messages) {\n    return function (key, message) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        if (isNumber(key)) {\n            if (key >= messages.length) {\n                console.error(\"Broken localize call found. Index out of bounds. Stacktrace is\\n: \".concat(new Error('').stack));\n                return;\n            }\n            return (0, common_1.format)(messages[key], args);\n        }\n        else {\n            if (isString(message)) {\n                console.warn(\"Message \".concat(message, \" didn't get externalized correctly.\"));\n                return (0, common_1.format)(message, args);\n            }\n            else {\n                console.error(\"Broken localize call found. Stacktrace is\\n: \".concat(new Error('').stack));\n            }\n        }\n    };\n}\nfunction resolveLanguage(file) {\n    var resolvedLanguage;\n    if (options.cacheLanguageResolution && resolvedLanguage) {\n        resolvedLanguage = resolvedLanguage;\n    }\n    else {\n        if (common_1.isPseudo || !options.language) {\n            resolvedLanguage = '.nls.json';\n        }\n        else {\n            var locale = options.language;\n            while (locale) {\n                var candidate = '.nls.' + locale + '.json';\n                if (fs.existsSync(file + candidate)) {\n                    resolvedLanguage = candidate;\n                    break;\n                }\n                else {\n                    var index = locale.lastIndexOf('-');\n                    if (index > 0) {\n                        locale = locale.substring(0, index);\n                    }\n                    else {\n                        resolvedLanguage = '.nls.json';\n                        locale = null;\n                    }\n                }\n            }\n        }\n        if (options.cacheLanguageResolution) {\n            resolvedLanguage = resolvedLanguage;\n        }\n    }\n    return file + resolvedLanguage;\n}\nfunction findInTheBoxBundle(root) {\n    var language = options.language;\n    while (language) {\n        var candidate = path.join(root, \"nls.bundle.\".concat(language, \".json\"));\n        if (fs.existsSync(candidate)) {\n            return candidate;\n        }\n        else {\n            var index = language.lastIndexOf('-');\n            if (index > 0) {\n                language = language.substring(0, index);\n            }\n            else {\n                language = undefined;\n            }\n        }\n    }\n    // Test if we can reslove the default bundle.\n    if (language === undefined) {\n        var candidate = path.join(root, 'nls.bundle.json');\n        if (fs.existsSync(candidate)) {\n            return candidate;\n        }\n    }\n    return undefined;\n}\nfunction mkdir(directory) {\n    try {\n        fs.mkdirSync(directory);\n    }\n    catch (err) {\n        if (err.code === 'EEXIST') {\n            return;\n        }\n        else if (err.code === 'ENOENT') {\n            var parent = path.dirname(directory);\n            if (parent !== directory) {\n                mkdir(parent);\n                fs.mkdirSync(directory);\n            }\n        }\n        else {\n            throw err;\n        }\n    }\n}\nfunction createDefaultNlsBundle(folder) {\n    var metaData = readJsonFileSync(path.join(folder, 'nls.metadata.json'));\n    var result = Object.create(null);\n    for (var module_1 in metaData) {\n        var entry = metaData[module_1];\n        result[module_1] = entry.messages;\n    }\n    return result;\n}\nfunction createNLSBundle(header, metaDataPath) {\n    var languagePackLocation = options.translationsConfig[header.id];\n    if (!languagePackLocation) {\n        return undefined;\n    }\n    var languagePack = readJsonFileSync(languagePackLocation).contents;\n    var metaData = readJsonFileSync(path.join(metaDataPath, 'nls.metadata.json'));\n    var result = Object.create(null);\n    for (var module_2 in metaData) {\n        var entry = metaData[module_2];\n        var translations = languagePack[\"\".concat(header.outDir, \"/\").concat(module_2)];\n        if (translations) {\n            var resultMessages = [];\n            for (var i = 0; i < entry.keys.length; i++) {\n                var messageKey = entry.keys[i];\n                var key = isString(messageKey) ? messageKey : messageKey.key;\n                var translatedMessage = translations[key];\n                if (translatedMessage === undefined) {\n                    translatedMessage = entry.messages[i];\n                }\n                resultMessages.push(translatedMessage);\n            }\n            result[module_2] = resultMessages;\n        }\n        else {\n            result[module_2] = entry.messages;\n        }\n    }\n    return result;\n}\nfunction touch(file) {\n    var d = new Date();\n    fs.utimes(file, d, d, function () {\n        // Do nothing. Ignore\n    });\n}\nfunction cacheBundle(key, bundle) {\n    resolvedBundles[key] = bundle;\n    return bundle;\n}\nfunction loadNlsBundleOrCreateFromI18n(header, bundlePath) {\n    var result;\n    var bundle = path.join(options.cacheRoot, \"\".concat(header.id, \"-\").concat(header.hash, \".json\"));\n    var useMemoryOnly = false;\n    var writeBundle = false;\n    try {\n        result = JSON.parse(fs.readFileSync(bundle, { encoding: 'utf8', flag: 'r' }));\n        touch(bundle);\n        return result;\n    }\n    catch (err) {\n        if (err.code === 'ENOENT') {\n            writeBundle = true;\n        }\n        else if (err instanceof SyntaxError) {\n            // We have a syntax error. So no valid JSON. Use\n            console.log(\"Syntax error parsing message bundle: \".concat(err.message, \".\"));\n            fs.unlink(bundle, function (err) {\n                if (err) {\n                    console.error(\"Deleting corrupted bundle \".concat(bundle, \" failed.\"));\n                }\n            });\n            useMemoryOnly = true;\n        }\n        else {\n            throw err;\n        }\n    }\n    result = createNLSBundle(header, bundlePath);\n    if (!result || useMemoryOnly) {\n        return result;\n    }\n    if (writeBundle) {\n        try {\n            fs.writeFileSync(bundle, JSON.stringify(result), { encoding: 'utf8', flag: 'wx' });\n        }\n        catch (err) {\n            if (err.code === 'EEXIST') {\n                return result;\n            }\n            throw err;\n        }\n    }\n    return result;\n}\nfunction loadDefaultNlsBundle(bundlePath) {\n    try {\n        return createDefaultNlsBundle(bundlePath);\n    }\n    catch (err) {\n        console.log(\"Generating default bundle from meta data failed.\", err);\n        return undefined;\n    }\n}\nfunction loadNlsBundle(header, bundlePath) {\n    var result;\n    // Core decided to use a language pack. Do the same in the extension\n    if (supportsLanguagePack()) {\n        try {\n            result = loadNlsBundleOrCreateFromI18n(header, bundlePath);\n        }\n        catch (err) {\n            console.log(\"Load or create bundle failed \", err);\n        }\n    }\n    if (!result) {\n        // No language pack found, but core is running in language pack mode\n        // Don't try to use old in the box bundles since the might be stale\n        // Fall right back to the default bundle.\n        if (options.languagePackSupport) {\n            return loadDefaultNlsBundle(bundlePath);\n        }\n        var candidate = findInTheBoxBundle(bundlePath);\n        if (candidate) {\n            try {\n                return readJsonFileSync(candidate);\n            }\n            catch (err) {\n                console.log(\"Loading in the box message bundle failed.\", err);\n            }\n        }\n        result = loadDefaultNlsBundle(bundlePath);\n    }\n    return result;\n}\nfunction tryFindMetaDataHeaderFile(file) {\n    var result;\n    var dirname = path.dirname(file);\n    while (true) {\n        result = path.join(dirname, 'nls.metadata.header.json');\n        if (fs.existsSync(result)) {\n            break;\n        }\n        var parent = path.dirname(dirname);\n        if (parent === dirname) {\n            result = undefined;\n            break;\n        }\n        else {\n            dirname = parent;\n        }\n    }\n    return result;\n}\nfunction loadMessageBundle(file) {\n    if (!file) {\n        // No file. We are in dev mode. Return the default\n        // localize function.\n        return common_1.localize;\n    }\n    // Remove extension since we load json files.\n    var ext = path.extname(file);\n    if (ext) {\n        file = file.substr(0, file.length - ext.length);\n    }\n    if (options.messageFormat === common_1.MessageFormat.both || options.messageFormat === common_1.MessageFormat.bundle) {\n        var headerFile = tryFindMetaDataHeaderFile(file);\n        if (headerFile) {\n            var bundlePath = path.dirname(headerFile);\n            var bundle = resolvedBundles[bundlePath];\n            if (bundle === undefined) {\n                try {\n                    var header = JSON.parse(fs.readFileSync(headerFile, 'utf8'));\n                    try {\n                        var nlsBundle = loadNlsBundle(header, bundlePath);\n                        bundle = cacheBundle(bundlePath, nlsBundle ? { header: header, nlsBundle: nlsBundle } : null);\n                    }\n                    catch (err) {\n                        console.error('Failed to load nls bundle', err);\n                        bundle = cacheBundle(bundlePath, null);\n                    }\n                }\n                catch (err) {\n                    console.error('Failed to read header file', err);\n                    bundle = cacheBundle(bundlePath, null);\n                }\n            }\n            if (bundle) {\n                var module_3 = file.substr(bundlePath.length + 1).replace(/\\\\/g, '/');\n                var messages = bundle.nlsBundle[module_3];\n                if (messages === undefined) {\n                    console.error(\"Messages for file \".concat(file, \" not found. See console for details.\"));\n                    return function () {\n                        return 'Messages not found.';\n                    };\n                }\n                return createScopedLocalizeFunction(messages);\n            }\n        }\n    }\n    if (options.messageFormat === common_1.MessageFormat.both || options.messageFormat === common_1.MessageFormat.file) {\n        // Try to load a single file bundle\n        try {\n            var json = readJsonFileSync(resolveLanguage(file));\n            if (Array.isArray(json)) {\n                return createScopedLocalizeFunction(json);\n            }\n            else {\n                if ((0, common_1.isDefined)(json.messages) && (0, common_1.isDefined)(json.keys)) {\n                    return createScopedLocalizeFunction(json.messages);\n                }\n                else {\n                    console.error(\"String bundle '\".concat(file, \"' uses an unsupported format.\"));\n                    return function () {\n                        return 'File bundle has unsupported format. See console for details';\n                    };\n                }\n            }\n        }\n        catch (err) {\n            if (err.code !== 'ENOENT') {\n                console.error('Failed to load single file bundle', err);\n            }\n        }\n    }\n    console.error(\"Failed to load message bundle for file \".concat(file));\n    return function () {\n        return 'Failed to load message bundle. See console for details.';\n    };\n}\nexports.loadMessageBundle = loadMessageBundle;\nfunction config(opts) {\n    if (opts) {\n        if (isString(opts.locale)) {\n            options.locale = opts.locale.toLowerCase();\n            options.language = options.locale;\n            resolvedBundles = Object.create(null);\n        }\n        if (opts.messageFormat !== undefined) {\n            options.messageFormat = opts.messageFormat;\n        }\n        if (opts.bundleFormat === common_1.BundleFormat.standalone && options.languagePackSupport === true) {\n            options.languagePackSupport = false;\n        }\n    }\n    (0, common_1.setPseudo)(options.locale === 'pseudo');\n    return loadMessageBundle;\n}\nexports.config = config;\nral_1.default.install(Object.freeze({\n    loadMessageBundle: loadMessageBundle,\n    config: config\n}));\n//# sourceMappingURL=main.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/vscode-nls@5.2.0/node_modules/vscode-nls/lib/node/main.js?")},5472:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   URI: () => (/* binding */ URI),\n/* harmony export */   Utils: () => (/* binding */ Utils)\n/* harmony export */ });\nvar LIB;(()=>{"use strict";var t={470:t=>{function e(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function r(t,e){for(var r,n="",o=0,i=-1,a=0,h=0;h<=t.length;++h){if(h<t.length)r=t.charCodeAt(h);else{if(47===r)break;r=47}if(47===r){if(i===h-1||1===a);else if(i!==h-1&&2===a){if(n.length<2||2!==o||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var s=n.lastIndexOf("/");if(s!==n.length-1){-1===s?(n="",o=0):o=(n=n.slice(0,s)).length-1-n.lastIndexOf("/"),i=h,a=0;continue}}else if(2===n.length||1===n.length){n="",o=0,i=h,a=0;continue}e&&(n.length>0?n+="/..":n="..",o=2)}else n.length>0?n+="/"+t.slice(i+1,h):n=t.slice(i+1,h),o=h-i-1;i=h,a=0}else 46===r&&-1!==a?++a:a=-1}return n}var n={resolve:function(){for(var t,n="",o=!1,i=arguments.length-1;i>=-1&&!o;i--){var a;i>=0?a=arguments[i]:(void 0===t&&(t=process.cwd()),a=t),e(a),0!==a.length&&(n=a+"/"+n,o=47===a.charCodeAt(0))}return n=r(n,!o),o?n.length>0?"/"+n:"/":n.length>0?n:"."},normalize:function(t){if(e(t),0===t.length)return".";var n=47===t.charCodeAt(0),o=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t="."),t.length>0&&o&&(t+="/"),n?"/"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var t,r=0;r<arguments.length;++r){var o=arguments[r];e(o),o.length>0&&(void 0===t?t=o:t+="/"+o)}return void 0===t?".":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return"";if((t=n.resolve(t))===(r=n.resolve(r)))return"";for(var o=1;o<t.length&&47===t.charCodeAt(o);++o);for(var i=t.length,a=i-o,h=1;h<r.length&&47===r.charCodeAt(h);++h);for(var s=r.length-h,c=a<s?a:s,f=-1,u=0;u<=c;++u){if(u===c){if(s>c){if(47===r.charCodeAt(h+u))return r.slice(h+u+1);if(0===u)return r.slice(h+u)}else a>c&&(47===t.charCodeAt(o+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(o+u);if(l!==r.charCodeAt(h+u))break;47===l&&(f=u)}var p="";for(u=o+f+1;u<=i;++u)u!==i&&47!==t.charCodeAt(u)||(0===p.length?p+="..":p+="/..");return p.length>0?p+r.slice(h+f):(h+=f,47===r.charCodeAt(h)&&++h,r.slice(h))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return".";for(var r=t.charCodeAt(0),n=47===r,o=-1,i=!0,a=t.length-1;a>=1;--a)if(47===(r=t.charCodeAt(a))){if(!i){o=a;break}}else i=!1;return-1===o?n?"/":".":n&&1===o?"//":t.slice(0,o)},basename:function(t,r){if(void 0!==r&&"string"!=typeof r)throw new TypeError(\'"ext" argument must be a string\');e(t);var n,o=0,i=-1,a=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return"";var h=r.length-1,s=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!a){o=n+1;break}}else-1===s&&(a=!1,s=n+1),h>=0&&(c===r.charCodeAt(h)?-1==--h&&(i=n):(h=-1,i=s))}return o===i?i=s:-1===i&&(i=t.length),t.slice(o,i)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!a){o=n+1;break}}else-1===i&&(a=!1,i=n+1);return-1===i?"":t.slice(o,i)},extname:function(t){e(t);for(var r=-1,n=0,o=-1,i=!0,a=0,h=t.length-1;h>=0;--h){var s=t.charCodeAt(h);if(47!==s)-1===o&&(i=!1,o=h+1),46===s?-1===r?r=h:1!==a&&(a=1):-1!==r&&(a=-1);else if(!i){n=h+1;break}}return-1===r||-1===o||0===a||1===a&&r===o-1&&r===n+1?"":t.slice(r,o)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError(\'The "pathObject" argument must be of type Object. Received type \'+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||"")+(e.ext||"");return r?r===e.root?r+n:r+"/"+n:n}(0,t)},parse:function(t){e(t);var r={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return r;var n,o=t.charCodeAt(0),i=47===o;i?(r.root="/",n=1):n=0;for(var a=-1,h=0,s=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(o=t.charCodeAt(f)))-1===s&&(c=!1,s=f+1),46===o?-1===a?a=f:1!==u&&(u=1):-1!==a&&(u=-1);else if(!c){h=f+1;break}return-1===a||-1===s||0===u||1===u&&a===s-1&&a===h+1?-1!==s&&(r.base=r.name=0===h&&i?t.slice(1,s):t.slice(h,s)):(0===h&&i?(r.name=t.slice(1,a),r.base=t.slice(1,s)):(r.name=t.slice(h,a),r.base=t.slice(h,s)),r.ext=t.slice(a,s)),h>0?r.dir=t.slice(0,h-1):i&&(r.dir="/"),r},sep:"/",delimiter:":",win32:null,posix:null};n.posix=n,t.exports=n}},e={};function r(n){var o=e[n];if(void 0!==o)return o.exports;var i=e[n]={exports:{}};return t[n](i,i.exports,r),i.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var n={};(()=>{var t;if(r.r(n),r.d(n,{URI:()=>g,Utils:()=>O}),"object"==typeof process)t="win32"===process.platform;else if("object"==typeof navigator){var e=navigator.userAgent;t=e.indexOf("Windows")>=0}var o,i,a=(o=function(t,e){return o=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])},o(t,e)},function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function r(){this.constructor=t}o(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r)}),h=/^\\w[\\w\\d+.-]*$/,s=/^\\//,c=/^\\/\\//;function f(t,e){if(!t.scheme&&e)throw new Error(\'[UriError]: Scheme is missing: {scheme: "", authority: "\'.concat(t.authority,\'", path: "\').concat(t.path,\'", query: "\').concat(t.query,\'", fragment: "\').concat(t.fragment,\'"}\'));if(t.scheme&&!h.test(t.scheme))throw new Error("[UriError]: Scheme contains illegal characters.");if(t.path)if(t.authority){if(!s.test(t.path))throw new Error(\'[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character\')}else if(c.test(t.path))throw new Error(\'[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")\')}var u="",l="/",p=/^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/,g=function(){function e(t,e,r,n,o,i){void 0===i&&(i=!1),"object"==typeof t?(this.scheme=t.scheme||u,this.authority=t.authority||u,this.path=t.path||u,this.query=t.query||u,this.fragment=t.fragment||u):(this.scheme=function(t,e){return t||e?t:"file"}(t,i),this.authority=e||u,this.path=function(t,e){switch(t){case"https":case"http":case"file":e?e[0]!==l&&(e=l+e):e=l}return e}(this.scheme,r||u),this.query=n||u,this.fragment=o||u,f(this,i))}return e.isUri=function(t){return t instanceof e||!!t&&"string"==typeof t.authority&&"string"==typeof t.fragment&&"string"==typeof t.path&&"string"==typeof t.query&&"string"==typeof t.scheme&&"string"==typeof t.fsPath&&"function"==typeof t.with&&"function"==typeof t.toString},Object.defineProperty(e.prototype,"fsPath",{get:function(){return C(this,!1)},enumerable:!1,configurable:!0}),e.prototype.with=function(t){if(!t)return this;var e=t.scheme,r=t.authority,n=t.path,o=t.query,i=t.fragment;return void 0===e?e=this.scheme:null===e&&(e=u),void 0===r?r=this.authority:null===r&&(r=u),void 0===n?n=this.path:null===n&&(n=u),void 0===o?o=this.query:null===o&&(o=u),void 0===i?i=this.fragment:null===i&&(i=u),e===this.scheme&&r===this.authority&&n===this.path&&o===this.query&&i===this.fragment?this:new v(e,r,n,o,i)},e.parse=function(t,e){void 0===e&&(e=!1);var r=p.exec(t);return r?new v(r[2]||u,_(r[4]||u),_(r[5]||u),_(r[7]||u),_(r[9]||u),e):new v(u,u,u,u,u)},e.file=function(e){var r=u;if(t&&(e=e.replace(/\\\\/g,l)),e[0]===l&&e[1]===l){var n=e.indexOf(l,2);-1===n?(r=e.substring(2),e=l):(r=e.substring(2,n),e=e.substring(n)||l)}return new v("file",r,e,u,u)},e.from=function(t){var e=new v(t.scheme,t.authority,t.path,t.query,t.fragment);return f(e,!0),e},e.prototype.toString=function(t){return void 0===t&&(t=!1),A(this,t)},e.prototype.toJSON=function(){return this},e.revive=function(t){if(t){if(t instanceof e)return t;var r=new v(t);return r._formatted=t.external,r._fsPath=t._sep===d?t.fsPath:null,r}return t},e}(),d=t?1:void 0,v=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e._formatted=null,e._fsPath=null,e}return a(e,t),Object.defineProperty(e.prototype,"fsPath",{get:function(){return this._fsPath||(this._fsPath=C(this,!1)),this._fsPath},enumerable:!1,configurable:!0}),e.prototype.toString=function(t){return void 0===t&&(t=!1),t?A(this,!0):(this._formatted||(this._formatted=A(this,!1)),this._formatted)},e.prototype.toJSON=function(){var t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=d),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t},e}(g),y=((i={})[58]="%3A",i[47]="%2F",i[63]="%3F",i[35]="%23",i[91]="%5B",i[93]="%5D",i[64]="%40",i[33]="%21",i[36]="%24",i[38]="%26",i[39]="%27",i[40]="%28",i[41]="%29",i[42]="%2A",i[43]="%2B",i[44]="%2C",i[59]="%3B",i[61]="%3D",i[32]="%20",i);function m(t,e,r){for(var n=void 0,o=-1,i=0;i<t.length;i++){var a=t.charCodeAt(i);if(a>=97&&a<=122||a>=65&&a<=90||a>=48&&a<=57||45===a||46===a||95===a||126===a||e&&47===a||r&&91===a||r&&93===a||r&&58===a)-1!==o&&(n+=encodeURIComponent(t.substring(o,i)),o=-1),void 0!==n&&(n+=t.charAt(i));else{void 0===n&&(n=t.substr(0,i));var h=y[a];void 0!==h?(-1!==o&&(n+=encodeURIComponent(t.substring(o,i)),o=-1),n+=h):-1===o&&(o=i)}}return-1!==o&&(n+=encodeURIComponent(t.substring(o))),void 0!==n?n:t}function b(t){for(var e=void 0,r=0;r<t.length;r++){var n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=y[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function C(e,r){var n;return n=e.authority&&e.path.length>1&&"file"===e.scheme?"//".concat(e.authority).concat(e.path):47===e.path.charCodeAt(0)&&(e.path.charCodeAt(1)>=65&&e.path.charCodeAt(1)<=90||e.path.charCodeAt(1)>=97&&e.path.charCodeAt(1)<=122)&&58===e.path.charCodeAt(2)?r?e.path.substr(1):e.path[1].toLowerCase()+e.path.substr(2):e.path,t&&(n=n.replace(/\\//g,"\\\\")),n}function A(t,e){var r=e?b:m,n="",o=t.scheme,i=t.authority,a=t.path,h=t.query,s=t.fragment;if(o&&(n+=o,n+=":"),(i||"file"===o)&&(n+=l,n+=l),i){var c=i.indexOf("@");if(-1!==c){var f=i.substr(0,c);i=i.substr(c+1),-1===(c=f.lastIndexOf(":"))?n+=r(f,!1,!1):(n+=r(f.substr(0,c),!1,!1),n+=":",n+=r(f.substr(c+1),!1,!0)),n+="@"}-1===(c=(i=i.toLowerCase()).lastIndexOf(":"))?n+=r(i,!1,!0):(n+=r(i.substr(0,c),!1,!0),n+=i.substr(c))}if(a){if(a.length>=3&&47===a.charCodeAt(0)&&58===a.charCodeAt(2))(u=a.charCodeAt(1))>=65&&u<=90&&(a="/".concat(String.fromCharCode(u+32),":").concat(a.substr(3)));else if(a.length>=2&&58===a.charCodeAt(1)){var u;(u=a.charCodeAt(0))>=65&&u<=90&&(a="".concat(String.fromCharCode(u+32),":").concat(a.substr(2)))}n+=r(a,!0,!1)}return h&&(n+="?",n+=r(h,!1,!1)),s&&(n+="#",n+=e?s:m(s,!1,!1)),n}function w(t){try{return decodeURIComponent(t)}catch(e){return t.length>3?t.substr(0,3)+w(t.substr(3)):t}}var x=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function _(t){return t.match(x)?t.replace(x,(function(t){return w(t)})):t}var O,P=r(470),j=function(t,e,r){if(r||2===arguments.length)for(var n,o=0,i=e.length;o<i;o++)!n&&o in e||(n||(n=Array.prototype.slice.call(e,0,o)),n[o]=e[o]);return t.concat(n||Array.prototype.slice.call(e))},I=P.posix||P,U="/";!function(t){t.joinPath=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];return t.with({path:I.join.apply(I,j([t.path],e,!1))})},t.resolvePath=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];var n=t.path,o=!1;n[0]!==U&&(n=U+n,o=!0);var i=I.resolve.apply(I,j([n],e,!1));return o&&i[0]===U&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===U)return t;var e=I.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=""),t.with({path:e})},t.basename=function(t){return I.basename(t.path)},t.extname=function(t){return I.extname(t.path)}}(O||(O={}))})(),LIB=n})();const{URI,Utils}=LIB;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/vscode-uri@3.0.7/node_modules/vscode-uri/lib/esm/index.js?')},6379:module=>{eval("// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js?")},5680:(__unused_webpack_module,exports)=>{"use strict";eval('\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.YamlCommands = void 0;\nvar YamlCommands;\n(function (YamlCommands) {\n    YamlCommands["JUMP_TO_SCHEMA"] = "jumpToSchema";\n})(YamlCommands = exports.YamlCommands || (exports.YamlCommands = {}));\n//# sourceMappingURL=commands.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/commands.js?')},7246:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.JSONSchemaSelection = void 0;\nconst yaml_documents_1 = __webpack_require__(4532);\nconst schemaUrls_1 = __webpack_require__(2791);\nconst requestTypes_1 = __webpack_require__(5651);\nclass JSONSchemaSelection {\n    constructor(schemaService, yamlSettings, connection) {\n        this.schemaService = schemaService;\n        this.yamlSettings = yamlSettings;\n        this.connection = connection;\n        this.connection?.onRequest(requestTypes_1.SchemaSelectionRequests.getSchema, (fileUri) => {\n            return this.getSchemas(fileUri);\n        });\n        this.connection?.onRequest(requestTypes_1.SchemaSelectionRequests.getAllSchemas, (fileUri) => {\n            return this.getAllSchemas(fileUri);\n        });\n    }\n    async getSchemas(docUri) {\n        const schemas = await this.getSchemasForFile(docUri);\n        return Array.from(schemas).map((val) => {\n            return {\n                name: val[1].title,\n                uri: val[0],\n                description: val[1].description,\n                versions: val[1].versions,\n            };\n        });\n    }\n    async getSchemasForFile(docUri) {\n        const document = this.yamlSettings?.documents.get(docUri);\n        const schemas = new Map();\n        if (!document) {\n            return schemas;\n        }\n        const yamlDoc = yaml_documents_1.yamlDocumentsCache.getYamlDocument(document);\n        for (const currentYAMLDoc of yamlDoc.documents) {\n            const schema = await this.schemaService.getSchemaForResource(document.uri, currentYAMLDoc);\n            if (schema?.schema) {\n                const schemaUrls = (0, schemaUrls_1.getSchemaUrls)(schema?.schema);\n                if (schemaUrls.size === 0) {\n                    continue;\n                }\n                for (const urlToSchema of schemaUrls) {\n                    schemas.set(urlToSchema[0], urlToSchema[1]);\n                }\n            }\n        }\n        return schemas;\n    }\n    async getAllSchemas(docUri) {\n        const fileSchemas = await this.getSchemasForFile(docUri);\n        const fileSchemasHandle = Array.from(fileSchemas.entries()).map((val) => {\n            return {\n                uri: val[0],\n                fromStore: false,\n                usedForCurrentFile: true,\n                name: val[1].title,\n                description: val[1].description,\n                versions: val[1].versions,\n            };\n        });\n        const result = [];\n        let allSchemas = this.schemaService.getAllSchemas();\n        allSchemas = allSchemas.filter((val) => !fileSchemas.has(val.uri));\n        result.push(...fileSchemasHandle);\n        result.push(...allSchemas);\n        return result;\n    }\n}\nexports.JSONSchemaSelection = JSONSchemaSelection;\n//# sourceMappingURL=schemaSelectionHandlers.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageserver/handlers/schemaSelectionHandlers.js?')},9689:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toOffsetLength = exports.convertAST = void 0;\nconst yaml_1 = __webpack_require__(6749);\nconst jsonParser07_1 = __webpack_require__(1406);\nconst maxRefCount = 1000;\nlet refDepth = 0;\nconst seenAlias = new Set();\nfunction convertAST(parent, node, doc, lineCounter) {\n    if (!parent) {\n        // first invocation\n        refDepth = 0;\n    }\n    if (!node) {\n        return null;\n    }\n    if ((0, yaml_1.isMap)(node)) {\n        return convertMap(node, parent, doc, lineCounter);\n    }\n    if ((0, yaml_1.isPair)(node)) {\n        return convertPair(node, parent, doc, lineCounter);\n    }\n    if ((0, yaml_1.isSeq)(node)) {\n        return convertSeq(node, parent, doc, lineCounter);\n    }\n    if ((0, yaml_1.isScalar)(node)) {\n        return convertScalar(node, parent);\n    }\n    if ((0, yaml_1.isAlias)(node) && !seenAlias.has(node) && refDepth < maxRefCount) {\n        seenAlias.add(node);\n        const converted = convertAlias(node, parent, doc, lineCounter);\n        seenAlias.delete(node);\n        return converted;\n    }\n    else {\n        return;\n    }\n}\nexports.convertAST = convertAST;\nfunction convertMap(node, parent, doc, lineCounter) {\n    let range;\n    if (node.flow && !node.range) {\n        range = collectFlowMapRange(node);\n    }\n    else {\n        range = node.range;\n    }\n    const result = new jsonParser07_1.ObjectASTNodeImpl(parent, node, ...toFixedOffsetLength(range, lineCounter));\n    for (const it of node.items) {\n        if ((0, yaml_1.isPair)(it)) {\n            result.properties.push(convertAST(result, it, doc, lineCounter));\n        }\n    }\n    return result;\n}\nfunction convertPair(node, parent, doc, lineCounter) {\n    const keyNode = node.key;\n    const valueNode = node.value;\n    const rangeStart = keyNode.range[0];\n    let rangeEnd = keyNode.range[1];\n    let nodeEnd = keyNode.range[2];\n    if (valueNode) {\n        rangeEnd = valueNode.range[1];\n        nodeEnd = valueNode.range[2];\n    }\n    // Pair does not return a range using the key/value ranges to fake one.\n    const result = new jsonParser07_1.PropertyASTNodeImpl(parent, node, ...toFixedOffsetLength([rangeStart, rangeEnd, nodeEnd], lineCounter));\n    if ((0, yaml_1.isAlias)(keyNode)) {\n        const keyAlias = new jsonParser07_1.StringASTNodeImpl(parent, keyNode, ...toOffsetLength(keyNode.range));\n        keyAlias.value = keyNode.source;\n        result.keyNode = keyAlias;\n    }\n    else {\n        result.keyNode = convertAST(result, keyNode, doc, lineCounter);\n    }\n    result.valueNode = convertAST(result, valueNode, doc, lineCounter);\n    return result;\n}\nfunction convertSeq(node, parent, doc, lineCounter) {\n    const result = new jsonParser07_1.ArrayASTNodeImpl(parent, node, ...toOffsetLength(node.range));\n    for (const it of node.items) {\n        if ((0, yaml_1.isNode)(it)) {\n            const convertedNode = convertAST(result, it, doc, lineCounter);\n            // due to recursion protection, convertAST may return undefined\n            if (convertedNode) {\n                result.children.push(convertedNode);\n            }\n        }\n    }\n    return result;\n}\nfunction convertScalar(node, parent) {\n    if (node.value === null) {\n        return new jsonParser07_1.NullASTNodeImpl(parent, node, ...toOffsetLength(node.range));\n    }\n    switch (typeof node.value) {\n        case 'string': {\n            const result = new jsonParser07_1.StringASTNodeImpl(parent, node, ...toOffsetLength(node.range));\n            result.value = node.value;\n            return result;\n        }\n        case 'boolean':\n            return new jsonParser07_1.BooleanASTNodeImpl(parent, node, node.value, ...toOffsetLength(node.range));\n        case 'number': {\n            const result = new jsonParser07_1.NumberASTNodeImpl(parent, node, ...toOffsetLength(node.range));\n            result.value = node.value;\n            result.isInteger = Number.isInteger(result.value);\n            return result;\n        }\n        default: {\n            // fail safe converting, we need to return some node anyway\n            const result = new jsonParser07_1.StringASTNodeImpl(parent, node, ...toOffsetLength(node.range));\n            result.value = node.source;\n            return result;\n        }\n    }\n}\nfunction convertAlias(node, parent, doc, lineCounter) {\n    refDepth++;\n    const resolvedNode = node.resolve(doc);\n    if (resolvedNode) {\n        return convertAST(parent, resolvedNode, doc, lineCounter);\n    }\n    else {\n        const resultNode = new jsonParser07_1.StringASTNodeImpl(parent, node, ...toOffsetLength(node.range));\n        resultNode.value = node.source;\n        return resultNode;\n    }\n}\nfunction toOffsetLength(range) {\n    return [range[0], range[1] - range[0]];\n}\nexports.toOffsetLength = toOffsetLength;\n/**\n * Convert offsets to offset+length with fix length to not include '\\n' character in some cases\n * @param range the yaml ast range\n * @param lineCounter the line counter\n * @returns the offset and length\n */\nfunction toFixedOffsetLength(range, lineCounter) {\n    const start = lineCounter.linePos(range[0]);\n    const end = lineCounter.linePos(range[1]);\n    const result = [range[0], range[1] - range[0]];\n    // -1 as range may include '\\n'\n    if (start.line !== end.line && (lineCounter.lineStarts.length !== end.line || end.col === 1)) {\n        result[1]--;\n    }\n    return result;\n}\nfunction collectFlowMapRange(node) {\n    let start = Number.MAX_SAFE_INTEGER;\n    let end = 0;\n    for (const it of node.items) {\n        if ((0, yaml_1.isPair)(it)) {\n            if ((0, yaml_1.isNode)(it.key)) {\n                if (it.key.range && it.key.range[0] <= start) {\n                    start = it.key.range[0];\n                }\n            }\n            if ((0, yaml_1.isNode)(it.value)) {\n                if (it.value.range && it.value.range[2] >= end) {\n                    end = it.value.range[2];\n                }\n            }\n        }\n    }\n    return [start, end, end];\n}\n//# sourceMappingURL=ast-converter.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/parser/ast-converter.js?")},8321:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getCustomTags = void 0;\nconst yaml_1 = __webpack_require__(6749);\nconst arrUtils_1 = __webpack_require__(8209);\nclass CommonTagImpl {\n    constructor(tag, type) {\n        this.tag = tag;\n        this.type = type;\n    }\n    get collection() {\n        if (this.type === 'mapping') {\n            return 'map';\n        }\n        if (this.type === 'sequence') {\n            return 'seq';\n        }\n        return undefined;\n    }\n    resolve(value) {\n        if ((0, yaml_1.isMap)(value) && this.type === 'mapping') {\n            return value;\n        }\n        if ((0, yaml_1.isSeq)(value) && this.type === 'sequence') {\n            return value;\n        }\n        if (typeof value === 'string' && this.type === 'scalar') {\n            return value;\n        }\n    }\n}\nclass IncludeTag {\n    constructor() {\n        this.tag = '!include';\n        this.type = 'scalar';\n    }\n    resolve(value, onError) {\n        if (value && value.length > 0 && value.trim()) {\n            return value;\n        }\n        onError('!include without value');\n    }\n}\n/**\n * Converts the tags from settings and adds known tags such as !include\n * and returns Tags that can be used by the parser.\n * @param customTags Tags for parser\n */\nfunction getCustomTags(customTags) {\n    const tags = [];\n    const filteredTags = (0, arrUtils_1.filterInvalidCustomTags)(customTags);\n    for (const tag of filteredTags) {\n        const typeInfo = tag.split(' ');\n        const tagName = typeInfo[0];\n        const tagType = (typeInfo[1] && typeInfo[1].toLowerCase()) || 'scalar';\n        tags.push(new CommonTagImpl(tagName, tagType));\n    }\n    tags.push(new IncludeTag());\n    return tags;\n}\nexports.getCustomTags = getCustomTags;\n//# sourceMappingURL=custom-tag-provider.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/parser/custom-tag-provider.js?")},9389:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.isKubernetesAssociatedDocument = exports.setKubernetesParserOption = void 0;\nconst yamlSchemaService_1 = __webpack_require__(7188);\nfunction setKubernetesParserOption(jsonDocuments, option) {\n    for (const jsonDoc of jsonDocuments) {\n        jsonDoc.isKubernetes = option;\n    }\n}\nexports.setKubernetesParserOption = setKubernetesParserOption;\nfunction isKubernetesAssociatedDocument(textDocument, paths) {\n    for (const path in paths) {\n        const globPath = paths[path];\n        const fpa = new yamlSchemaService_1.FilePatternAssociation(globPath);\n        if (fpa.matchesPattern(textDocument.uri)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.isKubernetesAssociatedDocument = isKubernetesAssociatedDocument;\n//# sourceMappingURL=isKubernetes.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/parser/isKubernetes.js?')},1406:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JSONDocument = exports.findNodeAtOffset = exports.contains = exports.getNodeValue = exports.newJSONDocument = exports.ValidationResult = exports.EnumMatch = exports.asSchema = exports.ObjectASTNodeImpl = exports.PropertyASTNodeImpl = exports.StringASTNodeImpl = exports.NumberASTNodeImpl = exports.ArrayASTNodeImpl = exports.BooleanASTNodeImpl = exports.NullASTNodeImpl = exports.ASTNodeImpl = exports.ProblemTypeMessages = exports.ProblemType = exports.YAML_SOURCE = exports.formats = void 0;\nconst objects_1 = __webpack_require__(285);\nconst schemaUtils_1 = __webpack_require__(4411);\nconst vscode_json_languageservice_1 = __webpack_require__(5355);\nconst nls = __webpack_require__(731);\nconst vscode_uri_1 = __webpack_require__(5472);\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst arrUtils_1 = __webpack_require__(8209);\nconst strings_1 = __webpack_require__(4726);\nconst yamlSchemaService_1 = __webpack_require__(7188);\nconst localize = nls.loadMessageBundle();\nconst MSG_PROPERTY_NOT_ALLOWED = 'Property {0} is not allowed.';\nexports.formats = {\n    'color-hex': {\n        errorMessage: localize('colorHexFormatWarning', 'Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA.'),\n        pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/,\n    },\n    'date-time': {\n        errorMessage: localize('dateTimeFormatWarning', 'String is not a RFC3339 date-time.'),\n        pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i,\n    },\n    date: {\n        errorMessage: localize('dateFormatWarning', 'String is not a RFC3339 date.'),\n        pattern: /^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i,\n    },\n    time: {\n        errorMessage: localize('timeFormatWarning', 'String is not a RFC3339 time.'),\n        pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i,\n    },\n    email: {\n        errorMessage: localize('emailFormatWarning', 'String is not an e-mail address.'),\n        pattern: /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,\n    },\n    ipv4: {\n        errorMessage: localize('ipv4FormatWarning', 'String does not match IPv4 format.'),\n        pattern: /^((25[0-5]|(2[0-4]|1\\d|[1-9]|)\\d)\\.?\\b){4}$/,\n    },\n    ipv6: {\n        errorMessage: localize('ipv6FormatWarning', 'String does not match IPv6 format.'),\n        pattern: /^([0-9a-f]|:){1,4}(:([0-9a-f]{0,4})*){1,7}$/i,\n    },\n};\nexports.YAML_SOURCE = 'YAML';\nconst YAML_SCHEMA_PREFIX = 'yaml-schema: ';\nvar ProblemType;\n(function (ProblemType) {\n    ProblemType[\"missingRequiredPropWarning\"] = \"missingRequiredPropWarning\";\n    ProblemType[\"typeMismatchWarning\"] = \"typeMismatchWarning\";\n    ProblemType[\"constWarning\"] = \"constWarning\";\n})(ProblemType = exports.ProblemType || (exports.ProblemType = {}));\nexports.ProblemTypeMessages = {\n    [ProblemType.missingRequiredPropWarning]: 'Missing property \"{0}\".',\n    [ProblemType.typeMismatchWarning]: 'Incorrect type. Expected \"{0}\".',\n    [ProblemType.constWarning]: 'Value must be {0}.',\n};\nclass ASTNodeImpl {\n    constructor(parent, internalNode, offset, length) {\n        this.offset = offset;\n        this.length = length;\n        this.parent = parent;\n        this.internalNode = internalNode;\n    }\n    getNodeFromOffsetEndInclusive(offset) {\n        const collector = [];\n        const findNode = (node) => {\n            if (offset >= node.offset && offset <= node.offset + node.length) {\n                const children = node.children;\n                for (let i = 0; i < children.length && children[i].offset <= offset; i++) {\n                    const item = findNode(children[i]);\n                    if (item) {\n                        collector.push(item);\n                    }\n                }\n                return node;\n            }\n            return null;\n        };\n        const foundNode = findNode(this);\n        let currMinDist = Number.MAX_VALUE;\n        let currMinNode = null;\n        for (const currNode of collector) {\n            const minDist = currNode.length + currNode.offset - offset + (offset - currNode.offset);\n            if (minDist < currMinDist) {\n                currMinNode = currNode;\n                currMinDist = minDist;\n            }\n        }\n        return currMinNode || foundNode;\n    }\n    get children() {\n        return [];\n    }\n    toString() {\n        return ('type: ' +\n            this.type +\n            ' (' +\n            this.offset +\n            '/' +\n            this.length +\n            ')' +\n            (this.parent ? ' parent: {' + this.parent.toString() + '}' : ''));\n    }\n}\nexports.ASTNodeImpl = ASTNodeImpl;\nclass NullASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, internalNode, offset, length) {\n        super(parent, internalNode, offset, length);\n        this.type = 'null';\n        this.value = null;\n    }\n}\nexports.NullASTNodeImpl = NullASTNodeImpl;\nclass BooleanASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, internalNode, boolValue, offset, length) {\n        super(parent, internalNode, offset, length);\n        this.type = 'boolean';\n        this.value = boolValue;\n    }\n}\nexports.BooleanASTNodeImpl = BooleanASTNodeImpl;\nclass ArrayASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, internalNode, offset, length) {\n        super(parent, internalNode, offset, length);\n        this.type = 'array';\n        this.items = [];\n    }\n    get children() {\n        return this.items;\n    }\n}\nexports.ArrayASTNodeImpl = ArrayASTNodeImpl;\nclass NumberASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, internalNode, offset, length) {\n        super(parent, internalNode, offset, length);\n        this.type = 'number';\n        this.isInteger = true;\n        this.value = Number.NaN;\n    }\n}\nexports.NumberASTNodeImpl = NumberASTNodeImpl;\nclass StringASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, internalNode, offset, length) {\n        super(parent, internalNode, offset, length);\n        this.type = 'string';\n        this.value = '';\n    }\n}\nexports.StringASTNodeImpl = StringASTNodeImpl;\nclass PropertyASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, internalNode, offset, length) {\n        super(parent, internalNode, offset, length);\n        this.type = 'property';\n        this.colonOffset = -1;\n    }\n    get children() {\n        return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];\n    }\n}\nexports.PropertyASTNodeImpl = PropertyASTNodeImpl;\nclass ObjectASTNodeImpl extends ASTNodeImpl {\n    constructor(parent, internalNode, offset, length) {\n        super(parent, internalNode, offset, length);\n        this.type = 'object';\n        this.properties = [];\n    }\n    get children() {\n        return this.properties;\n    }\n}\nexports.ObjectASTNodeImpl = ObjectASTNodeImpl;\nfunction asSchema(schema) {\n    if (schema === undefined) {\n        return undefined;\n    }\n    if ((0, objects_1.isBoolean)(schema)) {\n        return schema ? {} : { not: {} };\n    }\n    if (typeof schema !== 'object') {\n        // we need to report this case as JSONSchemaRef MUST be an Object or Boolean\n        console.warn(`Wrong schema: ${JSON.stringify(schema)}, it MUST be an Object or Boolean`);\n        schema = {\n            type: schema,\n        };\n    }\n    return schema;\n}\nexports.asSchema = asSchema;\nvar EnumMatch;\n(function (EnumMatch) {\n    EnumMatch[EnumMatch[\"Key\"] = 0] = \"Key\";\n    EnumMatch[EnumMatch[\"Enum\"] = 1] = \"Enum\";\n})(EnumMatch = exports.EnumMatch || (exports.EnumMatch = {}));\nclass SchemaCollector {\n    constructor(focusOffset = -1, exclude = null) {\n        this.focusOffset = focusOffset;\n        this.exclude = exclude;\n        this.schemas = [];\n    }\n    add(schema) {\n        this.schemas.push(schema);\n    }\n    merge(other) {\n        this.schemas.push(...other.schemas);\n    }\n    include(node) {\n        return (this.focusOffset === -1 || contains(node, this.focusOffset)) && node !== this.exclude;\n    }\n    newSub() {\n        return new SchemaCollector(-1, this.exclude);\n    }\n}\nclass NoOpSchemaCollector {\n    constructor() {\n        // ignore\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get schemas() {\n        return [];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    add(schema) {\n        // ignore\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    merge(other) {\n        // ignore\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    include(node) {\n        return true;\n    }\n    newSub() {\n        return this;\n    }\n}\nNoOpSchemaCollector.instance = new NoOpSchemaCollector();\nclass ValidationResult {\n    constructor(isKubernetes) {\n        this.problems = [];\n        this.propertiesMatches = 0;\n        this.propertiesValueMatches = 0;\n        this.primaryValueMatches = 0;\n        this.enumValueMatch = false;\n        if (isKubernetes) {\n            this.enumValues = [];\n        }\n        else {\n            this.enumValues = null;\n        }\n    }\n    hasProblems() {\n        return !!this.problems.length;\n    }\n    mergeAll(validationResults) {\n        for (const validationResult of validationResults) {\n            this.merge(validationResult);\n        }\n    }\n    merge(validationResult) {\n        this.problems = this.problems.concat(validationResult.problems);\n    }\n    mergeEnumValues(validationResult) {\n        if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {\n            this.enumValues = this.enumValues.concat(validationResult.enumValues);\n            for (const error of this.problems) {\n                if (error.code === vscode_json_languageservice_1.ErrorCode.EnumValueMismatch) {\n                    error.message = localize('enumWarning', 'Value is not accepted. Valid values: {0}.', [...new Set(this.enumValues)]\n                        .map((v) => {\n                        return JSON.stringify(v);\n                    })\n                        .join(', '));\n                }\n            }\n        }\n    }\n    /**\n     * Merge multiple warnings with same problemType together\n     * @param subValidationResult another possible result\n     */\n    mergeWarningGeneric(subValidationResult, problemTypesToMerge) {\n        if (this.problems?.length) {\n            for (const problemType of problemTypesToMerge) {\n                const bestResults = this.problems.filter((p) => p.problemType === problemType);\n                for (const bestResult of bestResults) {\n                    const mergingResult = subValidationResult.problems?.find((p) => p.problemType === problemType &&\n                        bestResult.location.offset === p.location.offset &&\n                        (problemType !== ProblemType.missingRequiredPropWarning || (0, arrUtils_1.isArrayEqual)(p.problemArgs, bestResult.problemArgs)) // missingProp is merged only with same problemArg\n                    );\n                    if (mergingResult) {\n                        if (mergingResult.problemArgs.length) {\n                            mergingResult.problemArgs\n                                .filter((p) => !bestResult.problemArgs.includes(p))\n                                .forEach((p) => bestResult.problemArgs.push(p));\n                            bestResult.message = getWarningMessage(bestResult.problemType, bestResult.problemArgs);\n                        }\n                        this.mergeSources(mergingResult, bestResult);\n                    }\n                }\n            }\n        }\n    }\n    mergePropertyMatch(propertyValidationResult) {\n        this.merge(propertyValidationResult);\n        this.propertiesMatches++;\n        if (propertyValidationResult.enumValueMatch ||\n            (!propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches)) {\n            this.propertiesValueMatches++;\n        }\n        if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues) {\n            this.primaryValueMatches++;\n        }\n    }\n    mergeSources(mergingResult, bestResult) {\n        const mergingSource = mergingResult.source.replace(YAML_SCHEMA_PREFIX, '');\n        if (!bestResult.source.includes(mergingSource)) {\n            bestResult.source = bestResult.source + ' | ' + mergingSource;\n        }\n        if (!bestResult.schemaUri.includes(mergingResult.schemaUri[0])) {\n            bestResult.schemaUri = bestResult.schemaUri.concat(mergingResult.schemaUri);\n        }\n    }\n    compareGeneric(other) {\n        const hasProblems = this.hasProblems();\n        if (hasProblems !== other.hasProblems()) {\n            return hasProblems ? -1 : 1;\n        }\n        if (this.enumValueMatch !== other.enumValueMatch) {\n            return other.enumValueMatch ? -1 : 1;\n        }\n        if (this.propertiesValueMatches !== other.propertiesValueMatches) {\n            return this.propertiesValueMatches - other.propertiesValueMatches;\n        }\n        if (this.primaryValueMatches !== other.primaryValueMatches) {\n            return this.primaryValueMatches - other.primaryValueMatches;\n        }\n        return this.propertiesMatches - other.propertiesMatches;\n    }\n    compareKubernetes(other) {\n        const hasProblems = this.hasProblems();\n        if (this.propertiesMatches !== other.propertiesMatches) {\n            return this.propertiesMatches - other.propertiesMatches;\n        }\n        if (this.enumValueMatch !== other.enumValueMatch) {\n            return other.enumValueMatch ? -1 : 1;\n        }\n        if (this.primaryValueMatches !== other.primaryValueMatches) {\n            return this.primaryValueMatches - other.primaryValueMatches;\n        }\n        if (this.propertiesValueMatches !== other.propertiesValueMatches) {\n            return this.propertiesValueMatches - other.propertiesValueMatches;\n        }\n        if (hasProblems !== other.hasProblems()) {\n            return hasProblems ? -1 : 1;\n        }\n        return this.propertiesMatches - other.propertiesMatches;\n    }\n}\nexports.ValidationResult = ValidationResult;\nfunction newJSONDocument(root, diagnostics = []) {\n    return new JSONDocument(root, diagnostics, []);\n}\nexports.newJSONDocument = newJSONDocument;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getNodeValue(node) {\n    switch (node.type) {\n        case 'array':\n            return node.children.map(getNodeValue);\n        case 'object': {\n            const obj = Object.create(null);\n            for (let _i = 0, _a = node.children; _i < _a.length; _i++) {\n                const prop = _a[_i];\n                const valueNode = prop.children[1];\n                if (valueNode) {\n                    obj[prop.children[0].value] = getNodeValue(valueNode);\n                }\n            }\n            return obj;\n        }\n        case 'null':\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return node.value;\n        default:\n            return undefined;\n    }\n}\nexports.getNodeValue = getNodeValue;\nfunction contains(node, offset, includeRightBound = false) {\n    return ((offset >= node.offset && offset <= node.offset + node.length) || (includeRightBound && offset === node.offset + node.length));\n}\nexports.contains = contains;\nfunction findNodeAtOffset(node, offset, includeRightBound) {\n    if (includeRightBound === void 0) {\n        includeRightBound = false;\n    }\n    if (contains(node, offset, includeRightBound)) {\n        const children = node.children;\n        if (Array.isArray(children)) {\n            for (let i = 0; i < children.length && children[i].offset <= offset; i++) {\n                const item = findNodeAtOffset(children[i], offset, includeRightBound);\n                if (item) {\n                    return item;\n                }\n            }\n        }\n        return node;\n    }\n    return undefined;\n}\nexports.findNodeAtOffset = findNodeAtOffset;\nclass JSONDocument {\n    constructor(root, syntaxErrors = [], comments = []) {\n        this.root = root;\n        this.syntaxErrors = syntaxErrors;\n        this.comments = comments;\n    }\n    getNodeFromOffset(offset, includeRightBound = false) {\n        if (this.root) {\n            return findNodeAtOffset(this.root, offset, includeRightBound);\n        }\n        return undefined;\n    }\n    getNodeFromOffsetEndInclusive(offset) {\n        return this.root && this.root.getNodeFromOffsetEndInclusive(offset);\n    }\n    visit(visitor) {\n        if (this.root) {\n            const doVisit = (node) => {\n                let ctn = visitor(node);\n                const children = node.children;\n                if (Array.isArray(children)) {\n                    for (let i = 0; i < children.length && ctn; i++) {\n                        ctn = doVisit(children[i]);\n                    }\n                }\n                return ctn;\n            };\n            doVisit(this.root);\n        }\n    }\n    validate(textDocument, schema) {\n        if (this.root && schema) {\n            const validationResult = new ValidationResult(this.isKubernetes);\n            validate(this.root, schema, schema, validationResult, NoOpSchemaCollector.instance, {\n                isKubernetes: this.isKubernetes,\n                disableAdditionalProperties: this.disableAdditionalProperties,\n                uri: this.uri,\n            });\n            return validationResult.problems.map((p) => {\n                const range = vscode_languageserver_types_1.Range.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));\n                const diagnostic = vscode_languageserver_types_1.Diagnostic.create(range, p.message, p.severity, p.code ? p.code : vscode_json_languageservice_1.ErrorCode.Undefined, p.source);\n                diagnostic.data = { schemaUri: p.schemaUri, ...p.data };\n                return diagnostic;\n            });\n        }\n        return null;\n    }\n    /**\n     * This method returns the list of applicable schemas\n     *\n     * currently used @param didCallFromAutoComplete flag to differentiate the method call, when it is from auto complete\n     * then user still types something and skip the validation for timebeing untill completed.\n     * On https://github.com/redhat-developer/yaml-language-server/pull/719 the auto completes need to populate the list of enum string which matches to the enum\n     * and on https://github.com/redhat-developer/vscode-yaml/issues/803 the validation should throw the error based on the enum string.\n     *\n     * @param schema schema\n     * @param focusOffset  offsetValue\n     * @param exclude excluded Node\n     * @param didCallFromAutoComplete true if method called from AutoComplete\n     * @returns array of applicable schemas\n     */\n    getMatchingSchemas(schema, focusOffset = -1, exclude = null, didCallFromAutoComplete) {\n        const matchingSchemas = new SchemaCollector(focusOffset, exclude);\n        if (this.root && schema) {\n            validate(this.root, schema, schema, new ValidationResult(this.isKubernetes), matchingSchemas, {\n                isKubernetes: this.isKubernetes,\n                disableAdditionalProperties: this.disableAdditionalProperties,\n                uri: this.uri,\n                callFromAutoComplete: didCallFromAutoComplete,\n            });\n        }\n        return matchingSchemas.schemas;\n    }\n}\nexports.JSONDocument = JSONDocument;\nfunction validate(node, schema, originalSchema, validationResult, matchingSchemas, options\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    const { isKubernetes, callFromAutoComplete } = options;\n    if (!node) {\n        return;\n    }\n    // schema should be an Object\n    if (typeof schema !== 'object') {\n        return;\n    }\n    if (!schema.url) {\n        schema.url = originalSchema.url;\n    }\n    schema.closestTitle = schema.title || originalSchema.closestTitle;\n    switch (node.type) {\n        case 'object':\n            _validateObjectNode(node, schema, validationResult, matchingSchemas);\n            break;\n        case 'array':\n            _validateArrayNode(node, schema, validationResult, matchingSchemas);\n            break;\n        case 'string':\n            _validateStringNode(node, schema, validationResult);\n            break;\n        case 'number':\n            _validateNumberNode(node, schema, validationResult);\n            break;\n        case 'property':\n            return validate(node.valueNode, schema, schema, validationResult, matchingSchemas, options);\n    }\n    _validateNode();\n    matchingSchemas.add({ node: node, schema: schema });\n    function _validateNode() {\n        function matchesType(type) {\n            return node.type === type || (type === 'integer' && node.type === 'number' && node.isInteger);\n        }\n        if (Array.isArray(schema.type)) {\n            if (!schema.type.some(matchesType)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                    message: schema.errorMessage ||\n                        localize('typeArrayMismatchWarning', 'Incorrect type. Expected one of {0}.', schema.type.join(', ')),\n                    source: getSchemaSource(schema, originalSchema),\n                    schemaUri: getSchemaUri(schema, originalSchema),\n                });\n            }\n        }\n        else if (schema.type) {\n            if (!matchesType(schema.type)) {\n                //get more specific name than just object\n                const schemaType = schema.type === 'object' ? (0, schemaUtils_1.getSchemaTypeName)(schema) : schema.type;\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                    message: schema.errorMessage || getWarningMessage(ProblemType.typeMismatchWarning, [schemaType]),\n                    source: getSchemaSource(schema, originalSchema),\n                    schemaUri: getSchemaUri(schema, originalSchema),\n                    problemType: ProblemType.typeMismatchWarning,\n                    problemArgs: [schemaType],\n                });\n            }\n        }\n        if (Array.isArray(schema.allOf)) {\n            for (const subSchemaRef of schema.allOf) {\n                validate(node, asSchema(subSchemaRef), schema, validationResult, matchingSchemas, options);\n            }\n        }\n        const notSchema = asSchema(schema.not);\n        if (notSchema) {\n            const subValidationResult = new ValidationResult(isKubernetes);\n            const subMatchingSchemas = matchingSchemas.newSub();\n            validate(node, notSchema, schema, subValidationResult, subMatchingSchemas, options);\n            if (!subValidationResult.hasProblems()) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                    message: localize('notSchemaWarning', 'Matches a schema that is not allowed.'),\n                    source: getSchemaSource(schema, originalSchema),\n                    schemaUri: getSchemaUri(schema, originalSchema),\n                });\n            }\n            for (const ms of subMatchingSchemas.schemas) {\n                ms.inverted = !ms.inverted;\n                matchingSchemas.add(ms);\n            }\n        }\n        const testAlternatives = (alternatives, maxOneMatch) => {\n            const matches = [];\n            const subMatches = [];\n            const noPropertyMatches = [];\n            // remember the best match that is used for error messages\n            let bestMatch = null;\n            for (const subSchemaRef of alternatives) {\n                const subSchema = { ...asSchema(subSchemaRef) };\n                const subValidationResult = new ValidationResult(isKubernetes);\n                const subMatchingSchemas = matchingSchemas.newSub();\n                validate(node, subSchema, schema, subValidationResult, subMatchingSchemas, options);\n                if (!subValidationResult.hasProblems() || callFromAutoComplete) {\n                    matches.push(subSchema);\n                    subMatches.push(subSchema);\n                    if (subValidationResult.propertiesMatches === 0) {\n                        noPropertyMatches.push(subSchema);\n                    }\n                    if (subSchema.format) {\n                        subMatches.pop();\n                    }\n                }\n                if (!bestMatch) {\n                    bestMatch = {\n                        schema: subSchema,\n                        validationResult: subValidationResult,\n                        matchingSchemas: subMatchingSchemas,\n                    };\n                }\n                else if (isKubernetes) {\n                    bestMatch = alternativeComparison(subValidationResult, bestMatch, subSchema, subMatchingSchemas);\n                }\n                else {\n                    bestMatch = genericComparison(node, maxOneMatch, subValidationResult, bestMatch, subSchema, subMatchingSchemas);\n                }\n            }\n            if (subMatches.length > 1 && (subMatches.length > 1 || noPropertyMatches.length === 0) && maxOneMatch) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: 1 },\n                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                    message: localize('oneOfWarning', 'Matches multiple schemas when only one must validate.'),\n                    source: getSchemaSource(schema, originalSchema),\n                    schemaUri: getSchemaUri(schema, originalSchema),\n                });\n            }\n            if (bestMatch !== null) {\n                validationResult.merge(bestMatch.validationResult);\n                validationResult.propertiesMatches += bestMatch.validationResult.propertiesMatches;\n                validationResult.propertiesValueMatches += bestMatch.validationResult.propertiesValueMatches;\n                validationResult.enumValueMatch = validationResult.enumValueMatch || bestMatch.validationResult.enumValueMatch;\n                if (bestMatch.validationResult.enumValues?.length) {\n                    validationResult.enumValues = (validationResult.enumValues || []).concat(bestMatch.validationResult.enumValues);\n                }\n                matchingSchemas.merge(bestMatch.matchingSchemas);\n            }\n            return matches.length;\n        };\n        if (Array.isArray(schema.anyOf)) {\n            testAlternatives(schema.anyOf, false);\n        }\n        if (Array.isArray(schema.oneOf)) {\n            testAlternatives(schema.oneOf, true);\n        }\n        const testBranch = (schema, originalSchema) => {\n            const subValidationResult = new ValidationResult(isKubernetes);\n            const subMatchingSchemas = matchingSchemas.newSub();\n            validate(node, asSchema(schema), originalSchema, subValidationResult, subMatchingSchemas, options);\n            validationResult.merge(subValidationResult);\n            validationResult.propertiesMatches += subValidationResult.propertiesMatches;\n            validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;\n            matchingSchemas.merge(subMatchingSchemas);\n        };\n        const testCondition = (ifSchema, originalSchema, thenSchema, elseSchema) => {\n            const subSchema = asSchema(ifSchema);\n            const subValidationResult = new ValidationResult(isKubernetes);\n            const subMatchingSchemas = matchingSchemas.newSub();\n            validate(node, subSchema, originalSchema, subValidationResult, subMatchingSchemas, options);\n            matchingSchemas.merge(subMatchingSchemas);\n            const { filePatternAssociation } = subSchema;\n            if (filePatternAssociation) {\n                const association = new yamlSchemaService_1.FilePatternAssociation(filePatternAssociation);\n                if (!association.matchesPattern(options.uri)) {\n                    subValidationResult.problems.push({\n                        location: { offset: node.offset, length: node.length },\n                        severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                        message: localize('ifFilePatternAssociation', `filePatternAssociation '${filePatternAssociation}' does not match with doc uri '${options.uri}'.`),\n                        source: getSchemaSource(schema, originalSchema),\n                        schemaUri: getSchemaUri(schema, originalSchema),\n                    });\n                    // don't want to expose the error up to code-completion results\n                    // validationResult.merge(subValidationResult);\n                }\n            }\n            if (!subValidationResult.hasProblems()) {\n                if (thenSchema) {\n                    testBranch(thenSchema, originalSchema);\n                }\n            }\n            else if (elseSchema) {\n                testBranch(elseSchema, originalSchema);\n            }\n        };\n        const ifSchema = asSchema(schema.if);\n        if (ifSchema) {\n            testCondition(ifSchema, schema, asSchema(schema.then), asSchema(schema.else));\n        }\n        if (Array.isArray(schema.enum)) {\n            const val = getNodeValue(node);\n            let enumValueMatch = false;\n            for (const e of schema.enum) {\n                if ((0, objects_1.equals)(val, e) || (callFromAutoComplete && (0, objects_1.isString)(val) && (0, objects_1.isString)(e) && val && e.startsWith(val))) {\n                    enumValueMatch = true;\n                    break;\n                }\n            }\n            validationResult.enumValues = schema.enum;\n            validationResult.enumValueMatch = enumValueMatch;\n            if (!enumValueMatch) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                    code: vscode_json_languageservice_1.ErrorCode.EnumValueMismatch,\n                    message: schema.errorMessage ||\n                        localize('enumWarning', 'Value is not accepted. Valid values: {0}.', schema.enum\n                            .map((v) => {\n                            return JSON.stringify(v);\n                        })\n                            .join(', ')),\n                    source: getSchemaSource(schema, originalSchema),\n                    schemaUri: getSchemaUri(schema, originalSchema),\n                });\n            }\n        }\n        if ((0, objects_1.isDefined)(schema.const)) {\n            const val = getNodeValue(node);\n            if (!(0, objects_1.equals)(val, schema.const) &&\n                !(callFromAutoComplete && (0, objects_1.isString)(val) && (0, objects_1.isString)(schema.const) && schema.const.startsWith(val))) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                    code: vscode_json_languageservice_1.ErrorCode.EnumValueMismatch,\n                    problemType: ProblemType.constWarning,\n                    message: schema.errorMessage || getWarningMessage(ProblemType.constWarning, [JSON.stringify(schema.const)]),\n                    source: getSchemaSource(schema, originalSchema),\n                    schemaUri: getSchemaUri(schema, originalSchema),\n                    problemArgs: [JSON.stringify(schema.const)],\n                });\n                validationResult.enumValueMatch = false;\n            }\n            else {\n                validationResult.enumValueMatch = true;\n            }\n            validationResult.enumValues = [schema.const];\n        }\n        if (schema.deprecationMessage && node.parent) {\n            validationResult.problems.push({\n                location: { offset: node.parent.offset, length: node.parent.length },\n                severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                message: schema.deprecationMessage,\n                source: getSchemaSource(schema, originalSchema),\n                schemaUri: getSchemaUri(schema, originalSchema),\n            });\n        }\n    }\n    function _validateNumberNode(node, schema, validationResult) {\n        const val = node.value;\n        if ((0, objects_1.isNumber)(schema.multipleOf)) {\n            if (val % schema.multipleOf !== 0) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                    message: localize('multipleOfWarning', 'Value is not divisible by {0}.', schema.multipleOf),\n                    source: getSchemaSource(schema, originalSchema),\n                    schemaUri: getSchemaUri(schema, originalSchema),\n                });\n            }\n        }\n        function getExclusiveLimit(limit, exclusive) {\n            if ((0, objects_1.isNumber)(exclusive)) {\n                return exclusive;\n            }\n            if ((0, objects_1.isBoolean)(exclusive) && exclusive) {\n                return limit;\n            }\n            return undefined;\n        }\n        function getLimit(limit, exclusive) {\n            if (!(0, objects_1.isBoolean)(exclusive) || !exclusive) {\n                return limit;\n            }\n            return undefined;\n        }\n        const exclusiveMinimum = getExclusiveLimit(schema.minimum, schema.exclusiveMinimum);\n        if ((0, objects_1.isNumber)(exclusiveMinimum) && val <= exclusiveMinimum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                message: localize('exclusiveMinimumWarning', 'Value is below the exclusive minimum of {0}.', exclusiveMinimum),\n                source: getSchemaSource(schema, originalSchema),\n                schemaUri: getSchemaUri(schema, originalSchema),\n            });\n        }\n        const exclusiveMaximum = getExclusiveLimit(schema.maximum, schema.exclusiveMaximum);\n        if ((0, objects_1.isNumber)(exclusiveMaximum) && val >= exclusiveMaximum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                message: localize('exclusiveMaximumWarning', 'Value is above the exclusive maximum of {0}.', exclusiveMaximum),\n                source: getSchemaSource(schema, originalSchema),\n                schemaUri: getSchemaUri(schema, originalSchema),\n            });\n        }\n        const minimum = getLimit(schema.minimum, schema.exclusiveMinimum);\n        if ((0, objects_1.isNumber)(minimum) && val < minimum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                message: localize('minimumWarning', 'Value is below the minimum of {0}.', minimum),\n                source: getSchemaSource(schema, originalSchema),\n                schemaUri: getSchemaUri(schema, originalSchema),\n            });\n        }\n        const maximum = getLimit(schema.maximum, schema.exclusiveMaximum);\n        if ((0, objects_1.isNumber)(maximum) && val > maximum) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                message: localize('maximumWarning', 'Value is above the maximum of {0}.', maximum),\n                source: getSchemaSource(schema, originalSchema),\n                schemaUri: getSchemaUri(schema, originalSchema),\n            });\n        }\n    }\n    function _validateStringNode(node, schema, validationResult) {\n        if ((0, objects_1.isNumber)(schema.minLength) && node.value.length < schema.minLength) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                message: localize('minLengthWarning', 'String is shorter than the minimum length of {0}.', schema.minLength),\n                source: getSchemaSource(schema, originalSchema),\n                schemaUri: getSchemaUri(schema, originalSchema),\n            });\n        }\n        if ((0, objects_1.isNumber)(schema.maxLength) && node.value.length > schema.maxLength) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                message: localize('maxLengthWarning', 'String is longer than the maximum length of {0}.', schema.maxLength),\n                source: getSchemaSource(schema, originalSchema),\n                schemaUri: getSchemaUri(schema, originalSchema),\n            });\n        }\n        if ((0, objects_1.isString)(schema.pattern)) {\n            const regex = (0, strings_1.safeCreateUnicodeRegExp)(schema.pattern);\n            if (!regex.test(node.value)) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                    message: schema.patternErrorMessage ||\n                        schema.errorMessage ||\n                        localize('patternWarning', 'String does not match the pattern of \"{0}\".', schema.pattern),\n                    source: getSchemaSource(schema, originalSchema),\n                    schemaUri: getSchemaUri(schema, originalSchema),\n                });\n            }\n        }\n        if (schema.format) {\n            switch (schema.format) {\n                case 'uri':\n                case 'uri-reference':\n                    {\n                        let errorMessage;\n                        if (!node.value) {\n                            errorMessage = localize('uriEmpty', 'URI expected.');\n                        }\n                        else {\n                            try {\n                                const uri = vscode_uri_1.URI.parse(node.value);\n                                if (!uri.scheme && schema.format === 'uri') {\n                                    errorMessage = localize('uriSchemeMissing', 'URI with a scheme is expected.');\n                                }\n                            }\n                            catch (e) {\n                                errorMessage = e.message;\n                            }\n                        }\n                        if (errorMessage) {\n                            validationResult.problems.push({\n                                location: { offset: node.offset, length: node.length },\n                                severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                                message: schema.patternErrorMessage ||\n                                    schema.errorMessage ||\n                                    localize('uriFormatWarning', 'String is not a URI: {0}', errorMessage),\n                                source: getSchemaSource(schema, originalSchema),\n                                schemaUri: getSchemaUri(schema, originalSchema),\n                            });\n                        }\n                    }\n                    break;\n                case 'color-hex':\n                case 'date-time':\n                case 'date':\n                case 'time':\n                case 'email':\n                case 'ipv4':\n                case 'ipv6':\n                    {\n                        const format = exports.formats[schema.format];\n                        if (!node.value || !format.pattern.test(node.value)) {\n                            validationResult.problems.push({\n                                location: { offset: node.offset, length: node.length },\n                                severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                                message: schema.patternErrorMessage || schema.errorMessage || format.errorMessage,\n                                source: getSchemaSource(schema, originalSchema),\n                                schemaUri: getSchemaUri(schema, originalSchema),\n                            });\n                        }\n                    }\n                    break;\n                default:\n            }\n        }\n    }\n    function _validateArrayNode(node, schema, validationResult, matchingSchemas) {\n        if (Array.isArray(schema.items)) {\n            const subSchemas = schema.items;\n            for (let index = 0; index < subSchemas.length; index++) {\n                const subSchemaRef = subSchemas[index];\n                const subSchema = asSchema(subSchemaRef);\n                const itemValidationResult = new ValidationResult(isKubernetes);\n                const item = node.items[index];\n                if (item) {\n                    validate(item, subSchema, schema, itemValidationResult, matchingSchemas, options);\n                    validationResult.mergePropertyMatch(itemValidationResult);\n                    validationResult.mergeEnumValues(itemValidationResult);\n                }\n                else if (node.items.length >= subSchemas.length) {\n                    validationResult.propertiesValueMatches++;\n                }\n            }\n            if (node.items.length > subSchemas.length) {\n                if (typeof schema.additionalItems === 'object') {\n                    for (let i = subSchemas.length; i < node.items.length; i++) {\n                        const itemValidationResult = new ValidationResult(isKubernetes);\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        validate(node.items[i], schema.additionalItems, schema, itemValidationResult, matchingSchemas, options);\n                        validationResult.mergePropertyMatch(itemValidationResult);\n                        validationResult.mergeEnumValues(itemValidationResult);\n                    }\n                }\n                else if (schema.additionalItems === false) {\n                    validationResult.problems.push({\n                        location: { offset: node.offset, length: node.length },\n                        severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                        message: localize('additionalItemsWarning', 'Array has too many items according to schema. Expected {0} or fewer.', subSchemas.length),\n                        source: getSchemaSource(schema, originalSchema),\n                        schemaUri: getSchemaUri(schema, originalSchema),\n                    });\n                }\n            }\n        }\n        else {\n            const itemSchema = asSchema(schema.items);\n            if (itemSchema) {\n                const itemValidationResult = new ValidationResult(isKubernetes);\n                node.items.forEach((item) => {\n                    if (itemSchema.oneOf && itemSchema.oneOf.length === 1) {\n                        const subSchemaRef = itemSchema.oneOf[0];\n                        const subSchema = { ...asSchema(subSchemaRef) };\n                        subSchema.title = schema.title;\n                        subSchema.closestTitle = schema.closestTitle;\n                        validate(item, subSchema, schema, itemValidationResult, matchingSchemas, options);\n                        validationResult.mergePropertyMatch(itemValidationResult);\n                        validationResult.mergeEnumValues(itemValidationResult);\n                    }\n                    else {\n                        validate(item, itemSchema, schema, itemValidationResult, matchingSchemas, options);\n                        validationResult.mergePropertyMatch(itemValidationResult);\n                        validationResult.mergeEnumValues(itemValidationResult);\n                    }\n                });\n            }\n        }\n        const containsSchema = asSchema(schema.contains);\n        if (containsSchema) {\n            const doesContain = node.items.some((item) => {\n                const itemValidationResult = new ValidationResult(isKubernetes);\n                validate(item, containsSchema, schema, itemValidationResult, NoOpSchemaCollector.instance, options);\n                return !itemValidationResult.hasProblems();\n            });\n            if (!doesContain) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                    message: schema.errorMessage || localize('requiredItemMissingWarning', 'Array does not contain required item.'),\n                    source: getSchemaSource(schema, originalSchema),\n                    schemaUri: getSchemaUri(schema, originalSchema),\n                });\n            }\n        }\n        if ((0, objects_1.isNumber)(schema.minItems) && node.items.length < schema.minItems) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                message: localize('minItemsWarning', 'Array has too few items. Expected {0} or more.', schema.minItems),\n                source: getSchemaSource(schema, originalSchema),\n                schemaUri: getSchemaUri(schema, originalSchema),\n            });\n        }\n        if ((0, objects_1.isNumber)(schema.maxItems) && node.items.length > schema.maxItems) {\n            validationResult.problems.push({\n                location: { offset: node.offset, length: node.length },\n                severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                message: localize('maxItemsWarning', 'Array has too many items. Expected {0} or fewer.', schema.maxItems),\n                source: getSchemaSource(schema, originalSchema),\n                schemaUri: getSchemaUri(schema, originalSchema),\n            });\n        }\n        if (schema.uniqueItems === true) {\n            const values = getNodeValue(node);\n            const duplicates = values.some((value, index) => {\n                return index !== values.lastIndexOf(value);\n            });\n            if (duplicates) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                    message: localize('uniqueItemsWarning', 'Array has duplicate items.'),\n                    source: getSchemaSource(schema, originalSchema),\n                    schemaUri: getSchemaUri(schema, originalSchema),\n                });\n            }\n        }\n    }\n    function _validateObjectNode(node, schema, validationResult, matchingSchemas) {\n        const seenKeys = Object.create(null);\n        const unprocessedProperties = [];\n        const unprocessedNodes = [...node.properties];\n        while (unprocessedNodes.length > 0) {\n            const propertyNode = unprocessedNodes.pop();\n            const key = propertyNode.keyNode.value;\n            //Replace the merge key with the actual values of what the node value points to in seen keys\n            if (key === '<<' && propertyNode.valueNode) {\n                switch (propertyNode.valueNode.type) {\n                    case 'object': {\n                        unprocessedNodes.push(...propertyNode.valueNode['properties']);\n                        break;\n                    }\n                    case 'array': {\n                        propertyNode.valueNode['items'].forEach((sequenceNode) => {\n                            if (sequenceNode && (0, objects_1.isIterable)(sequenceNode['properties'])) {\n                                unprocessedNodes.push(...sequenceNode['properties']);\n                            }\n                        });\n                        break;\n                    }\n                    default: {\n                        break;\n                    }\n                }\n            }\n            else {\n                seenKeys[key] = propertyNode.valueNode;\n                unprocessedProperties.push(key);\n            }\n        }\n        if (Array.isArray(schema.required)) {\n            for (const propertyName of schema.required) {\n                if (seenKeys[propertyName] === undefined) {\n                    const keyNode = node.parent && node.parent.type === 'property' && node.parent.keyNode;\n                    const location = keyNode ? { offset: keyNode.offset, length: keyNode.length } : { offset: node.offset, length: 1 };\n                    validationResult.problems.push({\n                        location: location,\n                        severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                        message: getWarningMessage(ProblemType.missingRequiredPropWarning, [propertyName]),\n                        source: getSchemaSource(schema, originalSchema),\n                        schemaUri: getSchemaUri(schema, originalSchema),\n                        problemArgs: [propertyName],\n                        problemType: ProblemType.missingRequiredPropWarning,\n                    });\n                }\n            }\n        }\n        const propertyProcessed = (prop) => {\n            let index = unprocessedProperties.indexOf(prop);\n            while (index >= 0) {\n                unprocessedProperties.splice(index, 1);\n                index = unprocessedProperties.indexOf(prop);\n            }\n        };\n        if (schema.properties) {\n            for (const propertyName of Object.keys(schema.properties)) {\n                propertyProcessed(propertyName);\n                const propertySchema = schema.properties[propertyName];\n                const child = seenKeys[propertyName];\n                if (child) {\n                    if ((0, objects_1.isBoolean)(propertySchema)) {\n                        if (!propertySchema) {\n                            const propertyNode = child.parent;\n                            validationResult.problems.push({\n                                location: {\n                                    offset: propertyNode.keyNode.offset,\n                                    length: propertyNode.keyNode.length,\n                                },\n                                severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                                message: schema.errorMessage || localize('DisallowedExtraPropWarning', MSG_PROPERTY_NOT_ALLOWED, propertyName),\n                                source: getSchemaSource(schema, originalSchema),\n                                schemaUri: getSchemaUri(schema, originalSchema),\n                            });\n                        }\n                        else {\n                            validationResult.propertiesMatches++;\n                            validationResult.propertiesValueMatches++;\n                        }\n                    }\n                    else {\n                        propertySchema.url = schema.url ?? originalSchema.url;\n                        const propertyValidationResult = new ValidationResult(isKubernetes);\n                        validate(child, propertySchema, schema, propertyValidationResult, matchingSchemas, options);\n                        validationResult.mergePropertyMatch(propertyValidationResult);\n                        validationResult.mergeEnumValues(propertyValidationResult);\n                    }\n                }\n            }\n        }\n        if (schema.patternProperties) {\n            for (const propertyPattern of Object.keys(schema.patternProperties)) {\n                const regex = (0, strings_1.safeCreateUnicodeRegExp)(propertyPattern);\n                for (const propertyName of unprocessedProperties.slice(0)) {\n                    if (regex.test(propertyName)) {\n                        propertyProcessed(propertyName);\n                        const child = seenKeys[propertyName];\n                        if (child) {\n                            const propertySchema = schema.patternProperties[propertyPattern];\n                            if ((0, objects_1.isBoolean)(propertySchema)) {\n                                if (!propertySchema) {\n                                    const propertyNode = child.parent;\n                                    validationResult.problems.push({\n                                        location: {\n                                            offset: propertyNode.keyNode.offset,\n                                            length: propertyNode.keyNode.length,\n                                        },\n                                        severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                                        message: schema.errorMessage || localize('DisallowedExtraPropWarning', MSG_PROPERTY_NOT_ALLOWED, propertyName),\n                                        source: getSchemaSource(schema, originalSchema),\n                                        schemaUri: getSchemaUri(schema, originalSchema),\n                                    });\n                                }\n                                else {\n                                    validationResult.propertiesMatches++;\n                                    validationResult.propertiesValueMatches++;\n                                }\n                            }\n                            else {\n                                const propertyValidationResult = new ValidationResult(isKubernetes);\n                                validate(child, propertySchema, schema, propertyValidationResult, matchingSchemas, options);\n                                validationResult.mergePropertyMatch(propertyValidationResult);\n                                validationResult.mergeEnumValues(propertyValidationResult);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (typeof schema.additionalProperties === 'object') {\n            for (const propertyName of unprocessedProperties) {\n                const child = seenKeys[propertyName];\n                if (child) {\n                    const propertyValidationResult = new ValidationResult(isKubernetes);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    validate(child, schema.additionalProperties, schema, propertyValidationResult, matchingSchemas, options);\n                    validationResult.mergePropertyMatch(propertyValidationResult);\n                    validationResult.mergeEnumValues(propertyValidationResult);\n                }\n            }\n        }\n        else if (schema.additionalProperties === false ||\n            (schema.type === 'object' && schema.additionalProperties === undefined && options.disableAdditionalProperties === true)) {\n            if (unprocessedProperties.length > 0) {\n                const possibleProperties = schema.properties && Object.keys(schema.properties).filter((prop) => !seenKeys[prop]);\n                for (const propertyName of unprocessedProperties) {\n                    const child = seenKeys[propertyName];\n                    if (child) {\n                        let propertyNode = null;\n                        if (child.type !== 'property') {\n                            propertyNode = child.parent;\n                            if (propertyNode.type === 'object') {\n                                propertyNode = propertyNode.properties[0];\n                            }\n                        }\n                        else {\n                            propertyNode = child;\n                        }\n                        const problem = {\n                            location: {\n                                offset: propertyNode.keyNode.offset,\n                                length: propertyNode.keyNode.length,\n                            },\n                            severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                            message: schema.errorMessage || localize('DisallowedExtraPropWarning', MSG_PROPERTY_NOT_ALLOWED, propertyName),\n                            source: getSchemaSource(schema, originalSchema),\n                            schemaUri: getSchemaUri(schema, originalSchema),\n                        };\n                        if (possibleProperties?.length) {\n                            problem.data = { properties: possibleProperties };\n                        }\n                        validationResult.problems.push(problem);\n                    }\n                }\n            }\n        }\n        if ((0, objects_1.isNumber)(schema.maxProperties)) {\n            if (node.properties.length > schema.maxProperties) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                    message: localize('MaxPropWarning', 'Object has more properties than limit of {0}.', schema.maxProperties),\n                    source: getSchemaSource(schema, originalSchema),\n                    schemaUri: getSchemaUri(schema, originalSchema),\n                });\n            }\n        }\n        if ((0, objects_1.isNumber)(schema.minProperties)) {\n            if (node.properties.length < schema.minProperties) {\n                validationResult.problems.push({\n                    location: { offset: node.offset, length: node.length },\n                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                    message: localize('MinPropWarning', 'Object has fewer properties than the required number of {0}', schema.minProperties),\n                    source: getSchemaSource(schema, originalSchema),\n                    schemaUri: getSchemaUri(schema, originalSchema),\n                });\n            }\n        }\n        if (schema.dependencies) {\n            for (const key of Object.keys(schema.dependencies)) {\n                const prop = seenKeys[key];\n                if (prop) {\n                    const propertyDep = schema.dependencies[key];\n                    if (Array.isArray(propertyDep)) {\n                        for (const requiredProp of propertyDep) {\n                            if (!seenKeys[requiredProp]) {\n                                validationResult.problems.push({\n                                    location: { offset: node.offset, length: node.length },\n                                    severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,\n                                    message: localize('RequiredDependentPropWarning', 'Object is missing property {0} required by property {1}.', requiredProp, key),\n                                    source: getSchemaSource(schema, originalSchema),\n                                    schemaUri: getSchemaUri(schema, originalSchema),\n                                });\n                            }\n                            else {\n                                validationResult.propertiesValueMatches++;\n                            }\n                        }\n                    }\n                    else {\n                        const propertySchema = asSchema(propertyDep);\n                        if (propertySchema) {\n                            const propertyValidationResult = new ValidationResult(isKubernetes);\n                            validate(node, propertySchema, schema, propertyValidationResult, matchingSchemas, options);\n                            validationResult.mergePropertyMatch(propertyValidationResult);\n                            validationResult.mergeEnumValues(propertyValidationResult);\n                        }\n                    }\n                }\n            }\n        }\n        const propertyNames = asSchema(schema.propertyNames);\n        if (propertyNames) {\n            for (const f of node.properties) {\n                const key = f.keyNode;\n                if (key) {\n                    validate(key, propertyNames, schema, validationResult, NoOpSchemaCollector.instance, options);\n                }\n            }\n        }\n    }\n    //Alternative comparison is specifically used by the kubernetes/openshift schema but may lead to better results then genericComparison depending on the schema\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function alternativeComparison(subValidationResult, bestMatch, subSchema, subMatchingSchemas) {\n        const compareResult = subValidationResult.compareKubernetes(bestMatch.validationResult);\n        if (compareResult > 0) {\n            // our node is the best matching so far\n            bestMatch = {\n                schema: subSchema,\n                validationResult: subValidationResult,\n                matchingSchemas: subMatchingSchemas,\n            };\n        }\n        else if (compareResult === 0) {\n            // there's already a best matching but we are as good\n            bestMatch.matchingSchemas.merge(subMatchingSchemas);\n            bestMatch.validationResult.mergeEnumValues(subValidationResult);\n        }\n        return bestMatch;\n    }\n    //genericComparison tries to find the best matching schema using a generic comparison\n    function genericComparison(node, maxOneMatch, subValidationResult, bestMatch, subSchema, subMatchingSchemas) {\n        if (!maxOneMatch &&\n            !subValidationResult.hasProblems() &&\n            (!bestMatch.validationResult.hasProblems() || callFromAutoComplete)) {\n            // no errors, both are equally good matches\n            bestMatch.matchingSchemas.merge(subMatchingSchemas);\n            bestMatch.validationResult.propertiesMatches += subValidationResult.propertiesMatches;\n            bestMatch.validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;\n        }\n        else {\n            const compareResult = subValidationResult.compareGeneric(bestMatch.validationResult);\n            if (compareResult > 0 ||\n                (compareResult === 0 &&\n                    maxOneMatch &&\n                    bestMatch.schema.type === 'object' &&\n                    node.type !== 'null' &&\n                    node.type !== bestMatch.schema.type)) {\n                // our node is the best matching so far\n                bestMatch = {\n                    schema: subSchema,\n                    validationResult: subValidationResult,\n                    matchingSchemas: subMatchingSchemas,\n                };\n            }\n            else if (compareResult === 0) {\n                // there's already a best matching but we are as good\n                bestMatch.matchingSchemas.merge(subMatchingSchemas);\n                bestMatch.validationResult.mergeEnumValues(subValidationResult);\n                bestMatch.validationResult.mergeWarningGeneric(subValidationResult, [\n                    ProblemType.missingRequiredPropWarning,\n                    ProblemType.typeMismatchWarning,\n                    ProblemType.constWarning,\n                ]);\n            }\n        }\n        return bestMatch;\n    }\n}\nfunction getSchemaSource(schema, originalSchema) {\n    if (schema) {\n        let label;\n        if (schema.title) {\n            label = schema.title;\n        }\n        else if (schema.closestTitle) {\n            label = schema.closestTitle;\n        }\n        else if (originalSchema.closestTitle) {\n            label = originalSchema.closestTitle;\n        }\n        else {\n            const uriString = schema.url ?? originalSchema.url;\n            if (uriString) {\n                const url = vscode_uri_1.URI.parse(uriString);\n                if (url.scheme === 'file') {\n                    label = url.fsPath;\n                }\n                label = url.toString();\n            }\n        }\n        if (label) {\n            return `${YAML_SCHEMA_PREFIX}${label}`;\n        }\n    }\n    return exports.YAML_SOURCE;\n}\nfunction getSchemaUri(schema, originalSchema) {\n    const uriString = schema.url ?? originalSchema.url;\n    return uriString ? [uriString] : [];\n}\nfunction getWarningMessage(problemType, args) {\n    return localize(problemType, exports.ProblemTypeMessages[problemType], args.join(' | '));\n}\n//# sourceMappingURL=jsonParser07.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/parser/jsonParser07.js?")},4532:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.yamlDocumentsCache = exports.YamlDocuments = exports.YAMLDocument = exports.SingleYAMLDocument = void 0;\nconst jsonParser07_1 = __webpack_require__(1406);\nconst yaml_1 = __webpack_require__(6749);\nconst yamlParser07_1 = __webpack_require__(1223);\nconst vscode_json_languageservice_1 = __webpack_require__(5355);\nconst ast_converter_1 = __webpack_require__(9689);\nconst arrUtils_1 = __webpack_require__(8209);\nconst astUtils_1 = __webpack_require__(3713);\nconst strings_1 = __webpack_require__(4726);\n/**\n * These documents are collected into a final YAMLDocument\n * and passed to the `parseYAML` caller.\n */\nclass SingleYAMLDocument extends jsonParser07_1.JSONDocument {\n    constructor(lineCounter) {\n        super(null, []);\n        this.lineCounter = lineCounter;\n    }\n    /**\n     * Create a deep copy of this document\n     */\n    clone() {\n        const copy = new SingleYAMLDocument(this.lineCounter);\n        copy.isKubernetes = this.isKubernetes;\n        copy.disableAdditionalProperties = this.disableAdditionalProperties;\n        copy.uri = this.uri;\n        copy.currentDocIndex = this.currentDocIndex;\n        copy._lineComments = this.lineComments.slice();\n        // this will re-create root node\n        copy.internalDocument = this._internalDocument.clone();\n        return copy;\n    }\n    collectLineComments() {\n        this._lineComments = [];\n        if (this._internalDocument.commentBefore) {\n            const comments = this._internalDocument.commentBefore.split('\\n');\n            comments.forEach((comment) => this._lineComments.push(`#${comment}`));\n        }\n        (0, yaml_1.visit)(this.internalDocument, (_key, node) => {\n            if (node?.commentBefore) {\n                const comments = node?.commentBefore.split('\\n');\n                comments.forEach((comment) => this._lineComments.push(`#${comment}`));\n            }\n            if (node?.comment) {\n                this._lineComments.push(`#${node.comment}`);\n            }\n        });\n        if (this._internalDocument.comment) {\n            this._lineComments.push(`#${this._internalDocument.comment}`);\n        }\n    }\n    /**\n     * Updates the internal AST tree of the object\n     * from the internal node. This is call whenever the\n     * internalDocument is set but also can be called to\n     * reflect any changes on the underlying document\n     * without setting the internalDocument explicitly.\n     */\n    updateFromInternalDocument() {\n        this.root = (0, ast_converter_1.convertAST)(null, this._internalDocument.contents, this._internalDocument, this.lineCounter);\n    }\n    set internalDocument(document) {\n        this._internalDocument = document;\n        this.updateFromInternalDocument();\n    }\n    get internalDocument() {\n        return this._internalDocument;\n    }\n    get lineComments() {\n        if (!this._lineComments) {\n            this.collectLineComments();\n        }\n        return this._lineComments;\n    }\n    set lineComments(val) {\n        this._lineComments = val;\n    }\n    get errors() {\n        return this.internalDocument.errors.map(YAMLErrorToYamlDocDiagnostics);\n    }\n    get warnings() {\n        return this.internalDocument.warnings.map(YAMLErrorToYamlDocDiagnostics);\n    }\n    getNodeFromPosition(positionOffset, textBuffer, configuredIndentation) {\n        const position = textBuffer.getPosition(positionOffset);\n        const lineContent = textBuffer.getLineContent(position.line);\n        if (lineContent.trim().length === 0) {\n            return [this.findClosestNode(positionOffset, textBuffer, configuredIndentation), true];\n        }\n        const textAfterPosition = lineContent.substring(position.character);\n        const spacesAfterPositionMatch = textAfterPosition.match(/^([ ]+)\\n?$/);\n        const areOnlySpacesAfterPosition = !!spacesAfterPositionMatch;\n        const countOfSpacesAfterPosition = spacesAfterPositionMatch?.[1].length;\n        let closestNode;\n        (0, yaml_1.visit)(this.internalDocument, (key, node) => {\n            if (!node) {\n                return;\n            }\n            const range = node.range;\n            if (!range) {\n                return;\n            }\n            const isNullNodeOnTheLine = () => areOnlySpacesAfterPosition &&\n                positionOffset + countOfSpacesAfterPosition === range[2] &&\n                (0, yaml_1.isScalar)(node) &&\n                node.value === null;\n            if ((range[0] <= positionOffset && range[1] >= positionOffset) || isNullNodeOnTheLine()) {\n                closestNode = node;\n            }\n            else {\n                return yaml_1.visit.SKIP;\n            }\n        });\n        return [closestNode, false];\n    }\n    findClosestNode(offset, textBuffer, configuredIndentation) {\n        let offsetDiff = this.internalDocument.range[2];\n        let maxOffset = this.internalDocument.range[0];\n        let closestNode;\n        (0, yaml_1.visit)(this.internalDocument, (key, node) => {\n            if (!node) {\n                return;\n            }\n            const range = node.range;\n            if (!range) {\n                return;\n            }\n            const diff = range[1] - offset;\n            if (maxOffset <= range[0] && diff <= 0 && Math.abs(diff) <= offsetDiff) {\n                offsetDiff = Math.abs(diff);\n                maxOffset = range[0];\n                closestNode = node;\n            }\n        });\n        const position = textBuffer.getPosition(offset);\n        const lineContent = textBuffer.getLineContent(position.line);\n        const indentation = (0, strings_1.getIndentation)(lineContent, position.character);\n        if ((0, yaml_1.isScalar)(closestNode) && closestNode.value === null) {\n            return closestNode;\n        }\n        if (indentation === position.character) {\n            closestNode = this.getProperParentByIndentation(indentation, closestNode, textBuffer, '', configuredIndentation);\n        }\n        return closestNode;\n    }\n    getProperParentByIndentation(indentation, node, textBuffer, currentLine, configuredIndentation, rootParent) {\n        if (!node) {\n            return this.internalDocument.contents;\n        }\n        configuredIndentation = !configuredIndentation ? 2 : configuredIndentation;\n        if ((0, yaml_1.isNode)(node) && node.range) {\n            const position = textBuffer.getPosition(node.range[0]);\n            const lineContent = textBuffer.getLineContent(position.line);\n            currentLine = currentLine === '' ? lineContent.trim() : currentLine;\n            if (currentLine.startsWith('-') && indentation === configuredIndentation && currentLine === lineContent.trim()) {\n                position.character += indentation;\n            }\n            if (position.character > indentation && position.character > 0) {\n                const parent = this.getParent(node);\n                if (parent) {\n                    return this.getProperParentByIndentation(indentation, parent, textBuffer, currentLine, configuredIndentation, rootParent);\n                }\n            }\n            else if (position.character < indentation) {\n                const parent = this.getParent(node);\n                if ((0, yaml_1.isPair)(parent) && (0, yaml_1.isNode)(parent.value)) {\n                    return parent.value;\n                }\n                else if ((0, yaml_1.isPair)(rootParent) && (0, yaml_1.isNode)(rootParent.value)) {\n                    return rootParent.value;\n                }\n            }\n            else {\n                return node;\n            }\n        }\n        else if ((0, yaml_1.isPair)(node)) {\n            rootParent = node;\n            const parent = this.getParent(node);\n            return this.getProperParentByIndentation(indentation, parent, textBuffer, currentLine, configuredIndentation, rootParent);\n        }\n        return node;\n    }\n    getParent(node) {\n        return (0, astUtils_1.getParent)(this.internalDocument, node);\n    }\n}\nexports.SingleYAMLDocument = SingleYAMLDocument;\n/**\n * Contains the SingleYAMLDocuments, to be passed\n * to the `parseYAML` caller.\n */\nclass YAMLDocument {\n    constructor(documents, tokens) {\n        this.documents = documents;\n        this.tokens = tokens;\n        this.errors = [];\n        this.warnings = [];\n    }\n}\nexports.YAMLDocument = YAMLDocument;\nclass YamlDocuments {\n    constructor() {\n        // a mapping of URIs to cached documents\n        this.cache = new Map();\n    }\n    /**\n     * Get cached YAMLDocument\n     * @param document TextDocument to parse\n     * @param parserOptions YAML parserOptions\n     * @param addRootObject if true and document is empty add empty object {} to force schema usage\n     * @returns the YAMLDocument\n     */\n    getYamlDocument(document, parserOptions, addRootObject = false) {\n        this.ensureCache(document, parserOptions ?? yamlParser07_1.defaultOptions, addRootObject);\n        return this.cache.get(document.uri).document;\n    }\n    /**\n     * For test purpose only!\n     */\n    clear() {\n        this.cache.clear();\n    }\n    ensureCache(document, parserOptions, addRootObject) {\n        const key = document.uri;\n        if (!this.cache.has(key)) {\n            this.cache.set(key, { version: -1, document: new YAMLDocument([], []), parserOptions: yamlParser07_1.defaultOptions });\n        }\n        const cacheEntry = this.cache.get(key);\n        if (cacheEntry.version !== document.version ||\n            (parserOptions.customTags && !(0, arrUtils_1.isArrayEqual)(cacheEntry.parserOptions.customTags, parserOptions.customTags))) {\n            let text = document.getText();\n            // if text is contains only whitespace wrap all text in object to force schema selection\n            if (addRootObject && !/\\S/.test(text)) {\n                text = `{${text}}`;\n            }\n            const doc = (0, yamlParser07_1.parse)(text, parserOptions, document);\n            cacheEntry.document = doc;\n            cacheEntry.version = document.version;\n            cacheEntry.parserOptions = parserOptions;\n        }\n    }\n}\nexports.YamlDocuments = YamlDocuments;\nexports.yamlDocumentsCache = new YamlDocuments();\nfunction YAMLErrorToYamlDocDiagnostics(error) {\n    return {\n        message: error.message,\n        location: {\n            start: error.pos[0],\n            end: error.pos[1],\n            toLineEnd: true,\n        },\n        severity: 1,\n        code: vscode_json_languageservice_1.ErrorCode.Undefined,\n    };\n}\n//# sourceMappingURL=yaml-documents.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/parser/yaml-documents.js?")},1223:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Copyright (c) Adam Voss. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.parse = exports.defaultOptions = exports.SingleYAMLDocument = exports.YAMLDocument = void 0;\nconst yaml_1 = __webpack_require__(6749);\nconst yaml_documents_1 = __webpack_require__(4532);\nObject.defineProperty(exports, "YAMLDocument", ({ enumerable: true, get: function () { return yaml_documents_1.YAMLDocument; } }));\nObject.defineProperty(exports, "SingleYAMLDocument", ({ enumerable: true, get: function () { return yaml_documents_1.SingleYAMLDocument; } }));\nconst custom_tag_provider_1 = __webpack_require__(8321);\nconst textBuffer_1 = __webpack_require__(90);\nexports.defaultOptions = {\n    customTags: [],\n    yamlVersion: \'1.2\',\n};\n/**\n * `yaml-ast-parser-custom-tags` parses the AST and\n * returns YAML AST nodes, which are then formatted\n * for consumption via the language server.\n */\nfunction parse(text, parserOptions = exports.defaultOptions, document) {\n    const options = {\n        strict: false,\n        customTags: (0, custom_tag_provider_1.getCustomTags)(parserOptions.customTags),\n        version: parserOptions.yamlVersion ?? exports.defaultOptions.yamlVersion,\n        keepSourceTokens: true,\n    };\n    const composer = new yaml_1.Composer(options);\n    const lineCounter = new yaml_1.LineCounter();\n    let isLastLineEmpty = false;\n    if (document) {\n        const textBuffer = new textBuffer_1.TextBuffer(document);\n        const position = textBuffer.getPosition(text.length);\n        const lineContent = textBuffer.getLineContent(position.line);\n        isLastLineEmpty = lineContent.trim().length === 0;\n    }\n    const parser = isLastLineEmpty ? new yaml_1.Parser() : new yaml_1.Parser(lineCounter.addNewLine);\n    const tokens = parser.parse(text);\n    const tokensArr = Array.from(tokens);\n    const docs = composer.compose(tokensArr, true, text.length);\n    // Generate the SingleYAMLDocs from the AST nodes\n    const yamlDocs = Array.from(docs, (doc) => parsedDocToSingleYAMLDocument(doc, lineCounter));\n    // Consolidate the SingleYAMLDocs\n    return new yaml_documents_1.YAMLDocument(yamlDocs, tokensArr);\n}\nexports.parse = parse;\nfunction parsedDocToSingleYAMLDocument(parsedDoc, lineCounter) {\n    const syd = new yaml_documents_1.SingleYAMLDocument(lineCounter);\n    syd.internalDocument = parsedDoc;\n    return syd;\n}\n//# sourceMappingURL=yamlParser07.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/parser/yamlParser07.js?')},9287:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.YAMLDocumentSymbols = void 0;\nconst jsonDocumentSymbols_1 = __webpack_require__(2613);\nconst yaml_documents_1 = __webpack_require__(4532);\nconst yaml_1 = __webpack_require__(6749);\nconst objects_1 = __webpack_require__(285);\nclass YAMLDocumentSymbols {\n    constructor(schemaService, telemetry) {\n        this.telemetry = telemetry;\n        this.jsonDocumentSymbols = new jsonDocumentSymbols_1.JSONDocumentSymbols(schemaService);\n        // override 'getKeyLabel' to handle complex mapping\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.jsonDocumentSymbols.getKeyLabel = (property) => {\n            const keyNode = property.keyNode.internalNode;\n            let name = '';\n            if ((0, yaml_1.isMap)(keyNode)) {\n                name = '{}';\n            }\n            else if ((0, yaml_1.isSeq)(keyNode)) {\n                name = '[]';\n            }\n            else {\n                name = keyNode.source;\n            }\n            return name;\n        };\n    }\n    findDocumentSymbols(document, context = { resultLimit: Number.MAX_VALUE }) {\n        let results = [];\n        try {\n            const doc = yaml_documents_1.yamlDocumentsCache.getYamlDocument(document);\n            if (!doc || doc['documents'].length === 0) {\n                return null;\n            }\n            for (const yamlDoc of doc['documents']) {\n                if (yamlDoc.root) {\n                    results = results.concat(this.jsonDocumentSymbols.findDocumentSymbols(document, yamlDoc, context));\n                }\n            }\n        }\n        catch (err) {\n            this.telemetry?.sendError('yaml.documentSymbols.error', { error: (0, objects_1.convertErrorToTelemetryMsg)(err) });\n        }\n        return results;\n    }\n    findHierarchicalDocumentSymbols(document, context = { resultLimit: Number.MAX_VALUE }) {\n        let results = [];\n        try {\n            const doc = yaml_documents_1.yamlDocumentsCache.getYamlDocument(document);\n            if (!doc || doc['documents'].length === 0) {\n                return null;\n            }\n            for (const yamlDoc of doc['documents']) {\n                if (yamlDoc.root) {\n                    results = results.concat(this.jsonDocumentSymbols.findDocumentSymbols2(document, yamlDoc, context));\n                }\n            }\n        }\n        catch (err) {\n            this.telemetry?.sendError('yaml.hierarchicalDocumentSymbols.error', { error: (0, objects_1.convertErrorToTelemetryMsg)(err) });\n        }\n        return results;\n    }\n}\nexports.YAMLDocumentSymbols = YAMLDocumentSymbols;\n//# sourceMappingURL=documentSymbols.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/documentSymbols.js?")},3323:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isModeline = exports.getSchemaFromModeline = void 0;\nconst yamlParser07_1 = __webpack_require__(1223);\n/**\n * Retrieve schema if declared as modeline.\n * Public for testing purpose, not part of the API.\n * @param doc\n */\nfunction getSchemaFromModeline(doc) {\n    if (doc instanceof yamlParser07_1.SingleYAMLDocument) {\n        const yamlLanguageServerModeline = doc.lineComments.find((lineComment) => {\n            return isModeline(lineComment);\n        });\n        if (yamlLanguageServerModeline != undefined) {\n            const schemaMatchs = yamlLanguageServerModeline.match(/\\$schema=\\S+/g);\n            if (schemaMatchs !== null && schemaMatchs.length >= 1) {\n                if (schemaMatchs.length >= 2) {\n                    console.log('Several $schema attributes have been found on the yaml-language-server modeline. The first one will be picked.');\n                }\n                return schemaMatchs[0].substring('$schema='.length);\n            }\n        }\n    }\n    return undefined;\n}\nexports.getSchemaFromModeline = getSchemaFromModeline;\nfunction isModeline(lineText) {\n    const matchModeline = lineText.match(/^#\\s+yaml-language-server\\s*:/g);\n    return matchModeline !== null && matchModeline.length === 1;\n}\nexports.isModeline = isModeline;\n//# sourceMappingURL=modelineUtil.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/modelineUtil.js?")},6725:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.MapKeyOrderValidator = void 0;\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst yaml_1 = __webpack_require__(6749);\nclass MapKeyOrderValidator {\n    validate(document, yamlDoc) {\n        const result = [];\n        (0, yaml_1.visit)(yamlDoc.internalDocument, (key, node) => {\n            if ((0, yaml_1.isMap)(node)) {\n                for (let i = 1; i < node.items.length; i++) {\n                    if (compare(node.items[i - 1], node.items[i]) > 0) {\n                        const range = createRange(document, node.items[i - 1]);\n                        result.push(vscode_languageserver_types_1.Diagnostic.create(range, `Wrong ordering of key "${node.items[i - 1].key}" in mapping`, vscode_languageserver_types_1.DiagnosticSeverity.Error, \'mapKeyOrder\'));\n                    }\n                }\n            }\n        });\n        return result;\n    }\n}\nexports.MapKeyOrderValidator = MapKeyOrderValidator;\nfunction createRange(document, node) {\n    const start = node?.srcToken.start[0]?.offset ?? node?.srcToken?.key.offset ?? node?.srcToken?.sep[0]?.offset;\n    const end = node?.srcToken?.value.offset ||\n        node?.srcToken?.sep[0]?.offset ||\n        node?.srcToken?.key.offset ||\n        node?.srcToken.start[node.srcToken.start.length - 1]?.offset;\n    return vscode_languageserver_types_1.Range.create(document.positionAt(start), document.positionAt(end));\n}\nfunction compare(thiz, that) {\n    const thatKey = String(that.key);\n    const thisKey = String(thiz.key);\n    return thisKey.localeCompare(thatKey);\n}\n//# sourceMappingURL=map-key-order.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/validation/map-key-order.js?')},7318:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UnusedAnchorsValidator = void 0;\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst yaml_1 = __webpack_require__(6749);\nconst astUtils_1 = __webpack_require__(3713);\nclass UnusedAnchorsValidator {\n    validate(document, yamlDoc) {\n        const result = [];\n        const anchors = new Set();\n        const usedAnchors = new Set();\n        const anchorParent = new Map();\n        (0, yaml_1.visit)(yamlDoc.internalDocument, (key, node, path) => {\n            if (!(0, yaml_1.isNode)(node)) {\n                return;\n            }\n            if (((0, yaml_1.isCollection)(node) || (0, yaml_1.isScalar)(node)) && node.anchor) {\n                anchors.add(node);\n                anchorParent.set(node, path[path.length - 1]);\n            }\n            if ((0, yaml_1.isAlias)(node)) {\n                usedAnchors.add(node.resolve(yamlDoc.internalDocument));\n            }\n        });\n        for (const anchor of anchors) {\n            if (!usedAnchors.has(anchor)) {\n                const aToken = this.getAnchorNode(anchorParent.get(anchor), anchor);\n                if (aToken) {\n                    const range = vscode_languageserver_types_1.Range.create(document.positionAt(aToken.offset), document.positionAt(aToken.offset + aToken.source.length));\n                    const warningDiagnostic = vscode_languageserver_types_1.Diagnostic.create(range, `Unused anchor \"${aToken.source}\"`, vscode_languageserver_types_1.DiagnosticSeverity.Hint, 0);\n                    warningDiagnostic.tags = [vscode_languageserver_types_1.DiagnosticTag.Unnecessary];\n                    result.push(warningDiagnostic);\n                }\n            }\n        }\n        return result;\n    }\n    getAnchorNode(parentNode, node) {\n        if (parentNode && parentNode.srcToken) {\n            const token = parentNode.srcToken;\n            if ((0, astUtils_1.isCollectionItem)(token)) {\n                return getAnchorFromCollectionItem(token);\n            }\n            else if (yaml_1.CST.isCollection(token)) {\n                for (const t of token.items) {\n                    if (node.srcToken !== t.value)\n                        continue;\n                    const anchor = getAnchorFromCollectionItem(t);\n                    if (anchor) {\n                        return anchor;\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n}\nexports.UnusedAnchorsValidator = UnusedAnchorsValidator;\nfunction getAnchorFromCollectionItem(token) {\n    for (const t of token.start) {\n        if (t.type === 'anchor') {\n            return t;\n        }\n    }\n    if (token.sep && Array.isArray(token.sep)) {\n        for (const t of token.sep) {\n            if (t.type === 'anchor') {\n                return t;\n            }\n        }\n    }\n}\n//# sourceMappingURL=unused-anchors.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/validation/unused-anchors.js?")},9029:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.YAMLStyleValidator = void 0;\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst yaml_1 = __webpack_require__(6749);\nclass YAMLStyleValidator {\n    constructor(settings) {\n        this.forbidMapping = settings.flowMapping === 'forbid';\n        this.forbidSequence = settings.flowSequence === 'forbid';\n    }\n    validate(document, yamlDoc) {\n        const result = [];\n        (0, yaml_1.visit)(yamlDoc.internalDocument, (key, node) => {\n            if (this.forbidMapping && (0, yaml_1.isMap)(node) && node.srcToken?.type === 'flow-collection') {\n                result.push(vscode_languageserver_types_1.Diagnostic.create(this.getRangeOf(document, node.srcToken), 'Flow style mapping is forbidden', vscode_languageserver_types_1.DiagnosticSeverity.Error, 'flowMap'));\n            }\n            if (this.forbidSequence && (0, yaml_1.isSeq)(node) && node.srcToken?.type === 'flow-collection') {\n                result.push(vscode_languageserver_types_1.Diagnostic.create(this.getRangeOf(document, node.srcToken), 'Flow style sequence is forbidden', vscode_languageserver_types_1.DiagnosticSeverity.Error, 'flowSeq'));\n            }\n        });\n        return result;\n    }\n    getRangeOf(document, node) {\n        return vscode_languageserver_types_1.Range.create(document.positionAt(node.start.offset), document.positionAt(node.end.pop().offset));\n    }\n}\nexports.YAMLStyleValidator = YAMLStyleValidator;\n//# sourceMappingURL=yaml-style.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/validation/yaml-style.js?")},3584:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.YamlCodeActions = void 0;\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst commands_1 = __webpack_require__(5680);\nconst path = __webpack_require__(1017);\nconst textBuffer_1 = __webpack_require__(90);\nconst jsonParser07_1 = __webpack_require__(1406);\nconst strings_1 = __webpack_require__(4726);\nconst arrUtils_1 = __webpack_require__(8209);\nconst yaml_1 = __webpack_require__(6749);\nconst yaml_documents_1 = __webpack_require__(4532);\nconst flow_style_rewriter_1 = __webpack_require__(1508);\nconst _ = __webpack_require__(1888);\nclass YamlCodeActions {\n    constructor(clientCapabilities) {\n        this.clientCapabilities = clientCapabilities;\n        this.indentation = '  ';\n    }\n    configure(settings) {\n        this.indentation = settings.indentation;\n    }\n    getCodeAction(document, params) {\n        if (!params.context.diagnostics) {\n            return;\n        }\n        const result = [];\n        result.push(...this.getConvertToBooleanActions(params.context.diagnostics, document));\n        result.push(...this.getJumpToSchemaActions(params.context.diagnostics));\n        result.push(...this.getTabToSpaceConverting(params.context.diagnostics, document));\n        result.push(...this.getUnusedAnchorsDelete(params.context.diagnostics, document));\n        result.push(...this.getConvertToBlockStyleActions(params.context.diagnostics, document));\n        result.push(...this.getKeyOrderActions(params.context.diagnostics, document));\n        return result;\n    }\n    getJumpToSchemaActions(diagnostics) {\n        const isOpenTextDocumentEnabled = this.clientCapabilities?.window?.showDocument?.support ?? false;\n        if (!isOpenTextDocumentEnabled) {\n            return [];\n        }\n        const schemaUriToDiagnostic = new Map();\n        for (const diagnostic of diagnostics) {\n            const schemaUri = diagnostic.data?.schemaUri || [];\n            for (const schemaUriStr of schemaUri) {\n                if (schemaUriStr) {\n                    if (!schemaUriToDiagnostic.has(schemaUriStr)) {\n                        schemaUriToDiagnostic.set(schemaUriStr, []);\n                    }\n                    schemaUriToDiagnostic.get(schemaUriStr).push(diagnostic);\n                }\n            }\n        }\n        const result = [];\n        for (const schemaUri of schemaUriToDiagnostic.keys()) {\n            const action = vscode_languageserver_types_1.CodeAction.create(`Jump to schema location (${path.basename(schemaUri)})`, vscode_languageserver_types_1.Command.create('JumpToSchema', commands_1.YamlCommands.JUMP_TO_SCHEMA, schemaUri));\n            action.diagnostics = schemaUriToDiagnostic.get(schemaUri);\n            result.push(action);\n        }\n        return result;\n    }\n    getTabToSpaceConverting(diagnostics, document) {\n        const result = [];\n        const textBuff = new textBuffer_1.TextBuffer(document);\n        const processedLine = [];\n        for (const diag of diagnostics) {\n            if (diag.message === 'Using tabs can lead to unpredictable results') {\n                if (processedLine.includes(diag.range.start.line)) {\n                    continue;\n                }\n                const lineContent = textBuff.getLineContent(diag.range.start.line);\n                let replacedTabs = 0;\n                let newText = '';\n                for (let i = diag.range.start.character; i <= diag.range.end.character; i++) {\n                    const char = lineContent.charAt(i);\n                    if (char !== '\\t') {\n                        break;\n                    }\n                    replacedTabs++;\n                    newText += this.indentation;\n                }\n                processedLine.push(diag.range.start.line);\n                let resultRange = diag.range;\n                if (replacedTabs !== diag.range.end.character - diag.range.start.character) {\n                    resultRange = vscode_languageserver_types_1.Range.create(diag.range.start, vscode_languageserver_types_1.Position.create(diag.range.end.line, diag.range.start.character + replacedTabs));\n                }\n                result.push(vscode_languageserver_types_1.CodeAction.create('Convert Tab to Spaces', createWorkspaceEdit(document.uri, [vscode_languageserver_types_1.TextEdit.replace(resultRange, newText)]), vscode_languageserver_types_1.CodeActionKind.QuickFix));\n            }\n        }\n        if (result.length !== 0) {\n            const replaceEdits = [];\n            for (let i = 0; i <= textBuff.getLineCount(); i++) {\n                const lineContent = textBuff.getLineContent(i);\n                let replacedTabs = 0;\n                let newText = '';\n                for (let j = 0; j < lineContent.length; j++) {\n                    const char = lineContent.charAt(j);\n                    if (char !== ' ' && char !== '\\t') {\n                        if (replacedTabs !== 0) {\n                            replaceEdits.push(vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(i, j - replacedTabs, i, j), newText));\n                            replacedTabs = 0;\n                            newText = '';\n                        }\n                        break;\n                    }\n                    if (char === ' ' && replacedTabs !== 0) {\n                        replaceEdits.push(vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(i, j - replacedTabs, i, j), newText));\n                        replacedTabs = 0;\n                        newText = '';\n                        continue;\n                    }\n                    if (char === '\\t') {\n                        newText += this.indentation;\n                        replacedTabs++;\n                    }\n                }\n                // line contains only tabs\n                if (replacedTabs !== 0) {\n                    replaceEdits.push(vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(i, 0, i, textBuff.getLineLength(i)), newText));\n                }\n            }\n            if (replaceEdits.length > 0) {\n                result.push(vscode_languageserver_types_1.CodeAction.create('Convert all Tabs to Spaces', createWorkspaceEdit(document.uri, replaceEdits), vscode_languageserver_types_1.CodeActionKind.QuickFix));\n            }\n        }\n        return result;\n    }\n    getUnusedAnchorsDelete(diagnostics, document) {\n        const result = [];\n        const buffer = new textBuffer_1.TextBuffer(document);\n        for (const diag of diagnostics) {\n            if (diag.message.startsWith('Unused anchor') && diag.source === jsonParser07_1.YAML_SOURCE) {\n                const range = vscode_languageserver_types_1.Range.create(diag.range.start, diag.range.end);\n                const actual = buffer.getText(range);\n                const lineContent = buffer.getLineContent(range.end.line);\n                const lastWhitespaceChar = (0, strings_1.getFirstNonWhitespaceCharacterAfterOffset)(lineContent, range.end.character);\n                range.end.character = lastWhitespaceChar;\n                const action = vscode_languageserver_types_1.CodeAction.create(`Delete unused anchor: ${actual}`, createWorkspaceEdit(document.uri, [vscode_languageserver_types_1.TextEdit.del(range)]), vscode_languageserver_types_1.CodeActionKind.QuickFix);\n                action.diagnostics = [diag];\n                result.push(action);\n            }\n        }\n        return result;\n    }\n    getConvertToBooleanActions(diagnostics, document) {\n        const results = [];\n        for (const diagnostic of diagnostics) {\n            if (diagnostic.message === 'Incorrect type. Expected \"boolean\".') {\n                const value = document.getText(diagnostic.range).toLocaleLowerCase();\n                if (value === '\"true\"' || value === '\"false\"' || value === \"'true'\" || value === \"'false'\") {\n                    const newValue = value.includes('true') ? 'true' : 'false';\n                    results.push(vscode_languageserver_types_1.CodeAction.create('Convert to boolean', createWorkspaceEdit(document.uri, [vscode_languageserver_types_1.TextEdit.replace(diagnostic.range, newValue)]), vscode_languageserver_types_1.CodeActionKind.QuickFix));\n                }\n            }\n        }\n        return results;\n    }\n    getConvertToBlockStyleActions(diagnostics, document) {\n        const results = [];\n        for (const diagnostic of diagnostics) {\n            if (diagnostic.code === 'flowMap' || diagnostic.code === 'flowSeq') {\n                const node = getNodeforDiagnostic(document, diagnostic);\n                if ((0, yaml_1.isMap)(node.internalNode) || (0, yaml_1.isSeq)(node.internalNode)) {\n                    const blockTypeDescription = (0, yaml_1.isMap)(node.internalNode) ? 'map' : 'sequence';\n                    const rewriter = new flow_style_rewriter_1.FlowStyleRewriter(this.indentation);\n                    results.push(vscode_languageserver_types_1.CodeAction.create(`Convert to block style ${blockTypeDescription}`, createWorkspaceEdit(document.uri, [vscode_languageserver_types_1.TextEdit.replace(diagnostic.range, rewriter.write(node))]), vscode_languageserver_types_1.CodeActionKind.QuickFix));\n                }\n            }\n        }\n        return results;\n    }\n    getKeyOrderActions(diagnostics, document) {\n        const results = [];\n        for (const diagnostic of diagnostics) {\n            if (diagnostic?.code === 'mapKeyOrder') {\n                let node = getNodeforDiagnostic(document, diagnostic);\n                while (node && node.type !== 'object') {\n                    node = node.parent;\n                }\n                if (node && (0, yaml_1.isMap)(node.internalNode)) {\n                    const sorted = _.cloneDeep(node.internalNode);\n                    if ((sorted.srcToken.type === 'block-map' || sorted.srcToken.type === 'flow-collection') &&\n                        (node.internalNode.srcToken.type === 'block-map' || node.internalNode.srcToken.type === 'flow-collection')) {\n                        sorted.srcToken.items.sort((a, b) => {\n                            if (a.key && b.key && yaml_1.CST.isScalar(a.key) && yaml_1.CST.isScalar(b.key)) {\n                                return a.key.source.localeCompare(b.key.source);\n                            }\n                            if (!a.key && b.key) {\n                                return -1;\n                            }\n                            if (a.key && !b.key) {\n                                return 1;\n                            }\n                            if (!a.key && !b.key) {\n                                return 0;\n                            }\n                        });\n                        for (let i = 0; i < sorted.srcToken.items.length; i++) {\n                            const item = sorted.srcToken.items[i];\n                            const uItem = node.internalNode.srcToken.items[i];\n                            item.start = uItem.start;\n                            if (item.value?.type === 'alias' ||\n                                item.value?.type === 'scalar' ||\n                                item.value?.type === 'single-quoted-scalar' ||\n                                item.value?.type === 'double-quoted-scalar') {\n                                const newLineIndex = item.value?.end?.findIndex((p) => p.type === 'newline') ?? -1;\n                                let newLineToken = null;\n                                if (uItem.value?.type === 'block-scalar') {\n                                    newLineToken = uItem.value?.props?.find((p) => p.type === 'newline');\n                                }\n                                else if (yaml_1.CST.isScalar(uItem.value)) {\n                                    newLineToken = uItem.value?.end?.find((p) => p.type === 'newline');\n                                }\n                                if (newLineToken && newLineIndex < 0) {\n                                    item.value.end = item.value.end ?? [];\n                                    item.value.end.push(newLineToken);\n                                }\n                                if (!newLineToken && newLineIndex > -1) {\n                                    item.value.end.splice(newLineIndex, 1);\n                                }\n                            }\n                            else if (item.value?.type === 'block-scalar') {\n                                const nwline = item.value.props.find((p) => p.type === 'newline');\n                                if (!nwline) {\n                                    item.value.props.push({ type: 'newline', indent: 0, offset: item.value.offset, source: '\\n' });\n                                }\n                            }\n                        }\n                    }\n                    const replaceRange = vscode_languageserver_types_1.Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));\n                    results.push(vscode_languageserver_types_1.CodeAction.create('Fix key order for this map', createWorkspaceEdit(document.uri, [vscode_languageserver_types_1.TextEdit.replace(replaceRange, yaml_1.CST.stringify(sorted.srcToken))]), vscode_languageserver_types_1.CodeActionKind.QuickFix));\n                }\n            }\n        }\n        return results;\n    }\n}\nexports.YamlCodeActions = YamlCodeActions;\nfunction getNodeforDiagnostic(document, diagnostic) {\n    const yamlDocuments = yaml_documents_1.yamlDocumentsCache.getYamlDocument(document);\n    const startOffset = document.offsetAt(diagnostic.range.start);\n    const yamlDoc = (0, arrUtils_1.matchOffsetToDocument)(startOffset, yamlDocuments);\n    const node = yamlDoc.getNodeFromOffset(startOffset);\n    return node;\n}\nfunction createWorkspaceEdit(uri, edits) {\n    const changes = {};\n    changes[uri] = edits;\n    const edit = {\n        changes,\n    };\n    return edit;\n}\n//# sourceMappingURL=yamlCodeActions.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/yamlCodeActions.js?")},8551:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.YamlCodeLens = void 0;\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst commands_1 = __webpack_require__(5680);\nconst yaml_documents_1 = __webpack_require__(4532);\nconst schemaUrls_1 = __webpack_require__(2791);\nconst objects_1 = __webpack_require__(285);\nconst schemaUtils_1 = __webpack_require__(4411);\nclass YamlCodeLens {\n    constructor(schemaService, telemetry) {\n        this.schemaService = schemaService;\n        this.telemetry = telemetry;\n    }\n    async getCodeLens(document) {\n        const result = [];\n        try {\n            const yamlDocument = yaml_documents_1.yamlDocumentsCache.getYamlDocument(document);\n            let schemaUrls = new Map();\n            for (const currentYAMLDoc of yamlDocument.documents) {\n                const schema = await this.schemaService.getSchemaForResource(document.uri, currentYAMLDoc);\n                if (schema?.schema) {\n                    // merge schemas from all docs to avoid duplicates\n                    schemaUrls = new Map([...(0, schemaUrls_1.getSchemaUrls)(schema?.schema), ...schemaUrls]);\n                }\n            }\n            for (const urlToSchema of schemaUrls) {\n                const lens = vscode_languageserver_types_1.CodeLens.create(vscode_languageserver_types_1.Range.create(0, 0, 0, 0));\n                lens.command = {\n                    title: (0, schemaUtils_1.getSchemaTitle)(urlToSchema[1], urlToSchema[0]),\n                    command: commands_1.YamlCommands.JUMP_TO_SCHEMA,\n                    arguments: [urlToSchema[0]],\n                };\n                result.push(lens);\n            }\n        }\n        catch (err) {\n            this.telemetry?.sendError('yaml.codeLens.error', { error: (0, objects_1.convertErrorToTelemetryMsg)(err) });\n        }\n        return result;\n    }\n    resolveCodeLens(param) {\n        return param;\n    }\n}\nexports.YamlCodeLens = YamlCodeLens;\n//# sourceMappingURL=yamlCodeLens.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/yamlCodeLens.js?")},1850:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.YamlCompletion = void 0;\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst yaml_1 = __webpack_require__(6749);\nconst arrUtils_1 = __webpack_require__(8209);\nconst indentationGuesser_1 = __webpack_require__(2866);\nconst textBuffer_1 = __webpack_require__(90);\nconst json_1 = __webpack_require__(6455);\nconst objects_1 = __webpack_require__(285);\nconst nls = __webpack_require__(731);\nconst isKubernetes_1 = __webpack_require__(9389);\nconst jsonParser07_1 = __webpack_require__(1406);\nconst astUtils_1 = __webpack_require__(3713);\nconst modelineUtil_1 = __webpack_require__(3323);\nconst schemaUtils_1 = __webpack_require__(4411);\nconst localize = nls.loadMessageBundle();\nconst doubleQuotesEscapeRegExp = /[\\\\]+\"/g;\nconst parentCompletionKind = vscode_languageserver_types_1.CompletionItemKind.Class;\nconst existingProposeItem = '__';\nclass YamlCompletion {\n    constructor(schemaService, clientCapabilities = {}, yamlDocument, telemetry) {\n        this.schemaService = schemaService;\n        this.clientCapabilities = clientCapabilities;\n        this.yamlDocument = yamlDocument;\n        this.telemetry = telemetry;\n        this.completionEnabled = true;\n        this.arrayPrefixIndentation = '';\n    }\n    configure(languageSettings) {\n        if (languageSettings) {\n            this.completionEnabled = languageSettings.completion;\n        }\n        this.customTags = languageSettings.customTags;\n        this.yamlVersion = languageSettings.yamlVersion;\n        this.configuredIndentation = languageSettings.indentation;\n        this.disableDefaultProperties = languageSettings.disableDefaultProperties;\n        this.parentSkeletonSelectedFirst = languageSettings.parentSkeletonSelectedFirst;\n    }\n    async doComplete(document, position, isKubernetes = false, doComplete = true) {\n        const result = vscode_languageserver_types_1.CompletionList.create([], false);\n        if (!this.completionEnabled) {\n            return result;\n        }\n        const doc = this.yamlDocument.getYamlDocument(document, { customTags: this.customTags, yamlVersion: this.yamlVersion }, true);\n        const textBuffer = new textBuffer_1.TextBuffer(document);\n        if (!this.configuredIndentation) {\n            const indent = (0, indentationGuesser_1.guessIndentation)(textBuffer, 2, true);\n            this.indentation = indent.insertSpaces ? ' '.repeat(indent.tabSize) : '\\t';\n        }\n        else {\n            this.indentation = this.configuredIndentation;\n        }\n        (0, isKubernetes_1.setKubernetesParserOption)(doc.documents, isKubernetes);\n        // set parser options\n        for (const jsonDoc of doc.documents) {\n            jsonDoc.uri = document.uri;\n        }\n        const offset = document.offsetAt(position);\n        const text = document.getText();\n        if (text.charAt(offset - 1) === ':') {\n            return Promise.resolve(result);\n        }\n        let currentDoc = (0, arrUtils_1.matchOffsetToDocument)(offset, doc);\n        if (currentDoc === null) {\n            return Promise.resolve(result);\n        }\n        // as we modify AST for completion, we need to use copy of original document\n        currentDoc = currentDoc.clone();\n        let [node, foundByClosest] = currentDoc.getNodeFromPosition(offset, textBuffer, this.indentation.length);\n        const currentWord = this.getCurrentWord(document, offset);\n        let lineContent = textBuffer.getLineContent(position.line);\n        const lineAfterPosition = lineContent.substring(position.character);\n        const areOnlySpacesAfterPosition = /^[ ]+\\n?$/.test(lineAfterPosition);\n        this.arrayPrefixIndentation = '';\n        let overwriteRange = null;\n        if (areOnlySpacesAfterPosition) {\n            overwriteRange = vscode_languageserver_types_1.Range.create(position, vscode_languageserver_types_1.Position.create(position.line, lineContent.length));\n            const isOnlyWhitespace = lineContent.trim().length === 0;\n            const isOnlyDash = lineContent.match(/^\\s*(-)\\s*$/);\n            if (node && (0, yaml_1.isScalar)(node) && !isOnlyWhitespace && !isOnlyDash) {\n                const lineToPosition = lineContent.substring(0, position.character);\n                const matches = \n                // get indentation of unfinished property (between indent and cursor)\n                lineToPosition.match(/^[\\s-]*([^:]+)?$/) ||\n                    // OR get unfinished value (between colon and cursor)\n                    lineToPosition.match(/:[ \\t]((?!:[ \\t]).*)$/);\n                if (matches?.[1]) {\n                    overwriteRange = vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(position.line, position.character - matches[1].length), vscode_languageserver_types_1.Position.create(position.line, lineContent.length));\n                }\n            }\n        }\n        else if (node && (0, yaml_1.isScalar)(node) && node.value === 'null') {\n            const nodeStartPos = document.positionAt(node.range[0]);\n            nodeStartPos.character += 1;\n            const nodeEndPos = document.positionAt(node.range[2]);\n            nodeEndPos.character += 1;\n            overwriteRange = vscode_languageserver_types_1.Range.create(nodeStartPos, nodeEndPos);\n        }\n        else if (node && (0, yaml_1.isScalar)(node) && node.value) {\n            const start = document.positionAt(node.range[0]);\n            overwriteRange = vscode_languageserver_types_1.Range.create(start, document.positionAt(node.range[1]));\n        }\n        else if (node && (0, yaml_1.isScalar)(node) && node.value === null && currentWord === '-') {\n            overwriteRange = vscode_languageserver_types_1.Range.create(position, position);\n            this.arrayPrefixIndentation = ' ';\n        }\n        else {\n            let overwriteStart = offset - currentWord.length;\n            if (overwriteStart > 0 && text[overwriteStart - 1] === '\"') {\n                overwriteStart--;\n            }\n            overwriteRange = vscode_languageserver_types_1.Range.create(document.positionAt(overwriteStart), position);\n        }\n        const proposed = {};\n        const collector = {\n            add: (completionItem, oneOfSchema) => {\n                const addSuggestionForParent = function (completionItem) {\n                    const existsInYaml = proposed[completionItem.label]?.label === existingProposeItem;\n                    //don't put to parent suggestion if already in yaml\n                    if (existsInYaml) {\n                        return;\n                    }\n                    const schema = completionItem.parent.schema;\n                    const schemaType = (0, schemaUtils_1.getSchemaTypeName)(schema);\n                    const schemaDescription = schema.markdownDescription || schema.description;\n                    let parentCompletion = result.items.find((item) => item.parent?.schema === schema && item.kind === parentCompletionKind);\n                    if (parentCompletion && parentCompletion.parent.insertTexts.includes(completionItem.insertText)) {\n                        // already exists in the parent\n                        return;\n                    }\n                    else if (!parentCompletion) {\n                        // create a new parent\n                        parentCompletion = {\n                            ...completionItem,\n                            label: schemaType,\n                            documentation: schemaDescription,\n                            sortText: '_' + schemaType,\n                            kind: parentCompletionKind,\n                        };\n                        parentCompletion.label = parentCompletion.label || completionItem.label;\n                        parentCompletion.parent.insertTexts = [completionItem.insertText];\n                        result.items.push(parentCompletion);\n                    }\n                    else {\n                        // add to the existing parent\n                        parentCompletion.parent.insertTexts.push(completionItem.insertText);\n                    }\n                };\n                const isForParentCompletion = !!completionItem.parent;\n                let label = completionItem.label;\n                if (!label) {\n                    // we receive not valid CompletionItem as `label` is mandatory field, so just ignore it\n                    console.warn(`Ignoring CompletionItem without label: ${JSON.stringify(completionItem)}`);\n                    return;\n                }\n                if (!(0, objects_1.isString)(label)) {\n                    label = String(label);\n                }\n                label = label.replace(/[\\n]/g, '');\n                if (label.length > 60) {\n                    const shortendedLabel = label.substr(0, 57).trim() + '...';\n                    if (!proposed[shortendedLabel]) {\n                        label = shortendedLabel;\n                    }\n                }\n                // trim $1 from end of completion\n                if (completionItem.insertText.endsWith('$1') && !isForParentCompletion) {\n                    completionItem.insertText = completionItem.insertText.substr(0, completionItem.insertText.length - 2);\n                }\n                if (overwriteRange && overwriteRange.start.line === overwriteRange.end.line) {\n                    completionItem.textEdit = vscode_languageserver_types_1.TextEdit.replace(overwriteRange, completionItem.insertText);\n                }\n                completionItem.label = label;\n                if (isForParentCompletion) {\n                    addSuggestionForParent(completionItem);\n                    return;\n                }\n                if (this.arrayPrefixIndentation) {\n                    this.updateCompletionText(completionItem, this.arrayPrefixIndentation + completionItem.insertText);\n                }\n                const existing = proposed[label];\n                const isInsertTextDifferent = existing?.label !== existingProposeItem && existing?.insertText !== completionItem.insertText;\n                if (!existing) {\n                    proposed[label] = completionItem;\n                    result.items.push(completionItem);\n                }\n                else if (isInsertTextDifferent) {\n                    // try to merge simple insert values\n                    const mergedText = this.mergeSimpleInsertTexts(label, existing.insertText, completionItem.insertText, oneOfSchema);\n                    if (mergedText) {\n                        this.updateCompletionText(existing, mergedText);\n                    }\n                    else {\n                        // add to result when it wasn't able to merge (even if the item is already there but with a different value)\n                        proposed[label] = completionItem;\n                        result.items.push(completionItem);\n                    }\n                }\n                if (existing && !existing.documentation && completionItem.documentation) {\n                    existing.documentation = completionItem.documentation;\n                }\n            },\n            error: (message) => {\n                this.telemetry?.sendError('yaml.completion.error', { error: (0, objects_1.convertErrorToTelemetryMsg)(message) });\n            },\n            log: (message) => {\n                console.log(message);\n            },\n            getNumberOfProposals: () => {\n                return result.items.length;\n            },\n            result,\n            proposed,\n        };\n        if (this.customTags.length > 0) {\n            this.getCustomTagValueCompletions(collector);\n        }\n        if (lineContent.endsWith('\\n')) {\n            lineContent = lineContent.substr(0, lineContent.length - 1);\n        }\n        try {\n            const schema = await this.schemaService.getSchemaForResource(document.uri, currentDoc);\n            if (!schema || schema.errors.length) {\n                if (position.line === 0 && position.character === 0 && !(0, modelineUtil_1.isModeline)(lineContent)) {\n                    const inlineSchemaCompletion = {\n                        kind: vscode_languageserver_types_1.CompletionItemKind.Text,\n                        label: 'Inline schema',\n                        insertText: '# yaml-language-server: $schema=',\n                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText,\n                    };\n                    result.items.push(inlineSchemaCompletion);\n                }\n            }\n            if ((0, modelineUtil_1.isModeline)(lineContent) || (0, astUtils_1.isInComment)(doc.tokens, offset)) {\n                const schemaIndex = lineContent.indexOf('$schema=');\n                if (schemaIndex !== -1 && schemaIndex + '$schema='.length <= position.character) {\n                    this.schemaService.getAllSchemas().forEach((schema) => {\n                        const schemaIdCompletion = {\n                            kind: vscode_languageserver_types_1.CompletionItemKind.Constant,\n                            label: schema.name ?? schema.uri,\n                            detail: schema.description,\n                            insertText: schema.uri,\n                            insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.PlainText,\n                            insertTextMode: vscode_languageserver_types_1.InsertTextMode.asIs,\n                        };\n                        result.items.push(schemaIdCompletion);\n                    });\n                }\n                return result;\n            }\n            if (!schema || schema.errors.length) {\n                return result;\n            }\n            let currentProperty = null;\n            if (!node) {\n                if (!currentDoc.internalDocument.contents || (0, yaml_1.isScalar)(currentDoc.internalDocument.contents)) {\n                    const map = currentDoc.internalDocument.createNode({});\n                    map.range = [offset, offset + 1, offset + 1];\n                    currentDoc.internalDocument.contents = map;\n                    currentDoc.updateFromInternalDocument();\n                    node = map;\n                }\n                else {\n                    node = currentDoc.findClosestNode(offset, textBuffer);\n                    foundByClosest = true;\n                }\n            }\n            const originalNode = node;\n            if (node) {\n                if (lineContent.length === 0) {\n                    node = currentDoc.internalDocument.contents;\n                }\n                else {\n                    const parent = currentDoc.getParent(node);\n                    if (parent) {\n                        if ((0, yaml_1.isScalar)(node)) {\n                            if (node.value) {\n                                if ((0, yaml_1.isPair)(parent)) {\n                                    if (parent.value === node) {\n                                        if (lineContent.trim().length > 0 && lineContent.indexOf(':') < 0) {\n                                            const map = this.createTempObjNode(currentWord, node, currentDoc);\n                                            const parentParent = currentDoc.getParent(parent);\n                                            if ((0, yaml_1.isSeq)(currentDoc.internalDocument.contents)) {\n                                                const index = (0, astUtils_1.indexOf)(currentDoc.internalDocument.contents, parent);\n                                                if (typeof index === 'number') {\n                                                    currentDoc.internalDocument.set(index, map);\n                                                    currentDoc.updateFromInternalDocument();\n                                                }\n                                            }\n                                            else if (parentParent && ((0, yaml_1.isMap)(parentParent) || (0, yaml_1.isSeq)(parentParent))) {\n                                                parentParent.set(parent.key, map);\n                                                currentDoc.updateFromInternalDocument();\n                                            }\n                                            else {\n                                                currentDoc.internalDocument.set(parent.key, map);\n                                                currentDoc.updateFromInternalDocument();\n                                            }\n                                            currentProperty = map.items[0];\n                                            node = map;\n                                        }\n                                        else if (lineContent.trim().length === 0) {\n                                            const parentParent = currentDoc.getParent(parent);\n                                            if (parentParent) {\n                                                node = parentParent;\n                                            }\n                                        }\n                                    }\n                                    else if (parent.key === node) {\n                                        const parentParent = currentDoc.getParent(parent);\n                                        currentProperty = parent;\n                                        if (parentParent) {\n                                            node = parentParent;\n                                        }\n                                    }\n                                }\n                                else if ((0, yaml_1.isSeq)(parent)) {\n                                    if (lineContent.trim().length > 0) {\n                                        const map = this.createTempObjNode(currentWord, node, currentDoc);\n                                        parent.delete(node);\n                                        parent.add(map);\n                                        currentDoc.updateFromInternalDocument();\n                                        node = map;\n                                    }\n                                    else {\n                                        node = parent;\n                                    }\n                                }\n                            }\n                            else if (node.value === null) {\n                                if ((0, yaml_1.isPair)(parent)) {\n                                    if (parent.key === node) {\n                                        node = parent;\n                                    }\n                                    else {\n                                        if ((0, yaml_1.isNode)(parent.key) && parent.key.range) {\n                                            const parentParent = currentDoc.getParent(parent);\n                                            if (foundByClosest && parentParent && (0, yaml_1.isMap)(parentParent) && (0, astUtils_1.isMapContainsEmptyPair)(parentParent)) {\n                                                node = parentParent;\n                                            }\n                                            else {\n                                                const parentPosition = document.positionAt(parent.key.range[0]);\n                                                //if cursor has bigger indentation that parent key, then we need to complete new empty object\n                                                if (position.character > parentPosition.character && position.line !== parentPosition.line) {\n                                                    const map = this.createTempObjNode(currentWord, node, currentDoc);\n                                                    if (parentParent && ((0, yaml_1.isMap)(parentParent) || (0, yaml_1.isSeq)(parentParent))) {\n                                                        parentParent.set(parent.key, map);\n                                                        currentDoc.updateFromInternalDocument();\n                                                    }\n                                                    else {\n                                                        currentDoc.internalDocument.set(parent.key, map);\n                                                        currentDoc.updateFromInternalDocument();\n                                                    }\n                                                    currentProperty = map.items[0];\n                                                    node = map;\n                                                }\n                                                else if (parentPosition.character === position.character) {\n                                                    if (parentParent) {\n                                                        node = parentParent;\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                                else if ((0, yaml_1.isSeq)(parent)) {\n                                    if (lineContent.charAt(position.character - 1) !== '-') {\n                                        const map = this.createTempObjNode(currentWord, node, currentDoc);\n                                        parent.delete(node);\n                                        parent.add(map);\n                                        currentDoc.updateFromInternalDocument();\n                                        node = map;\n                                    }\n                                    else if (lineContent.charAt(position.character - 1) === '-') {\n                                        const map = this.createTempObjNode('', node, currentDoc);\n                                        parent.delete(node);\n                                        parent.add(map);\n                                        currentDoc.updateFromInternalDocument();\n                                        node = map;\n                                    }\n                                    else {\n                                        node = parent;\n                                    }\n                                }\n                            }\n                        }\n                        else if ((0, yaml_1.isMap)(node)) {\n                            if (!foundByClosest && lineContent.trim().length === 0 && (0, yaml_1.isSeq)(parent)) {\n                                const nextLine = textBuffer.getLineContent(position.line + 1);\n                                if (textBuffer.getLineCount() === position.line + 1 || nextLine.trim().length === 0) {\n                                    node = parent;\n                                }\n                            }\n                        }\n                    }\n                    else if ((0, yaml_1.isScalar)(node)) {\n                        const map = this.createTempObjNode(currentWord, node, currentDoc);\n                        currentDoc.internalDocument.contents = map;\n                        currentDoc.updateFromInternalDocument();\n                        currentProperty = map.items[0];\n                        node = map;\n                    }\n                    else if ((0, yaml_1.isMap)(node)) {\n                        for (const pair of node.items) {\n                            if ((0, yaml_1.isNode)(pair.value) && pair.value.range && pair.value.range[0] === offset + 1) {\n                                node = pair.value;\n                            }\n                        }\n                    }\n                    else if ((0, yaml_1.isSeq)(node)) {\n                        if (lineContent.charAt(position.character - 1) !== '-') {\n                            const map = this.createTempObjNode(currentWord, node, currentDoc);\n                            map.items = [];\n                            currentDoc.updateFromInternalDocument();\n                            for (const pair of node.items) {\n                                if ((0, yaml_1.isMap)(pair)) {\n                                    pair.items.forEach((value) => {\n                                        map.items.push(value);\n                                    });\n                                }\n                            }\n                            node = map;\n                        }\n                    }\n                }\n            }\n            // completion for object keys\n            if (node && (0, yaml_1.isMap)(node)) {\n                // don't suggest properties that are already present\n                const properties = node.items;\n                for (const p of properties) {\n                    if (!currentProperty || currentProperty !== p) {\n                        if ((0, yaml_1.isScalar)(p.key)) {\n                            proposed[p.key.value + ''] = vscode_languageserver_types_1.CompletionItem.create(existingProposeItem);\n                        }\n                    }\n                }\n                this.addPropertyCompletions(schema, currentDoc, node, originalNode, '', collector, textBuffer, overwriteRange, doComplete);\n                if (!schema && currentWord.length > 0 && text.charAt(offset - currentWord.length - 1) !== '\"') {\n                    collector.add({\n                        kind: vscode_languageserver_types_1.CompletionItemKind.Property,\n                        label: currentWord,\n                        insertText: this.getInsertTextForProperty(currentWord, null, ''),\n                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,\n                    });\n                }\n            }\n            // proposals for values\n            const types = {};\n            this.getValueCompletions(schema, currentDoc, node, offset, document, collector, types, doComplete);\n        }\n        catch (err) {\n            this.telemetry?.sendError('yaml.completion.error', { error: (0, objects_1.convertErrorToTelemetryMsg)(err) });\n        }\n        this.finalizeParentCompletion(result);\n        const uniqueItems = result.items.filter((arr, index, self) => index ===\n            self.findIndex((item) => item.label === arr.label && item.insertText === arr.insertText && item.kind === arr.kind));\n        if (uniqueItems?.length > 0) {\n            result.items = uniqueItems;\n        }\n        return result;\n    }\n    updateCompletionText(completionItem, text) {\n        completionItem.insertText = text;\n        if (completionItem.textEdit) {\n            completionItem.textEdit.newText = text;\n        }\n    }\n    mergeSimpleInsertTexts(label, existingText, addingText, oneOfSchema) {\n        const containsNewLineAfterColon = (value) => {\n            return value.includes('\\n');\n        };\n        const startWithNewLine = (value) => {\n            return value.startsWith('\\n');\n        };\n        const isNullObject = (value) => {\n            const index = value.indexOf('\\n');\n            return index > 0 && value.substring(index, value.length).trim().length === 0;\n        };\n        if (containsNewLineAfterColon(existingText) || containsNewLineAfterColon(addingText)) {\n            //if the exisiting object null one then replace with the non-null object\n            if (oneOfSchema && isNullObject(existingText) && !isNullObject(addingText) && !startWithNewLine(addingText)) {\n                return addingText;\n            }\n            return undefined;\n        }\n        const existingValues = this.getValuesFromInsertText(existingText);\n        const addingValues = this.getValuesFromInsertText(addingText);\n        const newValues = Array.prototype.concat(existingValues, addingValues);\n        if (!newValues.length) {\n            return undefined;\n        }\n        else if (newValues.length === 1) {\n            return `${label}: \\${1:${newValues[0]}}`;\n        }\n        else {\n            return `${label}: \\${1|${newValues.join(',')}|}`;\n        }\n    }\n    getValuesFromInsertText(insertText) {\n        const value = insertText.substring(insertText.indexOf(':') + 1).trim();\n        if (!value) {\n            return [];\n        }\n        const valueMath = value.match(/^\\${1[|:]([^|]*)+\\|?}$/); // ${1|one,two,three|}  or  ${1:one}\n        if (valueMath) {\n            return valueMath[1].split(',');\n        }\n        return [value];\n    }\n    finalizeParentCompletion(result) {\n        const reindexText = (insertTexts) => {\n            //modify added props to have unique $x\n            let max$index = 0;\n            return insertTexts.map((text) => {\n                const match = text.match(/\\$([0-9]+)|\\${[0-9]+:/g);\n                if (!match) {\n                    return text;\n                }\n                const max$indexLocal = match\n                    .map((m) => +m.replace(/\\${([0-9]+)[:|]/g, '$1').replace('$', '')) // get numbers form $1 or ${1:...}\n                    .reduce((p, n) => (n > p ? n : p), 0); // find the max one\n                const reindexedStr = text\n                    .replace(/\\$([0-9]+)/g, (s, args) => '$' + (+args + max$index)) // increment each by max$index\n                    .replace(/\\${([0-9]+)[:|]/g, (s, args) => '${' + (+args + max$index) + ':'); // increment each by max$index\n                max$index += max$indexLocal;\n                return reindexedStr;\n            });\n        };\n        result.items.forEach((completionItem) => {\n            if (isParentCompletionItem(completionItem)) {\n                const indent = completionItem.parent.indent || '';\n                const reindexedTexts = reindexText(completionItem.parent.insertTexts);\n                // add indent to each object property and join completion item texts\n                let insertText = reindexedTexts.join(`\\n${indent}`);\n                // trim $1 from end of completion\n                if (insertText.endsWith('$1')) {\n                    insertText = insertText.substring(0, insertText.length - 2);\n                }\n                completionItem.insertText = this.arrayPrefixIndentation + insertText;\n                if (completionItem.textEdit) {\n                    completionItem.textEdit.newText = completionItem.insertText;\n                }\n                // remove $x or use {$x:value} in documentation\n                const mdText = insertText.replace(/\\${[0-9]+[:|](.*)}/g, (s, arg) => arg).replace(/\\$([0-9]+)/g, '');\n                const originalDocumentation = completionItem.documentation ? [completionItem.documentation, '', '----', ''] : [];\n                completionItem.documentation = {\n                    kind: vscode_languageserver_types_1.MarkupKind.Markdown,\n                    value: [...originalDocumentation, '```yaml', indent + mdText, '```'].join('\\n'),\n                };\n                delete completionItem.parent;\n            }\n        });\n    }\n    createTempObjNode(currentWord, node, currentDoc) {\n        const obj = {};\n        obj[currentWord] = null;\n        const map = currentDoc.internalDocument.createNode(obj);\n        map.range = node.range;\n        map.items[0].key.range = node.range;\n        map.items[0].value.range = node.range;\n        return map;\n    }\n    addPropertyCompletions(schema, doc, node, originalNode, separatorAfter, collector, textBuffer, overwriteRange, doComplete) {\n        const matchingSchemas = doc.getMatchingSchemas(schema.schema, -1, null, doComplete);\n        const existingKey = textBuffer.getText(overwriteRange);\n        const lineContent = textBuffer.getLineContent(overwriteRange.start.line);\n        const hasOnlyWhitespace = lineContent.trim().length === 0;\n        const hasColon = lineContent.indexOf(':') !== -1;\n        const isInArray = lineContent.trimLeft().indexOf('-') === 0;\n        const nodeParent = doc.getParent(node);\n        const matchOriginal = matchingSchemas.find((it) => it.node.internalNode === originalNode && it.schema.properties);\n        const oneOfSchema = matchingSchemas.filter((schema) => schema.schema.oneOf).map((oneOfSchema) => oneOfSchema.schema.oneOf)[0];\n        let didOneOfSchemaMatches = false;\n        if (oneOfSchema?.length < matchingSchemas.length) {\n            oneOfSchema?.forEach((property, index) => {\n                if (!matchingSchemas[index]?.schema.oneOf && matchingSchemas[index]?.schema.properties === property.properties) {\n                    didOneOfSchemaMatches = true;\n                }\n            });\n        }\n        for (const schema of matchingSchemas) {\n            if (((schema.node.internalNode === node && !matchOriginal) ||\n                (schema.node.internalNode === originalNode && !hasColon) ||\n                (schema.node.parent?.internalNode === originalNode && !hasColon)) &&\n                !schema.inverted) {\n                this.collectDefaultSnippets(schema.schema, separatorAfter, collector, {\n                    newLineFirst: false,\n                    indentFirstObject: false,\n                    shouldIndentWithTab: isInArray,\n                });\n                const schemaProperties = schema.schema.properties;\n                if (schemaProperties) {\n                    const maxProperties = schema.schema.maxProperties;\n                    if (maxProperties === undefined ||\n                        node.items === undefined ||\n                        node.items.length < maxProperties ||\n                        (node.items.length === maxProperties && !hasOnlyWhitespace)) {\n                        for (const key in schemaProperties) {\n                            if (Object.prototype.hasOwnProperty.call(schemaProperties, key)) {\n                                const propertySchema = schemaProperties[key];\n                                if (typeof propertySchema === 'object' && !propertySchema.deprecationMessage && !propertySchema['doNotSuggest']) {\n                                    let identCompensation = '';\n                                    if (nodeParent && (0, yaml_1.isSeq)(nodeParent) && node.items.length <= 1 && !hasOnlyWhitespace) {\n                                        // because there is a slash '-' to prevent the properties generated to have the correct\n                                        // indent\n                                        const sourceText = textBuffer.getText();\n                                        const indexOfSlash = sourceText.lastIndexOf('-', node.range[0] - 1);\n                                        if (indexOfSlash >= 0) {\n                                            // add one space to compensate the '-'\n                                            const overwriteChars = overwriteRange.end.character - overwriteRange.start.character;\n                                            identCompensation = ' ' + sourceText.slice(indexOfSlash + 1, node.range[1] - overwriteChars);\n                                        }\n                                    }\n                                    identCompensation += this.arrayPrefixIndentation;\n                                    // if check that current node has last pair with \"null\" value and key witch match key from schema,\n                                    // and if schema has array definition it add completion item for array item creation\n                                    let pair;\n                                    if (propertySchema.type === 'array' &&\n                                        (pair = node.items.find((it) => (0, yaml_1.isScalar)(it.key) &&\n                                            it.key.range &&\n                                            it.key.value === key &&\n                                            (0, yaml_1.isScalar)(it.value) &&\n                                            !it.value.value &&\n                                            textBuffer.getPosition(it.key.range[2]).line === overwriteRange.end.line - 1)) &&\n                                        pair) {\n                                        if (Array.isArray(propertySchema.items)) {\n                                            this.addSchemaValueCompletions(propertySchema.items[0], separatorAfter, collector, {}, 'property');\n                                        }\n                                        else if (typeof propertySchema.items === 'object' && propertySchema.items.type === 'object') {\n                                            this.addArrayItemValueCompletion(propertySchema.items, separatorAfter, collector);\n                                        }\n                                    }\n                                    let insertText = key;\n                                    if (!key.startsWith(existingKey) || !hasColon) {\n                                        insertText = this.getInsertTextForProperty(key, propertySchema, separatorAfter, identCompensation + this.indentation);\n                                    }\n                                    const isNodeNull = ((0, yaml_1.isScalar)(originalNode) && originalNode.value === null) ||\n                                        ((0, yaml_1.isMap)(originalNode) && originalNode.items.length === 0);\n                                    const existsParentCompletion = schema.schema.required?.length > 0;\n                                    if (!this.parentSkeletonSelectedFirst || !isNodeNull || !existsParentCompletion) {\n                                        collector.add({\n                                            kind: vscode_languageserver_types_1.CompletionItemKind.Property,\n                                            label: key,\n                                            insertText,\n                                            insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,\n                                            documentation: this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || '',\n                                        }, didOneOfSchemaMatches);\n                                    }\n                                    // if the prop is required add it also to parent suggestion\n                                    if (schema.schema.required?.includes(key)) {\n                                        collector.add({\n                                            label: key,\n                                            insertText: this.getInsertTextForProperty(key, propertySchema, separatorAfter, identCompensation + this.indentation),\n                                            insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,\n                                            documentation: this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || '',\n                                            parent: {\n                                                schema: schema.schema,\n                                                indent: identCompensation,\n                                            },\n                                        });\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                // Error fix\n                // If this is a array of string/boolean/number\n                //  test:\n                //    - item1\n                // it will treated as a property key since `:` has been appended\n                if (nodeParent && (0, yaml_1.isSeq)(nodeParent) && (0, schemaUtils_1.isPrimitiveType)(schema.schema)) {\n                    this.addSchemaValueCompletions(schema.schema, separatorAfter, collector, {}, 'property', Array.isArray(nodeParent.items));\n                }\n                if (schema.schema.propertyNames && schema.schema.additionalProperties && schema.schema.type === 'object') {\n                    const propertyNameSchema = (0, jsonParser07_1.asSchema)(schema.schema.propertyNames);\n                    const label = propertyNameSchema.title || 'property';\n                    collector.add({\n                        kind: vscode_languageserver_types_1.CompletionItemKind.Property,\n                        label,\n                        insertText: '$' + `{1:${label}}: `,\n                        insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,\n                        documentation: this.fromMarkup(propertyNameSchema.markdownDescription) || propertyNameSchema.description || '',\n                    });\n                }\n            }\n            if (nodeParent && schema.node.internalNode === nodeParent && schema.schema.defaultSnippets) {\n                // For some reason the first item in the array needs to be treated differently, otherwise\n                // the indentation will not be correct\n                if (node.items.length === 1) {\n                    this.collectDefaultSnippets(schema.schema, separatorAfter, collector, {\n                        newLineFirst: false,\n                        indentFirstObject: false,\n                        shouldIndentWithTab: true,\n                    }, 1);\n                }\n                else {\n                    this.collectDefaultSnippets(schema.schema, separatorAfter, collector, {\n                        newLineFirst: false,\n                        indentFirstObject: true,\n                        shouldIndentWithTab: false,\n                    }, 1);\n                }\n            }\n        }\n    }\n    getValueCompletions(schema, doc, node, offset, document, collector, types, doComplete) {\n        let parentKey = null;\n        if (node && (0, yaml_1.isScalar)(node)) {\n            node = doc.getParent(node);\n        }\n        if (!node) {\n            this.addSchemaValueCompletions(schema.schema, '', collector, types, 'value');\n            return;\n        }\n        if ((0, yaml_1.isPair)(node)) {\n            const valueNode = node.value;\n            if (valueNode && valueNode.range && offset > valueNode.range[0] + valueNode.range[2]) {\n                return; // we are past the value node\n            }\n            parentKey = (0, yaml_1.isScalar)(node.key) ? node.key.value + '' : null;\n            node = doc.getParent(node);\n        }\n        if (node && (parentKey !== null || (0, yaml_1.isSeq)(node))) {\n            const separatorAfter = '';\n            const matchingSchemas = doc.getMatchingSchemas(schema.schema, -1, null, doComplete);\n            for (const s of matchingSchemas) {\n                if (s.node.internalNode === node && !s.inverted && s.schema) {\n                    if (s.schema.items) {\n                        this.collectDefaultSnippets(s.schema, separatorAfter, collector, {\n                            newLineFirst: false,\n                            indentFirstObject: false,\n                            shouldIndentWithTab: false,\n                        });\n                        if ((0, yaml_1.isSeq)(node) && node.items) {\n                            if (Array.isArray(s.schema.items)) {\n                                const index = this.findItemAtOffset(node, document, offset);\n                                if (index < s.schema.items.length) {\n                                    this.addSchemaValueCompletions(s.schema.items[index], separatorAfter, collector, types, 'value');\n                                }\n                            }\n                            else if (typeof s.schema.items === 'object' &&\n                                (s.schema.items.type === 'object' || (0, schemaUtils_1.isAnyOfAllOfOneOfType)(s.schema.items))) {\n                                this.addSchemaValueCompletions(s.schema.items, separatorAfter, collector, types, 'value', true);\n                            }\n                            else {\n                                this.addSchemaValueCompletions(s.schema.items, separatorAfter, collector, types, 'value');\n                            }\n                        }\n                    }\n                    if (s.schema.properties) {\n                        const propertySchema = s.schema.properties[parentKey];\n                        if (propertySchema) {\n                            this.addSchemaValueCompletions(propertySchema, separatorAfter, collector, types, 'value');\n                        }\n                    }\n                    else if (s.schema.additionalProperties) {\n                        this.addSchemaValueCompletions(s.schema.additionalProperties, separatorAfter, collector, types, 'value');\n                    }\n                }\n            }\n            if (types['boolean']) {\n                this.addBooleanValueCompletion(true, separatorAfter, collector);\n                this.addBooleanValueCompletion(false, separatorAfter, collector);\n            }\n            if (types['null']) {\n                this.addNullValueCompletion(separatorAfter, collector);\n            }\n        }\n    }\n    addArrayItemValueCompletion(schema, separatorAfter, collector, index) {\n        const schemaType = (0, schemaUtils_1.getSchemaTypeName)(schema);\n        const insertText = `- ${this.getInsertTextForObject(schema, separatorAfter).insertText.trimLeft()}`;\n        //append insertText to documentation\n        const schemaTypeTitle = schemaType ? ' type `' + schemaType + '`' : '';\n        const schemaDescription = schema.description ? ' (' + schema.description + ')' : '';\n        const documentation = this.getDocumentationWithMarkdownText(`Create an item of an array${schemaTypeTitle}${schemaDescription}`, insertText);\n        collector.add({\n            kind: this.getSuggestionKind(schema.type),\n            label: '- (array item) ' + (schemaType || index),\n            documentation: documentation,\n            insertText: insertText,\n            insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,\n        });\n    }\n    getInsertTextForProperty(key, propertySchema, separatorAfter, indent = this.indentation) {\n        const propertyText = this.getInsertTextForValue(key, '', 'string');\n        const resultText = propertyText + ':';\n        let value;\n        let nValueProposals = 0;\n        if (propertySchema) {\n            let type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;\n            if (!type) {\n                if (propertySchema.properties) {\n                    type = 'object';\n                }\n                else if (propertySchema.items) {\n                    type = 'array';\n                }\n                else if (propertySchema.anyOf) {\n                    type = 'anyOf';\n                }\n            }\n            if (Array.isArray(propertySchema.defaultSnippets)) {\n                if (propertySchema.defaultSnippets.length === 1) {\n                    const body = propertySchema.defaultSnippets[0].body;\n                    if ((0, objects_1.isDefined)(body)) {\n                        value = this.getInsertTextForSnippetValue(body, '', {\n                            newLineFirst: true,\n                            indentFirstObject: false,\n                            shouldIndentWithTab: false,\n                        }, [], 1);\n                        // add space before default snippet value\n                        if (!value.startsWith(' ') && !value.startsWith('\\n')) {\n                            value = ' ' + value;\n                        }\n                    }\n                }\n                nValueProposals += propertySchema.defaultSnippets.length;\n            }\n            if (propertySchema.enum) {\n                if (!value && propertySchema.enum.length === 1) {\n                    value = ' ' + this.getInsertTextForGuessedValue(propertySchema.enum[0], '', type);\n                }\n                nValueProposals += propertySchema.enum.length;\n            }\n            if (propertySchema.const) {\n                if (!value) {\n                    value = this.getInsertTextForGuessedValue(propertySchema.const, '', type);\n                    value = evaluateTab1Symbol(value); // prevent const being selected after snippet insert\n                    value = ' ' + value;\n                }\n                nValueProposals++;\n            }\n            if ((0, objects_1.isDefined)(propertySchema.default)) {\n                if (!value) {\n                    value = ' ' + this.getInsertTextForGuessedValue(propertySchema.default, '', type);\n                }\n                nValueProposals++;\n            }\n            if (Array.isArray(propertySchema.examples) && propertySchema.examples.length) {\n                if (!value) {\n                    value = ' ' + this.getInsertTextForGuessedValue(propertySchema.examples[0], '', type);\n                }\n                nValueProposals += propertySchema.examples.length;\n            }\n            if (propertySchema.properties) {\n                return `${resultText}\\n${this.getInsertTextForObject(propertySchema, separatorAfter, indent).insertText}`;\n            }\n            else if (propertySchema.items) {\n                return `${resultText}\\n${indent}- ${this.getInsertTextForArray(propertySchema.items, separatorAfter, 1, indent).insertText}`;\n            }\n            if (nValueProposals === 0) {\n                switch (type) {\n                    case 'boolean':\n                        value = ' $1';\n                        break;\n                    case 'string':\n                        value = ' $1';\n                        break;\n                    case 'object':\n                        value = `\\n${indent}`;\n                        break;\n                    case 'array':\n                        value = `\\n${indent}- `;\n                        break;\n                    case 'number':\n                    case 'integer':\n                        value = ' ${1:0}';\n                        break;\n                    case 'null':\n                        value = ' ${1:null}';\n                        break;\n                    case 'anyOf':\n                        value = ' $1';\n                        break;\n                    default:\n                        return propertyText;\n                }\n            }\n        }\n        if (!value || nValueProposals > 1) {\n            value = ' $1';\n        }\n        return resultText + value + separatorAfter;\n    }\n    getInsertTextForObject(schema, separatorAfter, indent = this.indentation, insertIndex = 1) {\n        let insertText = '';\n        if (!schema.properties) {\n            insertText = `${indent}$${insertIndex++}\\n`;\n            return { insertText, insertIndex };\n        }\n        Object.keys(schema.properties).forEach((key) => {\n            const propertySchema = schema.properties[key];\n            let type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;\n            if (!type) {\n                if (propertySchema.anyOf) {\n                    type = 'anyOf';\n                }\n                if (propertySchema.properties) {\n                    type = 'object';\n                }\n                if (propertySchema.items) {\n                    type = 'array';\n                }\n            }\n            if (schema.required && schema.required.indexOf(key) > -1) {\n                switch (type) {\n                    case 'boolean':\n                    case 'string':\n                    case 'number':\n                    case 'integer':\n                    case 'anyOf': {\n                        let value = propertySchema.default || propertySchema.const;\n                        if (value) {\n                            if (type === 'string') {\n                                value = convertToStringValue(value);\n                            }\n                            insertText += `${indent}${key}: \\${${insertIndex++}:${value}}\\n`;\n                        }\n                        else {\n                            insertText += `${indent}${key}: $${insertIndex++}\\n`;\n                        }\n                        break;\n                    }\n                    case 'array':\n                        {\n                            const arrayInsertResult = this.getInsertTextForArray(propertySchema.items, separatorAfter, insertIndex++, indent);\n                            const arrayInsertLines = arrayInsertResult.insertText.split('\\n');\n                            let arrayTemplate = arrayInsertResult.insertText;\n                            if (arrayInsertLines.length > 1) {\n                                for (let index = 1; index < arrayInsertLines.length; index++) {\n                                    const element = arrayInsertLines[index];\n                                    arrayInsertLines[index] = `  ${element}`;\n                                }\n                                arrayTemplate = arrayInsertLines.join('\\n');\n                            }\n                            insertIndex = arrayInsertResult.insertIndex;\n                            insertText += `${indent}${key}:\\n${indent}${this.indentation}- ${arrayTemplate}\\n`;\n                        }\n                        break;\n                    case 'object':\n                        {\n                            const objectInsertResult = this.getInsertTextForObject(propertySchema, separatorAfter, `${indent}${this.indentation}`, insertIndex++);\n                            insertIndex = objectInsertResult.insertIndex;\n                            insertText += `${indent}${key}:\\n${objectInsertResult.insertText}\\n`;\n                        }\n                        break;\n                }\n            }\n            else if (!this.disableDefaultProperties && propertySchema.default !== undefined) {\n                switch (type) {\n                    case 'boolean':\n                    case 'number':\n                    case 'integer':\n                        insertText += `${indent}${\n                        //added quote if key is null\n                        key === 'null' ? this.getInsertTextForValue(key, '', 'string') : key}: \\${${insertIndex++}:${propertySchema.default}}\\n`;\n                        break;\n                    case 'string':\n                        insertText += `${indent}${key}: \\${${insertIndex++}:${convertToStringValue(propertySchema.default)}}\\n`;\n                        break;\n                    case 'array':\n                    case 'object':\n                        // TODO: support default value for array object\n                        break;\n                }\n            }\n        });\n        if (insertText.trim().length === 0) {\n            insertText = `${indent}$${insertIndex++}\\n`;\n        }\n        insertText = insertText.trimRight() + separatorAfter;\n        return { insertText, insertIndex };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getInsertTextForArray(schema, separatorAfter, insertIndex = 1, indent = this.indentation) {\n        let insertText = '';\n        if (!schema) {\n            insertText = `$${insertIndex++}`;\n            return { insertText, insertIndex };\n        }\n        let type = Array.isArray(schema.type) ? schema.type[0] : schema.type;\n        if (!type) {\n            if (schema.properties) {\n                type = 'object';\n            }\n            if (schema.items) {\n                type = 'array';\n            }\n        }\n        switch (schema.type) {\n            case 'boolean':\n                insertText = `\\${${insertIndex++}:false}`;\n                break;\n            case 'number':\n            case 'integer':\n                insertText = `\\${${insertIndex++}:0}`;\n                break;\n            case 'string':\n                insertText = `\\${${insertIndex++}:\"\"}`;\n                break;\n            case 'object':\n                {\n                    const objectInsertResult = this.getInsertTextForObject(schema, separatorAfter, `${indent}  `, insertIndex++);\n                    insertText = objectInsertResult.insertText.trimLeft();\n                    insertIndex = objectInsertResult.insertIndex;\n                }\n                break;\n        }\n        return { insertText, insertIndex };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getInsertTextForGuessedValue(value, separatorAfter, type) {\n        switch (typeof value) {\n            case 'object':\n                if (value === null) {\n                    return '${1:null}' + separatorAfter;\n                }\n                return this.getInsertTextForValue(value, separatorAfter, type);\n            case 'string': {\n                let snippetValue = JSON.stringify(value);\n                snippetValue = snippetValue.substr(1, snippetValue.length - 2); // remove quotes\n                snippetValue = this.getInsertTextForPlainText(snippetValue); // escape \\ and }\n                if (type === 'string') {\n                    snippetValue = convertToStringValue(snippetValue);\n                }\n                return '${1:' + snippetValue + '}' + separatorAfter;\n            }\n            case 'number':\n            case 'boolean':\n                return '${1:' + value + '}' + separatorAfter;\n        }\n        return this.getInsertTextForValue(value, separatorAfter, type);\n    }\n    getInsertTextForPlainText(text) {\n        return text.replace(/[\\\\$}]/g, '\\\\$&'); // escape $, \\ and }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getInsertTextForValue(value, separatorAfter, type) {\n        if (value === null) {\n            return 'null'; // replace type null with string 'null'\n        }\n        switch (typeof value) {\n            case 'object': {\n                const indent = this.indentation;\n                return this.getInsertTemplateForValue(value, indent, { index: 1 }, separatorAfter);\n            }\n            case 'number':\n            case 'boolean':\n                return this.getInsertTextForPlainText(value + separatorAfter);\n        }\n        type = Array.isArray(type) ? type[0] : type;\n        if (type === 'string') {\n            value = convertToStringValue(value);\n        }\n        return this.getInsertTextForPlainText(value + separatorAfter);\n    }\n    getInsertTemplateForValue(value, indent, navOrder, separatorAfter) {\n        if (Array.isArray(value)) {\n            let insertText = '\\n';\n            for (const arrValue of value) {\n                insertText += `${indent}- \\${${navOrder.index++}:${arrValue}}\\n`;\n            }\n            return insertText;\n        }\n        else if (typeof value === 'object') {\n            let insertText = '\\n';\n            for (const key in value) {\n                if (Object.prototype.hasOwnProperty.call(value, key)) {\n                    const element = value[key];\n                    insertText += `${indent}\\${${navOrder.index++}:${key}}:`;\n                    let valueTemplate;\n                    if (typeof element === 'object') {\n                        valueTemplate = `${this.getInsertTemplateForValue(element, indent + this.indentation, navOrder, separatorAfter)}`;\n                    }\n                    else {\n                        valueTemplate = ` \\${${navOrder.index++}:${this.getInsertTextForPlainText(element + separatorAfter)}}\\n`;\n                    }\n                    insertText += `${valueTemplate}`;\n                }\n            }\n            return insertText;\n        }\n        return this.getInsertTextForPlainText(value + separatorAfter);\n    }\n    addSchemaValueCompletions(schema, separatorAfter, collector, types, completionType, isArray) {\n        if (typeof schema === 'object') {\n            this.addEnumValueCompletions(schema, separatorAfter, collector, isArray);\n            this.addDefaultValueCompletions(schema, separatorAfter, collector);\n            this.collectTypes(schema, types);\n            if (isArray && completionType === 'value' && !(0, schemaUtils_1.isAnyOfAllOfOneOfType)(schema)) {\n                // add array only for final types (no anyOf, allOf, oneOf)\n                this.addArrayItemValueCompletion(schema, separatorAfter, collector);\n            }\n            if (Array.isArray(schema.allOf)) {\n                schema.allOf.forEach((s) => {\n                    return this.addSchemaValueCompletions(s, separatorAfter, collector, types, completionType, isArray);\n                });\n            }\n            if (Array.isArray(schema.anyOf)) {\n                schema.anyOf.forEach((s) => {\n                    return this.addSchemaValueCompletions(s, separatorAfter, collector, types, completionType, isArray);\n                });\n            }\n            if (Array.isArray(schema.oneOf)) {\n                schema.oneOf.forEach((s) => {\n                    return this.addSchemaValueCompletions(s, separatorAfter, collector, types, completionType, isArray);\n                });\n            }\n        }\n    }\n    collectTypes(schema, types) {\n        if (Array.isArray(schema.enum) || (0, objects_1.isDefined)(schema.const)) {\n            return;\n        }\n        const type = schema.type;\n        if (Array.isArray(type)) {\n            type.forEach(function (t) {\n                return (types[t] = true);\n            });\n        }\n        else if (type) {\n            types[type] = true;\n        }\n    }\n    addDefaultValueCompletions(schema, separatorAfter, collector, arrayDepth = 0) {\n        let hasProposals = false;\n        if ((0, objects_1.isDefined)(schema.default)) {\n            let type = schema.type;\n            let value = schema.default;\n            for (let i = arrayDepth; i > 0; i--) {\n                value = [value];\n                type = 'array';\n            }\n            let label;\n            if (typeof value == 'object') {\n                label = 'Default value';\n            }\n            else {\n                label = value.toString().replace(doubleQuotesEscapeRegExp, '\"');\n            }\n            collector.add({\n                kind: this.getSuggestionKind(type),\n                label,\n                insertText: this.getInsertTextForValue(value, separatorAfter, type),\n                insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,\n                detail: localize('json.suggest.default', 'Default value'),\n            });\n            hasProposals = true;\n        }\n        if (Array.isArray(schema.examples)) {\n            schema.examples.forEach((example) => {\n                let type = schema.type;\n                let value = example;\n                for (let i = arrayDepth; i > 0; i--) {\n                    value = [value];\n                    type = 'array';\n                }\n                collector.add({\n                    kind: this.getSuggestionKind(type),\n                    label: this.getLabelForValue(value),\n                    insertText: this.getInsertTextForValue(value, separatorAfter, type),\n                    insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,\n                });\n                hasProposals = true;\n            });\n        }\n        this.collectDefaultSnippets(schema, separatorAfter, collector, {\n            newLineFirst: true,\n            indentFirstObject: true,\n            shouldIndentWithTab: true,\n        });\n        if (!hasProposals && typeof schema.items === 'object' && !Array.isArray(schema.items)) {\n            this.addDefaultValueCompletions(schema.items, separatorAfter, collector, arrayDepth + 1);\n        }\n    }\n    addEnumValueCompletions(schema, separatorAfter, collector, isArray) {\n        if ((0, objects_1.isDefined)(schema.const) && !isArray) {\n            collector.add({\n                kind: this.getSuggestionKind(schema.type),\n                label: this.getLabelForValue(schema.const),\n                insertText: this.getInsertTextForValue(schema.const, separatorAfter, schema.type),\n                insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,\n                documentation: this.fromMarkup(schema.markdownDescription) || schema.description,\n            });\n        }\n        if (Array.isArray(schema.enum)) {\n            for (let i = 0, length = schema.enum.length; i < length; i++) {\n                const enm = schema.enum[i];\n                let documentation = this.fromMarkup(schema.markdownDescription) || schema.description;\n                if (schema.markdownEnumDescriptions && i < schema.markdownEnumDescriptions.length && this.doesSupportMarkdown()) {\n                    documentation = this.fromMarkup(schema.markdownEnumDescriptions[i]);\n                }\n                else if (schema.enumDescriptions && i < schema.enumDescriptions.length) {\n                    documentation = schema.enumDescriptions[i];\n                }\n                collector.add({\n                    kind: this.getSuggestionKind(schema.type),\n                    label: this.getLabelForValue(enm),\n                    insertText: this.getInsertTextForValue(enm, separatorAfter, schema.type),\n                    insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,\n                    documentation: documentation,\n                });\n            }\n        }\n    }\n    getLabelForValue(value) {\n        if (value === null) {\n            return 'null'; // return string with 'null' value if schema contains null as possible value\n        }\n        if (Array.isArray(value)) {\n            return JSON.stringify(value);\n        }\n        return '' + value;\n    }\n    collectDefaultSnippets(schema, separatorAfter, collector, settings, arrayDepth = 0) {\n        if (Array.isArray(schema.defaultSnippets)) {\n            for (const s of schema.defaultSnippets) {\n                let type = schema.type;\n                let value = s.body;\n                let label = s.label;\n                let insertText;\n                let filterText;\n                if ((0, objects_1.isDefined)(value)) {\n                    const type = s.type || schema.type;\n                    if (arrayDepth === 0 && type === 'array') {\n                        // We know that a - isn't present yet so we need to add one\n                        const fixedObj = {};\n                        Object.keys(value).forEach((val, index) => {\n                            if (index === 0 && !val.startsWith('-')) {\n                                fixedObj[`- ${val}`] = value[val];\n                            }\n                            else {\n                                fixedObj[`  ${val}`] = value[val];\n                            }\n                        });\n                        value = fixedObj;\n                    }\n                    const existingProps = Object.keys(collector.proposed).filter((proposedProp) => collector.proposed[proposedProp].label === existingProposeItem);\n                    insertText = this.getInsertTextForSnippetValue(value, separatorAfter, settings, existingProps);\n                    // if snippet result is empty and value has a real value, don't add it as a completion\n                    if (insertText === '' && value) {\n                        continue;\n                    }\n                    label = label || this.getLabelForSnippetValue(value);\n                }\n                else if (typeof s.bodyText === 'string') {\n                    let prefix = '', suffix = '', indent = '';\n                    for (let i = arrayDepth; i > 0; i--) {\n                        prefix = prefix + indent + '[\\n';\n                        suffix = suffix + '\\n' + indent + ']';\n                        indent += this.indentation;\n                        type = 'array';\n                    }\n                    insertText = prefix + indent + s.bodyText.split('\\n').join('\\n' + indent) + suffix + separatorAfter;\n                    label = label || insertText;\n                    filterText = insertText.replace(/[\\n]/g, ''); // remove new lines\n                }\n                collector.add({\n                    kind: s.suggestionKind || this.getSuggestionKind(type),\n                    label,\n                    sortText: s.sortText || s.label,\n                    documentation: this.fromMarkup(s.markdownDescription) || s.description,\n                    insertText,\n                    insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,\n                    filterText,\n                });\n            }\n        }\n    }\n    getInsertTextForSnippetValue(value, separatorAfter, settings, existingProps, depth) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const replacer = (value) => {\n            if (typeof value === 'string') {\n                if (value[0] === '^') {\n                    return value.substr(1);\n                }\n                if (value === 'true' || value === 'false') {\n                    return `\"${value}\"`;\n                }\n            }\n            return value;\n        };\n        return ((0, json_1.stringifyObject)(value, '', replacer, { ...settings, indentation: this.indentation, existingProps }, depth) + separatorAfter);\n    }\n    addBooleanValueCompletion(value, separatorAfter, collector) {\n        collector.add({\n            kind: this.getSuggestionKind('boolean'),\n            label: value ? 'true' : 'false',\n            insertText: this.getInsertTextForValue(value, separatorAfter, 'boolean'),\n            insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,\n            documentation: '',\n        });\n    }\n    addNullValueCompletion(separatorAfter, collector) {\n        collector.add({\n            kind: this.getSuggestionKind('null'),\n            label: 'null',\n            insertText: 'null' + separatorAfter,\n            insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,\n            documentation: '',\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getLabelForSnippetValue(value) {\n        const label = JSON.stringify(value);\n        return label.replace(/\\$\\{\\d+:([^}]+)\\}|\\$\\d+/g, '$1');\n    }\n    getCustomTagValueCompletions(collector) {\n        const validCustomTags = (0, arrUtils_1.filterInvalidCustomTags)(this.customTags);\n        validCustomTags.forEach((validTag) => {\n            // Valid custom tags are guarenteed to be strings\n            const label = validTag.split(' ')[0];\n            this.addCustomTagValueCompletion(collector, ' ', label);\n        });\n    }\n    addCustomTagValueCompletion(collector, separatorAfter, label) {\n        collector.add({\n            kind: this.getSuggestionKind('string'),\n            label: label,\n            insertText: label + separatorAfter,\n            insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,\n            documentation: '',\n        });\n    }\n    getDocumentationWithMarkdownText(documentation, insertText) {\n        let res = documentation;\n        if (this.doesSupportMarkdown()) {\n            insertText = insertText\n                .replace(/\\${[0-9]+[:|](.*)}/g, (s, arg) => {\n                return arg;\n            })\n                .replace(/\\$([0-9]+)/g, '');\n            res = this.fromMarkup(`${documentation}\\n \\`\\`\\`\\n${insertText}\\n\\`\\`\\``);\n        }\n        return res;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getSuggestionKind(type) {\n        if (Array.isArray(type)) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const array = type;\n            type = array.length > 0 ? array[0] : null;\n        }\n        if (!type) {\n            return vscode_languageserver_types_1.CompletionItemKind.Value;\n        }\n        switch (type) {\n            case 'string':\n                return vscode_languageserver_types_1.CompletionItemKind.Value;\n            case 'object':\n                return vscode_languageserver_types_1.CompletionItemKind.Module;\n            case 'property':\n                return vscode_languageserver_types_1.CompletionItemKind.Property;\n            default:\n                return vscode_languageserver_types_1.CompletionItemKind.Value;\n        }\n    }\n    getCurrentWord(doc, offset) {\n        let i = offset - 1;\n        const text = doc.getText();\n        while (i >= 0 && ' \\t\\n\\r\\v\":{[,]}'.indexOf(text.charAt(i)) === -1) {\n            i--;\n        }\n        return text.substring(i + 1, offset);\n    }\n    fromMarkup(markupString) {\n        if (markupString && this.doesSupportMarkdown()) {\n            return {\n                kind: vscode_languageserver_types_1.MarkupKind.Markdown,\n                value: markupString,\n            };\n        }\n        return undefined;\n    }\n    doesSupportMarkdown() {\n        if (this.supportsMarkdown === undefined) {\n            const completion = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;\n            this.supportsMarkdown =\n                completion &&\n                    completion.completionItem &&\n                    Array.isArray(completion.completionItem.documentationFormat) &&\n                    completion.completionItem.documentationFormat.indexOf(vscode_languageserver_types_1.MarkupKind.Markdown) !== -1;\n        }\n        return this.supportsMarkdown;\n    }\n    findItemAtOffset(seqNode, doc, offset) {\n        for (let i = seqNode.items.length - 1; i >= 0; i--) {\n            const node = seqNode.items[i];\n            if ((0, yaml_1.isNode)(node)) {\n                if (node.range) {\n                    if (offset > node.range[1]) {\n                        return i;\n                    }\n                    else if (offset >= node.range[0]) {\n                        return i;\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n}\nexports.YamlCompletion = YamlCompletion;\nconst isNumberExp = /^\\d+$/;\nfunction convertToStringValue(param) {\n    let value;\n    if (typeof param === 'string') {\n        value = param;\n    }\n    else {\n        value = '' + param;\n    }\n    if (value.length === 0) {\n        return value;\n    }\n    if (value === 'true' || value === 'false' || value === 'null' || isNumberExp.test(value)) {\n        return `\"${value}\"`;\n    }\n    if (value.indexOf('\"') !== -1) {\n        value = value.replace(doubleQuotesEscapeRegExp, '\"');\n    }\n    let doQuote = !isNaN(parseInt(value)) || value.charAt(0) === '@';\n    if (!doQuote) {\n        // need to quote value if in `foo: bar`, `foo : bar` (mapping) or `foo:` (partial map) format\n        // but `foo:bar` and `:bar` (colon without white-space after it) are just plain string\n        let idx = value.indexOf(':', 0);\n        for (; idx > 0 && idx < value.length; idx = value.indexOf(':', idx + 1)) {\n            if (idx === value.length - 1) {\n                // `foo:` (partial map) format\n                doQuote = true;\n                break;\n            }\n            // there are only two valid kinds of white-space in yaml: space or tab\n            // ref: https://yaml.org/spec/1.2.1/#id2775170\n            const nextChar = value.charAt(idx + 1);\n            if (nextChar === '\\t' || nextChar === ' ') {\n                doQuote = true;\n                break;\n            }\n        }\n    }\n    if (doQuote) {\n        value = `\"${value}\"`;\n    }\n    return value;\n}\n/**\n * simplify `{$1:value}` to `value`\n */\nfunction evaluateTab1Symbol(value) {\n    return value.replace(/\\$\\{1:(.*)\\}/, '$1');\n}\nfunction isParentCompletionItem(item) {\n    return 'parent' in item;\n}\n//# sourceMappingURL=yamlCompletion.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/yamlCompletion.js?")},6023:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.YamlDefinition = void 0;\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst yaml_1 = __webpack_require__(6749);\nconst yaml_documents_1 = __webpack_require__(4532);\nconst arrUtils_1 = __webpack_require__(8209);\nconst objects_1 = __webpack_require__(285);\nconst textBuffer_1 = __webpack_require__(90);\nclass YamlDefinition {\n    constructor(telemetry) {\n        this.telemetry = telemetry;\n    }\n    getDefinition(document, params) {\n        try {\n            const yamlDocument = yaml_documents_1.yamlDocumentsCache.getYamlDocument(document);\n            const offset = document.offsetAt(params.position);\n            const currentDoc = (0, arrUtils_1.matchOffsetToDocument)(offset, yamlDocument);\n            if (currentDoc) {\n                const [node] = currentDoc.getNodeFromPosition(offset, new textBuffer_1.TextBuffer(document));\n                if (node && (0, yaml_1.isAlias)(node)) {\n                    const defNode = node.resolve(currentDoc.internalDocument);\n                    if (defNode && defNode.range) {\n                        const targetRange = vscode_languageserver_types_1.Range.create(document.positionAt(defNode.range[0]), document.positionAt(defNode.range[2]));\n                        const selectionRange = vscode_languageserver_types_1.Range.create(document.positionAt(defNode.range[0]), document.positionAt(defNode.range[1]));\n                        return [vscode_languageserver_types_1.LocationLink.create(document.uri, targetRange, selectionRange)];\n                    }\n                }\n            }\n        }\n        catch (err) {\n            this.telemetry?.sendError('yaml.definition.error', { error: (0, objects_1.convertErrorToTelemetryMsg)(err) });\n        }\n        return undefined;\n    }\n}\nexports.YamlDefinition = YamlDefinition;\n//# sourceMappingURL=yamlDefinition.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/yamlDefinition.js?")},382:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getFoldingRanges = void 0;\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst yaml_documents_1 = __webpack_require__(4532);\nfunction getFoldingRanges(document, context) {\n    if (!document) {\n        return;\n    }\n    const result = [];\n    const doc = yaml_documents_1.yamlDocumentsCache.getYamlDocument(document);\n    for (const ymlDoc of doc.documents) {\n        if (doc.documents.length > 1) {\n            result.push(createNormalizedFolding(document, ymlDoc.root));\n        }\n        ymlDoc.visit((node) => {\n            if (node.type === 'object' && node.parent?.type === 'array') {\n                result.push(createNormalizedFolding(document, node));\n            }\n            if (node.type === 'property' && node.valueNode) {\n                switch (node.valueNode.type) {\n                    case 'array':\n                    case 'object':\n                        result.push(createNormalizedFolding(document, node));\n                        break;\n                    case 'string': {\n                        // check if it is a multi-line string\n                        const nodePosn = document.positionAt(node.offset);\n                        const valuePosn = document.positionAt(node.valueNode.offset + node.valueNode.length);\n                        if (nodePosn.line !== valuePosn.line) {\n                            result.push(createNormalizedFolding(document, node));\n                        }\n                        break;\n                    }\n                    default:\n                        return true;\n                }\n            }\n            return true;\n        });\n    }\n    const rangeLimit = context && context.rangeLimit;\n    if (typeof rangeLimit !== 'number' || result.length <= rangeLimit) {\n        return result;\n    }\n    if (context && context.onRangeLimitExceeded) {\n        context.onRangeLimitExceeded(document.uri);\n    }\n    return result.slice(0, context.rangeLimit);\n}\nexports.getFoldingRanges = getFoldingRanges;\nfunction createNormalizedFolding(document, node) {\n    const startPos = document.positionAt(node.offset);\n    let endPos = document.positionAt(node.offset + node.length);\n    const textFragment = document.getText(vscode_languageserver_types_1.Range.create(startPos, endPos));\n    const newLength = textFragment.length - textFragment.trimRight().length;\n    if (newLength > 0) {\n        endPos = document.positionAt(node.offset + node.length - newLength);\n    }\n    return vscode_languageserver_types_1.FoldingRange.create(startPos.line, endPos.line, startPos.character, endPos.character);\n}\n//# sourceMappingURL=yamlFolding.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/yamlFolding.js?")},2845:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Copyright (c) Adam Voss. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.YAMLFormatter = void 0;\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst prettier = __webpack_require__(543);\nconst parser = __webpack_require__(4753);\nclass YAMLFormatter {\n    constructor() {\n        this.formatterEnabled = true;\n    }\n    configure(shouldFormat) {\n        if (shouldFormat) {\n            this.formatterEnabled = shouldFormat.format;\n        }\n    }\n    format(document, options) {\n        if (!this.formatterEnabled) {\n            return [];\n        }\n        try {\n            const text = document.getText();\n            const prettierOptions = {\n                parser: 'yaml',\n                plugins: [parser],\n                // --- FormattingOptions ---\n                tabWidth: options.tabWidth || options.tabSize,\n                // --- CustomFormatterOptions ---\n                singleQuote: options.singleQuote,\n                bracketSpacing: options.bracketSpacing,\n                // 'preserve' is the default for Options.proseWrap. See also server.ts\n                proseWrap: 'always' === options.proseWrap ? 'always' : 'never' === options.proseWrap ? 'never' : 'preserve',\n                printWidth: options.printWidth,\n            };\n            const formatted = prettier.format(text, prettierOptions);\n            return [vscode_languageserver_types_1.TextEdit.replace(vscode_languageserver_types_1.Range.create(vscode_languageserver_types_1.Position.create(0, 0), document.positionAt(text.length)), formatted)];\n        }\n        catch (error) {\n            return [];\n        }\n    }\n}\nexports.YAMLFormatter = YAMLFormatter;\n//# sourceMappingURL=yamlFormatter.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/yamlFormatter.js?")},801:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.YAMLHover = void 0;\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst arrUtils_1 = __webpack_require__(8209);\nconst isKubernetes_1 = __webpack_require__(9389);\nconst yaml_documents_1 = __webpack_require__(4532);\nconst jsonParser07_1 = __webpack_require__(1406);\nconst vscode_uri_1 = __webpack_require__(5472);\nconst path = __webpack_require__(1017);\nconst objects_1 = __webpack_require__(285);\nclass YAMLHover {\n    constructor(schemaService, telemetry) {\n        this.telemetry = telemetry;\n        this.shouldHover = true;\n        this.schemaService = schemaService;\n    }\n    configure(languageSettings) {\n        if (languageSettings) {\n            this.shouldHover = languageSettings.hover;\n            this.indentation = languageSettings.indentation;\n        }\n    }\n    doHover(document, position, isKubernetes = false) {\n        try {\n            if (!this.shouldHover || !document) {\n                return Promise.resolve(undefined);\n            }\n            const doc = yaml_documents_1.yamlDocumentsCache.getYamlDocument(document);\n            const offset = document.offsetAt(position);\n            const currentDoc = (0, arrUtils_1.matchOffsetToDocument)(offset, doc);\n            if (currentDoc === null) {\n                return Promise.resolve(undefined);\n            }\n            (0, isKubernetes_1.setKubernetesParserOption)(doc.documents, isKubernetes);\n            const currentDocIndex = doc.documents.indexOf(currentDoc);\n            currentDoc.currentDocIndex = currentDocIndex;\n            return this.getHover(document, position, currentDoc);\n        }\n        catch (error) {\n            this.telemetry?.sendError('yaml.hover.error', { error: (0, objects_1.convertErrorToTelemetryMsg)(error) });\n        }\n    }\n    // method copied from https://github.com/microsoft/vscode-json-languageservice/blob/2ea5ad3d2ffbbe40dea11cfe764a502becf113ce/src/services/jsonHover.ts#L23\n    getHover(document, position, doc) {\n        const offset = document.offsetAt(position);\n        let node = doc.getNodeFromOffset(offset);\n        if (!node ||\n            ((node.type === 'object' || node.type === 'array') && offset > node.offset + 1 && offset < node.offset + node.length - 1)) {\n            return Promise.resolve(null);\n        }\n        const hoverRangeNode = node;\n        // use the property description when hovering over an object key\n        if (node.type === 'string') {\n            const parent = node.parent;\n            if (parent && parent.type === 'property' && parent.keyNode === node) {\n                node = parent.valueNode;\n                if (!node) {\n                    return Promise.resolve(null);\n                }\n            }\n        }\n        const hoverRange = vscode_languageserver_types_1.Range.create(document.positionAt(hoverRangeNode.offset), document.positionAt(hoverRangeNode.offset + hoverRangeNode.length));\n        const createHover = (contents) => {\n            if (this.indentation !== undefined) {\n                const indentationMatchRegex = new RegExp(` {${this.indentation.length}}`, 'g');\n                contents = contents.replace(indentationMatchRegex, '&emsp;');\n            }\n            const markupContent = {\n                kind: vscode_languageserver_types_1.MarkupKind.Markdown,\n                value: contents,\n            };\n            const result = {\n                contents: markupContent,\n                range: hoverRange,\n            };\n            return result;\n        };\n        const removePipe = (value) => {\n            return value.replace(/\\|\\|\\s*$/, '');\n        };\n        return this.schemaService.getSchemaForResource(document.uri, doc).then((schema) => {\n            if (schema && node && !schema.errors.length) {\n                const matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);\n                let title = undefined;\n                let markdownDescription = undefined;\n                let markdownEnumValueDescription = undefined;\n                let enumValue = undefined;\n                const markdownExamples = [];\n                matchingSchemas.every((s) => {\n                    if ((s.node === node || (node.type === 'property' && node.valueNode === s.node)) && !s.inverted && s.schema) {\n                        title = title || s.schema.title || s.schema.closestTitle;\n                        markdownDescription = markdownDescription || s.schema.markdownDescription || toMarkdown(s.schema.description);\n                        if (s.schema.enum) {\n                            const idx = s.schema.enum.indexOf((0, jsonParser07_1.getNodeValue)(node));\n                            if (s.schema.markdownEnumDescriptions) {\n                                markdownEnumValueDescription = s.schema.markdownEnumDescriptions[idx];\n                            }\n                            else if (s.schema.enumDescriptions) {\n                                markdownEnumValueDescription = toMarkdown(s.schema.enumDescriptions[idx]);\n                            }\n                            if (markdownEnumValueDescription) {\n                                enumValue = s.schema.enum[idx];\n                                if (typeof enumValue !== 'string') {\n                                    enumValue = JSON.stringify(enumValue);\n                                }\n                            }\n                        }\n                        if (s.schema.anyOf && isAllSchemasMatched(node, matchingSchemas, s.schema)) {\n                            //if append title and description of all matched schemas on hover\n                            title = '';\n                            markdownDescription = '';\n                            s.schema.anyOf.forEach((childSchema, index) => {\n                                title += childSchema.title || s.schema.closestTitle || '';\n                                markdownDescription += childSchema.markdownDescription || toMarkdown(childSchema.description) || '';\n                                if (index !== s.schema.anyOf.length - 1) {\n                                    title += ' || ';\n                                    markdownDescription += ' || ';\n                                }\n                            });\n                            title = removePipe(title);\n                            markdownDescription = removePipe(markdownDescription);\n                        }\n                        if (s.schema.examples) {\n                            s.schema.examples.forEach((example) => {\n                                markdownExamples.push(JSON.stringify(example, null, 2));\n                            });\n                        }\n                    }\n                    return true;\n                });\n                let result = '';\n                if (title) {\n                    result = '#### ' + toMarkdown(title);\n                }\n                if (markdownDescription) {\n                    if (result.length > 0) {\n                        result += '\\n\\n';\n                    }\n                    result += markdownDescription;\n                }\n                if (markdownEnumValueDescription) {\n                    if (result.length > 0) {\n                        result += '\\n\\n';\n                    }\n                    result += `\\`${toMarkdownCodeBlock(enumValue)}\\`: ${markdownEnumValueDescription}`;\n                }\n                if (markdownExamples.length !== 0) {\n                    if (result.length > 0) {\n                        result += '\\n\\n';\n                    }\n                    result += 'Examples:';\n                    markdownExamples.forEach((example) => {\n                        result += `\\n\\n\\`\\`\\`${example}\\`\\`\\``;\n                    });\n                }\n                if (result.length > 0 && schema.schema.url) {\n                    result += `\\n\\nSource: [${getSchemaName(schema.schema)}](${schema.schema.url})`;\n                }\n                return createHover(result);\n            }\n            return null;\n        });\n    }\n}\nexports.YAMLHover = YAMLHover;\nfunction getSchemaName(schema) {\n    let result = 'JSON Schema';\n    const urlString = schema.url;\n    if (urlString) {\n        const url = vscode_uri_1.URI.parse(urlString);\n        result = path.basename(url.fsPath);\n    }\n    else if (schema.title) {\n        result = schema.title;\n    }\n    return result;\n}\nfunction toMarkdown(plain) {\n    if (plain) {\n        const res = plain.replace(/([^\\n\\r])(\\r?\\n)([^\\n\\r])/gm, '$1\\n\\n$3'); // single new lines to \\n\\n (Markdown paragraph)\n        return res.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    return undefined;\n}\n// copied from https://github.com/microsoft/vscode-json-languageservice/blob/2ea5ad3d2ffbbe40dea11cfe764a502becf113ce/src/services/jsonHover.ts#L122\nfunction toMarkdownCodeBlock(content) {\n    // see https://daringfireball.net/projects/markdown/syntax#precode\n    if (content.indexOf('`') !== -1) {\n        return '`` ' + content + ' ``';\n    }\n    return content;\n}\n/**\n * check all the schemas which is inside anyOf presented or not in matching schema.\n * @param node node\n * @param matchingSchemas all matching schema\n * @param schema scheam which is having anyOf\n * @returns true if all the schemas which inside anyOf presents in matching schema\n */\nfunction isAllSchemasMatched(node, matchingSchemas, schema) {\n    let count = 0;\n    for (const matchSchema of matchingSchemas) {\n        if (node === matchSchema.node && matchSchema.schema !== schema) {\n            schema.anyOf.forEach((childSchema) => {\n                if (matchSchema.schema.title === childSchema.title &&\n                    matchSchema.schema.description === childSchema.description &&\n                    matchSchema.schema.properties === childSchema.properties) {\n                    count++;\n                }\n            });\n        }\n    }\n    return count === schema.anyOf.length;\n}\n//# sourceMappingURL=yamlHover.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/yamlHover.js?")},8613:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.YamlLinks = void 0;\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst jsonLinks_1 = __webpack_require__(8833);\nconst yaml_documents_1 = __webpack_require__(4532);\nconst objects_1 = __webpack_require__(285);\nclass YamlLinks {\n    constructor(telemetry) {\n        this.telemetry = telemetry;\n    }\n    findLinks(document) {\n        try {\n            const doc = yaml_documents_1.yamlDocumentsCache.getYamlDocument(document);\n            // Find links across all YAML Documents then report them back once finished\n            const linkPromises = [];\n            for (const yamlDoc of doc.documents) {\n                linkPromises.push((0, jsonLinks_1.findLinks)(document, yamlDoc));\n            }\n            // Wait for all the promises to return and then flatten them into one DocumentLink array\n            return Promise.all(linkPromises).then((yamlLinkArray) => [].concat(...yamlLinkArray));\n        }\n        catch (err) {\n            this.telemetry?.sendError('yaml.documentLink.error', { error: (0, objects_1.convertErrorToTelemetryMsg)(err) });\n        }\n    }\n}\nexports.YamlLinks = YamlLinks;\n//# sourceMappingURL=yamlLinks.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/yamlLinks.js?")},9691:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.doDocumentOnTypeFormatting = void 0;\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst textBuffer_1 = __webpack_require__(90);\nfunction doDocumentOnTypeFormatting(document, params) {\n    const { position } = params;\n    const tb = new textBuffer_1.TextBuffer(document);\n    if (params.ch === '\\n') {\n        const previousLine = tb.getLineContent(position.line - 1);\n        if (previousLine.trimRight().endsWith(':')) {\n            const currentLine = tb.getLineContent(position.line);\n            const subLine = currentLine.substring(position.character, currentLine.length);\n            const isInArray = previousLine.indexOf(' - ') !== -1;\n            if (subLine.trimRight().length === 0) {\n                const indentationFix = position.character - (previousLine.length - previousLine.trimLeft().length);\n                if (indentationFix === params.options.tabSize && !isInArray) {\n                    return; // skip if line already has proper formatting\n                }\n                const result = [];\n                if (currentLine.length > 0) {\n                    result.push(vscode_languageserver_types_1.TextEdit.del(vscode_languageserver_types_1.Range.create(position, vscode_languageserver_types_1.Position.create(position.line, currentLine.length - 1))));\n                }\n                result.push(vscode_languageserver_types_1.TextEdit.insert(position, ' '.repeat(params.options.tabSize + (isInArray ? 2 - indentationFix : 0))));\n                return result;\n            }\n            if (isInArray) {\n                return [vscode_languageserver_types_1.TextEdit.insert(position, ' '.repeat(params.options.tabSize))];\n            }\n        }\n        if (previousLine.trimRight().endsWith('|')) {\n            return [vscode_languageserver_types_1.TextEdit.insert(position, ' '.repeat(params.options.tabSize))];\n        }\n        if (previousLine.includes(' - ') && !previousLine.includes(': ')) {\n            return [vscode_languageserver_types_1.TextEdit.insert(position, '- ')];\n        }\n        if (previousLine.includes(' - ') && previousLine.includes(': ')) {\n            return [vscode_languageserver_types_1.TextEdit.insert(position, '  ')];\n        }\n    }\n}\nexports.doDocumentOnTypeFormatting = doDocumentOnTypeFormatting;\n//# sourceMappingURL=yamlOnTypeFormatting.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/yamlOnTypeFormatting.js?")},7188:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.YAMLSchemaService = exports.FilePatternAssociation = exports.MODIFICATION_ACTIONS = void 0;\nconst yamlLanguageService_1 = __webpack_require__(9134);\nconst jsonSchemaService_1 = __webpack_require__(9967);\nconst vscode_uri_1 = __webpack_require__(5472);\nconst nls = __webpack_require__(731);\nconst strings_1 = __webpack_require__(4726);\nconst yaml_1 = __webpack_require__(6749);\nconst path = __webpack_require__(1017);\nconst modelineUtil_1 = __webpack_require__(3323);\nconst ajv_1 = __webpack_require__(4014);\nconst schemaUtils_1 = __webpack_require__(4411);\nconst localize = nls.loadMessageBundle();\nconst ajv = new ajv_1.default();\n// load JSON Schema 07 def to validate loaded schemas\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst jsonSchema07 = __webpack_require__(5570);\nconst schema07Validator = ajv.compile(jsonSchema07);\nvar MODIFICATION_ACTIONS;\n(function (MODIFICATION_ACTIONS) {\n    MODIFICATION_ACTIONS[MODIFICATION_ACTIONS[\"delete\"] = 0] = \"delete\";\n    MODIFICATION_ACTIONS[MODIFICATION_ACTIONS[\"add\"] = 1] = \"add\";\n    MODIFICATION_ACTIONS[MODIFICATION_ACTIONS[\"deleteAll\"] = 2] = \"deleteAll\";\n})(MODIFICATION_ACTIONS = exports.MODIFICATION_ACTIONS || (exports.MODIFICATION_ACTIONS = {}));\nclass FilePatternAssociation {\n    constructor(pattern) {\n        try {\n            this.patternRegExp = new RegExp((0, strings_1.convertSimple2RegExpPattern)(pattern) + '$');\n        }\n        catch (e) {\n            // invalid pattern\n            this.patternRegExp = null;\n        }\n        this.schemas = [];\n    }\n    addSchema(id) {\n        this.schemas.push(id);\n    }\n    matchesPattern(fileName) {\n        return this.patternRegExp && this.patternRegExp.test(fileName);\n    }\n    getSchemas() {\n        return this.schemas;\n    }\n}\nexports.FilePatternAssociation = FilePatternAssociation;\nclass YAMLSchemaService extends jsonSchemaService_1.JSONSchemaService {\n    constructor(requestService, contextService, promiseConstructor) {\n        super(requestService, contextService, promiseConstructor);\n        this.schemaUriToNameAndDescription = new Map();\n        this.customSchemaProvider = undefined;\n        this.requestService = requestService;\n        this.schemaPriorityMapping = new Map();\n    }\n    registerCustomSchemaProvider(customSchemaProvider) {\n        this.customSchemaProvider = customSchemaProvider;\n    }\n    getAllSchemas() {\n        const result = [];\n        const schemaUris = new Set();\n        for (const filePattern of this.filePatternAssociations) {\n            const schemaUri = filePattern.uris[0];\n            if (schemaUris.has(schemaUri)) {\n                continue;\n            }\n            schemaUris.add(schemaUri);\n            const schemaHandle = {\n                uri: schemaUri,\n                fromStore: false,\n                usedForCurrentFile: false,\n            };\n            if (this.schemaUriToNameAndDescription.has(schemaUri)) {\n                const { name, description, versions } = this.schemaUriToNameAndDescription.get(schemaUri);\n                schemaHandle.name = name;\n                schemaHandle.description = description;\n                schemaHandle.fromStore = true;\n                schemaHandle.versions = versions;\n            }\n            result.push(schemaHandle);\n        }\n        return result;\n    }\n    async resolveSchemaContent(schemaToResolve, schemaURL, dependencies) {\n        const resolveErrors = schemaToResolve.errors.slice(0);\n        let schema = schemaToResolve.schema;\n        const contextService = this.contextService;\n        if (!schema07Validator(schema)) {\n            const errs = [];\n            for (const err of schema07Validator.errors) {\n                errs.push(`${err.instancePath} : ${err.message}`);\n            }\n            resolveErrors.push(`Schema '${(0, schemaUtils_1.getSchemaTitle)(schemaToResolve.schema, schemaURL)}' is not valid:\\n${errs.join('\\n')}`);\n        }\n        const findSection = (schema, path) => {\n            if (!path) {\n                return schema;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            let current = schema;\n            if (path[0] === '/') {\n                path = path.substr(1);\n            }\n            path.split('/').some((part) => {\n                current = current[part];\n                return !current;\n            });\n            return current;\n        };\n        const merge = (target, sourceRoot, sourceURI, path) => {\n            const section = findSection(sourceRoot, path);\n            if (section) {\n                for (const key in section) {\n                    if (Object.prototype.hasOwnProperty.call(section, key) && !Object.prototype.hasOwnProperty.call(target, key)) {\n                        target[key] = section[key];\n                    }\n                }\n            }\n            else {\n                resolveErrors.push(localize('json.schema.invalidref', \"$ref '{0}' in '{1}' can not be resolved.\", path, sourceURI));\n            }\n        };\n        const resolveExternalLink = (node, uri, linkPath, parentSchemaURL, parentSchemaDependencies\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ) => {\n            if (contextService && !/^\\w+:\\/\\/.*/.test(uri)) {\n                uri = contextService.resolveRelativePath(uri, parentSchemaURL);\n            }\n            uri = this.normalizeId(uri);\n            const referencedHandle = this.getOrAddSchemaHandle(uri);\n            return referencedHandle.getUnresolvedSchema().then((unresolvedSchema) => {\n                parentSchemaDependencies[uri] = true;\n                if (unresolvedSchema.errors.length) {\n                    const loc = linkPath ? uri + '#' + linkPath : uri;\n                    resolveErrors.push(localize('json.schema.problemloadingref', \"Problems loading reference '{0}': {1}\", loc, unresolvedSchema.errors[0]));\n                }\n                merge(node, unresolvedSchema.schema, uri, linkPath);\n                node.url = uri;\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                return resolveRefs(node, unresolvedSchema.schema, uri, referencedHandle.dependencies);\n            });\n        };\n        const resolveRefs = async (node, parentSchema, parentSchemaURL, parentSchemaDependencies\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ) => {\n            if (!node || typeof node !== 'object') {\n                return null;\n            }\n            const toWalk = [node];\n            const seen = [];\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const openPromises = [];\n            const collectEntries = (...entries) => {\n                for (const entry of entries) {\n                    if (typeof entry === 'object') {\n                        toWalk.push(entry);\n                    }\n                }\n            };\n            const collectMapEntries = (...maps) => {\n                for (const map of maps) {\n                    if (typeof map === 'object') {\n                        for (const key in map) {\n                            const entry = map[key];\n                            if (typeof entry === 'object') {\n                                toWalk.push(entry);\n                            }\n                        }\n                    }\n                }\n            };\n            const collectArrayEntries = (...arrays) => {\n                for (const array of arrays) {\n                    if (Array.isArray(array)) {\n                        for (const entry of array) {\n                            if (typeof entry === 'object') {\n                                toWalk.push(entry);\n                            }\n                        }\n                    }\n                }\n            };\n            const handleRef = (next) => {\n                const seenRefs = [];\n                while (next.$ref) {\n                    const ref = next.$ref;\n                    const segments = ref.split('#', 2);\n                    //return back removed $ref. We lost info about referenced type without it.\n                    next._$ref = next.$ref;\n                    delete next.$ref;\n                    if (segments[0].length > 0) {\n                        openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies));\n                        return;\n                    }\n                    else {\n                        if (seenRefs.indexOf(ref) === -1) {\n                            merge(next, parentSchema, parentSchemaURL, segments[1]); // can set next.$ref again, use seenRefs to avoid circle\n                            seenRefs.push(ref);\n                        }\n                    }\n                }\n                collectEntries(next.items, next.additionalItems, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else);\n                collectMapEntries(next.definitions, next.properties, next.patternProperties, next.dependencies);\n                collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.items, next.schemaSequence);\n            };\n            if (parentSchemaURL.indexOf('#') > 0) {\n                const segments = parentSchemaURL.split('#', 2);\n                if (segments[0].length > 0 && segments[1].length > 0) {\n                    const newSchema = {};\n                    await resolveExternalLink(newSchema, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies);\n                    for (const key in schema) {\n                        if (key === 'required') {\n                            continue;\n                        }\n                        if (Object.prototype.hasOwnProperty.call(schema, key) && !Object.prototype.hasOwnProperty.call(newSchema, key)) {\n                            newSchema[key] = schema[key];\n                        }\n                    }\n                    schema = newSchema;\n                }\n            }\n            while (toWalk.length) {\n                const next = toWalk.pop();\n                if (seen.indexOf(next) >= 0) {\n                    continue;\n                }\n                seen.push(next);\n                handleRef(next);\n            }\n            return Promise.all(openPromises);\n        };\n        await resolveRefs(schema, schema, schemaURL, dependencies);\n        return new jsonSchemaService_1.ResolvedSchema(schema, resolveErrors);\n    }\n    getSchemaForResource(resource, doc) {\n        const resolveModelineSchema = () => {\n            let schemaFromModeline = (0, modelineUtil_1.getSchemaFromModeline)(doc);\n            if (schemaFromModeline !== undefined) {\n                if (!schemaFromModeline.startsWith('file:') && !schemaFromModeline.startsWith('http')) {\n                    // If path contains a fragment and it is left intact, \"#\" will be\n                    // considered part of the filename and converted to \"%23\" by\n                    // path.resolve() -> take it out and add back after path.resolve\n                    let appendix = '';\n                    if (schemaFromModeline.indexOf('#') > 0) {\n                        const segments = schemaFromModeline.split('#', 2);\n                        schemaFromModeline = segments[0];\n                        appendix = segments[1];\n                    }\n                    if (!path.isAbsolute(schemaFromModeline)) {\n                        const resUri = vscode_uri_1.URI.parse(resource);\n                        schemaFromModeline = vscode_uri_1.URI.file(path.resolve(path.parse(resUri.fsPath).dir, schemaFromModeline)).toString();\n                    }\n                    else {\n                        schemaFromModeline = vscode_uri_1.URI.file(schemaFromModeline).toString();\n                    }\n                    if (appendix.length > 0) {\n                        schemaFromModeline += '#' + appendix;\n                    }\n                }\n                return schemaFromModeline;\n            }\n        };\n        const resolveSchemaForResource = (schemas) => {\n            const schemaHandle = super.createCombinedSchema(resource, schemas);\n            return schemaHandle.getResolvedSchema().then((schema) => {\n                if (schema.schema && typeof schema.schema === 'object') {\n                    schema.schema.url = schemaHandle.url;\n                }\n                if (schema.schema &&\n                    schema.schema.schemaSequence &&\n                    schema.schema.schemaSequence[doc.currentDocIndex]) {\n                    return new jsonSchemaService_1.ResolvedSchema(schema.schema.schemaSequence[doc.currentDocIndex]);\n                }\n                return schema;\n            });\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const resolveSchema = () => {\n            const seen = Object.create(null);\n            const schemas = [];\n            for (const entry of this.filePatternAssociations) {\n                if (entry.matchesPattern(resource)) {\n                    for (const schemaId of entry.getURIs()) {\n                        if (!seen[schemaId]) {\n                            schemas.push(schemaId);\n                            seen[schemaId] = true;\n                        }\n                    }\n                }\n            }\n            if (schemas.length > 0) {\n                // Join all schemas with the highest priority.\n                const highestPrioSchemas = this.highestPrioritySchemas(schemas);\n                return resolveSchemaForResource(highestPrioSchemas);\n            }\n            return Promise.resolve(null);\n        };\n        const modelineSchema = resolveModelineSchema();\n        if (modelineSchema) {\n            return resolveSchemaForResource([modelineSchema]);\n        }\n        if (this.customSchemaProvider) {\n            return this.customSchemaProvider(resource)\n                .then((schemaUri) => {\n                if (Array.isArray(schemaUri)) {\n                    if (schemaUri.length === 0) {\n                        return resolveSchema();\n                    }\n                    return Promise.all(schemaUri.map((schemaUri) => {\n                        return this.resolveCustomSchema(schemaUri, doc);\n                    })).then((schemas) => {\n                        return {\n                            errors: [],\n                            schema: {\n                                allOf: schemas.map((schemaObj) => {\n                                    return schemaObj.schema;\n                                }),\n                            },\n                        };\n                    }, () => {\n                        return resolveSchema();\n                    });\n                }\n                if (!schemaUri) {\n                    return resolveSchema();\n                }\n                return this.resolveCustomSchema(schemaUri, doc);\n            })\n                .then((schema) => {\n                return schema;\n            }, () => {\n                return resolveSchema();\n            });\n        }\n        else {\n            return resolveSchema();\n        }\n    }\n    // Set the priority of a schema in the schema service\n    addSchemaPriority(uri, priority) {\n        let currSchemaArray = this.schemaPriorityMapping.get(uri);\n        if (currSchemaArray) {\n            currSchemaArray = currSchemaArray.add(priority);\n            this.schemaPriorityMapping.set(uri, currSchemaArray);\n        }\n        else {\n            this.schemaPriorityMapping.set(uri, new Set().add(priority));\n        }\n    }\n    /**\n     * Search through all the schemas and find the ones with the highest priority\n     */\n    highestPrioritySchemas(schemas) {\n        let highestPrio = 0;\n        const priorityMapping = new Map();\n        schemas.forEach((schema) => {\n            // If the schema does not have a priority then give it a default one of [0]\n            const priority = this.schemaPriorityMapping.get(schema) || [0];\n            priority.forEach((prio) => {\n                if (prio > highestPrio) {\n                    highestPrio = prio;\n                }\n                // Build up a mapping of priority to schemas so that we can easily get the highest priority schemas easier\n                let currPriorityArray = priorityMapping.get(prio);\n                if (currPriorityArray) {\n                    currPriorityArray = currPriorityArray.concat(schema);\n                    priorityMapping.set(prio, currPriorityArray);\n                }\n                else {\n                    priorityMapping.set(prio, [schema]);\n                }\n            });\n        });\n        return priorityMapping.get(highestPrio) || [];\n    }\n    async resolveCustomSchema(schemaUri, doc) {\n        const unresolvedSchema = await this.loadSchema(schemaUri);\n        const schema = await this.resolveSchemaContent(unresolvedSchema, schemaUri, []);\n        if (schema.schema && typeof schema.schema === 'object') {\n            schema.schema.url = schemaUri;\n        }\n        if (schema.schema && schema.schema.schemaSequence && schema.schema.schemaSequence[doc.currentDocIndex]) {\n            return new jsonSchemaService_1.ResolvedSchema(schema.schema.schemaSequence[doc.currentDocIndex], schema.errors);\n        }\n        return schema;\n    }\n    /**\n     * Save a schema with schema ID and schema content.\n     * Overrides previous schemas set for that schema ID.\n     */\n    async saveSchema(schemaId, schemaContent) {\n        const id = this.normalizeId(schemaId);\n        this.getOrAddSchemaHandle(id, schemaContent);\n        this.schemaPriorityMapping.set(id, new Set().add(yamlLanguageService_1.SchemaPriority.Settings));\n        return Promise.resolve(undefined);\n    }\n    /**\n     * Delete schemas on specific path\n     */\n    async deleteSchemas(deletions) {\n        deletions.schemas.forEach((s) => {\n            this.deleteSchema(s);\n        });\n        return Promise.resolve(undefined);\n    }\n    /**\n     * Delete a schema with schema ID.\n     */\n    async deleteSchema(schemaId) {\n        const id = this.normalizeId(schemaId);\n        if (this.schemasById[id]) {\n            delete this.schemasById[id];\n        }\n        this.schemaPriorityMapping.delete(id);\n        return Promise.resolve(undefined);\n    }\n    /**\n     * Add content to a specified schema at a specified path\n     */\n    async addContent(additions) {\n        const schema = await this.getResolvedSchema(additions.schema);\n        if (schema) {\n            const resolvedSchemaLocation = this.resolveJSONSchemaToSection(schema.schema, additions.path);\n            if (typeof resolvedSchemaLocation === 'object') {\n                resolvedSchemaLocation[additions.key] = additions.content;\n            }\n            await this.saveSchema(additions.schema, schema.schema);\n        }\n    }\n    /**\n     * Delete content in a specified schema at a specified path\n     */\n    async deleteContent(deletions) {\n        const schema = await this.getResolvedSchema(deletions.schema);\n        if (schema) {\n            const resolvedSchemaLocation = this.resolveJSONSchemaToSection(schema.schema, deletions.path);\n            if (typeof resolvedSchemaLocation === 'object') {\n                delete resolvedSchemaLocation[deletions.key];\n            }\n            await this.saveSchema(deletions.schema, schema.schema);\n        }\n    }\n    /**\n     * Take a JSON Schema and the path that you would like to get to\n     * @returns the JSON Schema resolved at that specific path\n     */\n    resolveJSONSchemaToSection(schema, paths) {\n        const splitPathway = paths.split('/');\n        let resolvedSchemaLocation = schema;\n        for (const path of splitPathway) {\n            if (path === '') {\n                continue;\n            }\n            this.resolveNext(resolvedSchemaLocation, path);\n            resolvedSchemaLocation = resolvedSchemaLocation[path];\n        }\n        return resolvedSchemaLocation;\n    }\n    /**\n     * Resolve the next Object if they have compatible types\n     * @param object a location in the JSON Schema\n     * @param token the next token that you want to search for\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    resolveNext(object, token) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (Array.isArray(object) && isNaN(token)) {\n            throw new Error('Expected a number after the array object');\n        }\n        else if (typeof object === 'object' && typeof token !== 'string') {\n            throw new Error('Expected a string after the object');\n        }\n    }\n    /**\n     * Everything below here is needed because we're importing from vscode-json-languageservice umd and we need\n     * to provide a wrapper around the javascript methods we are calling since they have no type\n     */\n    normalizeId(id) {\n        // The parent's `super.normalizeId(id)` isn't visible, so duplicated the code here\n        try {\n            return vscode_uri_1.URI.parse(id).toString();\n        }\n        catch (e) {\n            return id;\n        }\n    }\n    /*\n     * Everything below here is needed because we're importing from vscode-json-languageservice umd and we need\n     * to provide a wrapper around the javascript methods we are calling since they have no type\n     */\n    getOrAddSchemaHandle(id, unresolvedSchemaContent) {\n        return super.getOrAddSchemaHandle(id, unresolvedSchemaContent);\n    }\n    loadSchema(schemaUri) {\n        const requestService = this.requestService;\n        return super.loadSchema(schemaUri).then((unresolvedJsonSchema) => {\n            // If json-language-server failed to parse the schema, attempt to parse it as YAML instead.\n            if (unresolvedJsonSchema.errors && unresolvedJsonSchema.schema === undefined) {\n                return requestService(schemaUri).then((content) => {\n                    if (!content) {\n                        const errorMessage = localize('json.schema.nocontent', \"Unable to load schema from '{0}': No content. {1}\", toDisplayString(schemaUri), unresolvedJsonSchema.errors);\n                        return new jsonSchemaService_1.UnresolvedSchema({}, [errorMessage]);\n                    }\n                    try {\n                        const schemaContent = (0, yaml_1.parse)(content);\n                        return new jsonSchemaService_1.UnresolvedSchema(schemaContent, []);\n                    }\n                    catch (yamlError) {\n                        const errorMessage = localize('json.schema.invalidFormat', \"Unable to parse content from '{0}': {1}.\", toDisplayString(schemaUri), yamlError);\n                        return new jsonSchemaService_1.UnresolvedSchema({}, [errorMessage]);\n                    }\n                }, \n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (error) => {\n                    let errorMessage = error.toString();\n                    const errorSplit = error.toString().split('Error: ');\n                    if (errorSplit.length > 1) {\n                        // more concise error message, URL and context are attached by caller anyways\n                        errorMessage = errorSplit[1];\n                    }\n                    return new jsonSchemaService_1.UnresolvedSchema({}, [errorMessage]);\n                });\n            }\n            unresolvedJsonSchema.uri = schemaUri;\n            if (this.schemaUriToNameAndDescription.has(schemaUri)) {\n                const { name, description, versions } = this.schemaUriToNameAndDescription.get(schemaUri);\n                unresolvedJsonSchema.schema.title = name ?? unresolvedJsonSchema.schema.title;\n                unresolvedJsonSchema.schema.description = description ?? unresolvedJsonSchema.schema.description;\n                unresolvedJsonSchema.schema.versions = versions ?? unresolvedJsonSchema.schema.versions;\n            }\n            return unresolvedJsonSchema;\n        });\n    }\n    registerExternalSchema(uri, filePatterns, unresolvedSchema, name, description, versions) {\n        if (name || description) {\n            this.schemaUriToNameAndDescription.set(uri, { name, description, versions });\n        }\n        return super.registerExternalSchema(uri, filePatterns, unresolvedSchema);\n    }\n    clearExternalSchemas() {\n        super.clearExternalSchemas();\n    }\n    setSchemaContributions(schemaContributions) {\n        super.setSchemaContributions(schemaContributions);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getRegisteredSchemaIds(filter) {\n        return super.getRegisteredSchemaIds(filter);\n    }\n    getResolvedSchema(schemaId) {\n        return super.getResolvedSchema(schemaId);\n    }\n    onResourceChange(uri) {\n        return super.onResourceChange(uri);\n    }\n}\nexports.YAMLSchemaService = YAMLSchemaService;\nfunction toDisplayString(url) {\n    try {\n        const uri = vscode_uri_1.URI.parse(url);\n        if (uri.scheme === 'file') {\n            return uri.fsPath;\n        }\n    }\n    catch (e) {\n        // ignore\n    }\n    return url;\n}\n//# sourceMappingURL=yamlSchemaService.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/yamlSchemaService.js?")},2725:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSelectionRanges = void 0;\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst yaml_documents_1 = __webpack_require__(4532);\nfunction getSelectionRanges(document, positions) {\n    if (!document) {\n        return;\n    }\n    const doc = yaml_documents_1.yamlDocumentsCache.getYamlDocument(document);\n    return positions.map((position) => {\n        const ranges = getRanges(position);\n        let current;\n        for (const range of ranges) {\n            current = vscode_languageserver_types_1.SelectionRange.create(range, current);\n        }\n        if (!current) {\n            current = vscode_languageserver_types_1.SelectionRange.create({\n                start: position,\n                end: position,\n            });\n        }\n        return current;\n    });\n    function getRanges(position) {\n        const offset = document.offsetAt(position);\n        const result = [];\n        for (const ymlDoc of doc.documents) {\n            let currentNode;\n            let firstNodeOffset;\n            let isFirstNode = true;\n            ymlDoc.visit((node) => {\n                const endOffset = node.offset + node.length;\n                // Skip if end offset doesn't even reach cursor position\n                if (endOffset < offset) {\n                    return true;\n                }\n                let startOffset = node.offset;\n                // Recheck start offset with the trimmed one in case of this\n                // key:\n                //   - value\n                // \n                if (startOffset > offset) {\n                    const nodePosition = document.positionAt(startOffset);\n                    if (nodePosition.line !== position.line) {\n                        return true;\n                    }\n                    const lineBeginning = { line: nodePosition.line, character: 0 };\n                    const text = document.getText({\n                        start: lineBeginning,\n                        end: nodePosition,\n                    });\n                    if (text.trim().length !== 0) {\n                        return true;\n                    }\n                    startOffset = document.offsetAt(lineBeginning);\n                    if (startOffset > offset) {\n                        return true;\n                    }\n                }\n                // Allow equal for children to override\n                if (!currentNode || startOffset >= currentNode.offset) {\n                    currentNode = node;\n                    firstNodeOffset = startOffset;\n                }\n                return true;\n            });\n            while (currentNode) {\n                const startOffset = isFirstNode ? firstNodeOffset : currentNode.offset;\n                const endOffset = currentNode.offset + currentNode.length;\n                const range = {\n                    start: document.positionAt(startOffset),\n                    end: document.positionAt(endOffset),\n                };\n                const text = document.getText(range);\n                const trimmedText = text.trimEnd();\n                const trimmedLength = text.length - trimmedText.length;\n                if (trimmedLength > 0) {\n                    range.end = document.positionAt(endOffset - trimmedLength);\n                }\n                // Add a jump between '' \"\" {} []\n                const isSurroundedBy = (startCharacter, endCharacter) => {\n                    return trimmedText.startsWith(startCharacter) && trimmedText.endsWith(endCharacter || startCharacter);\n                };\n                if ((currentNode.type === 'string' && (isSurroundedBy(\"'\") || isSurroundedBy('\"'))) ||\n                    (currentNode.type === 'object' && isSurroundedBy('{', '}')) ||\n                    (currentNode.type === 'array' && isSurroundedBy('[', ']'))) {\n                    result.push({\n                        start: document.positionAt(startOffset + 1),\n                        end: document.positionAt(endOffset - 1),\n                    });\n                }\n                result.push(range);\n                currentNode = currentNode.parent;\n                isFirstNode = false;\n            }\n            // A position can't be in multiple documents\n            if (result.length > 0) {\n                break;\n            }\n        }\n        return result.reverse();\n    }\n}\nexports.getSelectionRanges = getSelectionRanges;\n//# sourceMappingURL=yamlSelectionRanges.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/yamlSelectionRanges.js?")},4882:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.YAMLValidation = exports.yamlDiagToLSDiag = void 0;\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nconst jsonValidation_1 = __webpack_require__(2636);\nconst jsonParser07_1 = __webpack_require__(1406);\nconst textBuffer_1 = __webpack_require__(90);\nconst yaml_documents_1 = __webpack_require__(4532);\nconst objects_1 = __webpack_require__(285);\nconst unused_anchors_1 = __webpack_require__(7318);\nconst yaml_style_1 = __webpack_require__(9029);\nconst map_key_order_1 = __webpack_require__(6725);\n/**\n * Convert a YAMLDocDiagnostic to a language server Diagnostic\n * @param yamlDiag A YAMLDocDiagnostic from the parser\n * @param textDocument TextDocument from the language server client\n */\nconst yamlDiagToLSDiag = (yamlDiag, textDocument) => {\n    const start = textDocument.positionAt(yamlDiag.location.start);\n    const range = {\n        start,\n        end: yamlDiag.location.toLineEnd\n            ? vscode_languageserver_types_1.Position.create(start.line, new textBuffer_1.TextBuffer(textDocument).getLineLength(start.line))\n            : textDocument.positionAt(yamlDiag.location.end),\n    };\n    return vscode_languageserver_types_1.Diagnostic.create(range, yamlDiag.message, yamlDiag.severity, yamlDiag.code, jsonParser07_1.YAML_SOURCE);\n};\nexports.yamlDiagToLSDiag = yamlDiagToLSDiag;\nclass YAMLValidation {\n    constructor(schemaService, telemetry) {\n        this.telemetry = telemetry;\n        this.validators = [];\n        this.MATCHES_MULTIPLE = 'Matches multiple schemas when only one must validate.';\n        this.validationEnabled = true;\n        this.jsonValidation = new jsonValidation_1.JSONValidation(schemaService, Promise);\n    }\n    configure(settings) {\n        this.validators = [];\n        if (settings) {\n            this.validationEnabled = settings.validate;\n            this.customTags = settings.customTags;\n            this.disableAdditionalProperties = settings.disableAdditionalProperties;\n            this.yamlVersion = settings.yamlVersion;\n            // Add style validator if flow style is set to forbid only.\n            if (settings.flowMapping === 'forbid' || settings.flowSequence === 'forbid') {\n                this.validators.push(new yaml_style_1.YAMLStyleValidator(settings));\n            }\n            if (settings.keyOrdering) {\n                this.validators.push(new map_key_order_1.MapKeyOrderValidator());\n            }\n        }\n        this.validators.push(new unused_anchors_1.UnusedAnchorsValidator());\n    }\n    async doValidation(textDocument, isKubernetes = false) {\n        if (!this.validationEnabled) {\n            return Promise.resolve([]);\n        }\n        const validationResult = [];\n        try {\n            const yamlDocument = yaml_documents_1.yamlDocumentsCache.getYamlDocument(textDocument, { customTags: this.customTags, yamlVersion: this.yamlVersion }, true);\n            let index = 0;\n            for (const currentYAMLDoc of yamlDocument.documents) {\n                currentYAMLDoc.isKubernetes = isKubernetes;\n                currentYAMLDoc.currentDocIndex = index;\n                currentYAMLDoc.disableAdditionalProperties = this.disableAdditionalProperties;\n                currentYAMLDoc.uri = textDocument.uri;\n                const validation = await this.jsonValidation.doValidation(textDocument, currentYAMLDoc);\n                const syd = currentYAMLDoc;\n                if (syd.errors.length > 0) {\n                    // TODO: Get rid of these type assertions (shouldn't need them)\n                    validationResult.push(...syd.errors);\n                }\n                if (syd.warnings.length > 0) {\n                    validationResult.push(...syd.warnings);\n                }\n                validationResult.push(...validation);\n                validationResult.push(...this.runAdditionalValidators(textDocument, currentYAMLDoc));\n                index++;\n            }\n        }\n        catch (err) {\n            this.telemetry?.sendError('yaml.validation.error', { error: (0, objects_1.convertErrorToTelemetryMsg)(err) });\n        }\n        let previousErr;\n        const foundSignatures = new Set();\n        const duplicateMessagesRemoved = [];\n        for (let err of validationResult) {\n            /**\n             * A patch ontop of the validation that removes the\n             * 'Matches many schemas' error for kubernetes\n             * for a better user experience.\n             */\n            if (isKubernetes && err.message === this.MATCHES_MULTIPLE) {\n                continue;\n            }\n            if (Object.prototype.hasOwnProperty.call(err, 'location')) {\n                err = (0, exports.yamlDiagToLSDiag)(err, textDocument);\n            }\n            if (!err.source) {\n                err.source = jsonParser07_1.YAML_SOURCE;\n            }\n            if (previousErr &&\n                previousErr.message === err.message &&\n                previousErr.range.end.line === err.range.start.line &&\n                Math.abs(previousErr.range.end.character - err.range.end.character) >= 1) {\n                previousErr.range.end = err.range.end;\n                continue;\n            }\n            else {\n                previousErr = err;\n            }\n            const errSig = err.range.start.line + ' ' + err.range.start.character + ' ' + err.message;\n            if (!foundSignatures.has(errSig)) {\n                duplicateMessagesRemoved.push(err);\n                foundSignatures.add(errSig);\n            }\n        }\n        return duplicateMessagesRemoved;\n    }\n    runAdditionalValidators(document, yarnDoc) {\n        const result = [];\n        for (const validator of this.validators) {\n            result.push(...validator.validate(document, yarnDoc));\n        }\n        return result;\n    }\n}\nexports.YAMLValidation = YAMLValidation;\n//# sourceMappingURL=yamlValidation.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/services/yamlValidation.js?")},8209:(__unused_webpack_module,exports)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isArrayEqual = exports.filterInvalidCustomTags = exports.matchOffsetToDocument = exports.removeDuplicatesObj = exports.getLineOffsets = void 0;\nfunction getLineOffsets(textDocString) {\n    const lineOffsets = [];\n    const text = textDocString;\n    let isLineStart = true;\n    for (let i = 0; i < text.length; i++) {\n        if (isLineStart) {\n            lineOffsets.push(i);\n            isLineStart = false;\n        }\n        const ch = text.charAt(i);\n        isLineStart = ch === '\\r' || ch === '\\n';\n        if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n            i++;\n        }\n    }\n    if (isLineStart && text.length > 0) {\n        lineOffsets.push(text.length);\n    }\n    return lineOffsets;\n}\nexports.getLineOffsets = getLineOffsets;\nfunction removeDuplicatesObj(objArray) {\n    const nonDuplicateSet = new Set();\n    const nonDuplicateArr = [];\n    for (const obj in objArray) {\n        const currObj = objArray[obj];\n        const stringifiedObj = JSON.stringify(currObj);\n        if (!nonDuplicateSet.has(stringifiedObj)) {\n            nonDuplicateArr.push(currObj);\n            nonDuplicateSet.add(stringifiedObj);\n        }\n    }\n    return nonDuplicateArr;\n}\nexports.removeDuplicatesObj = removeDuplicatesObj;\nfunction matchOffsetToDocument(offset, jsonDocuments) {\n    for (const jsonDoc of jsonDocuments.documents) {\n        if (jsonDoc.internalDocument && jsonDoc.internalDocument.range[0] <= offset && jsonDoc.internalDocument.range[2] >= offset) {\n            return jsonDoc;\n        }\n    }\n    if (jsonDocuments.documents.length === 1) {\n        return jsonDocuments.documents[0];\n    }\n    return null;\n}\nexports.matchOffsetToDocument = matchOffsetToDocument;\nfunction filterInvalidCustomTags(customTags) {\n    const validCustomTags = ['mapping', 'scalar', 'sequence'];\n    if (!customTags) {\n        return [];\n    }\n    return customTags.filter((tag) => {\n        if (typeof tag === 'string') {\n            const typeInfo = tag.split(' ');\n            const type = (typeInfo[1] && typeInfo[1].toLowerCase()) || 'scalar';\n            // We need to check if map is a type because map will throw an error within the yaml-ast-parser\n            if (type === 'map') {\n                return false;\n            }\n            return validCustomTags.indexOf(type) !== -1;\n        }\n        return false;\n    });\n}\nexports.filterInvalidCustomTags = filterInvalidCustomTags;\nfunction isArrayEqual(fst, snd) {\n    if (!snd || !fst) {\n        return false;\n    }\n    if (snd.length !== fst.length) {\n        return false;\n    }\n    for (let index = fst.length - 1; index >= 0; index--) {\n        if (fst[index] !== snd[index]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isArrayEqual = isArrayEqual;\n//# sourceMappingURL=arrUtils.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/utils/arrUtils.js?")},3713:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isCollectionItem = exports.isInComment = exports.indexOf = exports.isMapContainsEmptyPair = exports.getParent = void 0;\nconst yaml_1 = __webpack_require__(6749);\nfunction getParent(doc, nodeToFind) {\n    let parentNode;\n    (0, yaml_1.visit)(doc, (_, node, path) => {\n        if (node === nodeToFind) {\n            parentNode = path[path.length - 1];\n            return yaml_1.visit.BREAK;\n        }\n    });\n    if ((0, yaml_1.isDocument)(parentNode)) {\n        return undefined;\n    }\n    return parentNode;\n}\nexports.getParent = getParent;\nfunction isMapContainsEmptyPair(map) {\n    if (map.items.length > 1) {\n        return false;\n    }\n    const pair = map.items[0];\n    return (0, yaml_1.isScalar)(pair.key) && (0, yaml_1.isScalar)(pair.value) && pair.key.value === '' && !pair.value.value;\n}\nexports.isMapContainsEmptyPair = isMapContainsEmptyPair;\nfunction indexOf(seq, item) {\n    for (const [i, obj] of seq.items.entries()) {\n        if (item === obj) {\n            return i;\n        }\n    }\n    return undefined;\n}\nexports.indexOf = indexOf;\n/**\n * Check that given offset is in YAML comment\n * @param doc the yaml document\n * @param offset the offset to check\n */\nfunction isInComment(tokens, offset) {\n    let inComment = false;\n    for (const token of tokens) {\n        if (token.type === 'document') {\n            _visit([], token, (item) => {\n                if (isCollectionItem(item) && item.value?.type === 'comment') {\n                    if (token.offset <= offset && item.value.source.length + item.value.offset >= offset) {\n                        inComment = true;\n                        return yaml_1.visit.BREAK;\n                    }\n                }\n                else if (item.type === 'comment' && item.offset <= offset && item.offset + item.source.length >= offset) {\n                    inComment = true;\n                    return yaml_1.visit.BREAK;\n                }\n            });\n        }\n        else if (token.type === 'comment') {\n            if (token.offset <= offset && token.source.length + token.offset >= offset) {\n                return true;\n            }\n        }\n        if (inComment) {\n            break;\n        }\n    }\n    return inComment;\n}\nexports.isInComment = isInComment;\nfunction isCollectionItem(token) {\n    return token['start'] !== undefined;\n}\nexports.isCollectionItem = isCollectionItem;\nfunction _visit(path, item, visitor) {\n    let ctrl = visitor(item, path);\n    if (typeof ctrl === 'symbol')\n        return ctrl;\n    for (const field of ['key', 'value']) {\n        const token = item[field];\n        if (token && 'items' in token) {\n            for (let i = 0; i < token.items.length; ++i) {\n                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === yaml_1.visit.BREAK)\n                    return yaml_1.visit.BREAK;\n                else if (ci === yaml_1.visit.REMOVE) {\n                    token.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n            if (typeof ctrl === 'function' && field === 'key')\n                ctrl = ctrl(item, path);\n        }\n    }\n    const token = item['sep'];\n    if (token) {\n        for (let i = 0; i < token.length; ++i) {\n            const ci = _visit(Object.freeze(path), token[i], visitor);\n            if (typeof ci === 'number')\n                i = ci - 1;\n            else if (ci === yaml_1.visit.BREAK)\n                return yaml_1.visit.BREAK;\n            else if (ci === yaml_1.visit.REMOVE) {\n                token.items.splice(i, 1);\n                i -= 1;\n            }\n        }\n    }\n    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;\n}\n//# sourceMappingURL=astUtils.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/utils/astUtils.js?")},1508:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FlowStyleRewriter = void 0;\nconst yaml_1 = __webpack_require__(6749);\nclass FlowStyleRewriter {\n    constructor(indentation) {\n        this.indentation = indentation;\n    }\n    write(node) {\n        if (node.internalNode.srcToken['type'] !== 'flow-collection') {\n            return null;\n        }\n        const collection = node.internalNode.srcToken;\n        const blockType = collection.start.type === 'flow-map-start' ? 'block-map' : 'block-seq';\n        const parentType = node.parent.type;\n        const blockStyle = {\n            type: blockType,\n            offset: collection.offset,\n            indent: collection.indent,\n            items: [],\n        };\n        for (const item of collection.items) {\n            yaml_1.CST.visit(item, ({ key, sep, value }) => {\n                if (blockType === 'block-map') {\n                    const start = [{ type: 'space', indent: 0, offset: key.offset, source: this.indentation }];\n                    if (parentType === 'property') {\n                        // add a new line if part of a map\n                        start.unshift({ type: 'newline', indent: 0, offset: key.offset, source: '\\n' });\n                    }\n                    blockStyle.items.push({\n                        start: start,\n                        key: key,\n                        sep: sep,\n                        value: value,\n                    });\n                }\n                else if (blockType === 'block-seq') {\n                    blockStyle.items.push({\n                        start: [\n                            { type: 'newline', indent: 0, offset: value.offset, source: '\\n' },\n                            { type: 'space', indent: 0, offset: value.offset, source: this.indentation },\n                            { type: 'seq-item-ind', indent: 0, offset: value.offset, source: '-' },\n                            { type: 'space', indent: 0, offset: value.offset, source: ' ' },\n                        ],\n                        value: value,\n                    });\n                }\n                if (value.type === 'flow-collection') {\n                    return yaml_1.visit.SKIP;\n                }\n            });\n        }\n        return yaml_1.CST.stringify(blockStyle);\n    }\n}\nexports.FlowStyleRewriter = FlowStyleRewriter;\n//# sourceMappingURL=flow-style-rewriter.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/utils/flow-style-rewriter.js?")},2866:(__unused_webpack_module,exports)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.guessIndentation = void 0;\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n    }\n}\nfunction guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = currentLineLength <= 65536;\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j);\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = linesIndentedWithTabsCount < linesIndentedWithSpacesCount;\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = insertSpaces ? 0 : 0.1 * linesCount;\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize,\n    };\n}\nexports.guessIndentation = guessIndentation;\n//# sourceMappingURL=indentationGuesser.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/utils/indentationGuesser.js?")},6455:(__unused_webpack_module,exports)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringifyObject = void 0;\nfunction stringifyObject(obj, indent, stringifyLiteral, settings, depth = 0, consecutiveArrays = 0) {\n    if (obj !== null && typeof obj === 'object') {\n        /**\n         * When we are autocompleting a snippet from a property we need the indent so everything underneath the property\n         * is properly indented. When we are auto completion from a value we don't want the indent because the cursor\n         * is already in the correct place\n         */\n        const newIndent = (depth === 0 && settings.shouldIndentWithTab) || depth > 0 ? indent + settings.indentation : '';\n        if (Array.isArray(obj)) {\n            consecutiveArrays += 1;\n            if (obj.length === 0) {\n                return '';\n            }\n            let result = '';\n            for (let i = 0; i < obj.length; i++) {\n                let pseudoObj = obj[i];\n                if (typeof obj[i] !== 'object') {\n                    result += '\\n' + newIndent + '- ' + stringifyLiteral(obj[i]);\n                    continue;\n                }\n                if (!Array.isArray(obj[i])) {\n                    pseudoObj = prependToObject(obj[i], consecutiveArrays);\n                }\n                result += stringifyObject(pseudoObj, indent, stringifyLiteral, settings, (depth += 1), consecutiveArrays);\n            }\n            return result;\n        }\n        else {\n            const keys = Object.keys(obj);\n            if (keys.length === 0) {\n                return '';\n            }\n            let result = (depth === 0 && settings.newLineFirst) || depth > 0 ? '\\n' : '';\n            let isFirstProp = true;\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                if (depth === 0 && settings.existingProps.includes(key)) {\n                    // Don't add existing properties to the YAML\n                    continue;\n                }\n                const isObject = typeof obj[key] === 'object';\n                const colonDelimiter = isObject ? ':' : ': '; // add space only when value is primitive\n                const parentArrayCompensation = isObject && /^\\s|-/.test(key) ? settings.indentation : ''; // add extra space if parent is an array\n                const objectIndent = newIndent + parentArrayCompensation;\n                const lineBreak = isFirstProp ? '' : '\\n'; // break line only if it's not the first property\n                // The first child of an array needs to be treated specially, otherwise indentations will be off\n                if (depth === 0 && isFirstProp && !settings.indentFirstObject) {\n                    const value = stringifyObject(obj[key], objectIndent, stringifyLiteral, settings, depth + 1, 0);\n                    result += lineBreak + indent + key + colonDelimiter + value;\n                }\n                else {\n                    const value = stringifyObject(obj[key], objectIndent, stringifyLiteral, settings, depth + 1, 0);\n                    result += lineBreak + newIndent + key + colonDelimiter + value;\n                }\n                isFirstProp = false;\n            }\n            return result;\n        }\n    }\n    return stringifyLiteral(obj);\n}\nexports.stringifyObject = stringifyObject;\nfunction prependToObject(obj, consecutiveArrays) {\n    const newObj = {};\n    for (let i = 0; i < Object.keys(obj).length; i++) {\n        const key = Object.keys(obj)[i];\n        if (i === 0) {\n            newObj['- '.repeat(consecutiveArrays) + key] = obj[key];\n        }\n        else {\n            newObj['  '.repeat(consecutiveArrays) + key] = obj[key];\n        }\n    }\n    return newObj;\n}\n//# sourceMappingURL=json.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/utils/json.js?")},285:(__unused_webpack_module,exports)=>{"use strict";eval("/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertErrorToTelemetryMsg = exports.isIterable = exports.isString = exports.isBoolean = exports.isDefined = exports.isNumber = exports.equals = void 0;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nfunction equals(one, other) {\n    if (one === other) {\n        return true;\n    }\n    if (one === null || one === undefined || other === null || other === undefined) {\n        return false;\n    }\n    if (typeof one !== typeof other) {\n        return false;\n    }\n    if (typeof one !== 'object') {\n        return false;\n    }\n    if (Array.isArray(one) !== Array.isArray(other)) {\n        return false;\n    }\n    let i, key;\n    if (Array.isArray(one)) {\n        if (one.length !== other.length) {\n            return false;\n        }\n        for (i = 0; i < one.length; i++) {\n            if (!equals(one[i], other[i])) {\n                return false;\n            }\n        }\n    }\n    else {\n        const oneKeys = [];\n        for (key in one) {\n            oneKeys.push(key);\n        }\n        oneKeys.sort();\n        const otherKeys = [];\n        for (key in other) {\n            otherKeys.push(key);\n        }\n        otherKeys.sort();\n        if (!equals(oneKeys, otherKeys)) {\n            return false;\n        }\n        for (i = 0; i < oneKeys.length; i++) {\n            if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexports.equals = equals;\nfunction isNumber(val) {\n    return typeof val === 'number';\n}\nexports.isNumber = isNumber;\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isDefined(val) {\n    return typeof val !== 'undefined';\n}\nexports.isDefined = isDefined;\nfunction isBoolean(val) {\n    return typeof val === 'boolean';\n}\nexports.isBoolean = isBoolean;\nfunction isString(val) {\n    return typeof val === 'string';\n}\nexports.isString = isString;\n/**\n * Check that provided value is Iterable\n * @param val the value to check\n * @returns true if val is iterable, false otherwise\n */\nfunction isIterable(val) {\n    return Symbol.iterator in Object(val);\n}\nexports.isIterable = isIterable;\n/**\n * Convert error to string witch should be sended to telemetry.\n * @param err any error\n */\nfunction convertErrorToTelemetryMsg(err) {\n    if (!err)\n        return 'null';\n    if (err instanceof Error) {\n        return err.stack ?? err.toString();\n    }\n    return err.toString();\n}\nexports.convertErrorToTelemetryMsg = convertErrorToTelemetryMsg;\n//# sourceMappingURL=objects.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/utils/objects.js?")},6614:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.workspaceFoldersChanged = exports.relativeToAbsolutePath = exports.isRelativePath = void 0;\nconst path_1 = __webpack_require__(1017);\nconst vscode_uri_1 = __webpack_require__(5472);\nconst isRelativePath = (path) => {\n    const relativePathRegex = /^(((\\.\\.?)|([\\w-@. ]+))(\\/|\\\\\\\\?))*[\\w-. ]*\\.[\\w-]+$/i;\n    return relativePathRegex.test(path);\n};\nexports.isRelativePath = isRelativePath;\nconst relativeToAbsolutePath = (workspaceFolders, workspaceRoot, uri) => {\n    // Iterate through all of the workspace root folders\n    for (const folder of workspaceFolders) {\n        // If the requested schema URI specifies a workspace root folder\n        // Convert it into an absolute path with the appropriate root folder path\n        if (uri.startsWith(folder.name)) {\n            const pathToFolder = vscode_uri_1.URI.parse(folder.uri).fsPath;\n            const withoutFolderPrefix = uri.split(path_1.sep);\n            withoutFolderPrefix.shift();\n            return vscode_uri_1.URI.file((0, path_1.join)(pathToFolder, withoutFolderPrefix.join())).toString();\n        }\n    }\n    // If a root folder was not specified, resolve the relative URI\n    // Against the location of the workspace file instead\n    if (workspaceRoot) {\n        return vscode_uri_1.URI.file((0, path_1.join)(workspaceRoot.fsPath, uri)).toString();\n    }\n    // Fallback in case nothing could be applied\n    return (0, path_1.normalize)(uri);\n};\nexports.relativeToAbsolutePath = relativeToAbsolutePath;\nconst workspaceFoldersChanged = (workspaceFolders, changedFolders) => {\n    workspaceFolders = workspaceFolders.filter((e) => {\n        return !changedFolders.removed.some((f) => {\n            return f.uri === e.uri;\n        });\n    });\n    workspaceFolders = workspaceFolders\n        .filter((e) => {\n        return !changedFolders.added.some((f) => {\n            return f.uri === e.uri;\n        });\n    })\n        .concat(changedFolders.added);\n    return workspaceFolders;\n};\nexports.workspaceFoldersChanged = workspaceFoldersChanged;\n//# sourceMappingURL=paths.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/utils/paths.js?')},2791:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSchemaUrls = exports.checkSchemaURI = exports.JSON_SCHEMASTORE_URL = exports.KUBERNETES_SCHEMA_URL = void 0;\nconst objects_1 = __webpack_require__(285);\nconst paths_1 = __webpack_require__(6614);\nexports.KUBERNETES_SCHEMA_URL = 'https://raw.githubusercontent.com/yannh/kubernetes-json-schema/master/v1.22.4-standalone-strict/all.json';\nexports.JSON_SCHEMASTORE_URL = 'https://www.schemastore.org/api/json/catalog.json';\nfunction checkSchemaURI(workspaceFolders, workspaceRoot, uri, telemetry) {\n    if (uri.trim().toLowerCase() === 'kubernetes') {\n        telemetry.send({ name: 'yaml.schema.configured', properties: { kubernetes: true } });\n        return exports.KUBERNETES_SCHEMA_URL;\n    }\n    else if ((0, paths_1.isRelativePath)(uri)) {\n        return (0, paths_1.relativeToAbsolutePath)(workspaceFolders, workspaceRoot, uri);\n    }\n    else {\n        return uri;\n    }\n}\nexports.checkSchemaURI = checkSchemaURI;\n/**\n * Collect all urls of sub schemas\n * @param schema the root schema\n * @returns map url to schema\n */\nfunction getSchemaUrls(schema) {\n    const result = new Map();\n    if (!schema) {\n        return result;\n    }\n    if (schema.url) {\n        if (schema.url.startsWith('schemaservice://combinedSchema/')) {\n            addSchemasForOf(schema, result);\n        }\n        else {\n            result.set(schema.url, schema);\n        }\n    }\n    else {\n        addSchemasForOf(schema, result);\n    }\n    return result;\n}\nexports.getSchemaUrls = getSchemaUrls;\nfunction addSchemasForOf(schema, result) {\n    if (schema.allOf) {\n        addInnerSchemaUrls(schema.allOf, result);\n    }\n    if (schema.anyOf) {\n        addInnerSchemaUrls(schema.anyOf, result);\n    }\n    if (schema.oneOf) {\n        addInnerSchemaUrls(schema.oneOf, result);\n    }\n}\nfunction addInnerSchemaUrls(schemas, result) {\n    for (const subSchema of schemas) {\n        if (!(0, objects_1.isBoolean)(subSchema) && subSchema.url && !result.has(subSchema.url)) {\n            result.set(subSchema.url, subSchema);\n        }\n    }\n}\n//# sourceMappingURL=schemaUrls.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/utils/schemaUrls.js?")},4411:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isAnyOfAllOfOneOfType = exports.isPrimitiveType = exports.getSchemaTitle = exports.getSchemaRefTypeTitle = exports.getSchemaTypeName = void 0;\nconst vscode_uri_1 = __webpack_require__(5472);\nconst path = __webpack_require__(1017);\nfunction getSchemaTypeName(schema) {\n    const closestTitleWithType = schema.type && schema.closestTitle;\n    if (schema.title) {\n        return schema.title;\n    }\n    if (schema.$id) {\n        return getSchemaRefTypeTitle(schema.$id);\n    }\n    if (schema.$ref || schema._$ref) {\n        return getSchemaRefTypeTitle(schema.$ref || schema._$ref);\n    }\n    return Array.isArray(schema.type)\n        ? schema.type.join(' | ')\n        : closestTitleWithType\n            ? schema.type.concat('(', schema.closestTitle, ')')\n            : schema.type || schema.closestTitle; //object\n}\nexports.getSchemaTypeName = getSchemaTypeName;\n/**\n * Get type name from reference url\n * @param $ref reference to the same file OR to the another component OR to the section in another component:\n * `schema-name.schema.json` -> schema-name\n * `custom-scheme://shared-schema.json#/definitions/SomeType` -> SomeType\n * `custom-scheme://schema-name.schema.json` -> schema-name\n * `shared-schema.schema.json#/definitions/SomeType` -> SomeType\n * `file:///Users/user/Documents/project/schemas/schema-name.schema.json` -> schema-name\n * `#/definitions/SomeType` -> SomeType\n * `#/definitions/io.k8s.api.apps.v1.DaemonSetSpec` => io.k8s.api.apps.v1.DaemonSetSpec\n * `file:///default_schema_id.yaml` => default_schema_id.yaml\n * test: https://regex101.com/r/ZpuXxk/1\n */\nfunction getSchemaRefTypeTitle($ref) {\n    const match = $ref.match(/^(?:.*\\/)?(.*?)(?:\\.schema\\.json)?$/);\n    let type = !!match && match[1];\n    if (!type) {\n        type = 'typeNotFound';\n        console.error(`$ref (${$ref}) not parsed properly`);\n    }\n    return type;\n}\nexports.getSchemaRefTypeTitle = getSchemaRefTypeTitle;\nfunction getSchemaTitle(schema, url) {\n    const uri = vscode_uri_1.URI.parse(url);\n    let baseName = path.basename(uri.fsPath);\n    if (!path.extname(uri.fsPath)) {\n        baseName += '.json';\n    }\n    if (Object.getOwnPropertyDescriptor(schema, 'name')) {\n        return Object.getOwnPropertyDescriptor(schema, 'name').value + ` (${baseName})`;\n    }\n    else if (schema.title) {\n        return schema.description ? schema.title + ' - ' + schema.description + ` (${baseName})` : schema.title + ` (${baseName})`;\n    }\n    return baseName;\n}\nexports.getSchemaTitle = getSchemaTitle;\nfunction isPrimitiveType(schema) {\n    return schema.type !== 'object' && !isAnyOfAllOfOneOfType(schema);\n}\nexports.isPrimitiveType = isPrimitiveType;\nfunction isAnyOfAllOfOneOfType(schema) {\n    return !!(schema.anyOf || schema.allOf || schema.oneOf);\n}\nexports.isAnyOfAllOfOneOfType = isAnyOfAllOfOneOfType;\n//# sourceMappingURL=schemaUtils.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/utils/schemaUtils.js?")},4726:(__unused_webpack_module,exports)=>{"use strict";eval("/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getFirstNonWhitespaceCharacterAfterOffset = exports.safeCreateUnicodeRegExp = exports.getIndentation = exports.convertSimple2RegExpPattern = exports.convertSimple2RegExp = exports.endsWith = exports.startsWith = void 0;\nfunction startsWith(haystack, needle) {\n    if (haystack.length < needle.length) {\n        return false;\n    }\n    for (let i = 0; i < needle.length; i++) {\n        if (haystack[i] !== needle[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.startsWith = startsWith;\n/**\n * Determines if haystack ends with needle.\n */\nfunction endsWith(haystack, needle) {\n    const diff = haystack.length - needle.length;\n    if (diff > 0) {\n        return haystack.lastIndexOf(needle) === diff;\n    }\n    else if (diff === 0) {\n        return haystack === needle;\n    }\n    else {\n        return false;\n    }\n}\nexports.endsWith = endsWith;\nfunction convertSimple2RegExp(pattern) {\n    const match = pattern.match(new RegExp('^/(.*?)/([gimy]*)$'));\n    return match ? convertRegexString2RegExp(match[1], match[2]) : convertGlobalPattern2RegExp(pattern);\n}\nexports.convertSimple2RegExp = convertSimple2RegExp;\nfunction convertGlobalPattern2RegExp(pattern) {\n    return new RegExp(pattern.replace(/[-\\\\{}+?|^$.,[\\]()#\\s]/g, '\\\\$&').replace(/[*]/g, '.*') + '$');\n}\nfunction convertRegexString2RegExp(pattern, flag) {\n    return new RegExp(pattern, flag);\n}\nfunction convertSimple2RegExpPattern(pattern) {\n    return pattern.replace(/[-\\\\{}+?|^$.,[\\]()#\\s]/g, '\\\\$&').replace(/[*]/g, '.*');\n}\nexports.convertSimple2RegExpPattern = convertSimple2RegExpPattern;\nfunction getIndentation(lineContent, position) {\n    if (lineContent.length < position) {\n        return 0;\n    }\n    for (let i = 0; i < position; i++) {\n        const char = lineContent.charCodeAt(i);\n        if (char !== 32 /* CharCode.Space */ && char !== 9 /* CharCode.Tab */) {\n            return i;\n        }\n    }\n    // assuming that current position is indentation\n    return position;\n}\nexports.getIndentation = getIndentation;\nfunction safeCreateUnicodeRegExp(pattern) {\n    // fall back to regular regexp if we cannot create Unicode one\n    try {\n        return new RegExp(pattern, 'u');\n    }\n    catch (ignore) {\n        return new RegExp(pattern);\n    }\n}\nexports.safeCreateUnicodeRegExp = safeCreateUnicodeRegExp;\nfunction getFirstNonWhitespaceCharacterAfterOffset(str, offset) {\n    offset++;\n    for (let i = offset; i < str.length; i++) {\n        const char = str.charAt(i);\n        if (char === ' ' || char === '\\t') {\n            offset++;\n        }\n        else {\n            return offset;\n        }\n    }\n    return offset;\n}\nexports.getFirstNonWhitespaceCharacterAfterOffset = getFirstNonWhitespaceCharacterAfterOffset;\n//# sourceMappingURL=strings.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/utils/strings.js?")},90:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextBuffer = void 0;\nconst vscode_languageserver_types_1 = __webpack_require__(3798);\nclass TextBuffer {\n    constructor(doc) {\n        this.doc = doc;\n    }\n    getLineCount() {\n        return this.doc.lineCount;\n    }\n    getLineLength(lineNumber) {\n        const lineOffsets = this.doc.getLineOffsets();\n        if (lineNumber >= lineOffsets.length) {\n            return this.doc.getText().length;\n        }\n        else if (lineNumber < 0) {\n            return 0;\n        }\n        const nextLineOffset = lineNumber + 1 < lineOffsets.length ? lineOffsets[lineNumber + 1] : this.doc.getText().length;\n        return nextLineOffset - lineOffsets[lineNumber];\n    }\n    getLineContent(lineNumber) {\n        const lineOffsets = this.doc.getLineOffsets();\n        if (lineNumber >= lineOffsets.length) {\n            return this.doc.getText();\n        }\n        else if (lineNumber < 0) {\n            return '';\n        }\n        const nextLineOffset = lineNumber + 1 < lineOffsets.length ? lineOffsets[lineNumber + 1] : this.doc.getText().length;\n        return this.doc.getText().substring(lineOffsets[lineNumber], nextLineOffset);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this.doc.getText(vscode_languageserver_types_1.Range.create(lineNumber - 1, index, lineNumber - 1, index + 1)).charCodeAt(0);\n    }\n    getText(range) {\n        return this.doc.getText(range);\n    }\n    getPosition(offest) {\n        return this.doc.positionAt(offest);\n    }\n}\nexports.TextBuffer = TextBuffer;\n//# sourceMappingURL=textBuffer.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/utils/textBuffer.js?")},9134:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Red Hat, Inc. All rights reserved.\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.getLanguageService = exports.SchemaPriority = void 0;\nconst yamlSchemaService_1 = __webpack_require__(7188);\nconst documentSymbols_1 = __webpack_require__(9287);\nconst yamlHover_1 = __webpack_require__(801);\nconst yamlValidation_1 = __webpack_require__(4882);\nconst yamlFormatter_1 = __webpack_require__(2845);\nconst yamlLinks_1 = __webpack_require__(8613);\nconst yamlFolding_1 = __webpack_require__(382);\nconst yamlCodeActions_1 = __webpack_require__(3584);\nconst yamlOnTypeFormatting_1 = __webpack_require__(9691);\nconst yamlCodeLens_1 = __webpack_require__(8551);\nconst yamlCompletion_1 = __webpack_require__(1850);\nconst yaml_documents_1 = __webpack_require__(4532);\nconst schemaSelectionHandlers_1 = __webpack_require__(7246);\nconst yamlDefinition_1 = __webpack_require__(6023);\nconst yamlSelectionRanges_1 = __webpack_require__(2725);\nvar SchemaPriority;\n(function (SchemaPriority) {\n    SchemaPriority[SchemaPriority["SchemaStore"] = 1] = "SchemaStore";\n    SchemaPriority[SchemaPriority["SchemaAssociation"] = 2] = "SchemaAssociation";\n    SchemaPriority[SchemaPriority["Settings"] = 3] = "Settings";\n})(SchemaPriority = exports.SchemaPriority || (exports.SchemaPriority = {}));\nfunction getLanguageService(params) {\n    const schemaService = new yamlSchemaService_1.YAMLSchemaService(params.schemaRequestService, params.workspaceContext);\n    const completer = new yamlCompletion_1.YamlCompletion(schemaService, params.clientCapabilities, yaml_documents_1.yamlDocumentsCache, params.telemetry);\n    const hover = new yamlHover_1.YAMLHover(schemaService, params.telemetry);\n    const yamlDocumentSymbols = new documentSymbols_1.YAMLDocumentSymbols(schemaService, params.telemetry);\n    const yamlValidation = new yamlValidation_1.YAMLValidation(schemaService, params.telemetry);\n    const formatter = new yamlFormatter_1.YAMLFormatter();\n    const yamlCodeActions = new yamlCodeActions_1.YamlCodeActions(params.clientCapabilities);\n    const yamlCodeLens = new yamlCodeLens_1.YamlCodeLens(schemaService, params.telemetry);\n    const yamlLinks = new yamlLinks_1.YamlLinks(params.telemetry);\n    const yamlDefinition = new yamlDefinition_1.YamlDefinition(params.telemetry);\n    new schemaSelectionHandlers_1.JSONSchemaSelection(schemaService, params.yamlSettings, params.connection);\n    return {\n        configure: (settings) => {\n            schemaService.clearExternalSchemas();\n            if (settings.schemas) {\n                schemaService.schemaPriorityMapping = new Map();\n                settings.schemas.forEach((settings) => {\n                    const currPriority = settings.priority ? settings.priority : 0;\n                    schemaService.addSchemaPriority(settings.uri, currPriority);\n                    schemaService.registerExternalSchema(settings.uri, settings.fileMatch, settings.schema, settings.name, settings.description, settings.versions);\n                });\n            }\n            yamlValidation.configure(settings);\n            hover.configure(settings);\n            completer.configure(settings);\n            formatter.configure(settings);\n            yamlCodeActions.configure(settings);\n        },\n        registerCustomSchemaProvider: (schemaProvider) => {\n            schemaService.registerCustomSchemaProvider(schemaProvider);\n        },\n        findLinks: yamlLinks.findLinks.bind(yamlLinks),\n        doComplete: completer.doComplete.bind(completer),\n        doValidation: yamlValidation.doValidation.bind(yamlValidation),\n        doHover: hover.doHover.bind(hover),\n        findDocumentSymbols: yamlDocumentSymbols.findDocumentSymbols.bind(yamlDocumentSymbols),\n        findDocumentSymbols2: yamlDocumentSymbols.findHierarchicalDocumentSymbols.bind(yamlDocumentSymbols),\n        doDefinition: yamlDefinition.getDefinition.bind(yamlDefinition),\n        resetSchema: (uri) => {\n            return schemaService.onResourceChange(uri);\n        },\n        doFormat: formatter.format.bind(formatter),\n        doDocumentOnTypeFormatting: yamlOnTypeFormatting_1.doDocumentOnTypeFormatting,\n        addSchema: (schemaID, schema) => {\n            return schemaService.saveSchema(schemaID, schema);\n        },\n        deleteSchema: (schemaID) => {\n            return schemaService.deleteSchema(schemaID);\n        },\n        modifySchemaContent: (schemaAdditions) => {\n            return schemaService.addContent(schemaAdditions);\n        },\n        deleteSchemaContent: (schemaDeletions) => {\n            return schemaService.deleteContent(schemaDeletions);\n        },\n        deleteSchemasWhole: (schemaDeletions) => {\n            return schemaService.deleteSchemas(schemaDeletions);\n        },\n        getFoldingRanges: yamlFolding_1.getFoldingRanges,\n        getSelectionRanges: yamlSelectionRanges_1.getSelectionRanges,\n        getCodeAction: (document, params) => {\n            return yamlCodeActions.getCodeAction(document, params);\n        },\n        getCodeLens: (document) => {\n            return yamlCodeLens.getCodeLens(document);\n        },\n        resolveCodeLens: (param) => yamlCodeLens.resolveCodeLens(param),\n    };\n}\nexports.getLanguageService = getLanguageService;\n//# sourceMappingURL=yamlLanguageService.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/languageservice/yamlLanguageService.js?')},5651:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SchemaSelectionRequests = exports.SchemaModificationNotification = exports.ColorSymbolRequest = exports.CustomSchemaRequest = exports.CustomSchemaContentRequest = exports.VSCodeContentRequest = exports.ResultLimitReachedNotification = exports.VSCodeContentRequestRegistration = exports.DynamicCustomSchemaRequestRegistration = exports.SchemaAssociationNotification = void 0;\n/* eslint-disable @typescript-eslint/no-namespace */\nconst vscode_languageserver_1 = __webpack_require__(864);\nvar SchemaAssociationNotification;\n(function (SchemaAssociationNotification) {\n    SchemaAssociationNotification.type = new vscode_languageserver_1.NotificationType('json/schemaAssociations');\n})(SchemaAssociationNotification = exports.SchemaAssociationNotification || (exports.SchemaAssociationNotification = {}));\nvar DynamicCustomSchemaRequestRegistration;\n(function (DynamicCustomSchemaRequestRegistration) {\n    DynamicCustomSchemaRequestRegistration.type = new vscode_languageserver_1.NotificationType('yaml/registerCustomSchemaRequest');\n})(DynamicCustomSchemaRequestRegistration = exports.DynamicCustomSchemaRequestRegistration || (exports.DynamicCustomSchemaRequestRegistration = {}));\nvar VSCodeContentRequestRegistration;\n(function (VSCodeContentRequestRegistration) {\n    VSCodeContentRequestRegistration.type = new vscode_languageserver_1.NotificationType('yaml/registerContentRequest');\n})(VSCodeContentRequestRegistration = exports.VSCodeContentRequestRegistration || (exports.VSCodeContentRequestRegistration = {}));\nvar ResultLimitReachedNotification;\n(function (ResultLimitReachedNotification) {\n    ResultLimitReachedNotification.type = new vscode_languageserver_1.NotificationType('yaml/resultLimitReached');\n})(ResultLimitReachedNotification = exports.ResultLimitReachedNotification || (exports.ResultLimitReachedNotification = {}));\nvar VSCodeContentRequest;\n(function (VSCodeContentRequest) {\n    VSCodeContentRequest.type = new vscode_languageserver_1.RequestType('vscode/content');\n})(VSCodeContentRequest = exports.VSCodeContentRequest || (exports.VSCodeContentRequest = {}));\nvar CustomSchemaContentRequest;\n(function (CustomSchemaContentRequest) {\n    CustomSchemaContentRequest.type = new vscode_languageserver_1.RequestType('custom/schema/content');\n})(CustomSchemaContentRequest = exports.CustomSchemaContentRequest || (exports.CustomSchemaContentRequest = {}));\nvar CustomSchemaRequest;\n(function (CustomSchemaRequest) {\n    CustomSchemaRequest.type = new vscode_languageserver_1.RequestType('custom/schema/request');\n})(CustomSchemaRequest = exports.CustomSchemaRequest || (exports.CustomSchemaRequest = {}));\nvar ColorSymbolRequest;\n(function (ColorSymbolRequest) {\n    ColorSymbolRequest.type = new vscode_languageserver_1.RequestType('json/colorSymbols');\n})(ColorSymbolRequest = exports.ColorSymbolRequest || (exports.ColorSymbolRequest = {}));\nvar SchemaModificationNotification;\n(function (SchemaModificationNotification) {\n    SchemaModificationNotification.type = new vscode_languageserver_1.RequestType('json/schema/modify');\n})(SchemaModificationNotification = exports.SchemaModificationNotification || (exports.SchemaModificationNotification = {}));\nvar SchemaSelectionRequests;\n(function (SchemaSelectionRequests) {\n    SchemaSelectionRequests.type = new vscode_languageserver_1.NotificationType('yaml/supportSchemaSelection');\n    SchemaSelectionRequests.getSchema = new vscode_languageserver_1.RequestType('yaml/get/jsonSchema');\n    SchemaSelectionRequests.getAllSchemas = new vscode_languageserver_1.RequestType('yaml/get/all/jsonSchemas');\n    SchemaSelectionRequests.schemaStoreInitialized = new vscode_languageserver_1.NotificationType('yaml/schema/store/initialized');\n})(SchemaSelectionRequests = exports.SchemaSelectionRequests || (exports.SchemaSelectionRequests = {}));\n//# sourceMappingURL=requestTypes.js.map\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml-language-server@1.14.0/node_modules/yaml-language-server/out/server/src/requestTypes.js?")},9491:e=>{"use strict";e.exports=require("assert")},2361:e=>{"use strict";e.exports=require("events")},7147:e=>{"use strict";e.exports=require("fs")},3685:e=>{"use strict";e.exports=require("http")},5687:e=>{"use strict";e.exports=require("https")},1808:e=>{"use strict";e.exports=require("net")},2037:e=>{"use strict";e.exports=require("os")},1017:e=>{"use strict";e.exports=require("path")},4404:e=>{"use strict";e.exports=require("tls")},3837:e=>{"use strict";e.exports=require("util")},5216:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\nvar Scalar = __webpack_require__(6686);\nvar resolveBlockMap = __webpack_require__(966);\nvar resolveBlockSeq = __webpack_require__(6250);\nvar resolveFlowCollection = __webpack_require__(9878);\n\nfunction composeCollection(CN, ctx, token, tagToken, onError) {\n    let coll;\n    switch (token.type) {\n        case 'block-map': {\n            coll = resolveBlockMap.resolveBlockMap(CN, ctx, token, onError);\n            break;\n        }\n        case 'block-seq': {\n            coll = resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError);\n            break;\n        }\n        case 'flow-collection': {\n            coll = resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError);\n            break;\n        }\n    }\n    if (!tagToken)\n        return coll;\n    const tagName = ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\n    if (!tagName)\n        return coll;\n    // Cast needed due to: https://github.com/Microsoft/TypeScript/issues/3841\n    const Coll = coll.constructor;\n    if (tagName === '!' || tagName === Coll.tagName) {\n        coll.tag = Coll.tagName;\n        return coll;\n    }\n    const expType = Node.isMap(coll) ? 'map' : 'seq';\n    let tag = ctx.schema.tags.find(t => t.collection === expType && t.tag === tagName);\n    if (!tag) {\n        const kt = ctx.schema.knownTags[tagName];\n        if (kt && kt.collection === expType) {\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\n            tag = kt;\n        }\n        else {\n            onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\n            coll.tag = tagName;\n            return coll;\n        }\n    }\n    const res = tag.resolve(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n    const node = Node.isNode(res)\n        ? res\n        : new Scalar.Scalar(res);\n    node.range = coll.range;\n    node.tag = tagName;\n    if (tag?.format)\n        node.format = tag.format;\n    return node;\n}\n\nexports.composeCollection = composeCollection;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/compose-collection.js?")},3858:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Document = __webpack_require__(7705);\nvar composeNode = __webpack_require__(9345);\nvar resolveEnd = __webpack_require__(6939);\nvar resolveProps = __webpack_require__(3813);\n\nfunction composeDoc(options, directives, { offset, start, value, end }, onError) {\n    const opts = Object.assign({ _directives: directives }, options);\n    const doc = new Document.Document(undefined, opts);\n    const ctx = {\n        atRoot: true,\n        directives: doc.directives,\n        options: doc.options,\n        schema: doc.schema\n    };\n    const props = resolveProps.resolveProps(start, {\n        indicator: 'doc-start',\n        next: value ?? end?.[0],\n        offset,\n        onError,\n        startOnNewline: true\n    });\n    if (props.found) {\n        doc.directives.docStart = true;\n        if (value &&\n            (value.type === 'block-map' || value.type === 'block-seq') &&\n            !props.hasNewline)\n            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');\n    }\n    doc.contents = value\n        ? composeNode.composeNode(ctx, value, props, onError)\n        : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);\n    const contentEnd = doc.contents.range[2];\n    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);\n    if (re.comment)\n        doc.comment = re.comment;\n    doc.range = [offset, contentEnd, re.offset];\n    return doc;\n}\n\nexports.composeDoc = composeDoc;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/compose-doc.js?")},9345:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Alias = __webpack_require__(1528);\nvar composeCollection = __webpack_require__(5216);\nvar composeScalar = __webpack_require__(9062);\nvar resolveEnd = __webpack_require__(6939);\nvar utilEmptyScalarPosition = __webpack_require__(4593);\n\nconst CN = { composeNode, composeEmptyNode };\nfunction composeNode(ctx, token, props, onError) {\n    const { spaceBefore, comment, anchor, tag } = props;\n    let node;\n    let isSrcToken = true;\n    switch (token.type) {\n        case 'alias':\n            node = composeAlias(ctx, token, onError);\n            if (anchor || tag)\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\n            break;\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'block-scalar':\n            node = composeScalar.composeScalar(ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        case 'block-map':\n        case 'block-seq':\n        case 'flow-collection':\n            node = composeCollection.composeCollection(CN, ctx, token, tag, onError);\n            if (anchor)\n                node.anchor = anchor.source.substring(1);\n            break;\n        default: {\n            const message = token.type === 'error'\n                ? token.message\n                : `Unsupported token (type: ${token.type})`;\n            onError(token, 'UNEXPECTED_TOKEN', message);\n            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);\n            isSrcToken = false;\n        }\n    }\n    if (anchor && node.anchor === '')\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        if (token.type === 'scalar' && token.source === '')\n            node.comment = comment;\n        else\n            node.commentBefore = comment;\n    }\n    // @ts-expect-error Type checking misses meaning of isSrcToken\n    if (ctx.options.keepSourceTokens && isSrcToken)\n        node.srcToken = token;\n    return node;\n}\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {\n    const token = {\n        type: 'scalar',\n        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),\n        indent: -1,\n        source: ''\n    };\n    const node = composeScalar.composeScalar(ctx, token, tag, onError);\n    if (anchor) {\n        node.anchor = anchor.source.substring(1);\n        if (node.anchor === '')\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\n    }\n    if (spaceBefore)\n        node.spaceBefore = true;\n    if (comment) {\n        node.comment = comment;\n        node.range[2] = end;\n    }\n    return node;\n}\nfunction composeAlias({ options }, { offset, source, end }, onError) {\n    const alias = new Alias.Alias(source.substring(1));\n    if (alias.source === '')\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\n    if (alias.source.endsWith(':'))\n        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);\n    const valueEnd = offset + source.length;\n    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);\n    alias.range = [offset, valueEnd, re.offset];\n    if (re.comment)\n        alias.comment = re.comment;\n    return alias;\n}\n\nexports.composeEmptyNode = composeEmptyNode;\nexports.composeNode = composeNode;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/compose-node.js?")},9062:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\nvar Scalar = __webpack_require__(6686);\nvar resolveBlockScalar = __webpack_require__(2870);\nvar resolveFlowScalar = __webpack_require__(1677);\n\nfunction composeScalar(ctx, token, tagToken, onError) {\n    const { value, type, comment, range } = token.type === 'block-scalar'\n        ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError)\n        : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);\n    const tagName = tagToken\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\n        : null;\n    const tag = tagToken && tagName\n        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)\n        : token.type === 'scalar'\n            ? findScalarTagByTest(ctx, value, token, onError)\n            : ctx.schema[Node.SCALAR];\n    let scalar;\n    try {\n        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\n        scalar = Node.isScalar(res) ? res : new Scalar.Scalar(res);\n    }\n    catch (error) {\n        const msg = error instanceof Error ? error.message : String(error);\n        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);\n        scalar = new Scalar.Scalar(value);\n    }\n    scalar.range = range;\n    scalar.source = value;\n    if (type)\n        scalar.type = type;\n    if (tagName)\n        scalar.tag = tagName;\n    if (tag.format)\n        scalar.format = tag.format;\n    if (comment)\n        scalar.comment = comment;\n    return scalar;\n}\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\n    if (tagName === '!')\n        return schema[Node.SCALAR]; // non-specific tag\n    const matchWithTest = [];\n    for (const tag of schema.tags) {\n        if (!tag.collection && tag.tag === tagName) {\n            if (tag.default && tag.test)\n                matchWithTest.push(tag);\n            else\n                return tag;\n        }\n    }\n    for (const tag of matchWithTest)\n        if (tag.test?.test(value))\n            return tag;\n    const kt = schema.knownTags[tagName];\n    if (kt && !kt.collection) {\n        // Ensure that the known tag is available for stringifying,\n        // but does not get used by default.\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\n        return kt;\n    }\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\n    return schema[Node.SCALAR];\n}\nfunction findScalarTagByTest({ directives, schema }, value, token, onError) {\n    const tag = schema.tags.find(tag => tag.default && tag.test?.test(value)) || schema[Node.SCALAR];\n    if (schema.compat) {\n        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??\n            schema[Node.SCALAR];\n        if (tag.tag !== compat.tag) {\n            const ts = directives.tagString(tag.tag);\n            const cs = directives.tagString(compat.tag);\n            const msg = `Value may be parsed as either ${ts} or ${cs}`;\n            onError(token, 'TAG_RESOLVE_FAILED', msg, true);\n        }\n    }\n    return tag;\n}\n\nexports.composeScalar = composeScalar;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/compose-scalar.js?")},4508:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar directives = __webpack_require__(3019);\nvar Document = __webpack_require__(7705);\nvar errors = __webpack_require__(5969);\nvar Node = __webpack_require__(6058);\nvar composeDoc = __webpack_require__(3858);\nvar resolveEnd = __webpack_require__(6939);\n\nfunction getErrorPos(src) {\n    if (typeof src === 'number')\n        return [src, src + 1];\n    if (Array.isArray(src))\n        return src.length === 2 ? src : [src[0], src[1]];\n    const { offset, source } = src;\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n    let comment = '';\n    let atComment = false;\n    let afterEmptyLine = false;\n    for (let i = 0; i < prelude.length; ++i) {\n        const source = prelude[i];\n        switch (source[0]) {\n            case '#':\n                comment +=\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\n                        (source.substring(1) || ' ');\n                atComment = true;\n                afterEmptyLine = false;\n                break;\n            case '%':\n                if (prelude[i + 1]?.[0] !== '#')\n                    i += 1;\n                atComment = false;\n                break;\n            default:\n                // This may be wrong after doc-end, but in that case it doesn't matter\n                if (!atComment)\n                    afterEmptyLine = true;\n                atComment = false;\n        }\n    }\n    return { comment, afterEmptyLine };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n    constructor(options = {}) {\n        this.doc = null;\n        this.atDirectives = false;\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n        this.onError = (source, code, message, warning) => {\n            const pos = getErrorPos(source);\n            if (warning)\n                this.warnings.push(new errors.YAMLWarning(pos, code, message));\n            else\n                this.errors.push(new errors.YAMLParseError(pos, code, message));\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        this.directives = new directives.Directives({ version: options.version || '1.2' });\n        this.options = options;\n    }\n    decorate(doc, afterDoc) {\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\n        //console.log({ dc: doc.comment, prelude, comment })\n        if (comment) {\n            const dc = doc.contents;\n            if (afterDoc) {\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\n            }\n            else if (afterEmptyLine || doc.directives.docStart || !dc) {\n                doc.commentBefore = comment;\n            }\n            else if (Node.isCollection(dc) && !dc.flow && dc.items.length > 0) {\n                let it = dc.items[0];\n                if (Node.isPair(it))\n                    it = it.key;\n                const cb = it.commentBefore;\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n            else {\n                const cb = dc.commentBefore;\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\n            }\n        }\n        if (afterDoc) {\n            Array.prototype.push.apply(doc.errors, this.errors);\n            Array.prototype.push.apply(doc.warnings, this.warnings);\n        }\n        else {\n            doc.errors = this.errors;\n            doc.warnings = this.warnings;\n        }\n        this.prelude = [];\n        this.errors = [];\n        this.warnings = [];\n    }\n    /**\n     * Current stream status information.\n     *\n     * Mostly useful at the end of input for an empty stream.\n     */\n    streamInfo() {\n        return {\n            comment: parsePrelude(this.prelude).comment,\n            directives: this.directives,\n            errors: this.errors,\n            warnings: this.warnings\n        };\n    }\n    /**\n     * Compose tokens into documents.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *compose(tokens, forceDoc = false, endOffset = -1) {\n        for (const token of tokens)\n            yield* this.next(token);\n        yield* this.end(forceDoc, endOffset);\n    }\n    /** Advance the composer by one CST token. */\n    *next(token) {\n        if (process.env.LOG_STREAM)\n            console.dir(token, { depth: null });\n        switch (token.type) {\n            case 'directive':\n                this.directives.add(token.source, (offset, message, warning) => {\n                    const pos = getErrorPos(token);\n                    pos[0] += offset;\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n                });\n                this.prelude.push(token.source);\n                this.atDirectives = true;\n                break;\n            case 'document': {\n                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);\n                if (this.atDirectives && !doc.directives.docStart)\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n                this.decorate(doc, false);\n                if (this.doc)\n                    yield this.doc;\n                this.doc = doc;\n                this.atDirectives = false;\n                break;\n            }\n            case 'byte-order-mark':\n            case 'space':\n                break;\n            case 'comment':\n            case 'newline':\n                this.prelude.push(token.source);\n                break;\n            case 'error': {\n                const msg = token.source\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\n                    : token.message;\n                const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n                if (this.atDirectives || !this.doc)\n                    this.errors.push(error);\n                else\n                    this.doc.errors.push(error);\n                break;\n            }\n            case 'doc-end': {\n                if (!this.doc) {\n                    const msg = 'Unexpected doc-end without preceding document';\n                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n                    break;\n                }\n                this.doc.directives.docEnd = true;\n                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n                this.decorate(this.doc, true);\n                if (end.comment) {\n                    const dc = this.doc.comment;\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\n                }\n                this.doc.range[2] = end.offset;\n                break;\n            }\n            default:\n                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\n        }\n    }\n    /**\n     * Call at end of input to yield any remaining document.\n     *\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n     */\n    *end(forceDoc = false, endOffset = -1) {\n        if (this.doc) {\n            this.decorate(this.doc, true);\n            yield this.doc;\n            this.doc = null;\n        }\n        else if (forceDoc) {\n            const opts = Object.assign({ _directives: this.directives }, this.options);\n            const doc = new Document.Document(undefined, opts);\n            if (this.atDirectives)\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n            doc.range = [0, endOffset, endOffset];\n            this.decorate(doc, false);\n            yield doc;\n        }\n    }\n}\n\nexports.Composer = Composer;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/composer.js?")},966:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Pair = __webpack_require__(6775);\nvar YAMLMap = __webpack_require__(3140);\nvar resolveProps = __webpack_require__(3813);\nvar utilContainsNewline = __webpack_require__(3760);\nvar utilFlowIndentCheck = __webpack_require__(5826);\nvar utilMapIncludes = __webpack_require__(4292);\n\nconst startColMsg = 'All mapping items must start at the same column';\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError) {\n    const map = new YAMLMap.YAMLMap(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bm.offset;\n    let commentEnd = null;\n    for (const collItem of bm.items) {\n        const { start, key, sep, value } = collItem;\n        // key properties\n        const keyProps = resolveProps.resolveProps(start, {\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            startOnNewline: true\n        });\n        const implicitKey = !keyProps.found;\n        if (implicitKey) {\n            if (key) {\n                if (key.type === 'block-seq')\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\n                else if ('indent' in key && key.indent !== bm.indent)\n                    onError(offset, 'BAD_INDENT', startColMsg);\n            }\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\n                commentEnd = keyProps.end;\n                if (keyProps.comment) {\n                    if (map.comment)\n                        map.comment += '\\n' + keyProps.comment;\n                    else\n                        map.comment = keyProps.comment;\n                }\n                continue;\n            }\n            if (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) {\n                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\n            }\n        }\n        else if (keyProps.found?.indent !== bm.indent) {\n            onError(offset, 'BAD_INDENT', startColMsg);\n        }\n        // key value\n        const keyStart = keyProps.end;\n        const keyNode = key\n            ? composeNode(ctx, key, keyProps, onError)\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\n        if (ctx.schema.compat)\n            utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);\n        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n        // value properties\n        const valueProps = resolveProps.resolveProps(sep ?? [], {\n            indicator: 'map-value-ind',\n            next: value,\n            offset: keyNode.range[2],\n            onError,\n            startOnNewline: !key || key.type === 'block-scalar'\n        });\n        offset = valueProps.end;\n        if (valueProps.found) {\n            if (implicitKey) {\n                if (value?.type === 'block-map' && !valueProps.hasNewline)\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\n                if (ctx.options.strict &&\n                    keyProps.start < valueProps.found.offset - 1024)\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\n            if (ctx.schema.compat)\n                utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);\n            offset = valueNode.range[2];\n            const pair = new Pair.Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n        else {\n            // key with no value\n            if (implicitKey)\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\n            if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair.Pair(keyNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            map.items.push(pair);\n        }\n    }\n    if (commentEnd && commentEnd < offset)\n        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');\n    map.range = [bm.offset, offset, commentEnd ?? offset];\n    return map;\n}\n\nexports.resolveBlockMap = resolveBlockMap;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/resolve-block-map.js?")},2870:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Scalar = __webpack_require__(6686);\n\nfunction resolveBlockScalar(scalar, strict, onError) {\n    const start = scalar.offset;\n    const header = parseBlockScalarHeader(scalar, strict, onError);\n    if (!header)\n        return { value: '', type: null, comment: '', range: [start, start, start] };\n    const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;\n    const lines = scalar.source ? splitLines(scalar.source) : [];\n    // determine the end of content & start of chomping\n    let chompStart = lines.length;\n    for (let i = lines.length - 1; i >= 0; --i) {\n        const content = lines[i][1];\n        if (content === '' || content === '\\r')\n            chompStart = i;\n        else\n            break;\n    }\n    // shortcut for empty contents\n    if (chompStart === 0) {\n        const value = header.chomp === '+' && lines.length > 0\n            ? '\\n'.repeat(Math.max(1, lines.length - 1))\n            : '';\n        let end = start + header.length;\n        if (scalar.source)\n            end += scalar.source.length;\n        return { value, type, comment: header.comment, range: [start, end, end] };\n    }\n    // find the indentation level to trim from start\n    let trimIndent = scalar.indent + header.indent;\n    let offset = scalar.offset + header.length;\n    let contentStart = 0;\n    for (let i = 0; i < chompStart; ++i) {\n        const [indent, content] = lines[i];\n        if (content === '' || content === '\\r') {\n            if (header.indent === 0 && indent.length > trimIndent)\n                trimIndent = indent.length;\n        }\n        else {\n            if (indent.length < trimIndent) {\n                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n                onError(offset + indent.length, 'MISSING_CHAR', message);\n            }\n            if (header.indent === 0)\n                trimIndent = indent.length;\n            contentStart = i;\n            break;\n        }\n        offset += indent.length + content.length + 1;\n    }\n    // include trailing more-indented empty lines in content\n    for (let i = lines.length - 1; i >= chompStart; --i) {\n        if (lines[i][0].length > trimIndent)\n            chompStart = i + 1;\n    }\n    let value = '';\n    let sep = '';\n    let prevMoreIndented = false;\n    // leading whitespace is kept intact\n    for (let i = 0; i < contentStart; ++i)\n        value += lines[i][0].slice(trimIndent) + '\\n';\n    for (let i = contentStart; i < chompStart; ++i) {\n        let [indent, content] = lines[i];\n        offset += indent.length + content.length + 1;\n        const crlf = content[content.length - 1] === '\\r';\n        if (crlf)\n            content = content.slice(0, -1);\n        /* istanbul ignore if already caught in lexer */\n        if (content && indent.length < trimIndent) {\n            const src = header.indent\n                ? 'explicit indentation indicator'\n                : 'first line';\n            const message = `Block scalar lines must not be less indented than their ${src}`;\n            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);\n            indent = '';\n        }\n        if (type === Scalar.Scalar.BLOCK_LITERAL) {\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n        }\n        else if (indent.length > trimIndent || content[0] === '\\t') {\n            // more-indented content within a folded block\n            if (sep === ' ')\n                sep = '\\n';\n            else if (!prevMoreIndented && sep === '\\n')\n                sep = '\\n\\n';\n            value += sep + indent.slice(trimIndent) + content;\n            sep = '\\n';\n            prevMoreIndented = true;\n        }\n        else if (content === '') {\n            // empty line\n            if (sep === '\\n')\n                value += '\\n';\n            else\n                sep = '\\n';\n        }\n        else {\n            value += sep + content;\n            sep = ' ';\n            prevMoreIndented = false;\n        }\n    }\n    switch (header.chomp) {\n        case '-':\n            break;\n        case '+':\n            for (let i = chompStart; i < lines.length; ++i)\n                value += '\\n' + lines[i][0].slice(trimIndent);\n            if (value[value.length - 1] !== '\\n')\n                value += '\\n';\n            break;\n        default:\n            value += '\\n';\n    }\n    const end = start + header.length + scalar.source.length;\n    return { value, type, comment: header.comment, range: [start, end, end] };\n}\nfunction parseBlockScalarHeader({ offset, props }, strict, onError) {\n    /* istanbul ignore if should not happen */\n    if (props[0].type !== 'block-scalar-header') {\n        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\n        return null;\n    }\n    const { source } = props[0];\n    const mode = source[0];\n    let indent = 0;\n    let chomp = '';\n    let error = -1;\n    for (let i = 1; i < source.length; ++i) {\n        const ch = source[i];\n        if (!chomp && (ch === '-' || ch === '+'))\n            chomp = ch;\n        else {\n            const n = Number(ch);\n            if (!indent && n)\n                indent = n;\n            else if (error === -1)\n                error = offset + i;\n        }\n    }\n    if (error !== -1)\n        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\n    let hasSpace = false;\n    let comment = '';\n    let length = source.length;\n    for (let i = 1; i < props.length; ++i) {\n        const token = props[i];\n        switch (token.type) {\n            case 'space':\n                hasSpace = true;\n            // fallthrough\n            case 'newline':\n                length += token.source.length;\n                break;\n            case 'comment':\n                if (strict && !hasSpace) {\n                    const message = 'Comments must be separated from other tokens by white space characters';\n                    onError(token, 'MISSING_CHAR', message);\n                }\n                length += token.source.length;\n                comment = token.source.substring(1);\n                break;\n            case 'error':\n                onError(token, 'UNEXPECTED_TOKEN', token.message);\n                length += token.source.length;\n                break;\n            /* istanbul ignore next should not happen */\n            default: {\n                const message = `Unexpected token in block scalar header: ${token.type}`;\n                onError(token, 'UNEXPECTED_TOKEN', message);\n                const ts = token.source;\n                if (ts && typeof ts === 'string')\n                    length += ts.length;\n            }\n        }\n    }\n    return { mode, indent, chomp, comment, length };\n}\n/** @returns Array of lines split up as `[indent, content]` */\nfunction splitLines(source) {\n    const split = source.split(/\\n( *)/);\n    const first = split[0];\n    const m = first.match(/^( *)/);\n    const line0 = m?.[1]\n        ? [m[1], first.slice(m[1].length)]\n        : ['', first];\n    const lines = [line0];\n    for (let i = 1; i < split.length; i += 2)\n        lines.push([split[i], split[i + 1]]);\n    return lines;\n}\n\nexports.resolveBlockScalar = resolveBlockScalar;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/resolve-block-scalar.js?")},6250:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar YAMLSeq = __webpack_require__(6221);\nvar resolveProps = __webpack_require__(3813);\nvar utilFlowIndentCheck = __webpack_require__(5826);\n\nfunction resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError) {\n    const seq = new YAMLSeq.YAMLSeq(ctx.schema);\n    if (ctx.atRoot)\n        ctx.atRoot = false;\n    let offset = bs.offset;\n    let commentEnd = null;\n    for (const { start, value } of bs.items) {\n        const props = resolveProps.resolveProps(start, {\n            indicator: 'seq-item-ind',\n            next: value,\n            offset,\n            onError,\n            startOnNewline: true\n        });\n        if (!props.found) {\n            if (props.anchor || props.tag || value) {\n                if (value && value.type === 'block-seq')\n                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');\n                else\n                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');\n            }\n            else {\n                commentEnd = props.end;\n                if (props.comment)\n                    seq.comment = props.comment;\n                continue;\n            }\n        }\n        const node = value\n            ? composeNode(ctx, value, props, onError)\n            : composeEmptyNode(ctx, props.end, start, null, props, onError);\n        if (ctx.schema.compat)\n            utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);\n        offset = node.range[2];\n        seq.items.push(node);\n    }\n    seq.range = [bs.offset, offset, commentEnd ?? offset];\n    return seq;\n}\n\nexports.resolveBlockSeq = resolveBlockSeq;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/resolve-block-seq.js?")},6939:(__unused_webpack_module,exports)=>{"use strict";eval("\n\nfunction resolveEnd(end, offset, reqSpace, onError) {\n    let comment = '';\n    if (end) {\n        let hasSpace = false;\n        let sep = '';\n        for (const token of end) {\n            const { source, type } = token;\n            switch (type) {\n                case 'space':\n                    hasSpace = true;\n                    break;\n                case 'comment': {\n                    if (reqSpace && !hasSpace)\n                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                    const cb = source.substring(1) || ' ';\n                    if (!comment)\n                        comment = cb;\n                    else\n                        comment += sep + cb;\n                    sep = '';\n                    break;\n                }\n                case 'newline':\n                    if (comment)\n                        sep += source;\n                    hasSpace = true;\n                    break;\n                default:\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);\n            }\n            offset += source.length;\n        }\n    }\n    return { comment, offset };\n}\n\nexports.resolveEnd = resolveEnd;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/resolve-end.js?")},9878:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\nvar Pair = __webpack_require__(6775);\nvar YAMLMap = __webpack_require__(3140);\nvar YAMLSeq = __webpack_require__(6221);\nvar resolveEnd = __webpack_require__(6939);\nvar resolveProps = __webpack_require__(3813);\nvar utilContainsNewline = __webpack_require__(3760);\nvar utilMapIncludes = __webpack_require__(4292);\n\nconst blockMsg = 'Block collections are not allowed within flow collections';\nconst isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');\nfunction resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError) {\n    const isMap = fc.start.source === '{';\n    const fcName = isMap ? 'flow map' : 'flow sequence';\n    const coll = isMap\n        ? new YAMLMap.YAMLMap(ctx.schema)\n        : new YAMLSeq.YAMLSeq(ctx.schema);\n    coll.flow = true;\n    const atRoot = ctx.atRoot;\n    if (atRoot)\n        ctx.atRoot = false;\n    let offset = fc.offset + fc.start.source.length;\n    for (let i = 0; i < fc.items.length; ++i) {\n        const collItem = fc.items[i];\n        const { start, key, sep, value } = collItem;\n        const props = resolveProps.resolveProps(start, {\n            flow: fcName,\n            indicator: 'explicit-key-ind',\n            next: key ?? sep?.[0],\n            offset,\n            onError,\n            startOnNewline: false\n        });\n        if (!props.found) {\n            if (!props.anchor && !props.tag && !sep && !value) {\n                if (i === 0 && props.comma)\n                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n                else if (i < fc.items.length - 1)\n                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\n                if (props.comment) {\n                    if (coll.comment)\n                        coll.comment += '\\n' + props.comment;\n                    else\n                        coll.comment = props.comment;\n                }\n                offset = props.end;\n                continue;\n            }\n            if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))\n                onError(key, // checked by containsNewline()\n                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n        }\n        if (i === 0) {\n            if (props.comma)\n                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\n        }\n        else {\n            if (!props.comma)\n                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\n            if (props.comment) {\n                let prevItemComment = '';\n                loop: for (const st of start) {\n                    switch (st.type) {\n                        case 'comma':\n                        case 'space':\n                            break;\n                        case 'comment':\n                            prevItemComment = st.source.substring(1);\n                            break loop;\n                        default:\n                            break loop;\n                    }\n                }\n                if (prevItemComment) {\n                    let prev = coll.items[coll.items.length - 1];\n                    if (Node.isPair(prev))\n                        prev = prev.value ?? prev.key;\n                    if (prev.comment)\n                        prev.comment += '\\n' + prevItemComment;\n                    else\n                        prev.comment = prevItemComment;\n                    props.comment = props.comment.substring(prevItemComment.length + 1);\n                }\n            }\n        }\n        if (!isMap && !sep && !props.found) {\n            // item is a value in a seq\n            //  key & sep are empty, start does not include ? or :\n            const valueNode = value\n                ? composeNode(ctx, value, props, onError)\n                : composeEmptyNode(ctx, props.end, sep, null, props, onError);\n            coll.items.push(valueNode);\n            offset = valueNode.range[2];\n            if (isBlock(value))\n                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n        }\n        else {\n            // item is a key+value pair\n            // key value\n            const keyStart = props.end;\n            const keyNode = key\n                ? composeNode(ctx, key, props, onError)\n                : composeEmptyNode(ctx, keyStart, start, null, props, onError);\n            if (isBlock(key))\n                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            // value properties\n            const valueProps = resolveProps.resolveProps(sep ?? [], {\n                flow: fcName,\n                indicator: 'map-value-ind',\n                next: value,\n                offset: keyNode.range[2],\n                onError,\n                startOnNewline: false\n            });\n            if (valueProps.found) {\n                if (!isMap && !props.found && ctx.options.strict) {\n                    if (sep)\n                        for (const st of sep) {\n                            if (st === valueProps.found)\n                                break;\n                            if (st.type === 'newline') {\n                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\n                                break;\n                            }\n                        }\n                    if (props.start < valueProps.found.offset - 1024)\n                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\n                }\n            }\n            else if (value) {\n                if ('source' in value && value.source && value.source[0] === ':')\n                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);\n                else\n                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\n            }\n            // value value\n            const valueNode = value\n                ? composeNode(ctx, value, valueProps, onError)\n                : valueProps.found\n                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)\n                    : null;\n            if (valueNode) {\n                if (isBlock(value))\n                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\n            }\n            else if (valueProps.comment) {\n                if (keyNode.comment)\n                    keyNode.comment += '\\n' + valueProps.comment;\n                else\n                    keyNode.comment = valueProps.comment;\n            }\n            const pair = new Pair.Pair(keyNode, valueNode);\n            if (ctx.options.keepSourceTokens)\n                pair.srcToken = collItem;\n            if (isMap) {\n                const map = coll;\n                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))\n                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\n                map.items.push(pair);\n            }\n            else {\n                const map = new YAMLMap.YAMLMap(ctx.schema);\n                map.flow = true;\n                map.items.push(pair);\n                coll.items.push(map);\n            }\n            offset = valueNode ? valueNode.range[2] : valueProps.end;\n        }\n    }\n    const expectedEnd = isMap ? '}' : ']';\n    const [ce, ...ee] = fc.end;\n    let cePos = offset;\n    if (ce && ce.source === expectedEnd)\n        cePos = ce.offset + ce.source.length;\n    else {\n        const name = fcName[0].toUpperCase() + fcName.substring(1);\n        const msg = atRoot\n            ? `${name} must end with a ${expectedEnd}`\n            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;\n        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);\n        if (ce && ce.source.length !== 1)\n            ee.unshift(ce);\n    }\n    if (ee.length > 0) {\n        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);\n        if (end.comment) {\n            if (coll.comment)\n                coll.comment += '\\n' + end.comment;\n            else\n                coll.comment = end.comment;\n        }\n        coll.range = [fc.offset, cePos, end.offset];\n    }\n    else {\n        coll.range = [fc.offset, cePos, cePos];\n    }\n    return coll;\n}\n\nexports.resolveFlowCollection = resolveFlowCollection;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/resolve-flow-collection.js?")},1677:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Scalar = __webpack_require__(6686);\nvar resolveEnd = __webpack_require__(6939);\n\nfunction resolveFlowScalar(scalar, strict, onError) {\n    const { offset, type, source, end } = scalar;\n    let _type;\n    let value;\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\n    switch (type) {\n        case 'scalar':\n            _type = Scalar.Scalar.PLAIN;\n            value = plainValue(source, _onError);\n            break;\n        case 'single-quoted-scalar':\n            _type = Scalar.Scalar.QUOTE_SINGLE;\n            value = singleQuotedValue(source, _onError);\n            break;\n        case 'double-quoted-scalar':\n            _type = Scalar.Scalar.QUOTE_DOUBLE;\n            value = doubleQuotedValue(source, _onError);\n            break;\n        /* istanbul ignore next should not happen */\n        default:\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\n            return {\n                value: '',\n                type: null,\n                comment: '',\n                range: [offset, offset + source.length, offset + source.length]\n            };\n    }\n    const valueEnd = offset + source.length;\n    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);\n    return {\n        value,\n        type: _type,\n        comment: re.comment,\n        range: [offset, valueEnd, re.offset]\n    };\n}\nfunction plainValue(source, onError) {\n    let badChar = '';\n    switch (source[0]) {\n        /* istanbul ignore next should not happen */\n        case '\\t':\n            badChar = 'a tab character';\n            break;\n        case ',':\n            badChar = 'flow indicator character ,';\n            break;\n        case '%':\n            badChar = 'directive indicator character %';\n            break;\n        case '|':\n        case '>': {\n            badChar = `block scalar indicator ${source[0]}`;\n            break;\n        }\n        case '@':\n        case '`': {\n            badChar = `reserved character ${source[0]}`;\n            break;\n        }\n    }\n    if (badChar)\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\n    return foldLines(source);\n}\nfunction singleQuotedValue(source, onError) {\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\n}\nfunction foldLines(source) {\n    /**\n     * The negative lookbehind here and in the `re` RegExp is to\n     * prevent causing a polynomial search time in certain cases.\n     *\n     * The try-catch is for Safari, which doesn't support this yet:\n     * https://caniuse.com/js-regexp-lookbehind\n     */\n    let first, line;\n    try {\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\n    }\n    catch (_) {\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\n    }\n    let match = first.exec(source);\n    if (!match)\n        return source;\n    let res = match[1];\n    let sep = ' ';\n    let pos = first.lastIndex;\n    line.lastIndex = pos;\n    while ((match = line.exec(source))) {\n        if (match[1] === '') {\n            if (sep === '\\n')\n                res += sep;\n            else\n                sep = '\\n';\n        }\n        else {\n            res += sep + match[1];\n            sep = ' ';\n        }\n        pos = line.lastIndex;\n    }\n    const last = /[ \\t]*(.*)/sy;\n    last.lastIndex = pos;\n    match = last.exec(source);\n    return res + sep + (match?.[1] ?? '');\n}\nfunction doubleQuotedValue(source, onError) {\n    let res = '';\n    for (let i = 1; i < source.length - 1; ++i) {\n        const ch = source[i];\n        if (ch === '\\r' && source[i + 1] === '\\n')\n            continue;\n        if (ch === '\\n') {\n            const { fold, offset } = foldNewline(source, i);\n            res += fold;\n            i = offset;\n        }\n        else if (ch === '\\\\') {\n            let next = source[++i];\n            const cc = escapeCodes[next];\n            if (cc)\n                res += cc;\n            else if (next === '\\n') {\n                // skip escaped newlines, but still trim the following line\n                next = source[i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === '\\r' && source[i + 1] === '\\n') {\n                // skip escaped CRLF newlines, but still trim the following line\n                next = source[++i + 1];\n                while (next === ' ' || next === '\\t')\n                    next = source[++i + 1];\n            }\n            else if (next === 'x' || next === 'u' || next === 'U') {\n                const length = { x: 2, u: 4, U: 8 }[next];\n                res += parseCharCode(source, i + 1, length, onError);\n                i += length;\n            }\n            else {\n                const raw = source.substr(i - 1, 2);\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n                res += raw;\n            }\n        }\n        else if (ch === ' ' || ch === '\\t') {\n            // trim trailing whitespace\n            const wsStart = i;\n            let next = source[i + 1];\n            while (next === ' ' || next === '\\t')\n                next = source[++i + 1];\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\n        }\n        else {\n            res += ch;\n        }\n    }\n    if (source[source.length - 1] !== '\"' || source.length === 1)\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\n    return res;\n}\n/**\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\n * Presumes `source[offset] === '\\n'`\n */\nfunction foldNewline(source, offset) {\n    let fold = '';\n    let ch = source[offset + 1];\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\n            break;\n        if (ch === '\\n')\n            fold += '\\n';\n        offset += 1;\n        ch = source[offset + 1];\n    }\n    if (!fold)\n        fold = ' ';\n    return { fold, offset };\n}\nconst escapeCodes = {\n    '0': '\\0',\n    a: '\\x07',\n    b: '\\b',\n    e: '\\x1b',\n    f: '\\f',\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    v: '\\v',\n    N: '\\u0085',\n    _: '\\u00a0',\n    L: '\\u2028',\n    P: '\\u2029',\n    ' ': ' ',\n    '\"': '\"',\n    '/': '/',\n    '\\\\': '\\\\',\n    '\\t': '\\t'\n};\nfunction parseCharCode(source, offset, length, onError) {\n    const cc = source.substr(offset, length);\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n    const code = ok ? parseInt(cc, 16) : NaN;\n    if (isNaN(code)) {\n        const raw = source.substr(offset - 2, length + 2);\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\n        return raw;\n    }\n    return String.fromCodePoint(code);\n}\n\nexports.resolveFlowScalar = resolveFlowScalar;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/resolve-flow-scalar.js?")},3813:(__unused_webpack_module,exports)=>{"use strict";eval("\n\nfunction resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {\n    let spaceBefore = false;\n    let atNewline = startOnNewline;\n    let hasSpace = startOnNewline;\n    let comment = '';\n    let commentSep = '';\n    let hasNewline = false;\n    let hasNewlineAfterProp = false;\n    let reqSpace = false;\n    let anchor = null;\n    let tag = null;\n    let comma = null;\n    let found = null;\n    let start = null;\n    for (const token of tokens) {\n        if (reqSpace) {\n            if (token.type !== 'space' &&\n                token.type !== 'newline' &&\n                token.type !== 'comma')\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n            reqSpace = false;\n        }\n        switch (token.type) {\n            case 'space':\n                // At the doc level, tabs at line start may be parsed\n                // as leading white space rather than indentation.\n                // In a flow collection, only the parser handles indent.\n                if (!flow &&\n                    atNewline &&\n                    indicator !== 'doc-start' &&\n                    token.source[0] === '\\t')\n                    onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\n                hasSpace = true;\n                break;\n            case 'comment': {\n                if (!hasSpace)\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\n                const cb = token.source.substring(1) || ' ';\n                if (!comment)\n                    comment = cb;\n                else\n                    comment += commentSep + cb;\n                commentSep = '';\n                atNewline = false;\n                break;\n            }\n            case 'newline':\n                if (atNewline) {\n                    if (comment)\n                        comment += token.source;\n                    else\n                        spaceBefore = true;\n                }\n                else\n                    commentSep += token.source;\n                atNewline = true;\n                hasNewline = true;\n                if (anchor || tag)\n                    hasNewlineAfterProp = true;\n                hasSpace = true;\n                break;\n            case 'anchor':\n                if (anchor)\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\n                if (token.source.endsWith(':'))\n                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);\n                anchor = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            case 'tag': {\n                if (tag)\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\n                tag = token;\n                if (start === null)\n                    start = token.offset;\n                atNewline = false;\n                hasSpace = false;\n                reqSpace = true;\n                break;\n            }\n            case indicator:\n                // Could here handle preceding comments differently\n                if (anchor || tag)\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\n                if (found)\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);\n                found = token;\n                atNewline = false;\n                hasSpace = false;\n                break;\n            case 'comma':\n                if (flow) {\n                    if (comma)\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\n                    comma = token;\n                    atNewline = false;\n                    hasSpace = false;\n                    break;\n                }\n            // else fallthrough\n            default:\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\n                atNewline = false;\n                hasSpace = false;\n        }\n    }\n    const last = tokens[tokens.length - 1];\n    const end = last ? last.offset + last.source.length : offset;\n    if (reqSpace &&\n        next &&\n        next.type !== 'space' &&\n        next.type !== 'newline' &&\n        next.type !== 'comma' &&\n        (next.type !== 'scalar' || next.source !== ''))\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\n    return {\n        comma,\n        found,\n        spaceBefore,\n        comment,\n        hasNewline,\n        hasNewlineAfterProp,\n        anchor,\n        tag,\n        end,\n        start: start ?? end\n    };\n}\n\nexports.resolveProps = resolveProps;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/resolve-props.js?")},3760:(__unused_webpack_module,exports)=>{"use strict";eval("\n\nfunction containsNewline(key) {\n    if (!key)\n        return null;\n    switch (key.type) {\n        case 'alias':\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            if (key.source.includes('\\n'))\n                return true;\n            if (key.end)\n                for (const st of key.end)\n                    if (st.type === 'newline')\n                        return true;\n            return false;\n        case 'flow-collection':\n            for (const it of key.items) {\n                for (const st of it.start)\n                    if (st.type === 'newline')\n                        return true;\n                if (it.sep)\n                    for (const st of it.sep)\n                        if (st.type === 'newline')\n                            return true;\n                if (containsNewline(it.key) || containsNewline(it.value))\n                    return true;\n            }\n            return false;\n        default:\n            return true;\n    }\n}\n\nexports.containsNewline = containsNewline;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/util-contains-newline.js?")},4593:(__unused_webpack_module,exports)=>{"use strict";eval("\n\nfunction emptyScalarPosition(offset, before, pos) {\n    if (before) {\n        if (pos === null)\n            pos = before.length;\n        for (let i = pos - 1; i >= 0; --i) {\n            let st = before[i];\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                case 'newline':\n                    offset -= st.source.length;\n                    continue;\n            }\n            // Technically, an empty scalar is immediately after the last non-empty\n            // node, but it's more useful to place it after any whitespace.\n            st = before[++i];\n            while (st?.type === 'space') {\n                offset += st.source.length;\n                st = before[++i];\n            }\n            break;\n        }\n    }\n    return offset;\n}\n\nexports.emptyScalarPosition = emptyScalarPosition;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/util-empty-scalar-position.js?")},5826:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar utilContainsNewline = __webpack_require__(3760);\n\nfunction flowIndentCheck(indent, fc, onError) {\n    if (fc?.type === 'flow-collection') {\n        const end = fc.end[0];\n        if (end.indent === indent &&\n            (end.source === ']' || end.source === '}') &&\n            utilContainsNewline.containsNewline(fc)) {\n            const msg = 'Flow end indicator should be more indented than parent';\n            onError(end, 'BAD_INDENT', msg, true);\n        }\n    }\n}\n\nexports.flowIndentCheck = flowIndentCheck;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/util-flow-indent-check.js?")},4292:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\n\nfunction mapIncludes(ctx, items, search) {\n    const { uniqueKeys } = ctx.options;\n    if (uniqueKeys === false)\n        return false;\n    const isEqual = typeof uniqueKeys === 'function'\n        ? uniqueKeys\n        : (a, b) => a === b ||\n            (Node.isScalar(a) &&\n                Node.isScalar(b) &&\n                a.value === b.value &&\n                !(a.value === '<<' && ctx.schema.merge));\n    return items.some(pair => isEqual(pair.key, search));\n}\n\nexports.mapIncludes = mapIncludes;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/compose/util-map-includes.js?")},7705:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Alias = __webpack_require__(1528);\nvar Collection = __webpack_require__(205);\nvar Node = __webpack_require__(6058);\nvar Pair = __webpack_require__(6775);\nvar toJS = __webpack_require__(6001);\nvar Schema = __webpack_require__(1150);\nvar stringify = __webpack_require__(5338);\nvar stringifyDocument = __webpack_require__(3545);\nvar anchors = __webpack_require__(641);\nvar applyReviver = __webpack_require__(5183);\nvar createNode = __webpack_require__(7507);\nvar directives = __webpack_require__(3019);\n\nclass Document {\n    constructor(value, replacer, options) {\n        /** A comment before this Document */\n        this.commentBefore = null;\n        /** A comment immediately after this Document */\n        this.comment = null;\n        /** Errors encountered during parsing. */\n        this.errors = [];\n        /** Warnings encountered during parsing. */\n        this.warnings = [];\n        Object.defineProperty(this, Node.NODE_TYPE, { value: Node.DOC });\n        let _replacer = null;\n        if (typeof replacer === 'function' || Array.isArray(replacer)) {\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const opt = Object.assign({\n            intAsBigInt: false,\n            keepSourceTokens: false,\n            logLevel: 'warn',\n            prettyErrors: true,\n            strict: true,\n            uniqueKeys: true,\n            version: '1.2'\n        }, options);\n        this.options = opt;\n        let { version } = opt;\n        if (options?._directives) {\n            this.directives = options._directives.atDocument();\n            if (this.directives.yaml.explicit)\n                version = this.directives.yaml.version;\n        }\n        else\n            this.directives = new directives.Directives({ version });\n        this.setSchema(version, options);\n        if (value === undefined)\n            this.contents = null;\n        else {\n            this.contents = this.createNode(value, _replacer, options);\n        }\n    }\n    /**\n     * Create a deep copy of this Document and its contents.\n     *\n     * Custom Node values that inherit from `Object` still refer to their original instances.\n     */\n    clone() {\n        const copy = Object.create(Document.prototype, {\n            [Node.NODE_TYPE]: { value: Node.DOC }\n        });\n        copy.commentBefore = this.commentBefore;\n        copy.comment = this.comment;\n        copy.errors = this.errors.slice();\n        copy.warnings = this.warnings.slice();\n        copy.options = Object.assign({}, this.options);\n        if (this.directives)\n            copy.directives = this.directives.clone();\n        copy.schema = this.schema.clone();\n        copy.contents = Node.isNode(this.contents)\n            ? this.contents.clone(copy.schema)\n            : this.contents;\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /** Adds a value to the document. */\n    add(value) {\n        if (assertCollection(this.contents))\n            this.contents.add(value);\n    }\n    /** Adds a value to the document. */\n    addIn(path, value) {\n        if (assertCollection(this.contents))\n            this.contents.addIn(path, value);\n    }\n    /**\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\n     *\n     * If `node` already has an anchor, `name` is ignored.\n     * Otherwise, the `node.anchor` value will be set to `name`,\n     * or if an anchor with that name is already present in the document,\n     * `name` will be used as a prefix for a new unique anchor.\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\n     */\n    createAlias(node, name) {\n        if (!node.anchor) {\n            const prev = anchors.anchorNames(this);\n            node.anchor =\n                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;\n        }\n        return new Alias.Alias(node.anchor);\n    }\n    createNode(value, replacer, options) {\n        let _replacer = undefined;\n        if (typeof replacer === 'function') {\n            value = replacer.call({ '': value }, '', value);\n            _replacer = replacer;\n        }\n        else if (Array.isArray(replacer)) {\n            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;\n            const asStr = replacer.filter(keyToStr).map(String);\n            if (asStr.length > 0)\n                replacer = replacer.concat(asStr);\n            _replacer = replacer;\n        }\n        else if (options === undefined && replacer) {\n            options = replacer;\n            replacer = undefined;\n        }\n        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};\n        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, \n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        anchorPrefix || 'a');\n        const ctx = {\n            aliasDuplicateObjects: aliasDuplicateObjects ?? true,\n            keepUndefined: keepUndefined ?? false,\n            onAnchor,\n            onTagObj,\n            replacer: _replacer,\n            schema: this.schema,\n            sourceObjects\n        };\n        const node = createNode.createNode(value, tag, ctx);\n        if (flow && Node.isCollection(node))\n            node.flow = true;\n        setAnchors();\n        return node;\n    }\n    /**\n     * Convert a key and a value into a `Pair` using the current schema,\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\n     */\n    createPair(key, value, options = {}) {\n        const k = this.createNode(key, null, options);\n        const v = this.createNode(value, null, options);\n        return new Pair.Pair(k, v);\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        return assertCollection(this.contents) ? this.contents.delete(key) : false;\n    }\n    /**\n     * Removes a value from the document.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        if (Collection.isEmptyPath(path)) {\n            if (this.contents == null)\n                return false;\n            this.contents = null;\n            return true;\n        }\n        return assertCollection(this.contents)\n            ? this.contents.deleteIn(path)\n            : false;\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    get(key, keepScalar) {\n        return Node.isCollection(this.contents)\n            ? this.contents.get(key, keepScalar)\n            : undefined;\n    }\n    /**\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        if (Collection.isEmptyPath(path))\n            return !keepScalar && Node.isScalar(this.contents)\n                ? this.contents.value\n                : this.contents;\n        return Node.isCollection(this.contents)\n            ? this.contents.getIn(path, keepScalar)\n            : undefined;\n    }\n    /**\n     * Checks if the document includes a value with the key `key`.\n     */\n    has(key) {\n        return Node.isCollection(this.contents) ? this.contents.has(key) : false;\n    }\n    /**\n     * Checks if the document includes a value at `path`.\n     */\n    hasIn(path) {\n        if (Collection.isEmptyPath(path))\n            return this.contents !== undefined;\n        return Node.isCollection(this.contents) ? this.contents.hasIn(path) : false;\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    set(key, value) {\n        if (this.contents == null) {\n            this.contents = Collection.collectionFromPath(this.schema, [key], value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.set(key, value);\n        }\n    }\n    /**\n     * Sets a value in this document. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        if (Collection.isEmptyPath(path))\n            this.contents = value;\n        else if (this.contents == null) {\n            this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);\n        }\n        else if (assertCollection(this.contents)) {\n            this.contents.setIn(path, value);\n        }\n    }\n    /**\n     * Change the YAML version and schema used by the document.\n     * A `null` version disables support for directives, explicit tags, anchors, and aliases.\n     * It also requires the `schema` option to be given as a `Schema` instance value.\n     *\n     * Overrides all previously set schema options.\n     */\n    setSchema(version, options = {}) {\n        if (typeof version === 'number')\n            version = String(version);\n        let opt;\n        switch (version) {\n            case '1.1':\n                if (this.directives)\n                    this.directives.yaml.version = '1.1';\n                else\n                    this.directives = new directives.Directives({ version: '1.1' });\n                opt = { merge: true, resolveKnownTags: false, schema: 'yaml-1.1' };\n                break;\n            case '1.2':\n            case 'next':\n                if (this.directives)\n                    this.directives.yaml.version = version;\n                else\n                    this.directives = new directives.Directives({ version });\n                opt = { merge: false, resolveKnownTags: true, schema: 'core' };\n                break;\n            case null:\n                if (this.directives)\n                    delete this.directives;\n                opt = null;\n                break;\n            default: {\n                const sv = JSON.stringify(version);\n                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);\n            }\n        }\n        // Not using `instanceof Schema` to allow for duck typing\n        if (options.schema instanceof Object)\n            this.schema = options.schema;\n        else if (opt)\n            this.schema = new Schema.Schema(Object.assign(opt, options));\n        else\n            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);\n    }\n    // json & jsonArg are only used from toJSON()\n    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\n        const ctx = {\n            anchors: new Map(),\n            doc: this,\n            keep: !json,\n            mapAsMap: mapAsMap === true,\n            mapKeyWarned: false,\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100,\n            stringify: stringify.stringify\n        };\n        const res = toJS.toJS(this.contents, jsonArg ?? '', ctx);\n        if (typeof onAnchor === 'function')\n            for (const { count, res } of ctx.anchors.values())\n                onAnchor(res, count);\n        return typeof reviver === 'function'\n            ? applyReviver.applyReviver(reviver, { '': res }, '', res)\n            : res;\n    }\n    /**\n     * A JSON representation of the document `contents`.\n     *\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\n     *   property name.\n     */\n    toJSON(jsonArg, onAnchor) {\n        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });\n    }\n    /** A YAML representation of the document. */\n    toString(options = {}) {\n        if (this.errors.length > 0)\n            throw new Error('Document with errors cannot be stringified');\n        if ('indent' in options &&\n            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\n            const s = JSON.stringify(options.indent);\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\n        }\n        return stringifyDocument.stringifyDocument(this, options);\n    }\n}\nfunction assertCollection(contents) {\n    if (Node.isCollection(contents))\n        return true;\n    throw new Error('Expected a YAML collection as document contents');\n}\n\nexports.Document = Document;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/doc/Document.js?")},641:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\nvar visit = __webpack_require__(2479);\n\n/**\n * Verify that the input string is a valid anchor.\n *\n * Will throw on errors.\n */\nfunction anchorIsValid(anchor) {\n    if (/[\\x00-\\x19\\s,[\\]{}]/.test(anchor)) {\n        const sa = JSON.stringify(anchor);\n        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;\n        throw new Error(msg);\n    }\n    return true;\n}\nfunction anchorNames(root) {\n    const anchors = new Set();\n    visit.visit(root, {\n        Value(_key, node) {\n            if (node.anchor)\n                anchors.add(node.anchor);\n        }\n    });\n    return anchors;\n}\n/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */\nfunction findNewAnchor(prefix, exclude) {\n    for (let i = 1; true; ++i) {\n        const name = `${prefix}${i}`;\n        if (!exclude.has(name))\n            return name;\n    }\n}\nfunction createNodeAnchors(doc, prefix) {\n    const aliasObjects = [];\n    const sourceObjects = new Map();\n    let prevAnchors = null;\n    return {\n        onAnchor: (source) => {\n            aliasObjects.push(source);\n            if (!prevAnchors)\n                prevAnchors = anchorNames(doc);\n            const anchor = findNewAnchor(prefix, prevAnchors);\n            prevAnchors.add(anchor);\n            return anchor;\n        },\n        /**\n         * With circular references, the source node is only resolved after all\n         * of its child nodes are. This is why anchors are set only after all of\n         * the nodes have been created.\n         */\n        setAnchors: () => {\n            for (const source of aliasObjects) {\n                const ref = sourceObjects.get(source);\n                if (typeof ref === 'object' &&\n                    ref.anchor &&\n                    (Node.isScalar(ref.node) || Node.isCollection(ref.node))) {\n                    ref.node.anchor = ref.anchor;\n                }\n                else {\n                    const error = new Error('Failed to resolve repeated object (this should not happen)');\n                    error.source = source;\n                    throw error;\n                }\n            }\n        },\n        sourceObjects\n    };\n}\n\nexports.anchorIsValid = anchorIsValid;\nexports.anchorNames = anchorNames;\nexports.createNodeAnchors = createNodeAnchors;\nexports.findNewAnchor = findNewAnchor;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/doc/anchors.js?")},5183:(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,\n * in section 24.5.1.1 \"Runtime Semantics: InternalizeJSONProperty\" of the\n * 2021 edition: https://tc39.es/ecma262/#sec-json.parse\n *\n * Includes extensions for handling Map and Set objects.\n */\nfunction applyReviver(reviver, obj, key, val) {\n    if (val && typeof val === 'object') {\n        if (Array.isArray(val)) {\n            for (let i = 0, len = val.length; i < len; ++i) {\n                const v0 = val[i];\n                const v1 = applyReviver(reviver, val, String(i), v0);\n                if (v1 === undefined)\n                    delete val[i];\n                else if (v1 !== v0)\n                    val[i] = v1;\n            }\n        }\n        else if (val instanceof Map) {\n            for (const k of Array.from(val.keys())) {\n                const v0 = val.get(k);\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    val.delete(k);\n                else if (v1 !== v0)\n                    val.set(k, v1);\n            }\n        }\n        else if (val instanceof Set) {\n            for (const v0 of Array.from(val)) {\n                const v1 = applyReviver(reviver, val, v0, v0);\n                if (v1 === undefined)\n                    val.delete(v0);\n                else if (v1 !== v0) {\n                    val.delete(v0);\n                    val.add(v1);\n                }\n            }\n        }\n        else {\n            for (const [k, v0] of Object.entries(val)) {\n                const v1 = applyReviver(reviver, val, k, v0);\n                if (v1 === undefined)\n                    delete val[k];\n                else if (v1 !== v0)\n                    val[k] = v1;\n            }\n        }\n    }\n    return reviver.call(obj, key, val);\n}\n\nexports.applyReviver = applyReviver;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/doc/applyReviver.js?")},7507:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Alias = __webpack_require__(1528);\nvar Node = __webpack_require__(6058);\nvar Scalar = __webpack_require__(6686);\n\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\nfunction findTagObject(value, tagName, tags) {\n    if (tagName) {\n        const match = tags.filter(t => t.tag === tagName);\n        const tagObj = match.find(t => !t.format) ?? match[0];\n        if (!tagObj)\n            throw new Error(`Tag ${tagName} not found`);\n        return tagObj;\n    }\n    return tags.find(t => t.identify?.(value) && !t.format);\n}\nfunction createNode(value, tagName, ctx) {\n    if (Node.isDocument(value))\n        value = value.contents;\n    if (Node.isNode(value))\n        return value;\n    if (Node.isPair(value)) {\n        const map = ctx.schema[Node.MAP].createNode?.(ctx.schema, null, ctx);\n        map.items.push(value);\n        return map;\n    }\n    if (value instanceof String ||\n        value instanceof Number ||\n        value instanceof Boolean ||\n        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere\n    ) {\n        // https://tc39.es/ecma262/#sec-serializejsonproperty\n        value = value.valueOf();\n    }\n    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;\n    // Detect duplicate references to the same object & use Alias nodes for all\n    // after first. The `ref` wrapper allows for circular references to resolve.\n    let ref = undefined;\n    if (aliasDuplicateObjects && value && typeof value === 'object') {\n        ref = sourceObjects.get(value);\n        if (ref) {\n            if (!ref.anchor)\n                ref.anchor = onAnchor(value);\n            return new Alias.Alias(ref.anchor);\n        }\n        else {\n            ref = { anchor: null, node: null };\n            sourceObjects.set(value, ref);\n        }\n    }\n    if (tagName?.startsWith('!!'))\n        tagName = defaultTagPrefix + tagName.slice(2);\n    let tagObj = findTagObject(value, tagName, schema.tags);\n    if (!tagObj) {\n        if (value && typeof value.toJSON === 'function') {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            value = value.toJSON();\n        }\n        if (!value || typeof value !== 'object') {\n            const node = new Scalar.Scalar(value);\n            if (ref)\n                ref.node = node;\n            return node;\n        }\n        tagObj =\n            value instanceof Map\n                ? schema[Node.MAP]\n                : Symbol.iterator in Object(value)\n                    ? schema[Node.SEQ]\n                    : schema[Node.MAP];\n    }\n    if (onTagObj) {\n        onTagObj(tagObj);\n        delete ctx.onTagObj;\n    }\n    const node = tagObj?.createNode\n        ? tagObj.createNode(ctx.schema, value, ctx)\n        : new Scalar.Scalar(value);\n    if (tagName)\n        node.tag = tagName;\n    if (ref)\n        ref.node = node;\n    return node;\n}\n\nexports.createNode = createNode;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/doc/createNode.js?")},3019:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\nvar visit = __webpack_require__(2479);\n\nconst escapeChars = {\n    '!': '%21',\n    ',': '%2C',\n    '[': '%5B',\n    ']': '%5D',\n    '{': '%7B',\n    '}': '%7D'\n};\nconst escapeTagName = (tn) => tn.replace(/[!,[\\]{}]/g, ch => escapeChars[ch]);\nclass Directives {\n    constructor(yaml, tags) {\n        /**\n         * The directives-end/doc-start marker `---`. If `null`, a marker may still be\n         * included in the document's stringified representation.\n         */\n        this.docStart = null;\n        /** The doc-end marker `...`.  */\n        this.docEnd = false;\n        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);\n        this.tags = Object.assign({}, Directives.defaultTags, tags);\n    }\n    clone() {\n        const copy = new Directives(this.yaml, this.tags);\n        copy.docStart = this.docStart;\n        return copy;\n    }\n    /**\n     * During parsing, get a Directives instance for the current document and\n     * update the stream state according to the current version's spec.\n     */\n    atDocument() {\n        const res = new Directives(this.yaml, this.tags);\n        switch (this.yaml.version) {\n            case '1.1':\n                this.atNextDocument = true;\n                break;\n            case '1.2':\n                this.atNextDocument = false;\n                this.yaml = {\n                    explicit: Directives.defaultYaml.explicit,\n                    version: '1.2'\n                };\n                this.tags = Object.assign({}, Directives.defaultTags);\n                break;\n        }\n        return res;\n    }\n    /**\n     * @param onError - May be called even if the action was successful\n     * @returns `true` on success\n     */\n    add(line, onError) {\n        if (this.atNextDocument) {\n            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };\n            this.tags = Object.assign({}, Directives.defaultTags);\n            this.atNextDocument = false;\n        }\n        const parts = line.trim().split(/[ \\t]+/);\n        const name = parts.shift();\n        switch (name) {\n            case '%TAG': {\n                if (parts.length !== 2) {\n                    onError(0, '%TAG directive should contain exactly two parts');\n                    if (parts.length < 2)\n                        return false;\n                }\n                const [handle, prefix] = parts;\n                this.tags[handle] = prefix;\n                return true;\n            }\n            case '%YAML': {\n                this.yaml.explicit = true;\n                if (parts.length !== 1) {\n                    onError(0, '%YAML directive should contain exactly one part');\n                    return false;\n                }\n                const [version] = parts;\n                if (version === '1.1' || version === '1.2') {\n                    this.yaml.version = version;\n                    return true;\n                }\n                else {\n                    const isValid = /^\\d+\\.\\d+$/.test(version);\n                    onError(6, `Unsupported YAML version ${version}`, isValid);\n                    return false;\n                }\n            }\n            default:\n                onError(0, `Unknown directive ${name}`, true);\n                return false;\n        }\n    }\n    /**\n     * Resolves a tag, matching handles to those defined in %TAG directives.\n     *\n     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\n     *   `'!local'` tag, or `null` if unresolvable.\n     */\n    tagName(source, onError) {\n        if (source === '!')\n            return '!'; // non-specific tag\n        if (source[0] !== '!') {\n            onError(`Not a valid tag: ${source}`);\n            return null;\n        }\n        if (source[1] === '<') {\n            const verbatim = source.slice(2, -1);\n            if (verbatim === '!' || verbatim === '!!') {\n                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);\n                return null;\n            }\n            if (source[source.length - 1] !== '>')\n                onError('Verbatim tags must end with a >');\n            return verbatim;\n        }\n        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);\n        if (!suffix)\n            onError(`The ${source} tag has no suffix`);\n        const prefix = this.tags[handle];\n        if (prefix)\n            return prefix + decodeURIComponent(suffix);\n        if (handle === '!')\n            return source; // local tag\n        onError(`Could not resolve tag: ${source}`);\n        return null;\n    }\n    /**\n     * Given a fully resolved tag, returns its printable string form,\n     * taking into account current tag prefixes and defaults.\n     */\n    tagString(tag) {\n        for (const [handle, prefix] of Object.entries(this.tags)) {\n            if (tag.startsWith(prefix))\n                return handle + escapeTagName(tag.substring(prefix.length));\n        }\n        return tag[0] === '!' ? tag : `!<${tag}>`;\n    }\n    toString(doc) {\n        const lines = this.yaml.explicit\n            ? [`%YAML ${this.yaml.version || '1.2'}`]\n            : [];\n        const tagEntries = Object.entries(this.tags);\n        let tagNames;\n        if (doc && tagEntries.length > 0 && Node.isNode(doc.contents)) {\n            const tags = {};\n            visit.visit(doc.contents, (_key, node) => {\n                if (Node.isNode(node) && node.tag)\n                    tags[node.tag] = true;\n            });\n            tagNames = Object.keys(tags);\n        }\n        else\n            tagNames = [];\n        for (const [handle, prefix] of tagEntries) {\n            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')\n                continue;\n            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))\n                lines.push(`%TAG ${handle} ${prefix}`);\n        }\n        return lines.join('\\n');\n    }\n}\nDirectives.defaultYaml = { explicit: false, version: '1.2' };\nDirectives.defaultTags = { '!!': 'tag:yaml.org,2002:' };\n\nexports.Directives = Directives;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/doc/directives.js?")},5969:(__unused_webpack_module,exports)=>{"use strict";eval("\n\nclass YAMLError extends Error {\n    constructor(name, pos, code, message) {\n        super();\n        this.name = name;\n        this.code = code;\n        this.message = message;\n        this.pos = pos;\n    }\n}\nclass YAMLParseError extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLParseError', pos, code, message);\n    }\n}\nclass YAMLWarning extends YAMLError {\n    constructor(pos, code, message) {\n        super('YAMLWarning', pos, code, message);\n    }\n}\nconst prettifyError = (src, lc) => (error) => {\n    if (error.pos[0] === -1)\n        return;\n    error.linePos = error.pos.map(pos => lc.linePos(pos));\n    const { line, col } = error.linePos[0];\n    error.message += ` at line ${line}, column ${col}`;\n    let ci = col - 1;\n    let lineStr = src\n        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\n        .replace(/[\\n\\r]+$/, '');\n    // Trim to max 80 chars, keeping col position near the middle\n    if (ci >= 60 && lineStr.length > 80) {\n        const trimStart = Math.min(ci - 39, lineStr.length - 79);\n        lineStr = '' + lineStr.substring(trimStart);\n        ci -= trimStart - 1;\n    }\n    if (lineStr.length > 80)\n        lineStr = lineStr.substring(0, 79) + '';\n    // Include previous line in context if pointing at line start\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\n        // Regexp won't match if start is trimmed\n        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);\n        if (prev.length > 80)\n            prev = prev.substring(0, 79) + '\\n';\n        lineStr = prev + lineStr;\n    }\n    if (/[^ ]/.test(lineStr)) {\n        let count = 1;\n        const end = error.linePos[1];\n        if (end && end.line === line && end.col > col) {\n            count = Math.max(1, Math.min(end.col - col, 80 - ci));\n        }\n        const pointer = ' '.repeat(ci) + '^'.repeat(count);\n        error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`;\n    }\n};\n\nexports.YAMLError = YAMLError;\nexports.YAMLParseError = YAMLParseError;\nexports.YAMLWarning = YAMLWarning;\nexports.prettifyError = prettifyError;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/errors.js?")},6749:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar composer = __webpack_require__(4508);\nvar Document = __webpack_require__(7705);\nvar Schema = __webpack_require__(1150);\nvar errors = __webpack_require__(5969);\nvar Alias = __webpack_require__(1528);\nvar Node = __webpack_require__(6058);\nvar Pair = __webpack_require__(6775);\nvar Scalar = __webpack_require__(6686);\nvar YAMLMap = __webpack_require__(3140);\nvar YAMLSeq = __webpack_require__(6221);\nvar cst = __webpack_require__(7584);\nvar lexer = __webpack_require__(2013);\nvar lineCounter = __webpack_require__(895);\nvar parser = __webpack_require__(9853);\nvar publicApi = __webpack_require__(9995);\nvar visit = __webpack_require__(2479);\n\n\n\nexports.Composer = composer.Composer;\nexports.Document = Document.Document;\nexports.Schema = Schema.Schema;\nexports.YAMLError = errors.YAMLError;\nexports.YAMLParseError = errors.YAMLParseError;\nexports.YAMLWarning = errors.YAMLWarning;\nexports.Alias = Alias.Alias;\nexports.isAlias = Node.isAlias;\nexports.isCollection = Node.isCollection;\nexports.isDocument = Node.isDocument;\nexports.isMap = Node.isMap;\nexports.isNode = Node.isNode;\nexports.isPair = Node.isPair;\nexports.isScalar = Node.isScalar;\nexports.isSeq = Node.isSeq;\nexports.Pair = Pair.Pair;\nexports.Scalar = Scalar.Scalar;\nexports.YAMLMap = YAMLMap.YAMLMap;\nexports.YAMLSeq = YAMLSeq.YAMLSeq;\nexports.CST = cst;\nexports.Lexer = lexer.Lexer;\nexports.LineCounter = lineCounter.LineCounter;\nexports.Parser = parser.Parser;\nexports.parse = publicApi.parse;\nexports.parseAllDocuments = publicApi.parseAllDocuments;\nexports.parseDocument = publicApi.parseDocument;\nexports.stringify = publicApi.stringify;\nexports.visit = visit.visit;\nexports.visitAsync = visit.visitAsync;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/index.js?")},1357:(__unused_webpack_module,exports)=>{"use strict";eval("\n\nfunction debug(logLevel, ...messages) {\n    if (logLevel === 'debug')\n        console.log(...messages);\n}\nfunction warn(logLevel, warning) {\n    if (logLevel === 'debug' || logLevel === 'warn') {\n        if (typeof process !== 'undefined' && process.emitWarning)\n            process.emitWarning(warning);\n        else\n            console.warn(warning);\n    }\n}\n\nexports.debug = debug;\nexports.warn = warn;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/log.js?")},1528:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar anchors = __webpack_require__(641);\nvar visit = __webpack_require__(2479);\nvar Node = __webpack_require__(6058);\n\nclass Alias extends Node.NodeBase {\n    constructor(source) {\n        super(Node.ALIAS);\n        this.source = source;\n        Object.defineProperty(this, 'tag', {\n            set() {\n                throw new Error('Alias nodes cannot have tags');\n            }\n        });\n    }\n    /**\n     * Resolve the value of this alias within `doc`, finding the last\n     * instance of the `source` anchor before this node.\n     */\n    resolve(doc) {\n        let found = undefined;\n        visit.visit(doc, {\n            Node: (_key, node) => {\n                if (node === this)\n                    return visit.visit.BREAK;\n                if (node.anchor === this.source)\n                    found = node;\n            }\n        });\n        return found;\n    }\n    toJSON(_arg, ctx) {\n        if (!ctx)\n            return { source: this.source };\n        const { anchors, doc, maxAliasCount } = ctx;\n        const source = this.resolve(doc);\n        if (!source) {\n            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n            throw new ReferenceError(msg);\n        }\n        const data = anchors.get(source);\n        /* istanbul ignore if */\n        if (!data || data.res === undefined) {\n            const msg = 'This should not happen: Alias anchor was not resolved?';\n            throw new ReferenceError(msg);\n        }\n        if (maxAliasCount >= 0) {\n            data.count += 1;\n            if (data.aliasCount === 0)\n                data.aliasCount = getAliasCount(doc, source, anchors);\n            if (data.count * data.aliasCount > maxAliasCount) {\n                const msg = 'Excessive alias count indicates a resource exhaustion attack';\n                throw new ReferenceError(msg);\n            }\n        }\n        return data.res;\n    }\n    toString(ctx, _onComment, _onChompKeep) {\n        const src = `*${this.source}`;\n        if (ctx) {\n            anchors.anchorIsValid(this.source);\n            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\n                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\n                throw new Error(msg);\n            }\n            if (ctx.implicitKey)\n                return `${src} `;\n        }\n        return src;\n    }\n}\nfunction getAliasCount(doc, node, anchors) {\n    if (Node.isAlias(node)) {\n        const source = node.resolve(doc);\n        const anchor = anchors && source && anchors.get(source);\n        return anchor ? anchor.count * anchor.aliasCount : 0;\n    }\n    else if (Node.isCollection(node)) {\n        let count = 0;\n        for (const item of node.items) {\n            const c = getAliasCount(doc, item, anchors);\n            if (c > count)\n                count = c;\n        }\n        return count;\n    }\n    else if (Node.isPair(node)) {\n        const kc = getAliasCount(doc, node.key, anchors);\n        const vc = getAliasCount(doc, node.value, anchors);\n        return Math.max(kc, vc);\n    }\n    return 1;\n}\n\nexports.Alias = Alias;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/nodes/Alias.js?")},205:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar createNode = __webpack_require__(7507);\nvar Node = __webpack_require__(6058);\n\nfunction collectionFromPath(schema, path, value) {\n    let v = value;\n    for (let i = path.length - 1; i >= 0; --i) {\n        const k = path[i];\n        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\n            const a = [];\n            a[k] = v;\n            v = a;\n        }\n        else {\n            v = new Map([[k, v]]);\n        }\n    }\n    return createNode.createNode(v, undefined, {\n        aliasDuplicateObjects: false,\n        keepUndefined: false,\n        onAnchor: () => {\n            throw new Error('This should not happen, please report a bug.');\n        },\n        schema,\n        sourceObjects: new Map()\n    });\n}\n// Type guard is intentionally a little wrong so as to be more useful,\n// as it does not cover untypable empty non-string iterables (e.g. []).\nconst isEmptyPath = (path) => path == null ||\n    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);\nclass Collection extends Node.NodeBase {\n    constructor(type, schema) {\n        super(type);\n        Object.defineProperty(this, 'schema', {\n            value: schema,\n            configurable: true,\n            enumerable: false,\n            writable: true\n        });\n    }\n    /**\n     * Create a copy of this collection.\n     *\n     * @param schema - If defined, overwrites the original's schema\n     */\n    clone(schema) {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (schema)\n            copy.schema = schema;\n        copy.items = copy.items.map(it => Node.isNode(it) || Node.isPair(it) ? it.clone(schema) : it);\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n    /**\n     * Adds a value to the collection. For `!!map` and `!!omap` the value must\n     * be a Pair instance or a `{ key, value }` object, which may not have a key\n     * that already exists in the map.\n     */\n    addIn(path, value) {\n        if (isEmptyPath(path))\n            this.add(value);\n        else {\n            const [key, ...rest] = path;\n            const node = this.get(key, true);\n            if (Node.isCollection(node))\n                node.addIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n    /**\n     * Removes a value from the collection.\n     * @returns `true` if the item was found and removed.\n     */\n    deleteIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.delete(key);\n        const node = this.get(key, true);\n        if (Node.isCollection(node))\n            return node.deleteIn(rest);\n        else\n            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n    }\n    /**\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\n     * scalar values from their surrounding node; to disable set `keepScalar` to\n     * `true` (collections are always returned intact).\n     */\n    getIn(path, keepScalar) {\n        const [key, ...rest] = path;\n        const node = this.get(key, true);\n        if (rest.length === 0)\n            return !keepScalar && Node.isScalar(node) ? node.value : node;\n        else\n            return Node.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;\n    }\n    hasAllNullValues(allowScalar) {\n        return this.items.every(node => {\n            if (!Node.isPair(node))\n                return false;\n            const n = node.value;\n            return (n == null ||\n                (allowScalar &&\n                    Node.isScalar(n) &&\n                    n.value == null &&\n                    !n.commentBefore &&\n                    !n.comment &&\n                    !n.tag));\n        });\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     */\n    hasIn(path) {\n        const [key, ...rest] = path;\n        if (rest.length === 0)\n            return this.has(key);\n        const node = this.get(key, true);\n        return Node.isCollection(node) ? node.hasIn(rest) : false;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     */\n    setIn(path, value) {\n        const [key, ...rest] = path;\n        if (rest.length === 0) {\n            this.set(key, value);\n        }\n        else {\n            const node = this.get(key, true);\n            if (Node.isCollection(node))\n                node.setIn(rest, value);\n            else if (node === undefined && this.schema)\n                this.set(key, collectionFromPath(this.schema, rest, value));\n            else\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\n        }\n    }\n}\nCollection.maxFlowStringSingleLineLength = 60;\n\nexports.Collection = Collection;\nexports.collectionFromPath = collectionFromPath;\nexports.isEmptyPath = isEmptyPath;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/nodes/Collection.js?")},6058:(__unused_webpack_module,exports)=>{"use strict";eval("\n\nconst ALIAS = Symbol.for('yaml.alias');\nconst DOC = Symbol.for('yaml.document');\nconst MAP = Symbol.for('yaml.map');\nconst PAIR = Symbol.for('yaml.pair');\nconst SCALAR = Symbol.for('yaml.scalar');\nconst SEQ = Symbol.for('yaml.seq');\nconst NODE_TYPE = Symbol.for('yaml.node.type');\nconst isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;\nconst isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;\nconst isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;\nconst isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;\nconst isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;\nconst isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;\nfunction isCollection(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case MAP:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nfunction isNode(node) {\n    if (node && typeof node === 'object')\n        switch (node[NODE_TYPE]) {\n            case ALIAS:\n            case MAP:\n            case SCALAR:\n            case SEQ:\n                return true;\n        }\n    return false;\n}\nconst hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;\nclass NodeBase {\n    constructor(type) {\n        Object.defineProperty(this, NODE_TYPE, { value: type });\n    }\n    /** Create a copy of this node.  */\n    clone() {\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\n        if (this.range)\n            copy.range = this.range.slice();\n        return copy;\n    }\n}\n\nexports.ALIAS = ALIAS;\nexports.DOC = DOC;\nexports.MAP = MAP;\nexports.NODE_TYPE = NODE_TYPE;\nexports.NodeBase = NodeBase;\nexports.PAIR = PAIR;\nexports.SCALAR = SCALAR;\nexports.SEQ = SEQ;\nexports.hasAnchor = hasAnchor;\nexports.isAlias = isAlias;\nexports.isCollection = isCollection;\nexports.isDocument = isDocument;\nexports.isMap = isMap;\nexports.isNode = isNode;\nexports.isPair = isPair;\nexports.isScalar = isScalar;\nexports.isSeq = isSeq;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/nodes/Node.js?")},6775:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar createNode = __webpack_require__(7507);\nvar stringifyPair = __webpack_require__(376);\nvar addPairToJSMap = __webpack_require__(3752);\nvar Node = __webpack_require__(6058);\n\nfunction createPair(key, value, ctx) {\n    const k = createNode.createNode(key, undefined, ctx);\n    const v = createNode.createNode(value, undefined, ctx);\n    return new Pair(k, v);\n}\nclass Pair {\n    constructor(key, value = null) {\n        Object.defineProperty(this, Node.NODE_TYPE, { value: Node.PAIR });\n        this.key = key;\n        this.value = value;\n    }\n    clone(schema) {\n        let { key, value } = this;\n        if (Node.isNode(key))\n            key = key.clone(schema);\n        if (Node.isNode(value))\n            value = value.clone(schema);\n        return new Pair(key, value);\n    }\n    toJSON(_, ctx) {\n        const pair = ctx?.mapAsMap ? new Map() : {};\n        return addPairToJSMap.addPairToJSMap(ctx, pair, this);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        return ctx?.doc\n            ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep)\n            : JSON.stringify(this);\n    }\n}\n\nexports.Pair = Pair;\nexports.createPair = createPair;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/nodes/Pair.js?")},6686:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\nvar toJS = __webpack_require__(6001);\n\nconst isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');\nclass Scalar extends Node.NodeBase {\n    constructor(value) {\n        super(Node.SCALAR);\n        this.value = value;\n    }\n    toJSON(arg, ctx) {\n        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);\n    }\n    toString() {\n        return String(this.value);\n    }\n}\nScalar.BLOCK_FOLDED = 'BLOCK_FOLDED';\nScalar.BLOCK_LITERAL = 'BLOCK_LITERAL';\nScalar.PLAIN = 'PLAIN';\nScalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';\nScalar.QUOTE_SINGLE = 'QUOTE_SINGLE';\n\nexports.Scalar = Scalar;\nexports.isScalarValue = isScalarValue;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/nodes/Scalar.js?")},3140:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar stringifyCollection = __webpack_require__(8354);\nvar addPairToJSMap = __webpack_require__(3752);\nvar Collection = __webpack_require__(205);\nvar Node = __webpack_require__(6058);\nvar Pair = __webpack_require__(6775);\nvar Scalar = __webpack_require__(6686);\n\nfunction findPair(items, key) {\n    const k = Node.isScalar(key) ? key.value : key;\n    for (const it of items) {\n        if (Node.isPair(it)) {\n            if (it.key === key || it.key === k)\n                return it;\n            if (Node.isScalar(it.key) && it.key.value === k)\n                return it;\n        }\n    }\n    return undefined;\n}\nclass YAMLMap extends Collection.Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:map';\n    }\n    constructor(schema) {\n        super(Node.MAP, schema);\n        this.items = [];\n    }\n    /**\n     * Adds a value to the collection.\n     *\n     * @param overwrite - If not set `true`, using a key that is already in the\n     *   collection will throw. Otherwise, overwrites the previous value.\n     */\n    add(pair, overwrite) {\n        let _pair;\n        if (Node.isPair(pair))\n            _pair = pair;\n        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {\n            // In TypeScript, this never happens.\n            _pair = new Pair.Pair(pair, pair?.value);\n        }\n        else\n            _pair = new Pair.Pair(pair.key, pair.value);\n        const prev = findPair(this.items, _pair.key);\n        const sortEntries = this.schema?.sortMapEntries;\n        if (prev) {\n            if (!overwrite)\n                throw new Error(`Key ${_pair.key} already set`);\n            // For scalars, keep the old node & its comments and anchors\n            if (Node.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))\n                prev.value.value = _pair.value;\n            else\n                prev.value = _pair.value;\n        }\n        else if (sortEntries) {\n            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);\n            if (i === -1)\n                this.items.push(_pair);\n            else\n                this.items.splice(i, 0, _pair);\n        }\n        else {\n            this.items.push(_pair);\n        }\n    }\n    delete(key) {\n        const it = findPair(this.items, key);\n        if (!it)\n            return false;\n        const del = this.items.splice(this.items.indexOf(it), 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const it = findPair(this.items, key);\n        const node = it?.value;\n        return (!keepScalar && Node.isScalar(node) ? node.value : node) ?? undefined;\n    }\n    has(key) {\n        return !!findPair(this.items, key);\n    }\n    set(key, value) {\n        this.add(new Pair.Pair(key, value), true);\n    }\n    /**\n     * @param ctx - Conversion context, originally set in Document#toJS()\n     * @param {Class} Type - If set, forces the returned collection type\n     * @returns Instance of Type, Map, or Object\n     */\n    toJSON(_, ctx, Type) {\n        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const item of this.items)\n            addPairToJSMap.addPairToJSMap(ctx, map, item);\n        return map;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        for (const item of this.items) {\n            if (!Node.isPair(item))\n                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\n        }\n        if (!ctx.allNullValues && this.hasAllNullValues(false))\n            ctx = Object.assign({}, ctx, { allNullValues: true });\n        return stringifyCollection.stringifyCollection(this, ctx, {\n            blockItemPrefix: '',\n            flowChars: { start: '{', end: '}' },\n            itemIndent: ctx.indent || '',\n            onChompKeep,\n            onComment\n        });\n    }\n}\n\nexports.YAMLMap = YAMLMap;\nexports.findPair = findPair;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/nodes/YAMLMap.js?")},6221:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar stringifyCollection = __webpack_require__(8354);\nvar Collection = __webpack_require__(205);\nvar Node = __webpack_require__(6058);\nvar Scalar = __webpack_require__(6686);\nvar toJS = __webpack_require__(6001);\n\nclass YAMLSeq extends Collection.Collection {\n    static get tagName() {\n        return 'tag:yaml.org,2002:seq';\n    }\n    constructor(schema) {\n        super(Node.SEQ, schema);\n        this.items = [];\n    }\n    add(value) {\n        this.items.push(value);\n    }\n    /**\n     * Removes a value from the collection.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     *\n     * @returns `true` if the item was found and removed.\n     */\n    delete(key) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return false;\n        const del = this.items.splice(idx, 1);\n        return del.length > 0;\n    }\n    get(key, keepScalar) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            return undefined;\n        const it = this.items[idx];\n        return !keepScalar && Node.isScalar(it) ? it.value : it;\n    }\n    /**\n     * Checks if the collection includes a value with the key `key`.\n     *\n     * `key` must contain a representation of an integer for this to succeed.\n     * It may be wrapped in a `Scalar`.\n     */\n    has(key) {\n        const idx = asItemIndex(key);\n        return typeof idx === 'number' && idx < this.items.length;\n    }\n    /**\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\n     * boolean to add/remove the item from the set.\n     *\n     * If `key` does not contain a representation of an integer, this will throw.\n     * It may be wrapped in a `Scalar`.\n     */\n    set(key, value) {\n        const idx = asItemIndex(key);\n        if (typeof idx !== 'number')\n            throw new Error(`Expected a valid index, not ${key}.`);\n        const prev = this.items[idx];\n        if (Node.isScalar(prev) && Scalar.isScalarValue(value))\n            prev.value = value;\n        else\n            this.items[idx] = value;\n    }\n    toJSON(_, ctx) {\n        const seq = [];\n        if (ctx?.onCreate)\n            ctx.onCreate(seq);\n        let i = 0;\n        for (const item of this.items)\n            seq.push(toJS.toJS(item, String(i++), ctx));\n        return seq;\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        return stringifyCollection.stringifyCollection(this, ctx, {\n            blockItemPrefix: '- ',\n            flowChars: { start: '[', end: ']' },\n            itemIndent: (ctx.indent || '') + '  ',\n            onChompKeep,\n            onComment\n        });\n    }\n}\nfunction asItemIndex(key) {\n    let idx = Node.isScalar(key) ? key.value : key;\n    if (idx && typeof idx === 'string')\n        idx = Number(idx);\n    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0\n        ? idx\n        : null;\n}\n\nexports.YAMLSeq = YAMLSeq;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/nodes/YAMLSeq.js?")},3752:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar log = __webpack_require__(1357);\nvar stringify = __webpack_require__(5338);\nvar Node = __webpack_require__(6058);\nvar Scalar = __webpack_require__(6686);\nvar toJS = __webpack_require__(6001);\n\nconst MERGE_KEY = '<<';\nfunction addPairToJSMap(ctx, map, { key, value }) {\n    if (ctx?.doc.schema.merge && isMergeKey(key)) {\n        value = Node.isAlias(value) ? value.resolve(ctx.doc) : value;\n        if (Node.isSeq(value))\n            for (const it of value.items)\n                mergeToJSMap(ctx, map, it);\n        else if (Array.isArray(value))\n            for (const it of value)\n                mergeToJSMap(ctx, map, it);\n        else\n            mergeToJSMap(ctx, map, value);\n    }\n    else {\n        const jsKey = toJS.toJS(key, '', ctx);\n        if (map instanceof Map) {\n            map.set(jsKey, toJS.toJS(value, jsKey, ctx));\n        }\n        else if (map instanceof Set) {\n            map.add(jsKey);\n        }\n        else {\n            const stringKey = stringifyKey(key, jsKey, ctx);\n            const jsValue = toJS.toJS(value, stringKey, ctx);\n            if (stringKey in map)\n                Object.defineProperty(map, stringKey, {\n                    value: jsValue,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n            else\n                map[stringKey] = jsValue;\n        }\n    }\n    return map;\n}\nconst isMergeKey = (key) => key === MERGE_KEY ||\n    (Node.isScalar(key) &&\n        key.value === MERGE_KEY &&\n        (!key.type || key.type === Scalar.Scalar.PLAIN));\n// If the value associated with a merge key is a single mapping node, each of\n// its key/value pairs is inserted into the current mapping, unless the key\n// already exists in it. If the value associated with the merge key is a\n// sequence, then this sequence is expected to contain mapping nodes and each\n// of these nodes is merged in turn according to its order in the sequence.\n// Keys in mapping nodes earlier in the sequence override keys specified in\n// later mapping nodes. -- http://yaml.org/type/merge.html\nfunction mergeToJSMap(ctx, map, value) {\n    const source = ctx && Node.isAlias(value) ? value.resolve(ctx.doc) : value;\n    if (!Node.isMap(source))\n        throw new Error('Merge sources must be maps or map aliases');\n    const srcMap = source.toJSON(null, ctx, Map);\n    for (const [key, value] of srcMap) {\n        if (map instanceof Map) {\n            if (!map.has(key))\n                map.set(key, value);\n        }\n        else if (map instanceof Set) {\n            map.add(key);\n        }\n        else if (!Object.prototype.hasOwnProperty.call(map, key)) {\n            Object.defineProperty(map, key, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n    }\n    return map;\n}\nfunction stringifyKey(key, jsKey, ctx) {\n    if (jsKey === null)\n        return '';\n    if (typeof jsKey !== 'object')\n        return String(jsKey);\n    if (Node.isNode(key) && ctx && ctx.doc) {\n        const strCtx = stringify.createStringifyContext(ctx.doc, {});\n        strCtx.anchors = new Set();\n        for (const node of ctx.anchors.keys())\n            strCtx.anchors.add(node.anchor);\n        strCtx.inFlow = true;\n        strCtx.inStringifyKey = true;\n        const strKey = key.toString(strCtx);\n        if (!ctx.mapKeyWarned) {\n            let jsonStr = JSON.stringify(strKey);\n            if (jsonStr.length > 40)\n                jsonStr = jsonStr.substring(0, 36) + '...\"';\n            log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\n            ctx.mapKeyWarned = true;\n        }\n        return strKey;\n    }\n    return JSON.stringify(jsKey);\n}\n\nexports.addPairToJSMap = addPairToJSMap;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/nodes/addPairToJSMap.js?")},6001:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\n\n/**\n * Recursively convert any node or its contents to native JavaScript\n *\n * @param value - The input value\n * @param arg - If `value` defines a `toJSON()` method, use this\n *   as its first argument\n * @param ctx - Conversion context, originally set in Document#toJS(). If\n *   `{ keep: true }` is not set, output should be suitable for JSON\n *   stringification.\n */\nfunction toJS(value, arg, ctx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    if (Array.isArray(value))\n        return value.map((v, i) => toJS(v, String(i), ctx));\n    if (value && typeof value.toJSON === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        if (!ctx || !Node.hasAnchor(value))\n            return value.toJSON(arg, ctx);\n        const data = { aliasCount: 0, count: 1, res: undefined };\n        ctx.anchors.set(value, data);\n        ctx.onCreate = res => {\n            data.res = res;\n            delete ctx.onCreate;\n        };\n        const res = value.toJSON(arg, ctx);\n        if (ctx.onCreate)\n            ctx.onCreate(res);\n        return res;\n    }\n    if (typeof value === 'bigint' && !ctx?.keep)\n        return Number(value);\n    return value;\n}\n\nexports.toJS = toJS;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/nodes/toJS.js?")},7984:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar resolveBlockScalar = __webpack_require__(2870);\nvar resolveFlowScalar = __webpack_require__(1677);\nvar errors = __webpack_require__(5969);\nvar stringifyString = __webpack_require__(396);\n\nfunction resolveAsScalar(token, strict = true, onError) {\n    if (token) {\n        const _onError = (pos, code, message) => {\n            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\n            if (onError)\n                onError(offset, code, message);\n            else\n                throw new errors.YAMLParseError([offset, offset + 1], code, message);\n        };\n        switch (token.type) {\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);\n            case 'block-scalar':\n                return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);\n        }\n    }\n    return null;\n}\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction createScalarToken(value, context) {\n    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;\n    const source = stringifyString.stringifyString({ type, value }, {\n        implicitKey,\n        indent: indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    const end = context.end ?? [\n        { type: 'newline', offset: -1, indent, source: '\\n' }\n    ];\n    switch (source[0]) {\n        case '|':\n        case '>': {\n            const he = source.indexOf('\\n');\n            const head = source.substring(0, he);\n            const body = source.substring(he + 1) + '\\n';\n            const props = [\n                { type: 'block-scalar-header', offset, indent, source: head }\n            ];\n            if (!addEndtoBlockProps(props, end))\n                props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n            return { type: 'block-scalar', offset, indent, props, source: body };\n        }\n        case '\"':\n            return { type: 'double-quoted-scalar', offset, indent, source, end };\n        case \"'\":\n            return { type: 'single-quoted-scalar', offset, indent, source, end };\n        default:\n            return { type: 'scalar', offset, indent, source, end };\n    }\n}\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction setScalarValue(token, value, context = {}) {\n    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;\n    let indent = 'indent' in token ? token.indent : null;\n    if (afterKey && typeof indent === 'number')\n        indent += 2;\n    if (!type)\n        switch (token.type) {\n            case 'single-quoted-scalar':\n                type = 'QUOTE_SINGLE';\n                break;\n            case 'double-quoted-scalar':\n                type = 'QUOTE_DOUBLE';\n                break;\n            case 'block-scalar': {\n                const header = token.props[0];\n                if (header.type !== 'block-scalar-header')\n                    throw new Error('Invalid block scalar header');\n                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\n                break;\n            }\n            default:\n                type = 'PLAIN';\n        }\n    const source = stringifyString.stringifyString({ type, value }, {\n        implicitKey: implicitKey || indent === null,\n        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\n        inFlow,\n        options: { blockQuote: true, lineWidth: -1 }\n    });\n    switch (source[0]) {\n        case '|':\n        case '>':\n            setBlockScalarValue(token, source);\n            break;\n        case '\"':\n            setFlowScalarValue(token, source, 'double-quoted-scalar');\n            break;\n        case \"'\":\n            setFlowScalarValue(token, source, 'single-quoted-scalar');\n            break;\n        default:\n            setFlowScalarValue(token, source, 'scalar');\n    }\n}\nfunction setBlockScalarValue(token, source) {\n    const he = source.indexOf('\\n');\n    const head = source.substring(0, he);\n    const body = source.substring(he + 1) + '\\n';\n    if (token.type === 'block-scalar') {\n        const header = token.props[0];\n        if (header.type !== 'block-scalar-header')\n            throw new Error('Invalid block scalar header');\n        header.source = head;\n        token.source = body;\n    }\n    else {\n        const { offset } = token;\n        const indent = 'indent' in token ? token.indent : -1;\n        const props = [\n            { type: 'block-scalar-header', offset, indent, source: head }\n        ];\n        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))\n            props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\n        for (const key of Object.keys(token))\n            if (key !== 'type' && key !== 'offset')\n                delete token[key];\n        Object.assign(token, { type: 'block-scalar', indent, props, source: body });\n    }\n}\n/** @returns `true` if last token is a newline */\nfunction addEndtoBlockProps(props, end) {\n    if (end)\n        for (const st of end)\n            switch (st.type) {\n                case 'space':\n                case 'comment':\n                    props.push(st);\n                    break;\n                case 'newline':\n                    props.push(st);\n                    return true;\n            }\n    return false;\n}\nfunction setFlowScalarValue(token, source, type) {\n    switch (token.type) {\n        case 'scalar':\n        case 'double-quoted-scalar':\n        case 'single-quoted-scalar':\n            token.type = type;\n            token.source = source;\n            break;\n        case 'block-scalar': {\n            const end = token.props.slice(1);\n            let oa = source.length;\n            if (token.props[0].type === 'block-scalar-header')\n                oa -= token.props[0].source.length;\n            for (const tok of end)\n                tok.offset += oa;\n            delete token.props;\n            Object.assign(token, { type, source, end });\n            break;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            const offset = token.offset + source.length;\n            const nl = { type: 'newline', offset, indent: token.indent, source: '\\n' };\n            delete token.items;\n            Object.assign(token, { type, source, end: [nl] });\n            break;\n        }\n        default: {\n            const indent = 'indent' in token ? token.indent : -1;\n            const end = 'end' in token && Array.isArray(token.end)\n                ? token.end.filter(st => st.type === 'space' ||\n                    st.type === 'comment' ||\n                    st.type === 'newline')\n                : [];\n            for (const key of Object.keys(token))\n                if (key !== 'type' && key !== 'offset')\n                    delete token[key];\n            Object.assign(token, { type, indent, source, end });\n        }\n    }\n}\n\nexports.createScalarToken = createScalarToken;\nexports.resolveAsScalar = resolveAsScalar;\nexports.setScalarValue = setScalarValue;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/parse/cst-scalar.js?")},9322:(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Stringify a CST document, token, or collection item\n *\n * Fair warning: This applies no validation whatsoever, and\n * simply concatenates the sources in their logical order.\n */\nconst stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);\nfunction stringifyToken(token) {\n    switch (token.type) {\n        case 'block-scalar': {\n            let res = '';\n            for (const tok of token.props)\n                res += stringifyToken(tok);\n            return res + token.source;\n        }\n        case 'block-map':\n        case 'block-seq': {\n            let res = '';\n            for (const item of token.items)\n                res += stringifyItem(item);\n            return res;\n        }\n        case 'flow-collection': {\n            let res = token.start.source;\n            for (const item of token.items)\n                res += stringifyItem(item);\n            for (const st of token.end)\n                res += st.source;\n            return res;\n        }\n        case 'document': {\n            let res = stringifyItem(token);\n            if (token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n        default: {\n            let res = token.source;\n            if ('end' in token && token.end)\n                for (const st of token.end)\n                    res += st.source;\n            return res;\n        }\n    }\n}\nfunction stringifyItem({ start, key, sep, value }) {\n    let res = '';\n    for (const st of start)\n        res += st.source;\n    if (key)\n        res += stringifyToken(key);\n    if (sep)\n        for (const st of sep)\n            res += st.source;\n    if (value)\n        res += stringifyToken(value);\n    return res;\n}\n\nexports.stringify = stringify;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/parse/cst-stringify.js?")},4899:(__unused_webpack_module,exports)=>{"use strict";eval("\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove item');\n/**\n * Apply a visitor to a CST document or item.\n *\n * Walks through the tree (depth-first) starting from the root, calling a\n * `visitor` function with two arguments when entering each item:\n *   - `item`: The current item, which included the following members:\n *     - `start: SourceToken[]`  Source tokens before the key or value,\n *       possibly including its anchor or tag.\n *     - `key?: Token | null`  Set for pair values. May then be `null`, if\n *       the key before the `:` separator is empty.\n *     - `sep?: SourceToken[]`  Source tokens between the key and the value,\n *       which should include the `:` map value indicator if `value` is set.\n *     - `value?: Token`  The value of a sequence item, or of a map pair.\n *   - `path`: The steps from the root to the current node, as an array of\n *     `['key' | 'value', number]` tuples.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this token, continue with\n *      next sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current item, then continue with the next one\n *   - `number`: Set the index of the next step. This is useful especially if\n *     the index of the current token has changed.\n *   - `function`: Define the next visitor for this item. After the original\n *     visitor is called on item entry, next visitors are called after handling\n *     a non-empty `key` and when exiting the item.\n */\nfunction visit(cst, visitor) {\n    if ('type' in cst && cst.type === 'document')\n        cst = { start: cst.start, value: cst.value };\n    _visit(Object.freeze([]), cst, visitor);\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current item */\nvisit.SKIP = SKIP;\n/** Remove the current item */\nvisit.REMOVE = REMOVE;\n/** Find the item at `path` from `cst` as the root */\nvisit.itemAtPath = (cst, path) => {\n    let item = cst;\n    for (const [field, index] of path) {\n        const tok = item?.[field];\n        if (tok && 'items' in tok) {\n            item = tok.items[index];\n        }\n        else\n            return undefined;\n    }\n    return item;\n};\n/**\n * Get the immediate parent collection of the item at `path` from `cst` as the root.\n *\n * Throws an error if the collection is not found, which should never happen if the item itself exists.\n */\nvisit.parentCollection = (cst, path) => {\n    const parent = visit.itemAtPath(cst, path.slice(0, -1));\n    const field = path[path.length - 1][0];\n    const coll = parent?.[field];\n    if (coll && 'items' in coll)\n        return coll;\n    throw new Error('Parent collection not found');\n};\nfunction _visit(path, item, visitor) {\n    let ctrl = visitor(item, path);\n    if (typeof ctrl === 'symbol')\n        return ctrl;\n    for (const field of ['key', 'value']) {\n        const token = item[field];\n        if (token && 'items' in token) {\n            for (let i = 0; i < token.items.length; ++i) {\n                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    token.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n            if (typeof ctrl === 'function' && field === 'key')\n                ctrl = ctrl(item, path);\n        }\n    }\n    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;\n}\n\nexports.visit = visit;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/parse/cst-visit.js?")},7584:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar cstScalar = __webpack_require__(7984);\nvar cstStringify = __webpack_require__(9322);\nvar cstVisit = __webpack_require__(4899);\n\n/** The byte order mark */\nconst BOM = '\\u{FEFF}';\n/** Start of doc-mode */\nconst DOCUMENT = '\\x02'; // C0: Start of Text\n/** Unexpected end of flow-mode */\nconst FLOW_END = '\\x18'; // C0: Cancel\n/** Next token is a scalar value */\nconst SCALAR = '\\x1f'; // C0: Unit Separator\n/** @returns `true` if `token` is a flow or block collection */\nconst isCollection = (token) => !!token && 'items' in token;\n/** @returns `true` if `token` is a flow or block scalar; not an alias */\nconst isScalar = (token) => !!token &&\n    (token.type === 'scalar' ||\n        token.type === 'single-quoted-scalar' ||\n        token.type === 'double-quoted-scalar' ||\n        token.type === 'block-scalar');\n/* istanbul ignore next */\n/** Get a printable representation of a lexer token */\nfunction prettyToken(token) {\n    switch (token) {\n        case BOM:\n            return '<BOM>';\n        case DOCUMENT:\n            return '<DOC>';\n        case FLOW_END:\n            return '<FLOW_END>';\n        case SCALAR:\n            return '<SCALAR>';\n        default:\n            return JSON.stringify(token);\n    }\n}\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\nfunction tokenType(source) {\n    switch (source) {\n        case BOM:\n            return 'byte-order-mark';\n        case DOCUMENT:\n            return 'doc-mode';\n        case FLOW_END:\n            return 'flow-error-end';\n        case SCALAR:\n            return 'scalar';\n        case '---':\n            return 'doc-start';\n        case '...':\n            return 'doc-end';\n        case '':\n        case '\\n':\n        case '\\r\\n':\n            return 'newline';\n        case '-':\n            return 'seq-item-ind';\n        case '?':\n            return 'explicit-key-ind';\n        case ':':\n            return 'map-value-ind';\n        case '{':\n            return 'flow-map-start';\n        case '}':\n            return 'flow-map-end';\n        case '[':\n            return 'flow-seq-start';\n        case ']':\n            return 'flow-seq-end';\n        case ',':\n            return 'comma';\n    }\n    switch (source[0]) {\n        case ' ':\n        case '\\t':\n            return 'space';\n        case '#':\n            return 'comment';\n        case '%':\n            return 'directive-line';\n        case '*':\n            return 'alias';\n        case '&':\n            return 'anchor';\n        case '!':\n            return 'tag';\n        case \"'\":\n            return 'single-quoted-scalar';\n        case '\"':\n            return 'double-quoted-scalar';\n        case '|':\n        case '>':\n            return 'block-scalar-header';\n    }\n    return null;\n}\n\nexports.createScalarToken = cstScalar.createScalarToken;\nexports.resolveAsScalar = cstScalar.resolveAsScalar;\nexports.setScalarValue = cstScalar.setScalarValue;\nexports.stringify = cstStringify.stringify;\nexports.visit = cstVisit.visit;\nexports.BOM = BOM;\nexports.DOCUMENT = DOCUMENT;\nexports.FLOW_END = FLOW_END;\nexports.SCALAR = SCALAR;\nexports.isCollection = isCollection;\nexports.isScalar = isScalar;\nexports.prettyToken = prettyToken;\nexports.tokenType = tokenType;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/parse/cst.js?")},2013:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar cst = __webpack_require__(7584);\n\n/*\nSTART -> stream\n\nstream\n  directive -> line-end -> stream\n  indent + line-end -> stream\n  [else] -> line-start\n\nline-end\n  comment -> line-end\n  newline -> .\n  input-end -> END\n\nline-start\n  doc-start -> doc\n  doc-end -> stream\n  [else] -> indent -> block-start\n\nblock-start\n  seq-item-start -> block-start\n  explicit-key-start -> block-start\n  map-value-start -> block-start\n  [else] -> doc\n\ndoc\n  line-end -> line-start\n  spaces -> doc\n  anchor -> doc\n  tag -> doc\n  flow-start -> flow -> doc\n  flow-end -> error -> doc\n  seq-item-start -> error -> doc\n  explicit-key-start -> error -> doc\n  map-value-start -> doc\n  alias -> doc\n  quote-start -> quoted-scalar -> doc\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\n  [else] -> plain-scalar(false, min) -> doc\n\nflow\n  line-end -> flow\n  spaces -> flow\n  anchor -> flow\n  tag -> flow\n  flow-start -> flow -> flow\n  flow-end -> .\n  seq-item-start -> error -> flow\n  explicit-key-start -> flow\n  map-value-start -> flow\n  alias -> flow\n  quote-start -> quoted-scalar -> flow\n  comma -> flow\n  [else] -> plain-scalar(true, 0) -> flow\n\nquoted-scalar\n  quote-end -> .\n  [else] -> quoted-scalar\n\nblock-scalar(min)\n  newline + peek(indent < min) -> .\n  [else] -> block-scalar(min)\n\nplain-scalar(is-flow, min)\n  scalar-end(is-flow) -> .\n  peek(newline + (indent < min)) -> .\n  [else] -> plain-scalar(min)\n*/\nfunction isEmpty(ch) {\n    switch (ch) {\n        case undefined:\n        case ' ':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n            return true;\n        default:\n            return false;\n    }\n}\nconst hexDigits = '0123456789ABCDEFabcdef'.split('');\nconst tagChars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\".split('');\nconst invalidFlowScalarChars = ',[]{}'.split('');\nconst invalidAnchorChars = ' ,[]{}\\n\\r\\t'.split('');\nconst isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);\n/**\n * Splits an input string into lexical tokens, i.e. smaller strings that are\n * easily identifiable by `tokens.tokenType()`.\n *\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\n * until a complete token can be emitted.\n *\n * In addition to slices of the original input, the following control characters\n * may also be emitted:\n *\n * - `\\x02` (Start of Text): A document starts with the next token\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\n * - `\\x1f` (Unit Separator): Next token is a scalar value\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\n */\nclass Lexer {\n    constructor() {\n        /**\n         * Flag indicating whether the end of the current buffer marks the end of\n         * all input\n         */\n        this.atEnd = false;\n        /**\n         * Explicit indent set in block scalar header, as an offset from the current\n         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\n         * explicitly set.\n         */\n        this.blockScalarIndent = -1;\n        /**\n         * Block scalars that include a + (keep) chomping indicator in their header\n         * include trailing empty lines, which are otherwise excluded from the\n         * scalar's contents.\n         */\n        this.blockScalarKeep = false;\n        /** Current input */\n        this.buffer = '';\n        /**\n         * Flag noting whether the map value indicator : can immediately follow this\n         * node within a flow context.\n         */\n        this.flowKey = false;\n        /** Count of surrounding flow collection levels. */\n        this.flowLevel = 0;\n        /**\n         * Minimum level of indentation required for next lines to be parsed as a\n         * part of the current scalar value.\n         */\n        this.indentNext = 0;\n        /** Indentation level of the current line. */\n        this.indentValue = 0;\n        /** Position of the next \\n character. */\n        this.lineEndPos = null;\n        /** Stores the state of the lexer if reaching the end of incpomplete input */\n        this.next = null;\n        /** A pointer to `buffer`; the current position of the lexer. */\n        this.pos = 0;\n    }\n    /**\n     * Generate YAML tokens from the `source` string. If `incomplete`,\n     * a part of the last line may be left as a buffer for the next call.\n     *\n     * @returns A generator of lexical tokens\n     */\n    *lex(source, incomplete = false) {\n        if (source) {\n            this.buffer = this.buffer ? this.buffer + source : source;\n            this.lineEndPos = null;\n        }\n        this.atEnd = !incomplete;\n        let next = this.next ?? 'stream';\n        while (next && (incomplete || this.hasChars(1)))\n            next = yield* this.parseNext(next);\n    }\n    atLineEnd() {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (ch === ' ' || ch === '\\t')\n            ch = this.buffer[++i];\n        if (!ch || ch === '#' || ch === '\\n')\n            return true;\n        if (ch === '\\r')\n            return this.buffer[i + 1] === '\\n';\n        return false;\n    }\n    charAt(n) {\n        return this.buffer[this.pos + n];\n    }\n    continueScalar(offset) {\n        let ch = this.buffer[offset];\n        if (this.indentNext > 0) {\n            let indent = 0;\n            while (ch === ' ')\n                ch = this.buffer[++indent + offset];\n            if (ch === '\\r') {\n                const next = this.buffer[indent + offset + 1];\n                if (next === '\\n' || (!next && !this.atEnd))\n                    return offset + indent + 1;\n            }\n            return ch === '\\n' || indent >= this.indentNext || (!ch && !this.atEnd)\n                ? offset + indent\n                : -1;\n        }\n        if (ch === '-' || ch === '.') {\n            const dt = this.buffer.substr(offset, 3);\n            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))\n                return -1;\n        }\n        return offset;\n    }\n    getLine() {\n        let end = this.lineEndPos;\n        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {\n            end = this.buffer.indexOf('\\n', this.pos);\n            this.lineEndPos = end;\n        }\n        if (end === -1)\n            return this.atEnd ? this.buffer.substring(this.pos) : null;\n        if (this.buffer[end - 1] === '\\r')\n            end -= 1;\n        return this.buffer.substring(this.pos, end);\n    }\n    hasChars(n) {\n        return this.pos + n <= this.buffer.length;\n    }\n    setNext(state) {\n        this.buffer = this.buffer.substring(this.pos);\n        this.pos = 0;\n        this.lineEndPos = null;\n        this.next = state;\n        return null;\n    }\n    peek(n) {\n        return this.buffer.substr(this.pos, n);\n    }\n    *parseNext(next) {\n        switch (next) {\n            case 'stream':\n                return yield* this.parseStream();\n            case 'line-start':\n                return yield* this.parseLineStart();\n            case 'block-start':\n                return yield* this.parseBlockStart();\n            case 'doc':\n                return yield* this.parseDocument();\n            case 'flow':\n                return yield* this.parseFlowCollection();\n            case 'quoted-scalar':\n                return yield* this.parseQuotedScalar();\n            case 'block-scalar':\n                return yield* this.parseBlockScalar();\n            case 'plain-scalar':\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseStream() {\n        let line = this.getLine();\n        if (line === null)\n            return this.setNext('stream');\n        if (line[0] === cst.BOM) {\n            yield* this.pushCount(1);\n            line = line.substring(1);\n        }\n        if (line[0] === '%') {\n            let dirEnd = line.length;\n            const cs = line.indexOf('#');\n            if (cs !== -1) {\n                const ch = line[cs - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd = cs - 1;\n            }\n            while (true) {\n                const ch = line[dirEnd - 1];\n                if (ch === ' ' || ch === '\\t')\n                    dirEnd -= 1;\n                else\n                    break;\n            }\n            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\n            yield* this.pushCount(line.length - n); // possible comment\n            this.pushNewline();\n            return 'stream';\n        }\n        if (this.atLineEnd()) {\n            const sp = yield* this.pushSpaces(true);\n            yield* this.pushCount(line.length - sp);\n            yield* this.pushNewline();\n            return 'stream';\n        }\n        yield cst.DOCUMENT;\n        return yield* this.parseLineStart();\n    }\n    *parseLineStart() {\n        const ch = this.charAt(0);\n        if (!ch && !this.atEnd)\n            return this.setNext('line-start');\n        if (ch === '-' || ch === '.') {\n            if (!this.atEnd && !this.hasChars(4))\n                return this.setNext('line-start');\n            const s = this.peek(3);\n            if (s === '---' && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                this.indentValue = 0;\n                this.indentNext = 0;\n                return 'doc';\n            }\n            else if (s === '...' && isEmpty(this.charAt(3))) {\n                yield* this.pushCount(3);\n                return 'stream';\n            }\n        }\n        this.indentValue = yield* this.pushSpaces(false);\n        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))\n            this.indentNext = this.indentValue;\n        return yield* this.parseBlockStart();\n    }\n    *parseBlockStart() {\n        const [ch0, ch1] = this.peek(2);\n        if (!ch1 && !this.atEnd)\n            return this.setNext('block-start');\n        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\n            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\n            this.indentNext = this.indentValue + 1;\n            this.indentValue += n;\n            return yield* this.parseBlockStart();\n        }\n        return 'doc';\n    }\n    *parseDocument() {\n        yield* this.pushSpaces(true);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('doc');\n        let n = yield* this.pushIndicators();\n        switch (line[n]) {\n            case '#':\n                yield* this.pushCount(line.length - n);\n            // fallthrough\n            case undefined:\n                yield* this.pushNewline();\n                return yield* this.parseLineStart();\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel = 1;\n                return 'flow';\n            case '}':\n            case ']':\n                // this is an error\n                yield* this.pushCount(1);\n                return 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'doc';\n            case '\"':\n            case \"'\":\n                return yield* this.parseQuotedScalar();\n            case '|':\n            case '>':\n                n += yield* this.parseBlockScalarHeader();\n                n += yield* this.pushSpaces(true);\n                yield* this.pushCount(line.length - n);\n                yield* this.pushNewline();\n                return yield* this.parseBlockScalar();\n            default:\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseFlowCollection() {\n        let nl, sp;\n        let indent = -1;\n        do {\n            nl = yield* this.pushNewline();\n            if (nl > 0) {\n                sp = yield* this.pushSpaces(false);\n                this.indentValue = indent = sp;\n            }\n            else {\n                sp = 0;\n            }\n            sp += yield* this.pushSpaces(true);\n        } while (nl + sp > 0);\n        const line = this.getLine();\n        if (line === null)\n            return this.setNext('flow');\n        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||\n            (indent === 0 &&\n                (line.startsWith('---') || line.startsWith('...')) &&\n                isEmpty(line[3]))) {\n            // Allowing for the terminal ] or } at the same (rather than greater)\n            // indent level as the initial [ or { is technically invalid, but\n            // failing here would be surprising to users.\n            const atFlowEndMarker = indent === this.indentNext - 1 &&\n                this.flowLevel === 1 &&\n                (line[0] === ']' || line[0] === '}');\n            if (!atFlowEndMarker) {\n                // this is an error\n                this.flowLevel = 0;\n                yield cst.FLOW_END;\n                return yield* this.parseLineStart();\n            }\n        }\n        let n = 0;\n        while (line[n] === ',') {\n            n += yield* this.pushCount(1);\n            n += yield* this.pushSpaces(true);\n            this.flowKey = false;\n        }\n        n += yield* this.pushIndicators();\n        switch (line[n]) {\n            case undefined:\n                return 'flow';\n            case '#':\n                yield* this.pushCount(line.length - n);\n                return 'flow';\n            case '{':\n            case '[':\n                yield* this.pushCount(1);\n                this.flowKey = false;\n                this.flowLevel += 1;\n                return 'flow';\n            case '}':\n            case ']':\n                yield* this.pushCount(1);\n                this.flowKey = true;\n                this.flowLevel -= 1;\n                return this.flowLevel ? 'flow' : 'doc';\n            case '*':\n                yield* this.pushUntil(isNotAnchorChar);\n                return 'flow';\n            case '\"':\n            case \"'\":\n                this.flowKey = true;\n                return yield* this.parseQuotedScalar();\n            case ':': {\n                const next = this.charAt(1);\n                if (this.flowKey || isEmpty(next) || next === ',') {\n                    this.flowKey = false;\n                    yield* this.pushCount(1);\n                    yield* this.pushSpaces(true);\n                    return 'flow';\n                }\n            }\n            // fallthrough\n            default:\n                this.flowKey = false;\n                return yield* this.parsePlainScalar();\n        }\n    }\n    *parseQuotedScalar() {\n        const quote = this.charAt(0);\n        let end = this.buffer.indexOf(quote, this.pos + 1);\n        if (quote === \"'\") {\n            while (end !== -1 && this.buffer[end + 1] === \"'\")\n                end = this.buffer.indexOf(\"'\", end + 2);\n        }\n        else {\n            // double-quote\n            while (end !== -1) {\n                let n = 0;\n                while (this.buffer[end - 1 - n] === '\\\\')\n                    n += 1;\n                if (n % 2 === 0)\n                    break;\n                end = this.buffer.indexOf('\"', end + 1);\n            }\n        }\n        // Only looking for newlines within the quotes\n        const qb = this.buffer.substring(0, end);\n        let nl = qb.indexOf('\\n', this.pos);\n        if (nl !== -1) {\n            while (nl !== -1) {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = qb.indexOf('\\n', cs);\n            }\n            if (nl !== -1) {\n                // this is an error caused by an unexpected unindent\n                end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\n            }\n        }\n        if (end === -1) {\n            if (!this.atEnd)\n                return this.setNext('quoted-scalar');\n            end = this.buffer.length;\n        }\n        yield* this.pushToIndex(end + 1, false);\n        return this.flowLevel ? 'flow' : 'doc';\n    }\n    *parseBlockScalarHeader() {\n        this.blockScalarIndent = -1;\n        this.blockScalarKeep = false;\n        let i = this.pos;\n        while (true) {\n            const ch = this.buffer[++i];\n            if (ch === '+')\n                this.blockScalarKeep = true;\n            else if (ch > '0' && ch <= '9')\n                this.blockScalarIndent = Number(ch) - 1;\n            else if (ch !== '-')\n                break;\n        }\n        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\n    }\n    *parseBlockScalar() {\n        let nl = this.pos - 1; // may be -1 if this.pos === 0\n        let indent = 0;\n        let ch;\n        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {\n            switch (ch) {\n                case ' ':\n                    indent += 1;\n                    break;\n                case '\\n':\n                    nl = i;\n                    indent = 0;\n                    break;\n                case '\\r': {\n                    const next = this.buffer[i + 1];\n                    if (!next && !this.atEnd)\n                        return this.setNext('block-scalar');\n                    if (next === '\\n')\n                        break;\n                } // fallthrough\n                default:\n                    break loop;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('block-scalar');\n        if (indent >= this.indentNext) {\n            if (this.blockScalarIndent === -1)\n                this.indentNext = indent;\n            else\n                this.indentNext += this.blockScalarIndent;\n            do {\n                const cs = this.continueScalar(nl + 1);\n                if (cs === -1)\n                    break;\n                nl = this.buffer.indexOf('\\n', cs);\n            } while (nl !== -1);\n            if (nl === -1) {\n                if (!this.atEnd)\n                    return this.setNext('block-scalar');\n                nl = this.buffer.length;\n            }\n        }\n        if (!this.blockScalarKeep) {\n            do {\n                let i = nl - 1;\n                let ch = this.buffer[i];\n                if (ch === '\\r')\n                    ch = this.buffer[--i];\n                const lastChar = i; // Drop the line if last char not more indented\n                while (ch === ' ' || ch === '\\t')\n                    ch = this.buffer[--i];\n                if (ch === '\\n' && i >= this.pos && i + 1 + indent > lastChar)\n                    nl = i;\n                else\n                    break;\n            } while (true);\n        }\n        yield cst.SCALAR;\n        yield* this.pushToIndex(nl + 1, true);\n        return yield* this.parseLineStart();\n    }\n    *parsePlainScalar() {\n        const inFlow = this.flowLevel > 0;\n        let end = this.pos - 1;\n        let i = this.pos - 1;\n        let ch;\n        while ((ch = this.buffer[++i])) {\n            if (ch === ':') {\n                const next = this.buffer[i + 1];\n                if (isEmpty(next) || (inFlow && next === ','))\n                    break;\n                end = i;\n            }\n            else if (isEmpty(ch)) {\n                let next = this.buffer[i + 1];\n                if (ch === '\\r') {\n                    if (next === '\\n') {\n                        i += 1;\n                        ch = '\\n';\n                        next = this.buffer[i + 1];\n                    }\n                    else\n                        end = i;\n                }\n                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))\n                    break;\n                if (ch === '\\n') {\n                    const cs = this.continueScalar(i + 1);\n                    if (cs === -1)\n                        break;\n                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'\n                }\n            }\n            else {\n                if (inFlow && invalidFlowScalarChars.includes(ch))\n                    break;\n                end = i;\n            }\n        }\n        if (!ch && !this.atEnd)\n            return this.setNext('plain-scalar');\n        yield cst.SCALAR;\n        yield* this.pushToIndex(end + 1, true);\n        return inFlow ? 'flow' : 'doc';\n    }\n    *pushCount(n) {\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos += n;\n            return n;\n        }\n        return 0;\n    }\n    *pushToIndex(i, allowEmpty) {\n        const s = this.buffer.slice(this.pos, i);\n        if (s) {\n            yield s;\n            this.pos += s.length;\n            return s.length;\n        }\n        else if (allowEmpty)\n            yield '';\n        return 0;\n    }\n    *pushIndicators() {\n        switch (this.charAt(0)) {\n            case '!':\n                return ((yield* this.pushTag()) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '&':\n                return ((yield* this.pushUntil(isNotAnchorChar)) +\n                    (yield* this.pushSpaces(true)) +\n                    (yield* this.pushIndicators()));\n            case '-': // this is an error\n            case '?': // this is an error outside flow collections\n            case ':': {\n                const inFlow = this.flowLevel > 0;\n                const ch1 = this.charAt(1);\n                if (isEmpty(ch1) || (inFlow && invalidFlowScalarChars.includes(ch1))) {\n                    if (!inFlow)\n                        this.indentNext = this.indentValue + 1;\n                    else if (this.flowKey)\n                        this.flowKey = false;\n                    return ((yield* this.pushCount(1)) +\n                        (yield* this.pushSpaces(true)) +\n                        (yield* this.pushIndicators()));\n                }\n            }\n        }\n        return 0;\n    }\n    *pushTag() {\n        if (this.charAt(1) === '<') {\n            let i = this.pos + 2;\n            let ch = this.buffer[i];\n            while (!isEmpty(ch) && ch !== '>')\n                ch = this.buffer[++i];\n            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\n        }\n        else {\n            let i = this.pos + 1;\n            let ch = this.buffer[i];\n            while (ch) {\n                if (tagChars.includes(ch))\n                    ch = this.buffer[++i];\n                else if (ch === '%' &&\n                    hexDigits.includes(this.buffer[i + 1]) &&\n                    hexDigits.includes(this.buffer[i + 2])) {\n                    ch = this.buffer[(i += 3)];\n                }\n                else\n                    break;\n            }\n            return yield* this.pushToIndex(i, false);\n        }\n    }\n    *pushNewline() {\n        const ch = this.buffer[this.pos];\n        if (ch === '\\n')\n            return yield* this.pushCount(1);\n        else if (ch === '\\r' && this.charAt(1) === '\\n')\n            return yield* this.pushCount(2);\n        else\n            return 0;\n    }\n    *pushSpaces(allowTabs) {\n        let i = this.pos - 1;\n        let ch;\n        do {\n            ch = this.buffer[++i];\n        } while (ch === ' ' || (allowTabs && ch === '\\t'));\n        const n = i - this.pos;\n        if (n > 0) {\n            yield this.buffer.substr(this.pos, n);\n            this.pos = i;\n        }\n        return n;\n    }\n    *pushUntil(test) {\n        let i = this.pos;\n        let ch = this.buffer[i];\n        while (!test(ch))\n            ch = this.buffer[++i];\n        return yield* this.pushToIndex(i, false);\n    }\n}\n\nexports.Lexer = Lexer;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/parse/lexer.js?")},895:(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Tracks newlines during parsing in order to provide an efficient API for\n * determining the one-indexed `{ line, col }` position for any offset\n * within the input.\n */\nclass LineCounter {\n    constructor() {\n        this.lineStarts = [];\n        /**\n         * Should be called in ascending order. Otherwise, call\n         * `lineCounter.lineStarts.sort()` before calling `linePos()`.\n         */\n        this.addNewLine = (offset) => this.lineStarts.push(offset);\n        /**\n         * Performs a binary search and returns the 1-indexed { line, col }\n         * position of `offset`. If `line === 0`, `addNewLine` has never been\n         * called or `offset` is before the first known newline.\n         */\n        this.linePos = (offset) => {\n            let low = 0;\n            let high = this.lineStarts.length;\n            while (low < high) {\n                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)\n                if (this.lineStarts[mid] < offset)\n                    low = mid + 1;\n                else\n                    high = mid;\n            }\n            if (this.lineStarts[low] === offset)\n                return { line: low + 1, col: 1 };\n            if (low === 0)\n                return { line: 0, col: offset };\n            const start = this.lineStarts[low - 1];\n            return { line: low, col: offset - start + 1 };\n        };\n    }\n}\n\nexports.LineCounter = LineCounter;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/parse/line-counter.js?")},9853:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar cst = __webpack_require__(7584);\nvar lexer = __webpack_require__(2013);\n\nfunction includesToken(list, type) {\n    for (let i = 0; i < list.length; ++i)\n        if (list[i].type === type)\n            return true;\n    return false;\n}\nfunction findNonEmptyIndex(list) {\n    for (let i = 0; i < list.length; ++i) {\n        switch (list[i].type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                break;\n            default:\n                return i;\n        }\n    }\n    return -1;\n}\nfunction isFlowToken(token) {\n    switch (token?.type) {\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n        case 'flow-collection':\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getPrevProps(parent) {\n    switch (parent.type) {\n        case 'document':\n            return parent.start;\n        case 'block-map': {\n            const it = parent.items[parent.items.length - 1];\n            return it.sep ?? it.start;\n        }\n        case 'block-seq':\n            return parent.items[parent.items.length - 1].start;\n        /* istanbul ignore next should not happen */\n        default:\n            return [];\n    }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n    if (prev.length === 0)\n        return [];\n    let i = prev.length;\n    loop: while (--i >= 0) {\n        switch (prev[i].type) {\n            case 'doc-start':\n            case 'explicit-key-ind':\n            case 'map-value-ind':\n            case 'seq-item-ind':\n            case 'newline':\n                break loop;\n        }\n    }\n    while (prev[++i]?.type === 'space') {\n        /* loop */\n    }\n    return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n    if (fc.start.type === 'flow-seq-start') {\n        for (const it of fc.items) {\n            if (it.sep &&\n                !it.value &&\n                !includesToken(it.start, 'explicit-key-ind') &&\n                !includesToken(it.sep, 'map-value-ind')) {\n                if (it.key)\n                    it.value = it.key;\n                delete it.key;\n                if (isFlowToken(it.value)) {\n                    if (it.value.end)\n                        Array.prototype.push.apply(it.value.end, it.sep);\n                    else\n                        it.value.end = it.sep;\n                }\n                else\n                    Array.prototype.push.apply(it.start, it.sep);\n                delete it.sep;\n            }\n        }\n    }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n    /**\n     * @param onNewLine - If defined, called separately with the start position of\n     *   each new line (in `parse()`, including the start of input).\n     */\n    constructor(onNewLine) {\n        /** If true, space and sequence indicators count as indentation */\n        this.atNewLine = true;\n        /** If true, next token is a scalar value */\n        this.atScalar = false;\n        /** Current indentation level */\n        this.indent = 0;\n        /** Current offset since the start of parsing */\n        this.offset = 0;\n        /** On the same line with a block map key */\n        this.onKeyLine = false;\n        /** Top indicates the node that's currently being built */\n        this.stack = [];\n        /** The source of the current token, set in parse() */\n        this.source = '';\n        /** The type of the current token, set in parse() */\n        this.type = '';\n        // Must be defined after `next()`\n        this.lexer = new lexer.Lexer();\n        this.onNewLine = onNewLine;\n    }\n    /**\n     * Parse `source` as a YAML stream.\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n     *\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n     *\n     * @returns A generator of tokens representing each directive, document, and other structure.\n     */\n    *parse(source, incomplete = false) {\n        if (this.onNewLine && this.offset === 0)\n            this.onNewLine(0);\n        for (const lexeme of this.lexer.lex(source, incomplete))\n            yield* this.next(lexeme);\n        if (!incomplete)\n            yield* this.end();\n    }\n    /**\n     * Advance the parser by the `source` of one lexical token.\n     */\n    *next(source) {\n        this.source = source;\n        if (process.env.LOG_TOKENS)\n            console.log('|', cst.prettyToken(source));\n        if (this.atScalar) {\n            this.atScalar = false;\n            yield* this.step();\n            this.offset += source.length;\n            return;\n        }\n        const type = cst.tokenType(source);\n        if (!type) {\n            const message = `Not a YAML token: ${source}`;\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\n            this.offset += source.length;\n        }\n        else if (type === 'scalar') {\n            this.atNewLine = false;\n            this.atScalar = true;\n            this.type = 'scalar';\n        }\n        else {\n            this.type = type;\n            yield* this.step();\n            switch (type) {\n                case 'newline':\n                    this.atNewLine = true;\n                    this.indent = 0;\n                    if (this.onNewLine)\n                        this.onNewLine(this.offset + source.length);\n                    break;\n                case 'space':\n                    if (this.atNewLine && source[0] === ' ')\n                        this.indent += source.length;\n                    break;\n                case 'explicit-key-ind':\n                case 'map-value-ind':\n                case 'seq-item-ind':\n                    if (this.atNewLine)\n                        this.indent += source.length;\n                    break;\n                case 'doc-mode':\n                case 'flow-error-end':\n                    return;\n                default:\n                    this.atNewLine = false;\n            }\n            this.offset += source.length;\n        }\n    }\n    /** Call at end of input to push out any remaining constructions */\n    *end() {\n        while (this.stack.length > 0)\n            yield* this.pop();\n    }\n    get sourceToken() {\n        const st = {\n            type: this.type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n        return st;\n    }\n    *step() {\n        const top = this.peek(1);\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n            while (this.stack.length > 0)\n                yield* this.pop();\n            this.stack.push({\n                type: 'doc-end',\n                offset: this.offset,\n                source: this.source\n            });\n            return;\n        }\n        if (!top)\n            return yield* this.stream();\n        switch (top.type) {\n            case 'document':\n                return yield* this.document(top);\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return yield* this.scalar(top);\n            case 'block-scalar':\n                return yield* this.blockScalar(top);\n            case 'block-map':\n                return yield* this.blockMap(top);\n            case 'block-seq':\n                return yield* this.blockSequence(top);\n            case 'flow-collection':\n                return yield* this.flowCollection(top);\n            case 'doc-end':\n                return yield* this.documentEnd(top);\n        }\n        /* istanbul ignore next should not happen */\n        yield* this.pop();\n    }\n    peek(n) {\n        return this.stack[this.stack.length - n];\n    }\n    *pop(error) {\n        const token = error ?? this.stack.pop();\n        /* istanbul ignore if should not happen */\n        if (!token) {\n            const message = 'Tried to pop an empty stack';\n            yield { type: 'error', offset: this.offset, source: '', message };\n        }\n        else if (this.stack.length === 0) {\n            yield token;\n        }\n        else {\n            const top = this.peek(1);\n            if (token.type === 'block-scalar') {\n                // Block scalars use their parent rather than header indent\n                token.indent = 'indent' in top ? top.indent : 0;\n            }\n            else if (token.type === 'flow-collection' && top.type === 'document') {\n                // Ignore all indent for top-level flow collections\n                token.indent = 0;\n            }\n            if (token.type === 'flow-collection')\n                fixFlowSeqItems(token);\n            switch (top.type) {\n                case 'document':\n                    top.value = token;\n                    break;\n                case 'block-scalar':\n                    top.props.push(token); // error\n                    break;\n                case 'block-map': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value) {\n                        top.items.push({ start: [], key: token, sep: [] });\n                        this.onKeyLine = true;\n                        return;\n                    }\n                    else if (it.sep) {\n                        it.value = token;\n                    }\n                    else {\n                        Object.assign(it, { key: token, sep: [] });\n                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');\n                        return;\n                    }\n                    break;\n                }\n                case 'block-seq': {\n                    const it = top.items[top.items.length - 1];\n                    if (it.value)\n                        top.items.push({ start: [], value: token });\n                    else\n                        it.value = token;\n                    break;\n                }\n                case 'flow-collection': {\n                    const it = top.items[top.items.length - 1];\n                    if (!it || it.value)\n                        top.items.push({ start: [], key: token, sep: [] });\n                    else if (it.sep)\n                        it.value = token;\n                    else\n                        Object.assign(it, { key: token, sep: [] });\n                    return;\n                }\n                /* istanbul ignore next should not happen */\n                default:\n                    yield* this.pop();\n                    yield* this.pop(token);\n            }\n            if ((top.type === 'document' ||\n                top.type === 'block-map' ||\n                top.type === 'block-seq') &&\n                (token.type === 'block-map' || token.type === 'block-seq')) {\n                const last = token.items[token.items.length - 1];\n                if (last &&\n                    !last.sep &&\n                    !last.value &&\n                    last.start.length > 0 &&\n                    findNonEmptyIndex(last.start) === -1 &&\n                    (token.indent === 0 ||\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n                    if (top.type === 'document')\n                        top.end = last.start;\n                    else\n                        top.items.push({ start: last.start });\n                    token.items.splice(-1, 1);\n                }\n            }\n        }\n    }\n    *stream() {\n        switch (this.type) {\n            case 'directive-line':\n                yield { type: 'directive', offset: this.offset, source: this.source };\n                return;\n            case 'byte-order-mark':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                yield this.sourceToken;\n                return;\n            case 'doc-mode':\n            case 'doc-start': {\n                const doc = {\n                    type: 'document',\n                    offset: this.offset,\n                    start: []\n                };\n                if (this.type === 'doc-start')\n                    doc.start.push(this.sourceToken);\n                this.stack.push(doc);\n                return;\n            }\n        }\n        yield {\n            type: 'error',\n            offset: this.offset,\n            message: `Unexpected ${this.type} token in YAML stream`,\n            source: this.source\n        };\n    }\n    *document(doc) {\n        if (doc.value)\n            return yield* this.lineEnd(doc);\n        switch (this.type) {\n            case 'doc-start': {\n                if (findNonEmptyIndex(doc.start) !== -1) {\n                    yield* this.pop();\n                    yield* this.step();\n                }\n                else\n                    doc.start.push(this.sourceToken);\n                return;\n            }\n            case 'anchor':\n            case 'tag':\n            case 'space':\n            case 'comment':\n            case 'newline':\n                doc.start.push(this.sourceToken);\n                return;\n        }\n        const bv = this.startBlockValue(doc);\n        if (bv)\n            this.stack.push(bv);\n        else {\n            yield {\n                type: 'error',\n                offset: this.offset,\n                message: `Unexpected ${this.type} token in YAML document`,\n                source: this.source\n            };\n        }\n    }\n    *scalar(scalar) {\n        if (this.type === 'map-value-ind') {\n            const prev = getPrevProps(this.peek(2));\n            const start = getFirstKeyStartProps(prev);\n            let sep;\n            if (scalar.end) {\n                sep = scalar.end;\n                sep.push(this.sourceToken);\n                delete scalar.end;\n            }\n            else\n                sep = [this.sourceToken];\n            const map = {\n                type: 'block-map',\n                offset: scalar.offset,\n                indent: scalar.indent,\n                items: [{ start, key: scalar, sep }]\n            };\n            this.onKeyLine = true;\n            this.stack[this.stack.length - 1] = map;\n        }\n        else\n            yield* this.lineEnd(scalar);\n    }\n    *blockScalar(scalar) {\n        switch (this.type) {\n            case 'space':\n            case 'comment':\n            case 'newline':\n                scalar.props.push(this.sourceToken);\n                return;\n            case 'scalar':\n                scalar.source = this.source;\n                // block-scalar source includes trailing newline\n                this.atNewLine = true;\n                this.indent = 0;\n                if (this.onNewLine) {\n                    let nl = this.source.indexOf('\\n') + 1;\n                    while (nl !== 0) {\n                        this.onNewLine(this.offset + nl);\n                        nl = this.source.indexOf('\\n', nl) + 1;\n                    }\n                }\n                yield* this.pop();\n                break;\n            /* istanbul ignore next should not happen */\n            default:\n                yield* this.pop();\n                yield* this.step();\n        }\n    }\n    *blockMap(map) {\n        const it = map.items[map.items.length - 1];\n        // it.sep is true-ish if pair already has key or : separator\n        switch (this.type) {\n            case 'newline':\n                this.onKeyLine = false;\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value) {\n                    map.items.push({ start: [this.sourceToken] });\n                }\n                else if (it.sep) {\n                    it.sep.push(this.sourceToken);\n                }\n                else {\n                    if (this.atIndentedComment(it.start, map.indent)) {\n                        const prev = map.items[map.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            map.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n        }\n        if (this.indent >= map.indent) {\n            const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;\n            // For empty nodes, assign newline-separated not indented empty tokens to following node\n            let start = [];\n            if (atNextItem && it.sep && !it.value) {\n                const nl = [];\n                for (let i = 0; i < it.sep.length; ++i) {\n                    const st = it.sep[i];\n                    switch (st.type) {\n                        case 'newline':\n                            nl.push(i);\n                            break;\n                        case 'space':\n                            break;\n                        case 'comment':\n                            if (st.indent > map.indent)\n                                nl.length = 0;\n                            break;\n                        default:\n                            nl.length = 0;\n                    }\n                }\n                if (nl.length >= 2)\n                    start = it.sep.splice(nl[1]);\n            }\n            switch (this.type) {\n                case 'anchor':\n                case 'tag':\n                    if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        it.sep.push(this.sourceToken);\n                    }\n                    else {\n                        it.start.push(this.sourceToken);\n                    }\n                    return;\n                case 'explicit-key-ind':\n                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {\n                        it.start.push(this.sourceToken);\n                    }\n                    else if (atNextItem || it.value) {\n                        start.push(this.sourceToken);\n                        map.items.push({ start });\n                    }\n                    else {\n                        this.stack.push({\n                            type: 'block-map',\n                            offset: this.offset,\n                            indent: this.indent,\n                            items: [{ start: [this.sourceToken] }]\n                        });\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'map-value-ind':\n                    if (includesToken(it.start, 'explicit-key-ind')) {\n                        if (!it.sep) {\n                            if (includesToken(it.start, 'newline')) {\n                                Object.assign(it, { key: null, sep: [this.sourceToken] });\n                            }\n                            else {\n                                const start = getFirstKeyStartProps(it.start);\n                                this.stack.push({\n                                    type: 'block-map',\n                                    offset: this.offset,\n                                    indent: this.indent,\n                                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                                });\n                            }\n                        }\n                        else if (it.value) {\n                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else if (isFlowToken(it.key) &&\n                            !includesToken(it.sep, 'newline')) {\n                            const start = getFirstKeyStartProps(it.start);\n                            const key = it.key;\n                            const sep = it.sep;\n                            sep.push(this.sourceToken);\n                            // @ts-expect-error type guard is wrong here\n                            delete it.key, delete it.sep;\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start, key, sep }]\n                            });\n                        }\n                        else if (start.length > 0) {\n                            // Not actually at next item\n                            it.sep = it.sep.concat(start, this.sourceToken);\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    else {\n                        if (!it.sep) {\n                            Object.assign(it, { key: null, sep: [this.sourceToken] });\n                        }\n                        else if (it.value || atNextItem) {\n                            map.items.push({ start, key: null, sep: [this.sourceToken] });\n                        }\n                        else if (includesToken(it.sep, 'map-value-ind')) {\n                            this.stack.push({\n                                type: 'block-map',\n                                offset: this.offset,\n                                indent: this.indent,\n                                items: [{ start: [], key: null, sep: [this.sourceToken] }]\n                            });\n                        }\n                        else {\n                            it.sep.push(this.sourceToken);\n                        }\n                    }\n                    this.onKeyLine = true;\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (atNextItem || it.value) {\n                        map.items.push({ start, key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    else if (it.sep) {\n                        this.stack.push(fs);\n                    }\n                    else {\n                        Object.assign(it, { key: fs, sep: [] });\n                        this.onKeyLine = true;\n                    }\n                    return;\n                }\n                default: {\n                    const bv = this.startBlockValue(map);\n                    if (bv) {\n                        if (atNextItem &&\n                            bv.type !== 'block-seq' &&\n                            includesToken(it.start, 'explicit-key-ind')) {\n                            map.items.push({ start });\n                        }\n                        this.stack.push(bv);\n                        return;\n                    }\n                }\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *blockSequence(seq) {\n        const it = seq.items[seq.items.length - 1];\n        switch (this.type) {\n            case 'newline':\n                if (it.value) {\n                    const end = 'end' in it.value ? it.value.end : undefined;\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n                    if (last?.type === 'comment')\n                        end?.push(this.sourceToken);\n                    else\n                        seq.items.push({ start: [this.sourceToken] });\n                }\n                else\n                    it.start.push(this.sourceToken);\n                return;\n            case 'space':\n            case 'comment':\n                if (it.value)\n                    seq.items.push({ start: [this.sourceToken] });\n                else {\n                    if (this.atIndentedComment(it.start, seq.indent)) {\n                        const prev = seq.items[seq.items.length - 2];\n                        const end = prev?.value?.end;\n                        if (Array.isArray(end)) {\n                            Array.prototype.push.apply(end, it.start);\n                            end.push(this.sourceToken);\n                            seq.items.pop();\n                            return;\n                        }\n                    }\n                    it.start.push(this.sourceToken);\n                }\n                return;\n            case 'anchor':\n            case 'tag':\n                if (it.value || this.indent <= seq.indent)\n                    break;\n                it.start.push(this.sourceToken);\n                return;\n            case 'seq-item-ind':\n                if (this.indent !== seq.indent)\n                    break;\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\n                    seq.items.push({ start: [this.sourceToken] });\n                else\n                    it.start.push(this.sourceToken);\n                return;\n        }\n        if (this.indent > seq.indent) {\n            const bv = this.startBlockValue(seq);\n            if (bv) {\n                this.stack.push(bv);\n                return;\n            }\n        }\n        yield* this.pop();\n        yield* this.step();\n    }\n    *flowCollection(fc) {\n        const it = fc.items[fc.items.length - 1];\n        if (this.type === 'flow-error-end') {\n            let top;\n            do {\n                yield* this.pop();\n                top = this.peek(1);\n            } while (top && top.type === 'flow-collection');\n        }\n        else if (fc.end.length === 0) {\n            switch (this.type) {\n                case 'comma':\n                case 'explicit-key-ind':\n                    if (!it || it.sep)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'map-value-ind':\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\n                    return;\n                case 'space':\n                case 'comment':\n                case 'newline':\n                case 'anchor':\n                case 'tag':\n                    if (!it || it.value)\n                        fc.items.push({ start: [this.sourceToken] });\n                    else if (it.sep)\n                        it.sep.push(this.sourceToken);\n                    else\n                        it.start.push(this.sourceToken);\n                    return;\n                case 'alias':\n                case 'scalar':\n                case 'single-quoted-scalar':\n                case 'double-quoted-scalar': {\n                    const fs = this.flowScalar(this.type);\n                    if (!it || it.value)\n                        fc.items.push({ start: [], key: fs, sep: [] });\n                    else if (it.sep)\n                        this.stack.push(fs);\n                    else\n                        Object.assign(it, { key: fs, sep: [] });\n                    return;\n                }\n                case 'flow-map-end':\n                case 'flow-seq-end':\n                    fc.end.push(this.sourceToken);\n                    return;\n            }\n            const bv = this.startBlockValue(fc);\n            /* istanbul ignore else should not happen */\n            if (bv)\n                this.stack.push(bv);\n            else {\n                yield* this.pop();\n                yield* this.step();\n            }\n        }\n        else {\n            const parent = this.peek(2);\n            if (parent.type === 'block-map' &&\n                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||\n                    (this.type === 'newline' &&\n                        !parent.items[parent.items.length - 1].sep))) {\n                yield* this.pop();\n                yield* this.step();\n            }\n            else if (this.type === 'map-value-ind' &&\n                parent.type !== 'flow-collection') {\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                fixFlowSeqItems(fc);\n                const sep = fc.end.splice(1, fc.end.length);\n                sep.push(this.sourceToken);\n                const map = {\n                    type: 'block-map',\n                    offset: fc.offset,\n                    indent: fc.indent,\n                    items: [{ start, key: fc, sep }]\n                };\n                this.onKeyLine = true;\n                this.stack[this.stack.length - 1] = map;\n            }\n            else {\n                yield* this.lineEnd(fc);\n            }\n        }\n    }\n    flowScalar(type) {\n        if (this.onNewLine) {\n            let nl = this.source.indexOf('\\n') + 1;\n            while (nl !== 0) {\n                this.onNewLine(this.offset + nl);\n                nl = this.source.indexOf('\\n', nl) + 1;\n            }\n        }\n        return {\n            type,\n            offset: this.offset,\n            indent: this.indent,\n            source: this.source\n        };\n    }\n    startBlockValue(parent) {\n        switch (this.type) {\n            case 'alias':\n            case 'scalar':\n            case 'single-quoted-scalar':\n            case 'double-quoted-scalar':\n                return this.flowScalar(this.type);\n            case 'block-scalar-header':\n                return {\n                    type: 'block-scalar',\n                    offset: this.offset,\n                    indent: this.indent,\n                    props: [this.sourceToken],\n                    source: ''\n                };\n            case 'flow-map-start':\n            case 'flow-seq-start':\n                return {\n                    type: 'flow-collection',\n                    offset: this.offset,\n                    indent: this.indent,\n                    start: this.sourceToken,\n                    items: [],\n                    end: []\n                };\n            case 'seq-item-ind':\n                return {\n                    type: 'block-seq',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start: [this.sourceToken] }]\n                };\n            case 'explicit-key-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                start.push(this.sourceToken);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start }]\n                };\n            }\n            case 'map-value-ind': {\n                this.onKeyLine = true;\n                const prev = getPrevProps(parent);\n                const start = getFirstKeyStartProps(prev);\n                return {\n                    type: 'block-map',\n                    offset: this.offset,\n                    indent: this.indent,\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\n                };\n            }\n        }\n        return null;\n    }\n    atIndentedComment(start, indent) {\n        if (this.type !== 'comment')\n            return false;\n        if (this.indent <= indent)\n            return false;\n        return start.every(st => st.type === 'newline' || st.type === 'space');\n    }\n    *documentEnd(docEnd) {\n        if (this.type !== 'doc-mode') {\n            if (docEnd.end)\n                docEnd.end.push(this.sourceToken);\n            else\n                docEnd.end = [this.sourceToken];\n            if (this.type === 'newline')\n                yield* this.pop();\n        }\n    }\n    *lineEnd(token) {\n        switch (this.type) {\n            case 'comma':\n            case 'doc-start':\n            case 'doc-end':\n            case 'flow-seq-end':\n            case 'flow-map-end':\n            case 'map-value-ind':\n                yield* this.pop();\n                yield* this.step();\n                break;\n            case 'newline':\n                this.onKeyLine = false;\n            // fallthrough\n            case 'space':\n            case 'comment':\n            default:\n                // all other values are errors\n                if (token.end)\n                    token.end.push(this.sourceToken);\n                else\n                    token.end = [this.sourceToken];\n                if (this.type === 'newline')\n                    yield* this.pop();\n        }\n    }\n}\n\nexports.Parser = Parser;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/parse/parser.js?")},9995:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar composer = __webpack_require__(4508);\nvar Document = __webpack_require__(7705);\nvar errors = __webpack_require__(5969);\nvar log = __webpack_require__(1357);\nvar lineCounter = __webpack_require__(895);\nvar parser = __webpack_require__(9853);\n\nfunction parseOptions(options) {\n    const prettyErrors = options.prettyErrors !== false;\n    const lineCounter$1 = options.lineCounter || (prettyErrors && new lineCounter.LineCounter()) || null;\n    return { lineCounter: lineCounter$1, prettyErrors };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser$1 = new parser.Parser(lineCounter?.addNewLine);\n    const composer$1 = new composer.Composer(options);\n    const docs = Array.from(composer$1.compose(parser$1.parse(source)));\n    if (prettyErrors && lineCounter)\n        for (const doc of docs) {\n            doc.errors.forEach(errors.prettifyError(source, lineCounter));\n            doc.warnings.forEach(errors.prettifyError(source, lineCounter));\n        }\n    if (docs.length > 0)\n        return docs;\n    return Object.assign([], { empty: true }, composer$1.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n    const { lineCounter, prettyErrors } = parseOptions(options);\n    const parser$1 = new parser.Parser(lineCounter?.addNewLine);\n    const composer$1 = new composer.Composer(options);\n    // `doc` is always set by compose.end(true) at the very latest\n    let doc = null;\n    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {\n        if (!doc)\n            doc = _doc;\n        else if (doc.options.logLevel !== 'silent') {\n            doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n            break;\n        }\n    }\n    if (prettyErrors && lineCounter) {\n        doc.errors.forEach(errors.prettifyError(source, lineCounter));\n        doc.warnings.forEach(errors.prettifyError(source, lineCounter));\n    }\n    return doc;\n}\nfunction parse(src, reviver, options) {\n    let _reviver = undefined;\n    if (typeof reviver === 'function') {\n        _reviver = reviver;\n    }\n    else if (options === undefined && reviver && typeof reviver === 'object') {\n        options = reviver;\n    }\n    const doc = parseDocument(src, options);\n    if (!doc)\n        return null;\n    doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));\n    if (doc.errors.length > 0) {\n        if (doc.options.logLevel !== 'silent')\n            throw doc.errors[0];\n        else\n            doc.errors = [];\n    }\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\n}\nfunction stringify(value, replacer, options) {\n    let _replacer = null;\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\n        _replacer = replacer;\n    }\n    else if (options === undefined && replacer) {\n        options = replacer;\n    }\n    if (typeof options === 'string')\n        options = options.length;\n    if (typeof options === 'number') {\n        const indent = Math.round(options);\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\n    }\n    if (value === undefined) {\n        const { keepUndefined } = options ?? replacer ?? {};\n        if (!keepUndefined)\n            return undefined;\n    }\n    return new Document.Document(value, _replacer, options).toString(options);\n}\n\nexports.parse = parse;\nexports.parseAllDocuments = parseAllDocuments;\nexports.parseDocument = parseDocument;\nexports.stringify = stringify;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/public-api.js?")},1150:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\nvar map = __webpack_require__(105);\nvar seq = __webpack_require__(8156);\nvar string = __webpack_require__(5962);\nvar tags = __webpack_require__(2019);\n\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\nclass Schema {\n    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {\n        this.compat = Array.isArray(compat)\n            ? tags.getTags(compat, 'compat')\n            : compat\n                ? tags.getTags(null, compat)\n                : null;\n        this.merge = !!merge;\n        this.name = (typeof schema === 'string' && schema) || 'core';\n        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};\n        this.tags = tags.getTags(customTags, this.name);\n        this.toStringOptions = toStringDefaults ?? null;\n        Object.defineProperty(this, Node.MAP, { value: map.map });\n        Object.defineProperty(this, Node.SCALAR, { value: string.string });\n        Object.defineProperty(this, Node.SEQ, { value: seq.seq });\n        // Used by createMap()\n        this.sortMapEntries =\n            typeof sortMapEntries === 'function'\n                ? sortMapEntries\n                : sortMapEntries === true\n                    ? sortMapEntriesByKey\n                    : null;\n    }\n    clone() {\n        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));\n        copy.tags = this.tags.slice();\n        return copy;\n    }\n}\n\nexports.Schema = Schema;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/Schema.js?")},105:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\nvar Pair = __webpack_require__(6775);\nvar YAMLMap = __webpack_require__(3140);\n\nfunction createMap(schema, obj, ctx) {\n    const { keepUndefined, replacer } = ctx;\n    const map = new YAMLMap.YAMLMap(schema);\n    const add = (key, value) => {\n        if (typeof replacer === 'function')\n            value = replacer.call(obj, key, value);\n        else if (Array.isArray(replacer) && !replacer.includes(key))\n            return;\n        if (value !== undefined || keepUndefined)\n            map.items.push(Pair.createPair(key, value, ctx));\n    };\n    if (obj instanceof Map) {\n        for (const [key, value] of obj)\n            add(key, value);\n    }\n    else if (obj && typeof obj === 'object') {\n        for (const key of Object.keys(obj))\n            add(key, obj[key]);\n    }\n    if (typeof schema.sortMapEntries === 'function') {\n        map.items.sort(schema.sortMapEntries);\n    }\n    return map;\n}\nconst map = {\n    collection: 'map',\n    createNode: createMap,\n    default: true,\n    nodeClass: YAMLMap.YAMLMap,\n    tag: 'tag:yaml.org,2002:map',\n    resolve(map, onError) {\n        if (!Node.isMap(map))\n            onError('Expected a mapping for this tag');\n        return map;\n    }\n};\n\nexports.map = map;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/common/map.js?")},4215:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Scalar = __webpack_require__(6686);\n\nconst nullTag = {\n    identify: value => value == null,\n    createNode: () => new Scalar.Scalar(null),\n    default: true,\n    tag: 'tag:yaml.org,2002:null',\n    test: /^(?:~|[Nn]ull|NULL)?$/,\n    resolve: () => new Scalar.Scalar(null),\n    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)\n        ? source\n        : ctx.options.nullStr\n};\n\nexports.nullTag = nullTag;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/common/null.js?")},8156:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar createNode = __webpack_require__(7507);\nvar Node = __webpack_require__(6058);\nvar YAMLSeq = __webpack_require__(6221);\n\nfunction createSeq(schema, obj, ctx) {\n    const { replacer } = ctx;\n    const seq = new YAMLSeq.YAMLSeq(schema);\n    if (obj && Symbol.iterator in Object(obj)) {\n        let i = 0;\n        for (let it of obj) {\n            if (typeof replacer === 'function') {\n                const key = obj instanceof Set ? it : String(i++);\n                it = replacer.call(obj, key, it);\n            }\n            seq.items.push(createNode.createNode(it, undefined, ctx));\n        }\n    }\n    return seq;\n}\nconst seq = {\n    collection: 'seq',\n    createNode: createSeq,\n    default: true,\n    nodeClass: YAMLSeq.YAMLSeq,\n    tag: 'tag:yaml.org,2002:seq',\n    resolve(seq, onError) {\n        if (!Node.isSeq(seq))\n            onError('Expected a sequence for this tag');\n        return seq;\n    }\n};\n\nexports.seq = seq;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/common/seq.js?")},5962:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar stringifyString = __webpack_require__(396);\n\nconst string = {\n    identify: value => typeof value === 'string',\n    default: true,\n    tag: 'tag:yaml.org,2002:str',\n    resolve: str => str,\n    stringify(item, ctx, onComment, onChompKeep) {\n        ctx = Object.assign({ actualString: true }, ctx);\n        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);\n    }\n};\n\nexports.string = string;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/common/string.js?")},6215:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Scalar = __webpack_require__(6686);\n\nconst boolTag = {\n    identify: value => typeof value === 'boolean',\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\n    resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),\n    stringify({ source, value }, ctx) {\n        if (source && boolTag.test.test(source)) {\n            const sv = source[0] === 't' || source[0] === 'T';\n            if (value === sv)\n                return source;\n        }\n        return value ? ctx.options.trueStr : ctx.options.falseStr;\n    }\n};\n\nexports.boolTag = boolTag;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/core/bool.js?")},4168:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Scalar = __webpack_require__(6686);\nvar stringifyNumber = __webpack_require__(4058);\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF|nan|NaN|NAN))$/,\n    resolve: str => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber.stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\n    resolve: str => parseFloat(str),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,\n    resolve(str) {\n        const node = new Scalar.Scalar(parseFloat(str));\n        const dot = str.indexOf('.');\n        if (dot !== -1 && str[str.length - 1] === '0')\n            node.minFractionDigits = str.length - dot - 1;\n        return node;\n    },\n    stringify: stringifyNumber.stringifyNumber\n};\n\nexports.float = float;\nexports.floatExp = floatExp;\nexports.floatNaN = floatNaN;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/core/float.js?")},5844:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar stringifyNumber = __webpack_require__(4058);\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nconst intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value) && value >= 0)\n        return prefix + value.toString(radix);\n    return stringifyNumber.stringifyNumber(node);\n}\nconst intOct = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^0o[0-7]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),\n    stringify: node => intStringify(node, 8, '0o')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber.stringifyNumber\n};\nconst intHex = {\n    identify: value => intIdentify(value) && value >= 0,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^0x[0-9a-fA-F]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexports.int = int;\nexports.intHex = intHex;\nexports.intOct = intOct;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/core/int.js?")},9835:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar map = __webpack_require__(105);\nvar _null = __webpack_require__(4215);\nvar seq = __webpack_require__(8156);\nvar string = __webpack_require__(5962);\nvar bool = __webpack_require__(6215);\nvar float = __webpack_require__(4168);\nvar int = __webpack_require__(5844);\n\nconst schema = [\n    map.map,\n    seq.seq,\n    string.string,\n    _null.nullTag,\n    bool.boolTag,\n    int.intOct,\n    int.int,\n    int.intHex,\n    float.floatNaN,\n    float.floatExp,\n    float.float\n];\n\nexports.schema = schema;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/core/schema.js?")},9779:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Scalar = __webpack_require__(6686);\nvar map = __webpack_require__(105);\nvar seq = __webpack_require__(8156);\n\nfunction intIdentify(value) {\n    return typeof value === 'bigint' || Number.isInteger(value);\n}\nconst stringifyJSON = ({ value }) => JSON.stringify(value);\nconst jsonScalars = [\n    {\n        identify: value => typeof value === 'string',\n        default: true,\n        tag: 'tag:yaml.org,2002:str',\n        resolve: str => str,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => value == null,\n        createNode: () => new Scalar.Scalar(null),\n        default: true,\n        tag: 'tag:yaml.org,2002:null',\n        test: /^null$/,\n        resolve: () => null,\n        stringify: stringifyJSON\n    },\n    {\n        identify: value => typeof value === 'boolean',\n        default: true,\n        tag: 'tag:yaml.org,2002:bool',\n        test: /^true|false$/,\n        resolve: str => str === 'true',\n        stringify: stringifyJSON\n    },\n    {\n        identify: intIdentify,\n        default: true,\n        tag: 'tag:yaml.org,2002:int',\n        test: /^-?(?:0|[1-9][0-9]*)$/,\n        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),\n        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)\n    },\n    {\n        identify: value => typeof value === 'number',\n        default: true,\n        tag: 'tag:yaml.org,2002:float',\n        test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\n        resolve: str => parseFloat(str),\n        stringify: stringifyJSON\n    }\n];\nconst jsonError = {\n    default: true,\n    tag: '',\n    test: /^/,\n    resolve(str, onError) {\n        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);\n        return str;\n    }\n};\nconst schema = [map.map, seq.seq].concat(jsonScalars, jsonError);\n\nexports.schema = schema;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/json/schema.js?")},2019:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar map = __webpack_require__(105);\nvar _null = __webpack_require__(4215);\nvar seq = __webpack_require__(8156);\nvar string = __webpack_require__(5962);\nvar bool = __webpack_require__(6215);\nvar float = __webpack_require__(4168);\nvar int = __webpack_require__(5844);\nvar schema = __webpack_require__(9835);\nvar schema$1 = __webpack_require__(9779);\nvar binary = __webpack_require__(336);\nvar omap = __webpack_require__(2550);\nvar pairs = __webpack_require__(3074);\nvar schema$2 = __webpack_require__(4184);\nvar set = __webpack_require__(2642);\nvar timestamp = __webpack_require__(1543);\n\nconst schemas = new Map([\n    ['core', schema.schema],\n    ['failsafe', [map.map, seq.seq, string.string]],\n    ['json', schema$1.schema],\n    ['yaml11', schema$2.schema],\n    ['yaml-1.1', schema$2.schema]\n]);\nconst tagsByName = {\n    binary: binary.binary,\n    bool: bool.boolTag,\n    float: float.float,\n    floatExp: float.floatExp,\n    floatNaN: float.floatNaN,\n    floatTime: timestamp.floatTime,\n    int: int.int,\n    intHex: int.intHex,\n    intOct: int.intOct,\n    intTime: timestamp.intTime,\n    map: map.map,\n    null: _null.nullTag,\n    omap: omap.omap,\n    pairs: pairs.pairs,\n    seq: seq.seq,\n    set: set.set,\n    timestamp: timestamp.timestamp\n};\nconst coreKnownTags = {\n    'tag:yaml.org,2002:binary': binary.binary,\n    'tag:yaml.org,2002:omap': omap.omap,\n    'tag:yaml.org,2002:pairs': pairs.pairs,\n    'tag:yaml.org,2002:set': set.set,\n    'tag:yaml.org,2002:timestamp': timestamp.timestamp\n};\nfunction getTags(customTags, schemaName) {\n    let tags = schemas.get(schemaName);\n    if (!tags) {\n        if (Array.isArray(customTags))\n            tags = [];\n        else {\n            const keys = Array.from(schemas.keys())\n                .filter(key => key !== 'yaml11')\n                .map(key => JSON.stringify(key))\n                .join(', ');\n            throw new Error(`Unknown schema \"${schemaName}\"; use one of ${keys} or define customTags array`);\n        }\n    }\n    if (Array.isArray(customTags)) {\n        for (const tag of customTags)\n            tags = tags.concat(tag);\n    }\n    else if (typeof customTags === 'function') {\n        tags = customTags(tags.slice());\n    }\n    return tags.map(tag => {\n        if (typeof tag !== 'string')\n            return tag;\n        const tagObj = tagsByName[tag];\n        if (tagObj)\n            return tagObj;\n        const keys = Object.keys(tagsByName)\n            .map(key => JSON.stringify(key))\n            .join(', ');\n        throw new Error(`Unknown custom tag \"${tag}\"; use one of ${keys}`);\n    });\n}\n\nexports.coreKnownTags = coreKnownTags;\nexports.getTags = getTags;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/tags.js?")},336:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Scalar = __webpack_require__(6686);\nvar stringifyString = __webpack_require__(396);\n\nconst binary = {\n    identify: value => value instanceof Uint8Array,\n    default: false,\n    tag: 'tag:yaml.org,2002:binary',\n    /**\n     * Returns a Buffer in node and an Uint8Array in browsers\n     *\n     * To use the resulting buffer as an image, you'll want to do something like:\n     *\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\n     */\n    resolve(src, onError) {\n        if (typeof Buffer === 'function') {\n            return Buffer.from(src, 'base64');\n        }\n        else if (typeof atob === 'function') {\n            // On IE 11, atob() can't handle newlines\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\n            const buffer = new Uint8Array(str.length);\n            for (let i = 0; i < str.length; ++i)\n                buffer[i] = str.charCodeAt(i);\n            return buffer;\n        }\n        else {\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\n            return src;\n        }\n    },\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\n        const buf = value; // checked earlier by binary.identify()\n        let str;\n        if (typeof Buffer === 'function') {\n            str =\n                buf instanceof Buffer\n                    ? buf.toString('base64')\n                    : Buffer.from(buf.buffer).toString('base64');\n        }\n        else if (typeof btoa === 'function') {\n            let s = '';\n            for (let i = 0; i < buf.length; ++i)\n                s += String.fromCharCode(buf[i]);\n            str = btoa(s);\n        }\n        else {\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\n        }\n        if (!type)\n            type = Scalar.Scalar.BLOCK_LITERAL;\n        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\n            const n = Math.ceil(str.length / lineWidth);\n            const lines = new Array(n);\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\n                lines[i] = str.substr(o, lineWidth);\n            }\n            str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\\n' : ' ');\n        }\n        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);\n    }\n};\n\nexports.binary = binary;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/yaml-1.1/binary.js?")},565:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Scalar = __webpack_require__(6686);\n\nfunction boolStringify({ value, source }, ctx) {\n    const boolObj = value ? trueTag : falseTag;\n    if (source && boolObj.test.test(source))\n        return source;\n    return value ? ctx.options.trueStr : ctx.options.falseStr;\n}\nconst trueTag = {\n    identify: value => value === true,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\n    resolve: () => new Scalar.Scalar(true),\n    stringify: boolStringify\n};\nconst falseTag = {\n    identify: value => value === false,\n    default: true,\n    tag: 'tag:yaml.org,2002:bool',\n    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\n    resolve: () => new Scalar.Scalar(false),\n    stringify: boolStringify\n};\n\nexports.falseTag = falseTag;\nexports.trueTag = trueTag;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/yaml-1.1/bool.js?")},9561:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Scalar = __webpack_require__(6686);\nvar stringifyNumber = __webpack_require__(4058);\n\nconst floatNaN = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?\\.(?:inf|Inf|INF|nan|NaN|NAN)$/,\n    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'\n        ? NaN\n        : str[0] === '-'\n            ? Number.NEGATIVE_INFINITY\n            : Number.POSITIVE_INFINITY,\n    stringify: stringifyNumber.stringifyNumber\n};\nconst floatExp = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'EXP',\n    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\n    resolve: (str) => parseFloat(str.replace(/_/g, '')),\n    stringify(node) {\n        const num = Number(node.value);\n        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);\n    }\n};\nconst float = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    test: /^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,\n    resolve(str) {\n        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));\n        const dot = str.indexOf('.');\n        if (dot !== -1) {\n            const f = str.substring(dot + 1).replace(/_/g, '');\n            if (f[f.length - 1] === '0')\n                node.minFractionDigits = f.length;\n        }\n        return node;\n    },\n    stringify: stringifyNumber.stringifyNumber\n};\n\nexports.float = float;\nexports.floatExp = floatExp;\nexports.floatNaN = floatNaN;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/yaml-1.1/float.js?")},4885:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar stringifyNumber = __webpack_require__(4058);\n\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\nfunction intResolve(str, offset, radix, { intAsBigInt }) {\n    const sign = str[0];\n    if (sign === '-' || sign === '+')\n        offset += 1;\n    str = str.substring(offset).replace(/_/g, '');\n    if (intAsBigInt) {\n        switch (radix) {\n            case 2:\n                str = `0b${str}`;\n                break;\n            case 8:\n                str = `0o${str}`;\n                break;\n            case 16:\n                str = `0x${str}`;\n                break;\n        }\n        const n = BigInt(str);\n        return sign === '-' ? BigInt(-1) * n : n;\n    }\n    const n = parseInt(str, radix);\n    return sign === '-' ? -1 * n : n;\n}\nfunction intStringify(node, radix, prefix) {\n    const { value } = node;\n    if (intIdentify(value)) {\n        const str = value.toString(radix);\n        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\n    }\n    return stringifyNumber.stringifyNumber(node);\n}\nconst intBin = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'BIN',\n    test: /^[-+]?0b[0-1_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),\n    stringify: node => intStringify(node, 2, '0b')\n};\nconst intOct = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'OCT',\n    test: /^[-+]?0[0-7_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),\n    stringify: node => intStringify(node, 8, '0')\n};\nconst int = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    test: /^[-+]?[0-9][0-9_]*$/,\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\n    stringify: stringifyNumber.stringifyNumber\n};\nconst intHex = {\n    identify: intIdentify,\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'HEX',\n    test: /^[-+]?0x[0-9a-fA-F_]+$/,\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\n    stringify: node => intStringify(node, 16, '0x')\n};\n\nexports.int = int;\nexports.intBin = intBin;\nexports.intHex = intHex;\nexports.intOct = intOct;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/yaml-1.1/int.js?")},2550:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar YAMLSeq = __webpack_require__(6221);\nvar toJS = __webpack_require__(6001);\nvar Node = __webpack_require__(6058);\nvar YAMLMap = __webpack_require__(3140);\nvar pairs = __webpack_require__(3074);\n\nclass YAMLOMap extends YAMLSeq.YAMLSeq {\n    constructor() {\n        super();\n        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);\n        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);\n        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);\n        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);\n        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);\n        this.tag = YAMLOMap.tag;\n    }\n    /**\n     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\n     * but TypeScript won't allow widening the signature of a child method.\n     */\n    toJSON(_, ctx) {\n        if (!ctx)\n            return super.toJSON(_);\n        const map = new Map();\n        if (ctx?.onCreate)\n            ctx.onCreate(map);\n        for (const pair of this.items) {\n            let key, value;\n            if (Node.isPair(pair)) {\n                key = toJS.toJS(pair.key, '', ctx);\n                value = toJS.toJS(pair.value, key, ctx);\n            }\n            else {\n                key = toJS.toJS(pair, '', ctx);\n            }\n            if (map.has(key))\n                throw new Error('Ordered maps must not include duplicate keys');\n            map.set(key, value);\n        }\n        return map;\n    }\n}\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\nconst omap = {\n    collection: 'seq',\n    identify: value => value instanceof Map,\n    nodeClass: YAMLOMap,\n    default: false,\n    tag: 'tag:yaml.org,2002:omap',\n    resolve(seq, onError) {\n        const pairs$1 = pairs.resolvePairs(seq, onError);\n        const seenKeys = [];\n        for (const { key } of pairs$1.items) {\n            if (Node.isScalar(key)) {\n                if (seenKeys.includes(key.value)) {\n                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);\n                }\n                else {\n                    seenKeys.push(key.value);\n                }\n            }\n        }\n        return Object.assign(new YAMLOMap(), pairs$1);\n    },\n    createNode(schema, iterable, ctx) {\n        const pairs$1 = pairs.createPairs(schema, iterable, ctx);\n        const omap = new YAMLOMap();\n        omap.items = pairs$1.items;\n        return omap;\n    }\n};\n\nexports.YAMLOMap = YAMLOMap;\nexports.omap = omap;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/yaml-1.1/omap.js?")},3074:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\nvar Pair = __webpack_require__(6775);\nvar Scalar = __webpack_require__(6686);\nvar YAMLSeq = __webpack_require__(6221);\n\nfunction resolvePairs(seq, onError) {\n    if (Node.isSeq(seq)) {\n        for (let i = 0; i < seq.items.length; ++i) {\n            let item = seq.items[i];\n            if (Node.isPair(item))\n                continue;\n            else if (Node.isMap(item)) {\n                if (item.items.length > 1)\n                    onError('Each pair must have its own sequence indicator');\n                const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));\n                if (item.commentBefore)\n                    pair.key.commentBefore = pair.key.commentBefore\n                        ? `${item.commentBefore}\\n${pair.key.commentBefore}`\n                        : item.commentBefore;\n                if (item.comment) {\n                    const cn = pair.value ?? pair.key;\n                    cn.comment = cn.comment\n                        ? `${item.comment}\\n${cn.comment}`\n                        : item.comment;\n                }\n                item = pair;\n            }\n            seq.items[i] = Node.isPair(item) ? item : new Pair.Pair(item);\n        }\n    }\n    else\n        onError('Expected a sequence for this tag');\n    return seq;\n}\nfunction createPairs(schema, iterable, ctx) {\n    const { replacer } = ctx;\n    const pairs = new YAMLSeq.YAMLSeq(schema);\n    pairs.tag = 'tag:yaml.org,2002:pairs';\n    let i = 0;\n    if (iterable && Symbol.iterator in Object(iterable))\n        for (let it of iterable) {\n            if (typeof replacer === 'function')\n                it = replacer.call(iterable, String(i++), it);\n            let key, value;\n            if (Array.isArray(it)) {\n                if (it.length === 2) {\n                    key = it[0];\n                    value = it[1];\n                }\n                else\n                    throw new TypeError(`Expected [key, value] tuple: ${it}`);\n            }\n            else if (it && it instanceof Object) {\n                const keys = Object.keys(it);\n                if (keys.length === 1) {\n                    key = keys[0];\n                    value = it[key];\n                }\n                else\n                    throw new TypeError(`Expected { key: value } tuple: ${it}`);\n            }\n            else {\n                key = it;\n            }\n            pairs.items.push(Pair.createPair(key, value, ctx));\n        }\n    return pairs;\n}\nconst pairs = {\n    collection: 'seq',\n    default: false,\n    tag: 'tag:yaml.org,2002:pairs',\n    resolve: resolvePairs,\n    createNode: createPairs\n};\n\nexports.createPairs = createPairs;\nexports.pairs = pairs;\nexports.resolvePairs = resolvePairs;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/yaml-1.1/pairs.js?")},4184:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar map = __webpack_require__(105);\nvar _null = __webpack_require__(4215);\nvar seq = __webpack_require__(8156);\nvar string = __webpack_require__(5962);\nvar binary = __webpack_require__(336);\nvar bool = __webpack_require__(565);\nvar float = __webpack_require__(9561);\nvar int = __webpack_require__(4885);\nvar omap = __webpack_require__(2550);\nvar pairs = __webpack_require__(3074);\nvar set = __webpack_require__(2642);\nvar timestamp = __webpack_require__(1543);\n\nconst schema = [\n    map.map,\n    seq.seq,\n    string.string,\n    _null.nullTag,\n    bool.trueTag,\n    bool.falseTag,\n    int.intBin,\n    int.intOct,\n    int.int,\n    int.intHex,\n    float.floatNaN,\n    float.floatExp,\n    float.float,\n    binary.binary,\n    omap.omap,\n    pairs.pairs,\n    set.set,\n    timestamp.intTime,\n    timestamp.floatTime,\n    timestamp.timestamp\n];\n\nexports.schema = schema;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/yaml-1.1/schema.js?")},2642:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\nvar Pair = __webpack_require__(6775);\nvar YAMLMap = __webpack_require__(3140);\n\nclass YAMLSet extends YAMLMap.YAMLMap {\n    constructor(schema) {\n        super(schema);\n        this.tag = YAMLSet.tag;\n    }\n    add(key) {\n        let pair;\n        if (Node.isPair(key))\n            pair = key;\n        else if (key &&\n            typeof key === 'object' &&\n            'key' in key &&\n            'value' in key &&\n            key.value === null)\n            pair = new Pair.Pair(key.key, null);\n        else\n            pair = new Pair.Pair(key, null);\n        const prev = YAMLMap.findPair(this.items, pair.key);\n        if (!prev)\n            this.items.push(pair);\n    }\n    /**\n     * If `keepPair` is `true`, returns the Pair matching `key`.\n     * Otherwise, returns the value of that Pair's key.\n     */\n    get(key, keepPair) {\n        const pair = YAMLMap.findPair(this.items, key);\n        return !keepPair && Node.isPair(pair)\n            ? Node.isScalar(pair.key)\n                ? pair.key.value\n                : pair.key\n            : pair;\n    }\n    set(key, value) {\n        if (typeof value !== 'boolean')\n            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\n        const prev = YAMLMap.findPair(this.items, key);\n        if (prev && !value) {\n            this.items.splice(this.items.indexOf(prev), 1);\n        }\n        else if (!prev && value) {\n            this.items.push(new Pair.Pair(key));\n        }\n    }\n    toJSON(_, ctx) {\n        return super.toJSON(_, ctx, Set);\n    }\n    toString(ctx, onComment, onChompKeep) {\n        if (!ctx)\n            return JSON.stringify(this);\n        if (this.hasAllNullValues(true))\n            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);\n        else\n            throw new Error('Set items must all have null values');\n    }\n}\nYAMLSet.tag = 'tag:yaml.org,2002:set';\nconst set = {\n    collection: 'map',\n    identify: value => value instanceof Set,\n    nodeClass: YAMLSet,\n    default: false,\n    tag: 'tag:yaml.org,2002:set',\n    resolve(map, onError) {\n        if (Node.isMap(map)) {\n            if (map.hasAllNullValues(true))\n                return Object.assign(new YAMLSet(), map);\n            else\n                onError('Set items must all have null values');\n        }\n        else\n            onError('Expected a mapping for this tag');\n        return map;\n    },\n    createNode(schema, iterable, ctx) {\n        const { replacer } = ctx;\n        const set = new YAMLSet(schema);\n        if (iterable && Symbol.iterator in Object(iterable))\n            for (let value of iterable) {\n                if (typeof replacer === 'function')\n                    value = replacer.call(iterable, value, value);\n                set.items.push(Pair.createPair(value, null, ctx));\n            }\n        return set;\n    }\n};\n\nexports.YAMLSet = YAMLSet;\nexports.set = set;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/yaml-1.1/set.js?")},1543:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar stringifyNumber = __webpack_require__(4058);\n\n/** Internal types handle bigint as number, because TS can't figure it out. */\nfunction parseSexagesimal(str, asBigInt) {\n    const sign = str[0];\n    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;\n    const num = (n) => asBigInt ? BigInt(n) : Number(n);\n    const res = parts\n        .replace(/_/g, '')\n        .split(':')\n        .reduce((res, p) => res * num(60) + num(p), num(0));\n    return (sign === '-' ? num(-1) * res : res);\n}\n/**\n * hhhh:mm:ss.sss\n *\n * Internal types handle bigint as number, because TS can't figure it out.\n */\nfunction stringifySexagesimal(node) {\n    let { value } = node;\n    let num = (n) => n;\n    if (typeof value === 'bigint')\n        num = n => BigInt(n);\n    else if (isNaN(value) || !isFinite(value))\n        return stringifyNumber.stringifyNumber(node);\n    let sign = '';\n    if (value < 0) {\n        sign = '-';\n        value *= num(-1);\n    }\n    const _60 = num(60);\n    const parts = [value % _60]; // seconds, including ms\n    if (value < 60) {\n        parts.unshift(0); // at least one : is required\n    }\n    else {\n        value = (value - parts[0]) / _60;\n        parts.unshift(value % _60); // minutes\n        if (value >= 60) {\n            value = (value - parts[0]) / _60;\n            parts.unshift(value); // hours\n        }\n    }\n    return (sign +\n        parts\n            .map(n => (n < 10 ? '0' + String(n) : String(n)))\n            .join(':')\n            .replace(/000000\\d*$/, '') // % 60 may introduce error\n    );\n}\nconst intTime = {\n    identify: value => typeof value === 'bigint' || Number.isInteger(value),\n    default: true,\n    tag: 'tag:yaml.org,2002:int',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,\n    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),\n    stringify: stringifySexagesimal\n};\nconst floatTime = {\n    identify: value => typeof value === 'number',\n    default: true,\n    tag: 'tag:yaml.org,2002:float',\n    format: 'TIME',\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,\n    resolve: str => parseSexagesimal(str, false),\n    stringify: stringifySexagesimal\n};\nconst timestamp = {\n    identify: value => value instanceof Date,\n    default: true,\n    tag: 'tag:yaml.org,2002:timestamp',\n    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\n    // may be omitted altogether, resulting in a date format. In such a case, the time part is\n    // assumed to be 00:00:00Z (start of day, UTC).\n    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\n        '(?:' + // time is optional\n        '(?:t|T|[ \\\\t]+)' + // t | T | whitespace\n        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\n        '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\n        ')?$'),\n    resolve(str) {\n        const match = str.match(timestamp.test);\n        if (!match)\n            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');\n        const [, year, month, day, hour, minute, second] = match.map(Number);\n        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;\n        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);\n        const tz = match[8];\n        if (tz && tz !== 'Z') {\n            let d = parseSexagesimal(tz, false);\n            if (Math.abs(d) < 30)\n                d *= 60;\n            date -= 60000 * d;\n        }\n        return new Date(date);\n    },\n    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '')\n};\n\nexports.floatTime = floatTime;\nexports.intTime = intTime;\nexports.timestamp = timestamp;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/schema/yaml-1.1/timestamp.js?")},2925:(__unused_webpack_module,exports)=>{"use strict";eval("\n\nconst FOLD_FLOW = 'flow';\nconst FOLD_BLOCK = 'block';\nconst FOLD_QUOTED = 'quoted';\n/**\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\n * terminated with `\\n` and started with `indent`.\n */\nfunction foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {\n    if (!lineWidth || lineWidth < 0)\n        return text;\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\n    if (text.length <= endStep)\n        return text;\n    const folds = [];\n    const escapedFolds = {};\n    let end = lineWidth - indent.length;\n    if (typeof indentAtStart === 'number') {\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))\n            folds.push(0);\n        else\n            end = lineWidth - indentAtStart;\n    }\n    let split = undefined;\n    let prev = undefined;\n    let overflow = false;\n    let i = -1;\n    let escStart = -1;\n    let escEnd = -1;\n    if (mode === FOLD_BLOCK) {\n        i = consumeMoreIndentedLines(text, i);\n        if (i !== -1)\n            end = i + endStep;\n    }\n    for (let ch; (ch = text[(i += 1)]);) {\n        if (mode === FOLD_QUOTED && ch === '\\\\') {\n            escStart = i;\n            switch (text[i + 1]) {\n                case 'x':\n                    i += 3;\n                    break;\n                case 'u':\n                    i += 5;\n                    break;\n                case 'U':\n                    i += 9;\n                    break;\n                default:\n                    i += 1;\n            }\n            escEnd = i;\n        }\n        if (ch === '\\n') {\n            if (mode === FOLD_BLOCK)\n                i = consumeMoreIndentedLines(text, i);\n            end = i + endStep;\n            split = undefined;\n        }\n        else {\n            if (ch === ' ' &&\n                prev &&\n                prev !== ' ' &&\n                prev !== '\\n' &&\n                prev !== '\\t') {\n                // space surrounded by non-space can be replaced with newline + indent\n                const next = text[i + 1];\n                if (next && next !== ' ' && next !== '\\n' && next !== '\\t')\n                    split = i;\n            }\n            if (i >= end) {\n                if (split) {\n                    folds.push(split);\n                    end = split + endStep;\n                    split = undefined;\n                }\n                else if (mode === FOLD_QUOTED) {\n                    // white-space collected at end may stretch past lineWidth\n                    while (prev === ' ' || prev === '\\t') {\n                        prev = ch;\n                        ch = text[(i += 1)];\n                        overflow = true;\n                    }\n                    // Account for newline escape, but don't break preceding escape\n                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;\n                    // Bail out if lineWidth & minContentWidth are shorter than an escape string\n                    if (escapedFolds[j])\n                        return text;\n                    folds.push(j);\n                    escapedFolds[j] = true;\n                    end = j + endStep;\n                    split = undefined;\n                }\n                else {\n                    overflow = true;\n                }\n            }\n        }\n        prev = ch;\n    }\n    if (overflow && onOverflow)\n        onOverflow();\n    if (folds.length === 0)\n        return text;\n    if (onFold)\n        onFold();\n    let res = text.slice(0, folds[0]);\n    for (let i = 0; i < folds.length; ++i) {\n        const fold = folds[i];\n        const end = folds[i + 1] || text.length;\n        if (fold === 0)\n            res = `\\n${indent}${text.slice(0, end)}`;\n        else {\n            if (mode === FOLD_QUOTED && escapedFolds[fold])\n                res += `${text[fold]}\\\\`;\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\n        }\n    }\n    return res;\n}\n/**\n * Presumes `i + 1` is at the start of a line\n * @returns index of last newline in more-indented block\n */\nfunction consumeMoreIndentedLines(text, i) {\n    let ch = text[i + 1];\n    while (ch === ' ' || ch === '\\t') {\n        do {\n            ch = text[(i += 1)];\n        } while (ch && ch !== '\\n');\n        ch = text[i + 1];\n    }\n    return i;\n}\n\nexports.FOLD_BLOCK = FOLD_BLOCK;\nexports.FOLD_FLOW = FOLD_FLOW;\nexports.FOLD_QUOTED = FOLD_QUOTED;\nexports.foldFlowLines = foldFlowLines;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/stringify/foldFlowLines.js?")},5338:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar anchors = __webpack_require__(641);\nvar Node = __webpack_require__(6058);\nvar stringifyComment = __webpack_require__(1273);\nvar stringifyString = __webpack_require__(396);\n\nfunction createStringifyContext(doc, options) {\n    const opt = Object.assign({\n        blockQuote: true,\n        commentString: stringifyComment.stringifyComment,\n        defaultKeyType: null,\n        defaultStringType: 'PLAIN',\n        directives: null,\n        doubleQuotedAsJSON: false,\n        doubleQuotedMinMultiLineLength: 40,\n        falseStr: 'false',\n        flowCollectionPadding: true,\n        indentSeq: true,\n        lineWidth: 80,\n        minContentWidth: 20,\n        nullStr: 'null',\n        simpleKeys: false,\n        singleQuote: null,\n        trueStr: 'true',\n        verifyAliasOrder: true\n    }, doc.schema.toStringOptions, options);\n    let inFlow;\n    switch (opt.collectionStyle) {\n        case 'block':\n            inFlow = false;\n            break;\n        case 'flow':\n            inFlow = true;\n            break;\n        default:\n            inFlow = null;\n    }\n    return {\n        anchors: new Set(),\n        doc,\n        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',\n        indent: '',\n        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',\n        inFlow,\n        options: opt\n    };\n}\nfunction getTagObject(tags, item) {\n    if (item.tag) {\n        const match = tags.filter(t => t.tag === item.tag);\n        if (match.length > 0)\n            return match.find(t => t.format === item.format) ?? match[0];\n    }\n    let tagObj = undefined;\n    let obj;\n    if (Node.isScalar(item)) {\n        obj = item.value;\n        const match = tags.filter(t => t.identify?.(obj));\n        tagObj =\n            match.find(t => t.format === item.format) ?? match.find(t => !t.format);\n    }\n    else {\n        obj = item;\n        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\n    }\n    if (!tagObj) {\n        const name = obj?.constructor?.name ?? typeof obj;\n        throw new Error(`Tag not resolved for ${name} value`);\n    }\n    return tagObj;\n}\n// needs to be called before value stringifier to allow for circular anchor refs\nfunction stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {\n    if (!doc.directives)\n        return '';\n    const props = [];\n    const anchor = (Node.isScalar(node) || Node.isCollection(node)) && node.anchor;\n    if (anchor && anchors.anchorIsValid(anchor)) {\n        anchors$1.add(anchor);\n        props.push(`&${anchor}`);\n    }\n    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;\n    if (tag)\n        props.push(doc.directives.tagString(tag));\n    return props.join(' ');\n}\nfunction stringify(item, ctx, onComment, onChompKeep) {\n    if (Node.isPair(item))\n        return item.toString(ctx, onComment, onChompKeep);\n    if (Node.isAlias(item)) {\n        if (ctx.doc.directives)\n            return item.toString(ctx);\n        if (ctx.resolvedAliases?.has(item)) {\n            throw new TypeError(`Cannot stringify circular structure without alias nodes`);\n        }\n        else {\n            if (ctx.resolvedAliases)\n                ctx.resolvedAliases.add(item);\n            else\n                ctx.resolvedAliases = new Set([item]);\n            item = item.resolve(ctx.doc);\n        }\n    }\n    let tagObj = undefined;\n    const node = Node.isNode(item)\n        ? item\n        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });\n    if (!tagObj)\n        tagObj = getTagObject(ctx.doc.schema.tags, node);\n    const props = stringifyProps(node, tagObj, ctx);\n    if (props.length > 0)\n        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;\n    const str = typeof tagObj.stringify === 'function'\n        ? tagObj.stringify(node, ctx, onComment, onChompKeep)\n        : Node.isScalar(node)\n            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)\n            : node.toString(ctx, onComment, onChompKeep);\n    if (!props)\n        return str;\n    return Node.isScalar(node) || str[0] === '{' || str[0] === '['\n        ? `${props} ${str}`\n        : `${props}\\n${ctx.indent}${str}`;\n}\n\nexports.createStringifyContext = createStringifyContext;\nexports.stringify = stringify;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/stringify/stringify.js?")},8354:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Collection = __webpack_require__(205);\nvar Node = __webpack_require__(6058);\nvar stringify = __webpack_require__(5338);\nvar stringifyComment = __webpack_require__(1273);\n\nfunction stringifyCollection(collection, ctx, options) {\n    const flow = ctx.inFlow ?? collection.flow;\n    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;\n    return stringify(collection, ctx, options);\n}\nfunction stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {\n    const { indent, options: { commentString } } = ctx;\n    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });\n    let chompKeep = false; // flag for the preceding node's status\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (Node.isNode(item)) {\n            if (!chompKeep && item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (Node.isPair(item)) {\n            const ik = Node.isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (!chompKeep && ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);\n            }\n        }\n        chompKeep = false;\n        let str = stringify.stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));\n        if (comment)\n            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));\n        if (chompKeep && comment)\n            chompKeep = false;\n        lines.push(blockItemPrefix + str);\n    }\n    let str;\n    if (lines.length === 0) {\n        str = flowChars.start + flowChars.end;\n    }\n    else {\n        str = lines[0];\n        for (let i = 1; i < lines.length; ++i) {\n            const line = lines[i];\n            str += line ? `\\n${indent}${line}` : '\\n';\n        }\n    }\n    if (comment) {\n        str += '\\n' + stringifyComment.indentComment(commentString(comment), indent);\n        if (onComment)\n            onComment();\n    }\n    else if (chompKeep && onChompKeep)\n        onChompKeep();\n    return str;\n}\nfunction stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {\n    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;\n    itemIndent += indentStep;\n    const itemCtx = Object.assign({}, ctx, {\n        indent: itemIndent,\n        inFlow: true,\n        type: null\n    });\n    let reqNewline = false;\n    let linesAtValue = 0;\n    const lines = [];\n    for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        let comment = null;\n        if (Node.isNode(item)) {\n            if (item.spaceBefore)\n                lines.push('');\n            addCommentBefore(ctx, lines, item.commentBefore, false);\n            if (item.comment)\n                comment = item.comment;\n        }\n        else if (Node.isPair(item)) {\n            const ik = Node.isNode(item.key) ? item.key : null;\n            if (ik) {\n                if (ik.spaceBefore)\n                    lines.push('');\n                addCommentBefore(ctx, lines, ik.commentBefore, false);\n                if (ik.comment)\n                    reqNewline = true;\n            }\n            const iv = Node.isNode(item.value) ? item.value : null;\n            if (iv) {\n                if (iv.comment)\n                    comment = iv.comment;\n                if (iv.commentBefore)\n                    reqNewline = true;\n            }\n            else if (item.value == null && ik && ik.comment) {\n                comment = ik.comment;\n            }\n        }\n        if (comment)\n            reqNewline = true;\n        let str = stringify.stringify(item, itemCtx, () => (comment = null));\n        if (i < items.length - 1)\n            str += ',';\n        if (comment)\n            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));\n        if (!reqNewline && (lines.length > linesAtValue || str.includes('\\n')))\n            reqNewline = true;\n        lines.push(str);\n        linesAtValue = lines.length;\n    }\n    let str;\n    const { start, end } = flowChars;\n    if (lines.length === 0) {\n        str = start + end;\n    }\n    else {\n        if (!reqNewline) {\n            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);\n            reqNewline = len > Collection.Collection.maxFlowStringSingleLineLength;\n        }\n        if (reqNewline) {\n            str = start;\n            for (const line of lines)\n                str += line ? `\\n${indentStep}${indent}${line}` : '\\n';\n            str += `\\n${indent}${end}`;\n        }\n        else {\n            str = `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;\n        }\n    }\n    if (comment) {\n        str += stringifyComment.lineComment(str, indent, commentString(comment));\n        if (onComment)\n            onComment();\n    }\n    return str;\n}\nfunction addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {\n    if (comment && chompKeep)\n        comment = comment.replace(/^\\n+/, '');\n    if (comment) {\n        const ic = stringifyComment.indentComment(commentString(comment), indent);\n        lines.push(ic.trimStart()); // Avoid double indent on first line\n    }\n}\n\nexports.stringifyCollection = stringifyCollection;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/stringify/stringifyCollection.js?")},1273:(__unused_webpack_module,exports)=>{"use strict";eval("\n\n/**\n * Stringifies a comment.\n *\n * Empty comment lines are left empty,\n * lines consisting of a single space are replaced by `#`,\n * and all other lines are prefixed with a `#`.\n */\nconst stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');\nfunction indentComment(comment, indent) {\n    if (/^\\n+$/.test(comment))\n        return comment.substring(1);\n    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;\n}\nconst lineComment = (str, indent, comment) => str.endsWith('\\n')\n    ? indentComment(comment, indent)\n    : comment.includes('\\n')\n        ? '\\n' + indentComment(comment, indent)\n        : (str.endsWith(' ') ? '' : ' ') + comment;\n\nexports.indentComment = indentComment;\nexports.lineComment = lineComment;\nexports.stringifyComment = stringifyComment;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/stringify/stringifyComment.js?")},3545:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\nvar stringify = __webpack_require__(5338);\nvar stringifyComment = __webpack_require__(1273);\n\nfunction stringifyDocument(doc, options) {\n    const lines = [];\n    let hasDirectives = options.directives === true;\n    if (options.directives !== false && doc.directives) {\n        const dir = doc.directives.toString(doc);\n        if (dir) {\n            lines.push(dir);\n            hasDirectives = true;\n        }\n        else if (doc.directives.docStart)\n            hasDirectives = true;\n    }\n    if (hasDirectives)\n        lines.push('---');\n    const ctx = stringify.createStringifyContext(doc, options);\n    const { commentString } = ctx.options;\n    if (doc.commentBefore) {\n        if (lines.length !== 1)\n            lines.unshift('');\n        const cs = commentString(doc.commentBefore);\n        lines.unshift(stringifyComment.indentComment(cs, ''));\n    }\n    let chompKeep = false;\n    let contentComment = null;\n    if (doc.contents) {\n        if (Node.isNode(doc.contents)) {\n            if (doc.contents.spaceBefore && hasDirectives)\n                lines.push('');\n            if (doc.contents.commentBefore) {\n                const cs = commentString(doc.contents.commentBefore);\n                lines.push(stringifyComment.indentComment(cs, ''));\n            }\n            // top-level block scalars need to be indented if followed by a comment\n            ctx.forceBlockIndent = !!doc.comment;\n            contentComment = doc.contents.comment;\n        }\n        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);\n        let body = stringify.stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);\n        if (contentComment)\n            body += stringifyComment.lineComment(body, '', commentString(contentComment));\n        if ((body[0] === '|' || body[0] === '>') &&\n            lines[lines.length - 1] === '---') {\n            // Top-level block scalars with a preceding doc marker ought to use the\n            // same line for their header.\n            lines[lines.length - 1] = `--- ${body}`;\n        }\n        else\n            lines.push(body);\n    }\n    else {\n        lines.push(stringify.stringify(doc.contents, ctx));\n    }\n    if (doc.directives?.docEnd) {\n        if (doc.comment) {\n            const cs = commentString(doc.comment);\n            if (cs.includes('\\n')) {\n                lines.push('...');\n                lines.push(stringifyComment.indentComment(cs, ''));\n            }\n            else {\n                lines.push(`... ${cs}`);\n            }\n        }\n        else {\n            lines.push('...');\n        }\n    }\n    else {\n        let dc = doc.comment;\n        if (dc && chompKeep)\n            dc = dc.replace(/^\\n+/, '');\n        if (dc) {\n            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')\n                lines.push('');\n            lines.push(stringifyComment.indentComment(commentString(dc), ''));\n        }\n    }\n    return lines.join('\\n') + '\\n';\n}\n\nexports.stringifyDocument = stringifyDocument;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/stringify/stringifyDocument.js?")},4058:(__unused_webpack_module,exports)=>{"use strict";eval("\n\nfunction stringifyNumber({ format, minFractionDigits, tag, value }) {\n    if (typeof value === 'bigint')\n        return String(value);\n    const num = typeof value === 'number' ? value : Number(value);\n    if (!isFinite(num))\n        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';\n    let n = JSON.stringify(value);\n    if (!format &&\n        minFractionDigits &&\n        (!tag || tag === 'tag:yaml.org,2002:float') &&\n        /^\\d/.test(n)) {\n        let i = n.indexOf('.');\n        if (i < 0) {\n            i = n.length;\n            n += '.';\n        }\n        let d = minFractionDigits - (n.length - i - 1);\n        while (d-- > 0)\n            n += '0';\n    }\n    return n;\n}\n\nexports.stringifyNumber = stringifyNumber;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/stringify/stringifyNumber.js?")},376:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\nvar Scalar = __webpack_require__(6686);\nvar stringify = __webpack_require__(5338);\nvar stringifyComment = __webpack_require__(1273);\n\nfunction stringifyPair({ key, value }, ctx, onComment, onChompKeep) {\n    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;\n    let keyComment = (Node.isNode(key) && key.comment) || null;\n    if (simpleKeys) {\n        if (keyComment) {\n            throw new Error('With simple keys, key nodes cannot have comments');\n        }\n        if (Node.isCollection(key)) {\n            const msg = 'With simple keys, collection cannot be used as a key value';\n            throw new Error(msg);\n        }\n    }\n    let explicitKey = !simpleKeys &&\n        (!key ||\n            (keyComment && value == null && !ctx.inFlow) ||\n            Node.isCollection(key) ||\n            (Node.isScalar(key)\n                ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL\n                : typeof key === 'object'));\n    ctx = Object.assign({}, ctx, {\n        allNullValues: false,\n        implicitKey: !explicitKey && (simpleKeys || !allNullValues),\n        indent: indent + indentStep\n    });\n    let keyCommentDone = false;\n    let chompKeep = false;\n    let str = stringify.stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));\n    if (!explicitKey && !ctx.inFlow && str.length > 1024) {\n        if (simpleKeys)\n            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\n        explicitKey = true;\n    }\n    if (ctx.inFlow) {\n        if (allNullValues || value == null) {\n            if (keyCommentDone && onComment)\n                onComment();\n            return str === '' ? '?' : explicitKey ? `? ${str}` : str;\n        }\n    }\n    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {\n        str = `? ${str}`;\n        if (keyComment && !keyCommentDone) {\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n        }\n        else if (chompKeep && onChompKeep)\n            onChompKeep();\n        return str;\n    }\n    if (keyCommentDone)\n        keyComment = null;\n    if (explicitKey) {\n        if (keyComment)\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n        str = `? ${str}\\n${indent}:`;\n    }\n    else {\n        str = `${str}:`;\n        if (keyComment)\n            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));\n    }\n    let vsb, vcb, valueComment;\n    if (Node.isNode(value)) {\n        vsb = !!value.spaceBefore;\n        vcb = value.commentBefore;\n        valueComment = value.comment;\n    }\n    else {\n        vsb = false;\n        vcb = null;\n        valueComment = null;\n        if (value && typeof value === 'object')\n            value = doc.createNode(value);\n    }\n    ctx.implicitKey = false;\n    if (!explicitKey && !keyComment && Node.isScalar(value))\n        ctx.indentAtStart = str.length + 1;\n    chompKeep = false;\n    if (!indentSeq &&\n        indentStep.length >= 2 &&\n        !ctx.inFlow &&\n        !explicitKey &&\n        Node.isSeq(value) &&\n        !value.flow &&\n        !value.tag &&\n        !value.anchor) {\n        // If indentSeq === false, consider '- ' as part of indentation where possible\n        ctx.indent = ctx.indent.substring(2);\n    }\n    let valueCommentDone = false;\n    const valueStr = stringify.stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));\n    let ws = ' ';\n    if (keyComment || vsb || vcb) {\n        ws = vsb ? '\\n' : '';\n        if (vcb) {\n            const cs = commentString(vcb);\n            ws += `\\n${stringifyComment.indentComment(cs, ctx.indent)}`;\n        }\n        if (valueStr === '' && !ctx.inFlow) {\n            if (ws === '\\n')\n                ws = '\\n\\n';\n        }\n        else {\n            ws += `\\n${ctx.indent}`;\n        }\n    }\n    else if (!explicitKey && Node.isCollection(value)) {\n        const vs0 = valueStr[0];\n        const nl0 = valueStr.indexOf('\\n');\n        const hasNewline = nl0 !== -1;\n        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;\n        if (hasNewline || !flow) {\n            let hasPropsLine = false;\n            if (hasNewline && (vs0 === '&' || vs0 === '!')) {\n                let sp0 = valueStr.indexOf(' ');\n                if (vs0 === '&' &&\n                    sp0 !== -1 &&\n                    sp0 < nl0 &&\n                    valueStr[sp0 + 1] === '!') {\n                    sp0 = valueStr.indexOf(' ', sp0 + 1);\n                }\n                if (sp0 === -1 || nl0 < sp0)\n                    hasPropsLine = true;\n            }\n            if (!hasPropsLine)\n                ws = `\\n${ctx.indent}`;\n        }\n    }\n    else if (valueStr === '' || valueStr[0] === '\\n') {\n        ws = '';\n    }\n    str += ws + valueStr;\n    if (ctx.inFlow) {\n        if (valueCommentDone && onComment)\n            onComment();\n    }\n    else if (valueComment && !valueCommentDone) {\n        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));\n    }\n    else if (chompKeep && onChompKeep) {\n        onChompKeep();\n    }\n    return str;\n}\n\nexports.stringifyPair = stringifyPair;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/stringify/stringifyPair.js?")},396:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Scalar = __webpack_require__(6686);\nvar foldFlowLines = __webpack_require__(2925);\n\nconst getFoldOptions = (ctx, isBlock) => ({\n    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,\n    lineWidth: ctx.options.lineWidth,\n    minContentWidth: ctx.options.minContentWidth\n});\n// Also checks for lines starting with %, as parsing the output as YAML 1.1 will\n// presume that's starting a new document.\nconst containsDocumentMarker = (str) => /^(%|---|\\.\\.\\.)/m.test(str);\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\n    if (!lineWidth || lineWidth < 0)\n        return false;\n    const limit = lineWidth - indentLength;\n    const strLen = str.length;\n    if (strLen <= limit)\n        return false;\n    for (let i = 0, start = 0; i < strLen; ++i) {\n        if (str[i] === '\\n') {\n            if (i - start > limit)\n                return true;\n            start = i + 1;\n            if (strLen - start <= limit)\n                return false;\n        }\n    }\n    return true;\n}\nfunction doubleQuotedString(value, ctx) {\n    const json = JSON.stringify(value);\n    if (ctx.options.doubleQuotedAsJSON)\n        return json;\n    const { implicitKey } = ctx;\n    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    let str = '';\n    let start = 0;\n    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\n        if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\n            // space before newline needs to be escaped to not be folded\n            str += json.slice(start, i) + '\\\\ ';\n            i += 1;\n            start = i;\n            ch = '\\\\';\n        }\n        if (ch === '\\\\')\n            switch (json[i + 1]) {\n                case 'u':\n                    {\n                        str += json.slice(start, i);\n                        const code = json.substr(i + 2, 4);\n                        switch (code) {\n                            case '0000':\n                                str += '\\\\0';\n                                break;\n                            case '0007':\n                                str += '\\\\a';\n                                break;\n                            case '000b':\n                                str += '\\\\v';\n                                break;\n                            case '001b':\n                                str += '\\\\e';\n                                break;\n                            case '0085':\n                                str += '\\\\N';\n                                break;\n                            case '00a0':\n                                str += '\\\\_';\n                                break;\n                            case '2028':\n                                str += '\\\\L';\n                                break;\n                            case '2029':\n                                str += '\\\\P';\n                                break;\n                            default:\n                                if (code.substr(0, 2) === '00')\n                                    str += '\\\\x' + code.substr(2);\n                                else\n                                    str += json.substr(i, 6);\n                        }\n                        i += 5;\n                        start = i + 1;\n                    }\n                    break;\n                case 'n':\n                    if (implicitKey ||\n                        json[i + 2] === '\"' ||\n                        json.length < minMultiLineLength) {\n                        i += 1;\n                    }\n                    else {\n                        // folding will eat first newline\n                        str += json.slice(start, i) + '\\n\\n';\n                        while (json[i + 2] === '\\\\' &&\n                            json[i + 3] === 'n' &&\n                            json[i + 4] !== '\"') {\n                            str += '\\n';\n                            i += 2;\n                        }\n                        str += indent;\n                        // space after newline needs to be escaped to not be folded\n                        if (json[i + 2] === ' ')\n                            str += '\\\\';\n                        i += 1;\n                        start = i + 1;\n                    }\n                    break;\n                default:\n                    i += 1;\n            }\n    }\n    str = start ? str + json.slice(start) : json;\n    return implicitKey\n        ? str\n        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));\n}\nfunction singleQuotedString(value, ctx) {\n    if (ctx.options.singleQuote === false ||\n        (ctx.implicitKey && value.includes('\\n')) ||\n        /[ \\t]\\n|\\n[ \\t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline\n    )\n        return doubleQuotedString(value, ctx);\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\n    const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\n    return ctx.implicitKey\n        ? res\n        : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction quotedString(value, ctx) {\n    const { singleQuote } = ctx.options;\n    let qs;\n    if (singleQuote === false)\n        qs = doubleQuotedString;\n    else {\n        const hasDouble = value.includes('\"');\n        const hasSingle = value.includes(\"'\");\n        if (hasDouble && !hasSingle)\n            qs = singleQuotedString;\n        else if (hasSingle && !hasDouble)\n            qs = doubleQuotedString;\n        else\n            qs = singleQuote ? singleQuotedString : doubleQuotedString;\n    }\n    return qs(value, ctx);\n}\nfunction blockString({ comment, type, value }, ctx, onComment, onChompKeep) {\n    const { blockQuote, commentString, lineWidth } = ctx.options;\n    // 1. Block can't end in whitespace unless the last line is non-empty.\n    // 2. Strings consisting of only whitespace are best rendered explicitly.\n    if (!blockQuote || /\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\n        return quotedString(value, ctx);\n    }\n    const indent = ctx.indent ||\n        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\n    const literal = blockQuote === 'literal'\n        ? true\n        : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED\n            ? false\n            : type === Scalar.Scalar.BLOCK_LITERAL\n                ? true\n                : !lineLengthOverLimit(value, lineWidth, indent.length);\n    if (!value)\n        return literal ? '|\\n' : '>\\n';\n    // determine chomping from whitespace at value end\n    let chomp;\n    let endStart;\n    for (endStart = value.length; endStart > 0; --endStart) {\n        const ch = value[endStart - 1];\n        if (ch !== '\\n' && ch !== '\\t' && ch !== ' ')\n            break;\n    }\n    let end = value.substring(endStart);\n    const endNlPos = end.indexOf('\\n');\n    if (endNlPos === -1) {\n        chomp = '-'; // strip\n    }\n    else if (value === end || endNlPos !== end.length - 1) {\n        chomp = '+'; // keep\n        if (onChompKeep)\n            onChompKeep();\n    }\n    else {\n        chomp = ''; // clip\n    }\n    if (end) {\n        value = value.slice(0, -end.length);\n        if (end[end.length - 1] === '\\n')\n            end = end.slice(0, -1);\n        end = end.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\n    }\n    // determine indent indicator from whitespace at value start\n    let startWithSpace = false;\n    let startEnd;\n    let startNlPos = -1;\n    for (startEnd = 0; startEnd < value.length; ++startEnd) {\n        const ch = value[startEnd];\n        if (ch === ' ')\n            startWithSpace = true;\n        else if (ch === '\\n')\n            startNlPos = startEnd;\n        else\n            break;\n    }\n    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);\n    if (start) {\n        value = value.substring(start.length);\n        start = start.replace(/\\n+/g, `$&${indent}`);\n    }\n    const indentSize = indent ? '2' : '1'; // root is at -1\n    let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;\n    if (comment) {\n        header += ' ' + commentString(comment.replace(/ ?[\\r\\n]+/g, ' '));\n        if (onComment)\n            onComment();\n    }\n    if (literal) {\n        value = value.replace(/\\n+/g, `$&${indent}`);\n        return `${header}\\n${indent}${start}${value}${end}`;\n    }\n    value = value\n        .replace(/\\n+/g, '\\n$&')\n        .replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\n        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent\n        .replace(/\\n+/g, `$&${indent}`);\n    const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx, true));\n    return `${header}\\n${indent}${body}`;\n}\nfunction plainString(item, ctx, onComment, onChompKeep) {\n    const { type, value } = item;\n    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;\n    if ((implicitKey && /[\\n[\\]{},]/.test(value)) ||\n        (inFlow && /[[\\]{},]/.test(value))) {\n        return quotedString(value, ctx);\n    }\n    if (!value ||\n        /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\n        // not allowed:\n        // - empty string, '-' or '?'\n        // - start with an indicator character (except [?:-]) or /[?-] /\n        // - '\\n ', ': ' or ' \\n' anywhere\n        // - '#' not preceded by a non-space char\n        // - end with ' ' or ':'\n        return implicitKey || inFlow || !value.includes('\\n')\n            ? quotedString(value, ctx)\n            : blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (!implicitKey &&\n        !inFlow &&\n        type !== Scalar.Scalar.PLAIN &&\n        value.includes('\\n')) {\n        // Where allowed & type not set explicitly, prefer block style for multiline strings\n        return blockString(item, ctx, onComment, onChompKeep);\n    }\n    if (containsDocumentMarker(value)) {\n        if (indent === '') {\n            ctx.forceBlockIndent = true;\n            return blockString(item, ctx, onComment, onChompKeep);\n        }\n        else if (implicitKey && indent === indentStep) {\n            return quotedString(value, ctx);\n        }\n    }\n    const str = value.replace(/\\n+/g, `$&\\n${indent}`);\n    // Verify that output will be parsed as a string, as e.g. plain numbers and\n    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\n    // and others in v1.1.\n    if (actualString) {\n        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);\n        const { compat, tags } = ctx.doc.schema;\n        if (tags.some(test) || compat?.some(test))\n            return quotedString(value, ctx);\n    }\n    return implicitKey\n        ? str\n        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));\n}\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\n    const { implicitKey, inFlow } = ctx;\n    const ss = typeof item.value === 'string'\n        ? item\n        : Object.assign({}, item, { value: String(item.value) });\n    let { type } = item;\n    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {\n        // force double quotes on control characters & unpaired surrogates\n        if (/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\\u{D800}-\\u{DFFF}]/u.test(ss.value))\n            type = Scalar.Scalar.QUOTE_DOUBLE;\n    }\n    const _stringify = (_type) => {\n        switch (_type) {\n            case Scalar.Scalar.BLOCK_FOLDED:\n            case Scalar.Scalar.BLOCK_LITERAL:\n                return implicitKey || inFlow\n                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers\n                    : blockString(ss, ctx, onComment, onChompKeep);\n            case Scalar.Scalar.QUOTE_DOUBLE:\n                return doubleQuotedString(ss.value, ctx);\n            case Scalar.Scalar.QUOTE_SINGLE:\n                return singleQuotedString(ss.value, ctx);\n            case Scalar.Scalar.PLAIN:\n                return plainString(ss, ctx, onComment, onChompKeep);\n            default:\n                return null;\n        }\n    };\n    let res = _stringify(type);\n    if (res === null) {\n        const { defaultKeyType, defaultStringType } = ctx.options;\n        const t = (implicitKey && defaultKeyType) || defaultStringType;\n        res = _stringify(t);\n        if (res === null)\n            throw new Error(`Unsupported default string type ${t}`);\n    }\n    return res;\n}\n\nexports.stringifyString = stringifyString;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/stringify/stringifyString.js?")},2479:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nvar Node = __webpack_require__(6058);\n\nconst BREAK = Symbol('break visit');\nconst SKIP = Symbol('skip children');\nconst REMOVE = Symbol('remove node');\n/**\n * Apply a visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nfunction visit(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (Node.isDocument(node)) {\n        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        visit_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisit.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisit.SKIP = SKIP;\n/** Remove the current node */\nvisit.REMOVE = REMOVE;\nfunction visit_(key, node, visitor, path) {\n    const ctrl = callVisitor(key, node, visitor, path);\n    if (Node.isNode(ctrl) || Node.isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visit_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (Node.isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = visit_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (Node.isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = visit_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = visit_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\n/**\n * Apply an async visitor to an AST node or document.\n *\n * Walks through the tree (depth-first) starting from `node`, calling a\n * `visitor` function with three arguments:\n *   - `key`: For sequence values and map `Pair`, the node's index in the\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\n *     `null` for the root node.\n *   - `node`: The current node.\n *   - `path`: The ancestry of the current node.\n *\n * The return value of the visitor may be used to control the traversal:\n *   - `Promise`: Must resolve to one of the following values\n *   - `undefined` (default): Do nothing and continue\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\n *     sibling\n *   - `visit.BREAK`: Terminate traversal completely\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\n *   - `Node`: Replace the current node, then continue by visiting it\n *   - `number`: While iterating the items of a sequence or map, set the index\n *     of the next step. This is useful especially if the index of the current\n *     node has changed.\n *\n * If `visitor` is a single function, it will be called with all values\n * encountered in the tree, including e.g. `null` values. Alternatively,\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\n * `Alias` and `Scalar` node. To define the same visitor function for more than\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\n * specific defined one will be used for each node.\n */\nasync function visitAsync(node, visitor) {\n    const visitor_ = initVisitor(visitor);\n    if (Node.isDocument(node)) {\n        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));\n        if (cd === REMOVE)\n            node.contents = null;\n    }\n    else\n        await visitAsync_(null, node, visitor_, Object.freeze([]));\n}\n// Without the `as symbol` casts, TS declares these in the `visit`\n// namespace using `var`, but then complains about that because\n// `unique symbol` must be `const`.\n/** Terminate visit traversal completely */\nvisitAsync.BREAK = BREAK;\n/** Do not visit the children of the current node */\nvisitAsync.SKIP = SKIP;\n/** Remove the current node */\nvisitAsync.REMOVE = REMOVE;\nasync function visitAsync_(key, node, visitor, path) {\n    const ctrl = await callVisitor(key, node, visitor, path);\n    if (Node.isNode(ctrl) || Node.isPair(ctrl)) {\n        replaceNode(key, path, ctrl);\n        return visitAsync_(key, ctrl, visitor, path);\n    }\n    if (typeof ctrl !== 'symbol') {\n        if (Node.isCollection(node)) {\n            path = Object.freeze(path.concat(node));\n            for (let i = 0; i < node.items.length; ++i) {\n                const ci = await visitAsync_(i, node.items[i], visitor, path);\n                if (typeof ci === 'number')\n                    i = ci - 1;\n                else if (ci === BREAK)\n                    return BREAK;\n                else if (ci === REMOVE) {\n                    node.items.splice(i, 1);\n                    i -= 1;\n                }\n            }\n        }\n        else if (Node.isPair(node)) {\n            path = Object.freeze(path.concat(node));\n            const ck = await visitAsync_('key', node.key, visitor, path);\n            if (ck === BREAK)\n                return BREAK;\n            else if (ck === REMOVE)\n                node.key = null;\n            const cv = await visitAsync_('value', node.value, visitor, path);\n            if (cv === BREAK)\n                return BREAK;\n            else if (cv === REMOVE)\n                node.value = null;\n        }\n    }\n    return ctrl;\n}\nfunction initVisitor(visitor) {\n    if (typeof visitor === 'object' &&\n        (visitor.Collection || visitor.Node || visitor.Value)) {\n        return Object.assign({\n            Alias: visitor.Node,\n            Map: visitor.Node,\n            Scalar: visitor.Node,\n            Seq: visitor.Node\n        }, visitor.Value && {\n            Map: visitor.Value,\n            Scalar: visitor.Value,\n            Seq: visitor.Value\n        }, visitor.Collection && {\n            Map: visitor.Collection,\n            Seq: visitor.Collection\n        }, visitor);\n    }\n    return visitor;\n}\nfunction callVisitor(key, node, visitor, path) {\n    if (typeof visitor === 'function')\n        return visitor(key, node, path);\n    if (Node.isMap(node))\n        return visitor.Map?.(key, node, path);\n    if (Node.isSeq(node))\n        return visitor.Seq?.(key, node, path);\n    if (Node.isPair(node))\n        return visitor.Pair?.(key, node, path);\n    if (Node.isScalar(node))\n        return visitor.Scalar?.(key, node, path);\n    if (Node.isAlias(node))\n        return visitor.Alias?.(key, node, path);\n    return undefined;\n}\nfunction replaceNode(key, path, node) {\n    const parent = path[path.length - 1];\n    if (Node.isCollection(parent)) {\n        parent.items[key] = node;\n    }\n    else if (Node.isPair(parent)) {\n        if (key === 'key')\n            parent.key = node;\n        else\n            parent.value = node;\n    }\n    else if (Node.isDocument(parent)) {\n        parent.contents = node;\n    }\n    else {\n        const pt = Node.isAlias(parent) ? 'alias' : 'scalar';\n        throw new Error(`Cannot replace node with ${pt} parent`);\n    }\n}\n\nexports.visit = visit;\nexports.visitAsync = visitAsync;\n\n\n//# sourceURL=webpack:///../node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/dist/visit.js?")},739:module=>{"use strict";eval('module.exports = JSON.parse(\'{"$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON AnySchema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}\');\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/refs/data.json?')},5570:module=>{"use strict";eval('module.exports = JSON.parse(\'{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}\');\n\n//# sourceURL=webpack:///../node_modules/.pnpm/ajv@8.12.0/node_modules/ajv/dist/refs/json-schema-draft-07.json?')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={id:e,loaded:!1,exports:{}};return __webpack_modules__[e].call(t.exports,t,t.exports,__webpack_require__),t.loaded=!0,t.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var t in n)__webpack_require__.o(n,t)&&!__webpack_require__.o(e,t)&&Object.defineProperty(e,t,{enumerable:!0,get:n[t]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},__webpack_require__.nmd=e=>(e.paths=[],e.children||(e.children=[]),e);var __webpack_exports__=__webpack_require__(6663)})();